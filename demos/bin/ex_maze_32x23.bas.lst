------- FILE e:\Documents\bB\demos\ex_maze_32x23.bas.asm LEVEL 1 PASS 3
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_maze_32x23.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_maze_32x23.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 3
      0  5000 ????				      include	"2600basic.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 3
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 3
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 3
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 17	   pfres      =	23
      5  5000 ????
      6  5000 ????	       00 ed	   rand16     =	z
      7  5000 ????
      8  5000 ????	       00 ec	   _Bit6_Flip_P0 =	y
      9  5000 ????
     10  5000 ????	       00 ec	   _Bit5_Direction_Changed =	y
     11  5000 ????
     12  5000 ????	       00 ec	   _Bit3_vblank =	y
     13  5000 ????
     14  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     15  5000 ????
     16  5000 ????	       00 ec	   _BitOp_01  =	y
     17  5000 ????
     18  5000 ????	       00 e8	   _Bit7_P1_Dir_Right =	u
     19  5000 ????
     20  5000 ????	       00 e8	   _Bit6_P1_Dir_Left =	u
     21  5000 ????
     22  5000 ????	       00 e8	   _Bit5_P1_Dir_Down =	u
     23  5000 ????
     24  5000 ????	       00 e8	   _Bit4_P1_Dir_Up =	u
     25  5000 ????
     26  5000 ????	       00 e8	   _Bit3_P0_Dir_Right =	u
     27  5000 ????
     28  5000 ????	       00 e8	   _Bit2_P0_Dir_Left =	u
     29  5000 ????
     30  5000 ????	       00 e8	   _Bit1_P0_Dir_Down =	u
     31  5000 ????
     32  5000 ????	       00 e8	   _Bit0_P0_Dir_Up =	u
     33  5000 ????
     34  5000 ????	       00 e8	   _BitOp_P0_P1_Dir =	u
     35  5000 ????
     36  5000 ????	       00 e1	   _Frame_Counter =	n
     37  5000 ????
     38  5000 ????	       00 e0	   _Master_Counter =	m
     39  5000 ????
     40  5000 ????	       00 de	   _MyTemp01  =	k
     41  5000 ????
     42  5000 ????	       00 d9	   _Enemy_Rand_Look =	f
     43  5000 ????
     44  5000 ????	       00 d8	   _Enemy_Counter =	e
     45  5000 ????
     46  5000 ????	       00 86	   _P1_U_D    =	player1y
     47  5000 ????	       00 81	   _P1_L_R    =	player1x
     48  5000 ????	       00 85	   _P0_U_D    =	player0y
     49  5000 ????	       00 80	   _P0_L_R    =	player0x
     50  5000 ????	       00 01	   superchip  =	1
     51  5000 ????	       00 03	   bs_mask    =	3
     52  5000 ????	       00 10	   bankswitch =	16
     53  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     54  5000 ????	       00 01	   no_blank_lines =	1
------- FILE 2600basic.h
      7  5000 ????
      8  5000 ????	       00 80	   player0x   =	$80
      9  5000 ????	       00 81	   player1x   =	$81
     10  5000 ????	       00 82	   missile0x  =	$82
     11  5000 ????	       00 83	   missile1x  =	$83
     12  5000 ????	       00 84	   ballx      =	$84
     13  5000 ????
     14  5000 ????	       00 85	   objecty    =	$85
     15  5000 ????	       00 85	   player0y   =	$85
     16  5000 ????	       00 86	   player1y   =	$86
     17  5000 ????	       00 87	   missile1height =	$87
     18  5000 ????	       00 88	   missile1y  =	$88
     19  5000 ????	       00 89	   bally      =	$89
     20  5000 ????
     21  5000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  5000 ????
     23  5000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  5000 ????	       00 8a	   player0pointerlo =	$8A
     25  5000 ????	       00 8b	   player0pointerhi =	$8B
     26  5000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  5000 ????	       00 8c	   player1pointerlo =	$8C
     28  5000 ????	       00 8d	   player1pointerhi =	$8D
     29  5000 ????
     30  5000 ????	       00 8e	   player0height =	$8E
     31  5000 ????	       00 8f	   player1height =	$8F
     32  5000 ????	       00 90	   missile0height =	$90
     33  5000 ????	       00 91	   missile0y  =	$91
     34  5000 ????	       00 92	   ballheight =	$92
     35  5000 ????
     36  5000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  5000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  5000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  5000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  5000 ????
     41  5000 ????	       00 93	   score      =	$93	; $93-$95
     42  5000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  5000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  5000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  5000 ????	       00 9e	   temp3      =	$9E
     46  5000 ????	       00 9f	   temp4      =	$9F
     47  5000 ????	       00 a0	   temp5      =	$A0
     48  5000 ????	       00 a1	   temp6      =	$A1
     49  5000 ????
     50  5000 ????	       00 a2	   rand       =	$A2
     51  5000 ????	       00 a3	   scorecolor =	$A3
     52  5000 ????
     53  5000 ????	       00 a4	   var0       =	$A4
     54  5000 ????	       00 a5	   var1       =	$A5
     55  5000 ????	       00 a6	   var2       =	$A6
     56  5000 ????	       00 a7	   var3       =	$A7
     57  5000 ????	       00 a8	   var4       =	$A8
     58  5000 ????	       00 a9	   var5       =	$A9
     59  5000 ????	       00 aa	   var6       =	$AA
     60  5000 ????	       00 ab	   var7       =	$AB
     61  5000 ????	       00 ac	   var8       =	$AC
     62  5000 ????	       00 ad	   var9       =	$AD
     63  5000 ????	       00 ae	   var10      =	$AE
     64  5000 ????	       00 af	   var11      =	$AF
     65  5000 ????	       00 b0	   var12      =	$B0
     66  5000 ????	       00 b1	   var13      =	$B1
     67  5000 ????	       00 b2	   var14      =	$B2
     68  5000 ????	       00 b3	   var15      =	$B3
     69  5000 ????	       00 b4	   var16      =	$B4
     70  5000 ????	       00 b5	   var17      =	$B5
     71  5000 ????	       00 b6	   var18      =	$B6
     72  5000 ????	       00 b7	   var19      =	$B7
     73  5000 ????	       00 b8	   var20      =	$B8
     74  5000 ????	       00 b9	   var21      =	$B9
     75  5000 ????	       00 ba	   var22      =	$BA
     76  5000 ????	       00 bb	   var23      =	$BB
     77  5000 ????	       00 bc	   var24      =	$BC
     78  5000 ????	       00 bd	   var25      =	$BD
     79  5000 ????	       00 be	   var26      =	$BE
     80  5000 ????	       00 bf	   var27      =	$BF
     81  5000 ????	       00 c0	   var28      =	$C0
     82  5000 ????	       00 c1	   var29      =	$C1
     83  5000 ????	       00 c2	   var30      =	$C2
     84  5000 ????	       00 c3	   var31      =	$C3
     85  5000 ????	       00 c4	   var32      =	$C4
     86  5000 ????	       00 c5	   var33      =	$C5
     87  5000 ????	       00 c6	   var34      =	$C6
     88  5000 ????	       00 c7	   var35      =	$C7
     89  5000 ????	       00 c8	   var36      =	$C8
     90  5000 ????	       00 c9	   var37      =	$C9
     91  5000 ????	       00 ca	   var38      =	$CA
     92  5000 ????	       00 cb	   var39      =	$CB
     93  5000 ????	       00 cc	   var40      =	$CC
     94  5000 ????	       00 cd	   var41      =	$CD
     95  5000 ????	       00 ce	   var42      =	$CE
     96  5000 ????	       00 cf	   var43      =	$CF
     97  5000 ????	       00 d0	   var44      =	$D0
     98  5000 ????	       00 d1	   var45      =	$D1
     99  5000 ????	       00 d2	   var46      =	$D2
    100  5000 ????	       00 d3	   var47      =	$D3
    101  5000 ????
    102  5000 ????	       00 d4	   A	      =	$d4
    103  5000 ????	       00 d4	   a	      =	$d4
    104  5000 ????	       00 d5	   B	      =	$d5
    105  5000 ????	       00 d5	   b	      =	$d5
    106  5000 ????	       00 d6	   C	      =	$d6
    107  5000 ????	       00 d6	   c	      =	$d6
    108  5000 ????	       00 d7	   D	      =	$d7
    109  5000 ????	       00 d7	   d	      =	$d7
    110  5000 ????	       00 d8	   E	      =	$d8
    111  5000 ????	       00 d8	   e	      =	$d8
    112  5000 ????	       00 d9	   F	      =	$d9
    113  5000 ????	       00 d9	   f	      =	$d9
    114  5000 ????	       00 da	   G	      =	$da
    115  5000 ????	       00 da	   g	      =	$da
    116  5000 ????	       00 db	   H	      =	$db
    117  5000 ????	       00 db	   h	      =	$db
    118  5000 ????	       00 dc	   I	      =	$dc
    119  5000 ????	       00 dc	   i	      =	$dc
    120  5000 ????	       00 dd	   J	      =	$dd
    121  5000 ????	       00 dd	   j	      =	$dd
    122  5000 ????	       00 de	   K	      =	$de
    123  5000 ????	       00 de	   k	      =	$de
    124  5000 ????	       00 df	   L	      =	$df
    125  5000 ????	       00 df	   l	      =	$df
    126  5000 ????	       00 e0	   M	      =	$e0
    127  5000 ????	       00 e0	   m	      =	$e0
    128  5000 ????	       00 e1	   N	      =	$e1
    129  5000 ????	       00 e1	   n	      =	$e1
    130  5000 ????	       00 e2	   O	      =	$e2
    131  5000 ????	       00 e2	   o	      =	$e2
    132  5000 ????	       00 e3	   P	      =	$e3
    133  5000 ????	       00 e3	   p	      =	$e3
    134  5000 ????	       00 e4	   Q	      =	$e4
    135  5000 ????	       00 e4	   q	      =	$e4
    136  5000 ????	       00 e5	   R	      =	$e5
    137  5000 ????	       00 e5	   r	      =	$e5
    138  5000 ????	       00 e6	   S	      =	$e6
    139  5000 ????	       00 e6	   s	      =	$e6
    140  5000 ????	       00 e7	   T	      =	$e7
    141  5000 ????	       00 e7	   t	      =	$e7
    142  5000 ????	       00 e8	   U	      =	$e8
    143  5000 ????	       00 e8	   u	      =	$e8
    144  5000 ????	       00 e9	   V	      =	$e9
    145  5000 ????	       00 e9	   v	      =	$e9
    146  5000 ????	       00 ea	   W	      =	$ea
    147  5000 ????	       00 ea	   w	      =	$ea
    148  5000 ????	       00 eb	   X	      =	$eb
    149  5000 ????	       00 eb	   x	      =	$eb
    150  5000 ????	       00 ec	   Y	      =	$ec
    151  5000 ????	       00 ec	   y	      =	$ec
    152  5000 ????	       00 ed	   Z	      =	$ed
    153  5000 ????	       00 ed	   z	      =	$ed
    154  5000 ????
    155  5000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  5000 ????	       00 ef	   playfieldpos =	$ef
    157  5000 ????
    158  5000 ????						; available for other uses, or if unused, provide more stack space
    159  5000 ????
    160  5000 ????	       00 f0	   aux1       =	$f0
    161  5000 ????	       00 f1	   aux2       =	$f1
    162  5000 ????	       00 f2	   aux3       =	$f2
    163  5000 ????	       00 f3	   aux4       =	$f3
    164  5000 ????	       00 f4	   aux5       =	$f4
    165  5000 ????	       00 f5	   aux6       =	$f5
    166  5000 ????
    167  5000 ????						; playfield color/height pointers
    168  5000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  5000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  5000 ????						; the above pointers are the same because if color and height are both used together,
    171  5000 ????						; they must used absolute indexed and cannot use pointers
    172  5000 ????
    173  5000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  5000 ????						; upper 3 bits of $f2 contain the number of lives
    175  5000 ????	       00 f4	   lifecolor  =	$f4
    176  5000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  5000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  5000 ????
    179  5000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  5000 ????	       00 f3	   pfscore2   =	$f3
    181  5000 ????	       00 f4	   pfscorecolor =	$f4
    182  5000 ????
    183  5000 ????	       00 f6	   stack1     =	$f6
    184  5000 ????	       00 f7	   stack2     =	$f7
    185  5000 ????	       00 f8	   stack3     =	$f8
    186  5000 ????	       00 f9	   stack4     =	$f9
    187  5000 ????						; the stack bytes above may be used in the kernel
    188  5000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  5000 ????
    190  5000 ????				      MAC	return
    191  5000 ????				      ifnconst	bankswitch
    192  5000 ????				      rts
    193  5000 ????				      else
    194  5000 ????				      jmp	BS_return
    195  5000 ????				      endif
    196  5000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  5000 ????
    198  5000 ????				      ifconst	superchip
    199  5000 ????	       10 d0	   playfieldbase =	$10D0
------- FILE superchip.h LEVEL 3 PASS 3
      0  5000 ????				      include	superchip.h
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????	       f0 00	   write_RAM  =	$F000
      4  5000 ????	       f0 00	   wRAM       =	$F000
      5  5000 ????	       f0 00	   w000       =	$F000
      6  5000 ????	       f0 01	   w001       =	$F001
      7  5000 ????	       f0 02	   w002       =	$F002
      8  5000 ????	       f0 03	   w003       =	$F003
      9  5000 ????	       f0 04	   w004       =	$F004
     10  5000 ????	       f0 05	   w005       =	$F005
     11  5000 ????	       f0 06	   w006       =	$F006
     12  5000 ????	       f0 07	   w007       =	$F007
     13  5000 ????	       f0 08	   w008       =	$F008
     14  5000 ????	       f0 09	   w009       =	$F009
     15  5000 ????	       f0 0a	   w010       =	$F00A
     16  5000 ????	       f0 0b	   w011       =	$F00B
     17  5000 ????	       f0 0c	   w012       =	$F00C
     18  5000 ????	       f0 0d	   w013       =	$F00D
     19  5000 ????	       f0 0e	   w014       =	$F00E
     20  5000 ????	       f0 0f	   w015       =	$F00F
     21  5000 ????	       f0 10	   w016       =	$F010
     22  5000 ????	       f0 11	   w017       =	$F011
     23  5000 ????	       f0 12	   w018       =	$F012
     24  5000 ????	       f0 13	   w019       =	$F013
     25  5000 ????	       f0 14	   w020       =	$F014
     26  5000 ????	       f0 15	   w021       =	$F015
     27  5000 ????	       f0 16	   w022       =	$F016
     28  5000 ????	       f0 17	   w023       =	$F017
     29  5000 ????	       f0 18	   w024       =	$F018
     30  5000 ????	       f0 19	   w025       =	$F019
     31  5000 ????	       f0 1a	   w026       =	$F01A
     32  5000 ????	       f0 1b	   w027       =	$F01B
     33  5000 ????	       f0 1c	   w028       =	$F01C
     34  5000 ????	       f0 1d	   w029       =	$F01D
     35  5000 ????	       f0 1e	   w030       =	$F01E
     36  5000 ????	       f0 1f	   w031       =	$F01F
     37  5000 ????	       f0 20	   w032       =	$F020
     38  5000 ????	       f0 21	   w033       =	$F021
     39  5000 ????	       f0 22	   w034       =	$F022
     40  5000 ????	       f0 23	   w035       =	$F023
     41  5000 ????	       f0 24	   w036       =	$F024
     42  5000 ????	       f0 25	   w037       =	$F025
     43  5000 ????	       f0 26	   w038       =	$F026
     44  5000 ????	       f0 27	   w039       =	$F027
     45  5000 ????	       f0 28	   w040       =	$F028
     46  5000 ????	       f0 29	   w041       =	$F029
     47  5000 ????	       f0 2a	   w042       =	$F02A
     48  5000 ????	       f0 2b	   w043       =	$F02B
     49  5000 ????	       f0 2c	   w044       =	$F02C
     50  5000 ????	       f0 2d	   w045       =	$F02D
     51  5000 ????	       f0 2e	   w046       =	$F02E
     52  5000 ????	       f0 2f	   w047       =	$F02F
     53  5000 ????	       f0 30	   w048       =	$F030
     54  5000 ????	       f0 31	   w049       =	$F031
     55  5000 ????	       f0 32	   w050       =	$F032
     56  5000 ????	       f0 33	   w051       =	$F033
     57  5000 ????	       f0 34	   w052       =	$F034
     58  5000 ????	       f0 35	   w053       =	$F035
     59  5000 ????	       f0 36	   w054       =	$F036
     60  5000 ????	       f0 37	   w055       =	$F037
     61  5000 ????	       f0 38	   w056       =	$F038
     62  5000 ????	       f0 39	   w057       =	$F039
     63  5000 ????	       f0 3a	   w058       =	$F03A
     64  5000 ????	       f0 3b	   w059       =	$F03B
     65  5000 ????	       f0 3c	   w060       =	$F03C
     66  5000 ????	       f0 3d	   w061       =	$F03D
     67  5000 ????	       f0 3e	   w062       =	$F03E
     68  5000 ????	       f0 3f	   w063       =	$F03F
     69  5000 ????	       f0 40	   w064       =	$F040
     70  5000 ????	       f0 41	   w065       =	$F041
     71  5000 ????	       f0 42	   w066       =	$F042
     72  5000 ????	       f0 43	   w067       =	$F043
     73  5000 ????	       f0 44	   w068       =	$F044
     74  5000 ????	       f0 45	   w069       =	$F045
     75  5000 ????	       f0 46	   w070       =	$F046
     76  5000 ????	       f0 47	   w071       =	$F047
     77  5000 ????	       f0 48	   w072       =	$F048
     78  5000 ????	       f0 49	   w073       =	$F049
     79  5000 ????	       f0 4a	   w074       =	$F04A
     80  5000 ????	       f0 4b	   w075       =	$F04B
     81  5000 ????	       f0 4c	   w076       =	$F04C
     82  5000 ????	       f0 4d	   w077       =	$F04D
     83  5000 ????	       f0 4e	   w078       =	$F04E
     84  5000 ????	       f0 4f	   w079       =	$F04F
     85  5000 ????	       f0 50	   w080       =	$F050
     86  5000 ????	       f0 51	   w081       =	$F051
     87  5000 ????	       f0 52	   w082       =	$F052
     88  5000 ????	       f0 53	   w083       =	$F053
     89  5000 ????	       f0 54	   w084       =	$F054
     90  5000 ????	       f0 55	   w085       =	$F055
     91  5000 ????	       f0 56	   w086       =	$F056
     92  5000 ????	       f0 57	   w087       =	$F057
     93  5000 ????	       f0 58	   w088       =	$F058
     94  5000 ????	       f0 59	   w089       =	$F059
     95  5000 ????	       f0 5a	   w090       =	$F05A
     96  5000 ????	       f0 5b	   w091       =	$F05B
     97  5000 ????	       f0 5c	   w092       =	$F05C
     98  5000 ????	       f0 5d	   w093       =	$F05D
     99  5000 ????	       f0 5e	   w094       =	$F05E
    100  5000 ????	       f0 5f	   w095       =	$F05F
    101  5000 ????	       f0 60	   w096       =	$F060
    102  5000 ????	       f0 61	   w097       =	$F061
    103  5000 ????	       f0 62	   w098       =	$F062
    104  5000 ????	       f0 63	   w099       =	$F063
    105  5000 ????	       f0 64	   w100       =	$F064
    106  5000 ????	       f0 65	   w101       =	$F065
    107  5000 ????	       f0 66	   w102       =	$F066
    108  5000 ????	       f0 67	   w103       =	$F067
    109  5000 ????	       f0 68	   w104       =	$F068
    110  5000 ????	       f0 69	   w105       =	$F069
    111  5000 ????	       f0 6a	   w106       =	$F06A
    112  5000 ????	       f0 6b	   w107       =	$F06B
    113  5000 ????	       f0 6c	   w108       =	$F06C
    114  5000 ????	       f0 6d	   w109       =	$F06D
    115  5000 ????	       f0 6e	   w110       =	$F06E
    116  5000 ????	       f0 6f	   w111       =	$F06F
    117  5000 ????	       f0 70	   w112       =	$F070
    118  5000 ????	       f0 71	   w113       =	$F071
    119  5000 ????	       f0 72	   w114       =	$F072
    120  5000 ????	       f0 73	   w115       =	$F073
    121  5000 ????	       f0 74	   w116       =	$F074
    122  5000 ????	       f0 75	   w117       =	$F075
    123  5000 ????	       f0 76	   w118       =	$F076
    124  5000 ????	       f0 77	   w119       =	$F077
    125  5000 ????	       f0 78	   w120       =	$F078
    126  5000 ????	       f0 79	   w121       =	$F079
    127  5000 ????	       f0 7a	   w122       =	$F07A
    128  5000 ????	       f0 7b	   w123       =	$F07B
    129  5000 ????	       f0 7c	   w124       =	$F07C
    130  5000 ????	       f0 7d	   w125       =	$F07D
    131  5000 ????	       f0 7e	   w126       =	$F07E
    132  5000 ????	       f0 7f	   w127       =	$F07F
    133  5000 ????
    134  5000 ????	       f0 80	   read_RAM   =	$F080
    135  5000 ????	       f0 80	   rRAM       =	$F080
    136  5000 ????	       f0 80	   r000       =	$F080
    137  5000 ????	       f0 81	   r001       =	$F081
    138  5000 ????	       f0 82	   r002       =	$F082
    139  5000 ????	       f0 83	   r003       =	$F083
    140  5000 ????	       f0 84	   r004       =	$F084
    141  5000 ????	       f0 85	   r005       =	$F085
    142  5000 ????	       f0 86	   r006       =	$F086
    143  5000 ????	       f0 87	   r007       =	$F087
    144  5000 ????	       f0 88	   r008       =	$F088
    145  5000 ????	       f0 89	   r009       =	$F089
    146  5000 ????	       f0 8a	   r010       =	$F08A
    147  5000 ????	       f0 8b	   r011       =	$F08B
    148  5000 ????	       f0 8c	   r012       =	$F08C
    149  5000 ????	       f0 8d	   r013       =	$F08D
    150  5000 ????	       f0 8e	   r014       =	$F08E
    151  5000 ????	       f0 8f	   r015       =	$F08F
    152  5000 ????	       f0 90	   r016       =	$F090
    153  5000 ????	       f0 91	   r017       =	$F091
    154  5000 ????	       f0 92	   r018       =	$F092
    155  5000 ????	       f0 93	   r019       =	$F093
    156  5000 ????	       f0 94	   r020       =	$F094
    157  5000 ????	       f0 95	   r021       =	$F095
    158  5000 ????	       f0 96	   r022       =	$F096
    159  5000 ????	       f0 97	   r023       =	$F097
    160  5000 ????	       f0 98	   r024       =	$F098
    161  5000 ????	       f0 99	   r025       =	$F099
    162  5000 ????	       f0 9a	   r026       =	$F09A
    163  5000 ????	       f0 9b	   r027       =	$F09B
    164  5000 ????	       f0 9c	   r028       =	$F09C
    165  5000 ????	       f0 9d	   r029       =	$F09D
    166  5000 ????	       f0 9e	   r030       =	$F09E
    167  5000 ????	       f0 9f	   r031       =	$F09F
    168  5000 ????	       f0 a0	   r032       =	$F0A0
    169  5000 ????	       f0 a1	   r033       =	$F0A1
    170  5000 ????	       f0 a2	   r034       =	$F0A2
    171  5000 ????	       f0 a3	   r035       =	$F0A3
    172  5000 ????	       f0 a4	   r036       =	$F0A4
    173  5000 ????	       f0 a5	   r037       =	$F0A5
    174  5000 ????	       f0 a6	   r038       =	$F0A6
    175  5000 ????	       f0 a7	   r039       =	$F0A7
    176  5000 ????	       f0 a8	   r040       =	$F0A8
    177  5000 ????	       f0 a9	   r041       =	$F0A9
    178  5000 ????	       f0 aa	   r042       =	$F0AA
    179  5000 ????	       f0 ab	   r043       =	$F0AB
    180  5000 ????	       f0 ac	   r044       =	$F0AC
    181  5000 ????	       f0 ad	   r045       =	$F0AD
    182  5000 ????	       f0 ae	   r046       =	$F0AE
    183  5000 ????	       f0 af	   r047       =	$F0AF
    184  5000 ????	       f0 b0	   r048       =	$F0B0
    185  5000 ????	       f0 b1	   r049       =	$F0B1
    186  5000 ????	       f0 b2	   r050       =	$F0B2
    187  5000 ????	       f0 b3	   r051       =	$F0B3
    188  5000 ????	       f0 b4	   r052       =	$F0B4
    189  5000 ????	       f0 b5	   r053       =	$F0B5
    190  5000 ????	       f0 b6	   r054       =	$F0B6
    191  5000 ????	       f0 b7	   r055       =	$F0B7
    192  5000 ????	       f0 b8	   r056       =	$F0B8
    193  5000 ????	       f0 b9	   r057       =	$F0B9
    194  5000 ????	       f0 ba	   r058       =	$F0BA
    195  5000 ????	       f0 bb	   r059       =	$F0BB
    196  5000 ????	       f0 bc	   r060       =	$F0BC
    197  5000 ????	       f0 bd	   r061       =	$F0BD
    198  5000 ????	       f0 be	   r062       =	$F0BE
    199  5000 ????	       f0 bf	   r063       =	$F0BF
    200  5000 ????	       f0 c0	   r064       =	$F0C0
    201  5000 ????	       f0 c1	   r065       =	$F0C1
    202  5000 ????	       f0 c2	   r066       =	$F0C2
    203  5000 ????	       f0 c3	   r067       =	$F0C3
    204  5000 ????	       f0 c4	   r068       =	$F0C4
    205  5000 ????	       f0 c5	   r069       =	$F0C5
    206  5000 ????	       f0 c6	   r070       =	$F0C6
    207  5000 ????	       f0 c7	   r071       =	$F0C7
    208  5000 ????	       f0 c8	   r072       =	$F0C8
    209  5000 ????	       f0 c9	   r073       =	$F0C9
    210  5000 ????	       f0 ca	   r074       =	$F0CA
    211  5000 ????	       f0 cb	   r075       =	$F0CB
    212  5000 ????	       f0 cc	   r076       =	$F0CC
    213  5000 ????	       f0 cd	   r077       =	$F0CD
    214  5000 ????	       f0 ce	   r078       =	$F0CE
    215  5000 ????	       f0 cf	   r079       =	$F0CF
    216  5000 ????	       f0 d0	   r080       =	$F0D0
    217  5000 ????	       f0 d1	   r081       =	$F0D1
    218  5000 ????	       f0 d2	   r082       =	$F0D2
    219  5000 ????	       f0 d3	   r083       =	$F0D3
    220  5000 ????	       f0 d4	   r084       =	$F0D4
    221  5000 ????	       f0 d5	   r085       =	$F0D5
    222  5000 ????	       f0 d6	   r086       =	$F0D6
    223  5000 ????	       f0 d7	   r087       =	$F0D7
    224  5000 ????	       f0 d8	   r088       =	$F0D8
    225  5000 ????	       f0 d9	   r089       =	$F0D9
    226  5000 ????	       f0 da	   r090       =	$F0DA
    227  5000 ????	       f0 db	   r091       =	$F0DB
    228  5000 ????	       f0 dc	   r092       =	$F0DC
    229  5000 ????	       f0 dd	   r093       =	$F0DD
    230  5000 ????	       f0 de	   r094       =	$F0DE
    231  5000 ????	       f0 df	   r095       =	$F0DF
    232  5000 ????	       f0 e0	   r096       =	$F0E0
    233  5000 ????	       f0 e1	   r097       =	$F0E1
    234  5000 ????	       f0 e2	   r098       =	$F0E2
    235  5000 ????	       f0 e3	   r099       =	$F0E3
    236  5000 ????	       f0 e4	   r100       =	$F0E4
    237  5000 ????	       f0 e5	   r101       =	$F0E5
    238  5000 ????	       f0 e6	   r102       =	$F0E6
    239  5000 ????	       f0 e7	   r103       =	$F0E7
    240  5000 ????	       f0 e8	   r104       =	$F0E8
    241  5000 ????	       f0 e9	   r105       =	$F0E9
    242  5000 ????	       f0 ea	   r106       =	$F0EA
    243  5000 ????	       f0 eb	   r107       =	$F0EB
    244  5000 ????	       f0 ec	   r108       =	$F0EC
    245  5000 ????	       f0 ed	   r109       =	$F0ED
    246  5000 ????	       f0 ee	   r110       =	$F0EE
    247  5000 ????	       f0 ef	   r111       =	$F0EF
    248  5000 ????	       f0 f0	   r112       =	$F0F0
    249  5000 ????	       f0 f1	   r113       =	$F0F1
    250  5000 ????	       f0 f2	   r114       =	$F0F2
    251  5000 ????	       f0 f3	   r115       =	$F0F3
    252  5000 ????	       f0 f4	   r116       =	$F0F4
    253  5000 ????	       f0 f5	   r117       =	$F0F5
    254  5000 ????	       f0 f6	   r118       =	$F0F6
    255  5000 ????	       f0 f7	   r119       =	$F0F7
    256  5000 ????	       f0 f8	   r120       =	$F0F8
    257  5000 ????	       f0 f9	   r121       =	$F0F9
    258  5000 ????	       f0 fa	   r122       =	$F0FA
    259  5000 ????	       f0 fb	   r123       =	$F0FB
    260  5000 ????	       f0 fc	   r124       =	$F0FC
    261  5000 ????	       f0 fd	   r125       =	$F0FD
    262  5000 ????	       f0 fe	   r126       =	$F0FE
    263  5000 ????	       f0 ff	   r127       =	$F0FF
------- FILE 2600basic.h
    201  5000 ????			  -	      else
    202  5000 ????			  -playfieldbase =	$A4
    203  5000 ????				      endif
    204  5000 ????
    205  5000 ????				      ifnconst	pfhalfwidth
    206  5000 ????	       00 04	   pfwidth    =	4
    207  5000 ????	       00 0e	   PF1L       =	PF1
    208  5000 ????	       00 0f	   PF2L       =	PF2
    209  5000 ????	       00 0e	   PF1R       =	PF1
    210  5000 ????	       00 0f	   PF2R       =	PF2
    211  5000 ????	       00 00	   pfadjust   =	0
    212  5000 ????			  -	      else
    213  5000 ????			  -pfwidth    =	2
    214  5000 ????			  -	      ifconst	pfcenter
    215  5000 ????			  -PF1L       =	$3F	; no effect
    216  5000 ????			  -PF2L       =	PF2
    217  5000 ????			  -PF1R       =	$3F
    218  5000 ????			  -PF2R       =	PF2	; no effect
    219  5000 ????			  -pfadjust   =	1
    220  5000 ????			  -	      else
    221  5000 ????			  -PF1L       =	PF1
    222  5000 ????			  -PF2L       =	PF2
    223  5000 ????			  -PF1R       =	$3F	; no effect
    224  5000 ????			  -PF2R       =	$3F	; no effect
    225  5000 ????			  -pfadjust   =	0
    226  5000 ????			  -	      endif
    227  5000 ????				      endif
    228  5000 ????
    229  5000 ????						; define playfield start based on height
    230  5000 ????			  -	      ifnconst	pfres
    231  5000 ????			  -playfield  =	playfieldbase
    232  5000 ????				      else
    233  5000 ????	       10 a4	   playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  5000 ????				      endif
------- FILE e:\Documents\bB\demos\ex_maze_32x23.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 3
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 20	   bscode_length =	32
      4  5000 ????	       00 17	   pfres      =	23
      5  5000 ????
      6  5000 ????	       00 ed	   rand16     =	z
      7  5000 ????
      8  5000 ????	       00 ec	   _Bit6_Flip_P0 =	y
      9  5000 ????
     10  5000 ????	       00 ec	   _Bit5_Direction_Changed =	y
     11  5000 ????
     12  5000 ????	       00 ec	   _Bit3_vblank =	y
     13  5000 ????
     14  5000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     15  5000 ????
     16  5000 ????	       00 ec	   _BitOp_01  =	y
     17  5000 ????
     18  5000 ????	       00 e8	   _Bit7_P1_Dir_Right =	u
     19  5000 ????
     20  5000 ????	       00 e8	   _Bit6_P1_Dir_Left =	u
     21  5000 ????
     22  5000 ????	       00 e8	   _Bit5_P1_Dir_Down =	u
     23  5000 ????
     24  5000 ????	       00 e8	   _Bit4_P1_Dir_Up =	u
     25  5000 ????
     26  5000 ????	       00 e8	   _Bit3_P0_Dir_Right =	u
     27  5000 ????
     28  5000 ????	       00 e8	   _Bit2_P0_Dir_Left =	u
     29  5000 ????
     30  5000 ????	       00 e8	   _Bit1_P0_Dir_Down =	u
     31  5000 ????
     32  5000 ????	       00 e8	   _Bit0_P0_Dir_Up =	u
     33  5000 ????
     34  5000 ????	       00 e8	   _BitOp_P0_P1_Dir =	u
     35  5000 ????
     36  5000 ????	       00 e1	   _Frame_Counter =	n
     37  5000 ????
     38  5000 ????	       00 e0	   _Master_Counter =	m
     39  5000 ????
     40  5000 ????	       00 de	   _MyTemp01  =	k
     41  5000 ????
     42  5000 ????	       00 d9	   _Enemy_Rand_Look =	f
     43  5000 ????
     44  5000 ????	       00 d8	   _Enemy_Counter =	e
     45  5000 ????
     46  5000 ????	       00 86	   _P1_U_D    =	player1y
     47  5000 ????	       00 81	   _P1_L_R    =	player1x
     48  5000 ????	       00 85	   _P0_U_D    =	player0y
     49  5000 ????	       00 80	   _P0_L_R    =	player0x
     50  5000 ????	       00 01	   superchip  =	1
     51  5000 ????	       00 03	   bs_mask    =	3
     52  5000 ????	       00 10	   bankswitch =	16
     53  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     54  5000 ????	       00 01	   no_blank_lines =	1
------- FILE e:\Documents\bB\demos\ex_maze_32x23.bas.asm
      8  5000 ????				      ifconst	bankswitch
      9  5000 ????			  -	      if	bankswitch == 8
     10  5000 ????			  -	      ORG	$1000
     11  5000 ????			  -	      RORG	$D000
     12  5000 ????				      endif
     13  5000 ????				      if	bankswitch == 16
     14  1000					      ORG	$1000
     15  1000					      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000					      repeat	256
     29  1000		       ff		      .byte.b	$ff
     28  1000					      repend
     29  1001		       ff		      .byte.b	$ff
     28  1001					      repend
     29  1002		       ff		      .byte.b	$ff
     28  1002					      repend
     29  1003		       ff		      .byte.b	$ff
     28  1003					      repend
     29  1004		       ff		      .byte.b	$ff
     28  1004					      repend
     29  1005		       ff		      .byte.b	$ff
     28  1005					      repend
     29  1006		       ff		      .byte.b	$ff
     28  1006					      repend
     29  1007		       ff		      .byte.b	$ff
     28  1007					      repend
     29  1008		       ff		      .byte.b	$ff
     28  1008					      repend
     29  1009		       ff		      .byte.b	$ff
     28  1009					      repend
     29  100a		       ff		      .byte.b	$ff
     28  100a					      repend
     29  100b		       ff		      .byte.b	$ff
     28  100b					      repend
     29  100c		       ff		      .byte.b	$ff
     28  100c					      repend
     29  100d		       ff		      .byte.b	$ff
     28  100d					      repend
     29  100e		       ff		      .byte.b	$ff
     28  100e					      repend
     29  100f		       ff		      .byte.b	$ff
     28  100f					      repend
     29  1010		       ff		      .byte.b	$ff
     28  1010					      repend
     29  1011		       ff		      .byte.b	$ff
     28  1011					      repend
     29  1012		       ff		      .byte.b	$ff
     28  1012					      repend
     29  1013		       ff		      .byte.b	$ff
     28  1013					      repend
     29  1014		       ff		      .byte.b	$ff
     28  1014					      repend
     29  1015		       ff		      .byte.b	$ff
     28  1015					      repend
     29  1016		       ff		      .byte.b	$ff
     28  1016					      repend
     29  1017		       ff		      .byte.b	$ff
     28  1017					      repend
     29  1018		       ff		      .byte.b	$ff
     28  1018					      repend
     29  1019		       ff		      .byte.b	$ff
     28  1019					      repend
     29  101a		       ff		      .byte.b	$ff
     28  101a					      repend
     29  101b		       ff		      .byte.b	$ff
     28  101b					      repend
     29  101c		       ff		      .byte.b	$ff
     28  101c					      repend
     29  101d		       ff		      .byte.b	$ff
     28  101d					      repend
     29  101e		       ff		      .byte.b	$ff
     28  101e					      repend
     29  101f		       ff		      .byte.b	$ff
     28  101f					      repend
     29  1020		       ff		      .byte.b	$ff
     28  1020					      repend
     29  1021		       ff		      .byte.b	$ff
     28  1021					      repend
     29  1022		       ff		      .byte.b	$ff
     28  1022					      repend
     29  1023		       ff		      .byte.b	$ff
     28  1023					      repend
     29  1024		       ff		      .byte.b	$ff
     28  1024					      repend
     29  1025		       ff		      .byte.b	$ff
     28  1025					      repend
     29  1026		       ff		      .byte.b	$ff
     28  1026					      repend
     29  1027		       ff		      .byte.b	$ff
     28  1027					      repend
     29  1028		       ff		      .byte.b	$ff
     28  1028					      repend
     29  1029		       ff		      .byte.b	$ff
     28  1029					      repend
     29  102a		       ff		      .byte.b	$ff
     28  102a					      repend
     29  102b		       ff		      .byte.b	$ff
     28  102b					      repend
     29  102c		       ff		      .byte.b	$ff
     28  102c					      repend
     29  102d		       ff		      .byte.b	$ff
     28  102d					      repend
     29  102e		       ff		      .byte.b	$ff
     28  102e					      repend
     29  102f		       ff		      .byte.b	$ff
     28  102f					      repend
     29  1030		       ff		      .byte.b	$ff
     28  1030					      repend
     29  1031		       ff		      .byte.b	$ff
     28  1031					      repend
     29  1032		       ff		      .byte.b	$ff
     28  1032					      repend
     29  1033		       ff		      .byte.b	$ff
     28  1033					      repend
     29  1034		       ff		      .byte.b	$ff
     28  1034					      repend
     29  1035		       ff		      .byte.b	$ff
     28  1035					      repend
     29  1036		       ff		      .byte.b	$ff
     28  1036					      repend
     29  1037		       ff		      .byte.b	$ff
     28  1037					      repend
     29  1038		       ff		      .byte.b	$ff
     28  1038					      repend
     29  1039		       ff		      .byte.b	$ff
     28  1039					      repend
     29  103a		       ff		      .byte.b	$ff
     28  103a					      repend
     29  103b		       ff		      .byte.b	$ff
     28  103b					      repend
     29  103c		       ff		      .byte.b	$ff
     28  103c					      repend
     29  103d		       ff		      .byte.b	$ff
     28  103d					      repend
     29  103e		       ff		      .byte.b	$ff
     28  103e					      repend
     29  103f		       ff		      .byte.b	$ff
     28  103f					      repend
     29  1040		       ff		      .byte.b	$ff
     28  1040					      repend
     29  1041		       ff		      .byte.b	$ff
     28  1041					      repend
     29  1042		       ff		      .byte.b	$ff
     28  1042					      repend
     29  1043		       ff		      .byte.b	$ff
     28  1043					      repend
     29  1044		       ff		      .byte.b	$ff
     28  1044					      repend
     29  1045		       ff		      .byte.b	$ff
     28  1045					      repend
     29  1046		       ff		      .byte.b	$ff
     28  1046					      repend
     29  1047		       ff		      .byte.b	$ff
     28  1047					      repend
     29  1048		       ff		      .byte.b	$ff
     28  1048					      repend
     29  1049		       ff		      .byte.b	$ff
     28  1049					      repend
     29  104a		       ff		      .byte.b	$ff
     28  104a					      repend
     29  104b		       ff		      .byte.b	$ff
     28  104b					      repend
     29  104c		       ff		      .byte.b	$ff
     28  104c					      repend
     29  104d		       ff		      .byte.b	$ff
     28  104d					      repend
     29  104e		       ff		      .byte.b	$ff
     28  104e					      repend
     29  104f		       ff		      .byte.b	$ff
     28  104f					      repend
     29  1050		       ff		      .byte.b	$ff
     28  1050					      repend
     29  1051		       ff		      .byte.b	$ff
     28  1051					      repend
     29  1052		       ff		      .byte.b	$ff
     28  1052					      repend
     29  1053		       ff		      .byte.b	$ff
     28  1053					      repend
     29  1054		       ff		      .byte.b	$ff
     28  1054					      repend
     29  1055		       ff		      .byte.b	$ff
     28  1055					      repend
     29  1056		       ff		      .byte.b	$ff
     28  1056					      repend
     29  1057		       ff		      .byte.b	$ff
     28  1057					      repend
     29  1058		       ff		      .byte.b	$ff
     28  1058					      repend
     29  1059		       ff		      .byte.b	$ff
     28  1059					      repend
     29  105a		       ff		      .byte.b	$ff
     28  105a					      repend
     29  105b		       ff		      .byte.b	$ff
     28  105b					      repend
     29  105c		       ff		      .byte.b	$ff
     28  105c					      repend
     29  105d		       ff		      .byte.b	$ff
     28  105d					      repend
     29  105e		       ff		      .byte.b	$ff
     28  105e					      repend
     29  105f		       ff		      .byte.b	$ff
     28  105f					      repend
     29  1060		       ff		      .byte.b	$ff
     28  1060					      repend
     29  1061		       ff		      .byte.b	$ff
     28  1061					      repend
     29  1062		       ff		      .byte.b	$ff
     28  1062					      repend
     29  1063		       ff		      .byte.b	$ff
     28  1063					      repend
     29  1064		       ff		      .byte.b	$ff
     28  1064					      repend
     29  1065		       ff		      .byte.b	$ff
     28  1065					      repend
     29  1066		       ff		      .byte.b	$ff
     28  1066					      repend
     29  1067		       ff		      .byte.b	$ff
     28  1067					      repend
     29  1068		       ff		      .byte.b	$ff
     28  1068					      repend
     29  1069		       ff		      .byte.b	$ff
     28  1069					      repend
     29  106a		       ff		      .byte.b	$ff
     28  106a					      repend
     29  106b		       ff		      .byte.b	$ff
     28  106b					      repend
     29  106c		       ff		      .byte.b	$ff
     28  106c					      repend
     29  106d		       ff		      .byte.b	$ff
     28  106d					      repend
     29  106e		       ff		      .byte.b	$ff
     28  106e					      repend
     29  106f		       ff		      .byte.b	$ff
     28  106f					      repend
     29  1070		       ff		      .byte.b	$ff
     28  1070					      repend
     29  1071		       ff		      .byte.b	$ff
     28  1071					      repend
     29  1072		       ff		      .byte.b	$ff
     28  1072					      repend
     29  1073		       ff		      .byte.b	$ff
     28  1073					      repend
     29  1074		       ff		      .byte.b	$ff
     28  1074					      repend
     29  1075		       ff		      .byte.b	$ff
     28  1075					      repend
     29  1076		       ff		      .byte.b	$ff
     28  1076					      repend
     29  1077		       ff		      .byte.b	$ff
     28  1077					      repend
     29  1078		       ff		      .byte.b	$ff
     28  1078					      repend
     29  1079		       ff		      .byte.b	$ff
     28  1079					      repend
     29  107a		       ff		      .byte.b	$ff
     28  107a					      repend
     29  107b		       ff		      .byte.b	$ff
     28  107b					      repend
     29  107c		       ff		      .byte.b	$ff
     28  107c					      repend
     29  107d		       ff		      .byte.b	$ff
     28  107d					      repend
     29  107e		       ff		      .byte.b	$ff
     28  107e					      repend
     29  107f		       ff		      .byte.b	$ff
     28  107f					      repend
     29  1080		       ff		      .byte.b	$ff
     28  1080					      repend
     29  1081		       ff		      .byte.b	$ff
     28  1081					      repend
     29  1082		       ff		      .byte.b	$ff
     28  1082					      repend
     29  1083		       ff		      .byte.b	$ff
     28  1083					      repend
     29  1084		       ff		      .byte.b	$ff
     28  1084					      repend
     29  1085		       ff		      .byte.b	$ff
     28  1085					      repend
     29  1086		       ff		      .byte.b	$ff
     28  1086					      repend
     29  1087		       ff		      .byte.b	$ff
     28  1087					      repend
     29  1088		       ff		      .byte.b	$ff
     28  1088					      repend
     29  1089		       ff		      .byte.b	$ff
     28  1089					      repend
     29  108a		       ff		      .byte.b	$ff
     28  108a					      repend
     29  108b		       ff		      .byte.b	$ff
     28  108b					      repend
     29  108c		       ff		      .byte.b	$ff
     28  108c					      repend
     29  108d		       ff		      .byte.b	$ff
     28  108d					      repend
     29  108e		       ff		      .byte.b	$ff
     28  108e					      repend
     29  108f		       ff		      .byte.b	$ff
     28  108f					      repend
     29  1090		       ff		      .byte.b	$ff
     28  1090					      repend
     29  1091		       ff		      .byte.b	$ff
     28  1091					      repend
     29  1092		       ff		      .byte.b	$ff
     28  1092					      repend
     29  1093		       ff		      .byte.b	$ff
     28  1093					      repend
     29  1094		       ff		      .byte.b	$ff
     28  1094					      repend
     29  1095		       ff		      .byte.b	$ff
     28  1095					      repend
     29  1096		       ff		      .byte.b	$ff
     28  1096					      repend
     29  1097		       ff		      .byte.b	$ff
     28  1097					      repend
     29  1098		       ff		      .byte.b	$ff
     28  1098					      repend
     29  1099		       ff		      .byte.b	$ff
     28  1099					      repend
     29  109a		       ff		      .byte.b	$ff
     28  109a					      repend
     29  109b		       ff		      .byte.b	$ff
     28  109b					      repend
     29  109c		       ff		      .byte.b	$ff
     28  109c					      repend
     29  109d		       ff		      .byte.b	$ff
     28  109d					      repend
     29  109e		       ff		      .byte.b	$ff
     28  109e					      repend
     29  109f		       ff		      .byte.b	$ff
     28  109f					      repend
     29  10a0		       ff		      .byte.b	$ff
     28  10a0					      repend
     29  10a1		       ff		      .byte.b	$ff
     28  10a1					      repend
     29  10a2		       ff		      .byte.b	$ff
     28  10a2					      repend
     29  10a3		       ff		      .byte.b	$ff
     28  10a3					      repend
     29  10a4		       ff		      .byte.b	$ff
     28  10a4					      repend
     29  10a5		       ff		      .byte.b	$ff
     28  10a5					      repend
     29  10a6		       ff		      .byte.b	$ff
     28  10a6					      repend
     29  10a7		       ff		      .byte.b	$ff
     28  10a7					      repend
     29  10a8		       ff		      .byte.b	$ff
     28  10a8					      repend
     29  10a9		       ff		      .byte.b	$ff
     28  10a9					      repend
     29  10aa		       ff		      .byte.b	$ff
     28  10aa					      repend
     29  10ab		       ff		      .byte.b	$ff
     28  10ab					      repend
     29  10ac		       ff		      .byte.b	$ff
     28  10ac					      repend
     29  10ad		       ff		      .byte.b	$ff
     28  10ad					      repend
     29  10ae		       ff		      .byte.b	$ff
     28  10ae					      repend
     29  10af		       ff		      .byte.b	$ff
     28  10af					      repend
     29  10b0		       ff		      .byte.b	$ff
     28  10b0					      repend
     29  10b1		       ff		      .byte.b	$ff
     28  10b1					      repend
     29  10b2		       ff		      .byte.b	$ff
     28  10b2					      repend
     29  10b3		       ff		      .byte.b	$ff
     28  10b3					      repend
     29  10b4		       ff		      .byte.b	$ff
     28  10b4					      repend
     29  10b5		       ff		      .byte.b	$ff
     28  10b5					      repend
     29  10b6		       ff		      .byte.b	$ff
     28  10b6					      repend
     29  10b7		       ff		      .byte.b	$ff
     28  10b7					      repend
     29  10b8		       ff		      .byte.b	$ff
     28  10b8					      repend
     29  10b9		       ff		      .byte.b	$ff
     28  10b9					      repend
     29  10ba		       ff		      .byte.b	$ff
     28  10ba					      repend
     29  10bb		       ff		      .byte.b	$ff
     28  10bb					      repend
     29  10bc		       ff		      .byte.b	$ff
     28  10bc					      repend
     29  10bd		       ff		      .byte.b	$ff
     28  10bd					      repend
     29  10be		       ff		      .byte.b	$ff
     28  10be					      repend
     29  10bf		       ff		      .byte.b	$ff
     28  10bf					      repend
     29  10c0		       ff		      .byte.b	$ff
     28  10c0					      repend
     29  10c1		       ff		      .byte.b	$ff
     28  10c1					      repend
     29  10c2		       ff		      .byte.b	$ff
     28  10c2					      repend
     29  10c3		       ff		      .byte.b	$ff
     28  10c3					      repend
     29  10c4		       ff		      .byte.b	$ff
     28  10c4					      repend
     29  10c5		       ff		      .byte.b	$ff
     28  10c5					      repend
     29  10c6		       ff		      .byte.b	$ff
     28  10c6					      repend
     29  10c7		       ff		      .byte.b	$ff
     28  10c7					      repend
     29  10c8		       ff		      .byte.b	$ff
     28  10c8					      repend
     29  10c9		       ff		      .byte.b	$ff
     28  10c9					      repend
     29  10ca		       ff		      .byte.b	$ff
     28  10ca					      repend
     29  10cb		       ff		      .byte.b	$ff
     28  10cb					      repend
     29  10cc		       ff		      .byte.b	$ff
     28  10cc					      repend
     29  10cd		       ff		      .byte.b	$ff
     28  10cd					      repend
     29  10ce		       ff		      .byte.b	$ff
     28  10ce					      repend
     29  10cf		       ff		      .byte.b	$ff
     28  10cf					      repend
     29  10d0		       ff		      .byte.b	$ff
     28  10d0					      repend
     29  10d1		       ff		      .byte.b	$ff
     28  10d1					      repend
     29  10d2		       ff		      .byte.b	$ff
     28  10d2					      repend
     29  10d3		       ff		      .byte.b	$ff
     28  10d3					      repend
     29  10d4		       ff		      .byte.b	$ff
     28  10d4					      repend
     29  10d5		       ff		      .byte.b	$ff
     28  10d5					      repend
     29  10d6		       ff		      .byte.b	$ff
     28  10d6					      repend
     29  10d7		       ff		      .byte.b	$ff
     28  10d7					      repend
     29  10d8		       ff		      .byte.b	$ff
     28  10d8					      repend
     29  10d9		       ff		      .byte.b	$ff
     28  10d9					      repend
     29  10da		       ff		      .byte.b	$ff
     28  10da					      repend
     29  10db		       ff		      .byte.b	$ff
     28  10db					      repend
     29  10dc		       ff		      .byte.b	$ff
     28  10dc					      repend
     29  10dd		       ff		      .byte.b	$ff
     28  10dd					      repend
     29  10de		       ff		      .byte.b	$ff
     28  10de					      repend
     29  10df		       ff		      .byte.b	$ff
     28  10df					      repend
     29  10e0		       ff		      .byte.b	$ff
     28  10e0					      repend
     29  10e1		       ff		      .byte.b	$ff
     28  10e1					      repend
     29  10e2		       ff		      .byte.b	$ff
     28  10e2					      repend
     29  10e3		       ff		      .byte.b	$ff
     28  10e3					      repend
     29  10e4		       ff		      .byte.b	$ff
     28  10e4					      repend
     29  10e5		       ff		      .byte.b	$ff
     28  10e5					      repend
     29  10e6		       ff		      .byte.b	$ff
     28  10e6					      repend
     29  10e7		       ff		      .byte.b	$ff
     28  10e7					      repend
     29  10e8		       ff		      .byte.b	$ff
     28  10e8					      repend
     29  10e9		       ff		      .byte.b	$ff
     28  10e9					      repend
     29  10ea		       ff		      .byte.b	$ff
     28  10ea					      repend
     29  10eb		       ff		      .byte.b	$ff
     28  10eb					      repend
     29  10ec		       ff		      .byte.b	$ff
     28  10ec					      repend
     29  10ed		       ff		      .byte.b	$ff
     28  10ed					      repend
     29  10ee		       ff		      .byte.b	$ff
     28  10ee					      repend
     29  10ef		       ff		      .byte.b	$ff
     28  10ef					      repend
     29  10f0		       ff		      .byte.b	$ff
     28  10f0					      repend
     29  10f1		       ff		      .byte.b	$ff
     28  10f1					      repend
     29  10f2		       ff		      .byte.b	$ff
     28  10f2					      repend
     29  10f3		       ff		      .byte.b	$ff
     28  10f3					      repend
     29  10f4		       ff		      .byte.b	$ff
     28  10f4					      repend
     29  10f5		       ff		      .byte.b	$ff
     28  10f5					      repend
     29  10f6		       ff		      .byte.b	$ff
     28  10f6					      repend
     29  10f7		       ff		      .byte.b	$ff
     28  10f7					      repend
     29  10f8		       ff		      .byte.b	$ff
     28  10f8					      repend
     29  10f9		       ff		      .byte.b	$ff
     28  10f9					      repend
     29  10fa		       ff		      .byte.b	$ff
     28  10fa					      repend
     29  10fb		       ff		      .byte.b	$ff
     28  10fb					      repend
     29  10fc		       ff		      .byte.b	$ff
     28  10fc					      repend
     29  10fd		       ff		      .byte.b	$ff
     28  10fd					      repend
     29  10fe		       ff		      .byte.b	$ff
     28  10fe					      repend
     29  10ff		       ff		      .byte.b	$ff
     30  1100					      repend
     31  1100				   game
     32  1100				   .
     33  1100							; 
     34  1100
     35  1100				   .
     36  1100							; 
     37  1100
     38  1100				   .
     39  1100							; 
     40  1100
     41  1100				   .
     42  1100							; 
     43  1100
     44  1100				   .
     45  1100							; 
     46  1100
     47  1100				   .
     48  1100							; 
     49  1100
     50  1100				   .
     51  1100							; 
     52  1100
     53  1100				   .
     54  1100							; 
     55  1100
     56  1100				   .
     57  1100							; 
     58  1100
     59  1100				   .
     60  1100							; 
     61  1100
     62  1100				   .
     63  1100							; 
     64  1100
     65  1100				   .
     66  1100							; 
     67  1100
     68  1100				   .
     69  1100							; 
     70  1100
     71  1100				   .
     72  1100							; 
     73  1100
     74  1100				   .
     75  1100							; 
     76  1100
     77  1100				   .
     78  1100							; 
     79  1100
     80  1100				   .
     81  1100							; 
     82  1100
     83  1100				   .
     84  1100							; 
     85  1100
     86  1100				   .
     87  1100							; 
     88  1100
     89  1100				   .
     90  1100							; 
     91  1100
     92  1100				   .
     93  1100							; 
     94  1100
     95  1100				   .
     96  1100							; 
     97  1100
     98  1100				   .
     99  1100							; 
    100  1100
    101  1100				   .
    102  1100							; 
    103  1100
    104  1100				   .
    105  1100							; 
    106  1100
    107  1100				   .
    108  1100							; 
    109  1100
    110  1100				   .
    111  1100							; 
    112  1100
    113  1100				   .
    114  1100							; 
    115  1100
    116  1100				   .
    117  1100							; 
    118  1100
    119  1100				   .L00 		;  set kernel_options no_blank_lines
    120  1100
    121  1100				   .
    122  1100							; 
    123  1100
    124  1100				   .
    125  1100							; 
    126  1100
    127  1100				   .
    128  1100							; 
    129  1100
    130  1100				   .
    131  1100							; 
    132  1100
    133  1100				   .
    134  1100							; 
    135  1100
    136  1100				   .
    137  1100							; 
    138  1100
    139  1100				   .
    140  1100							; 
    141  1100
    142  1100				   .L01 		;  set romsize 16kSC
    143  1100
    144  1100				   .
    145  1100							; 
    146  1100
    147  1100				   .
    148  1100							; 
    149  1100
    150  1100				   .
    151  1100							; 
    152  1100
    153  1100				   .
    154  1100							; 
    155  1100
    156  1100				   .
    157  1100							; 
    158  1100
    159  1100				   .
    160  1100							; 
    161  1100
    162  1100				   .
    163  1100							; 
    164  1100
    165  1100				   .
    166  1100							; 
    167  1100
    168  1100				   .L02 		;  set optimization inlinerand
    169  1100
    170  1100				   .
    171  1100							; 
    172  1100
    173  1100				   .
    174  1100							; 
    175  1100
    176  1100				   .
    177  1100							; 
    178  1100
    179  1100				   .
    180  1100							; 
    181  1100
    182  1100				   .
    183  1100							; 
    184  1100
    185  1100				   .
    186  1100							; 
    187  1100
    188  1100				   .
    189  1100							; 
    190  1100
    191  1100				   .
    192  1100							; 
    193  1100
    194  1100				   .
    195  1100							; 
    196  1100
    197  1100				   .
    198  1100							; 
    199  1100
    200  1100				   .
    201  1100							; 
    202  1100
    203  1100				   .
    204  1100							; 
    205  1100
    206  1100				   .
    207  1100							; 
    208  1100
    209  1100				   .
    210  1100							; 
    211  1100
    212  1100				   .
    213  1100							; 
    214  1100
    215  1100				   .
    216  1100							; 
    217  1100
    218  1100				   .
    219  1100							; 
    220  1100
    221  1100				   .
    222  1100							; 
    223  1100
    224  1100				   .
    225  1100							; 
    226  1100
    227  1100				   .
    228  1100							; 
    229  1100
    230  1100				   .
    231  1100							; 
    232  1100
    233  1100				   .
    234  1100							; 
    235  1100
    236  1100				   .
    237  1100							; 
    238  1100
    239  1100				   .
    240  1100							; 
    241  1100
    242  1100				   .
    243  1100							; 
    244  1100
    245  1100				   .
    246  1100							; 
    247  1100
    248  1100				   .
    249  1100							; 
    250  1100
    251  1100				   .
    252  1100							; 
    253  1100
    254  1100				   .
    255  1100							; 
    256  1100
    257  1100				   .
    258  1100							; 
    259  1100
    260  1100				   .L03 		;  dim _P0_L_R  =  player0x.a
    261  1100
    262  1100				   .L04 		;  dim _P0_U_D  =  player0y.b
    263  1100
    264  1100				   .
    265  1100							; 
    266  1100
    267  1100				   .
    268  1100							; 
    269  1100
    270  1100				   .
    271  1100							; 
    272  1100
    273  1100				   .
    274  1100							; 
    275  1100
    276  1100				   .
    277  1100							; 
    278  1100
    279  1100				   .L05 		;  dim _P1_L_R  =  player1x.c
    280  1100
    281  1100				   .L06 		;  dim _P1_U_D  =  player1y.d
    282  1100
    283  1100				   .
    284  1100							; 
    285  1100
    286  1100				   .
    287  1100							; 
    288  1100
    289  1100				   .
    290  1100							; 
    291  1100
    292  1100				   .
    293  1100							; 
    294  1100
    295  1100				   .
    296  1100							; 
    297  1100
    298  1100				   .L07 		;  dim _Enemy_Counter	=  e
    299  1100
    300  1100				   .
    301  1100							; 
    302  1100
    303  1100				   .
    304  1100							; 
    305  1100
    306  1100				   .
    307  1100							; 
    308  1100
    309  1100				   .
    310  1100							; 
    311  1100
    312  1100				   .L08 		;  dim _Enemy_Rand_Look  =  f
    313  1100
    314  1100				   .
    315  1100							; 
    316  1100
    317  1100				   .
    318  1100							; 
    319  1100
    320  1100				   .
    321  1100							; 
    322  1100
    323  1100				   .
    324  1100							; 
    325  1100
    326  1100				   .L09 		;  dim _MyTemp01  =  k
    327  1100
    328  1100				   .
    329  1100							; 
    330  1100
    331  1100				   .
    332  1100							; 
    333  1100
    334  1100				   .
    335  1100							; 
    336  1100
    337  1100				   .
    338  1100							; 
    339  1100
    340  1100				   .L010		;  dim _Master_Counter  =  m
    341  1100
    342  1100				   .L011		;  dim _Frame_Counter	=  n
    343  1100
    344  1100				   .
    345  1100							; 
    346  1100
    347  1100				   .
    348  1100							; 
    349  1100
    350  1100				   .
    351  1100							; 
    352  1100
    353  1100				   .
    354  1100							; 
    355  1100
    356  1100				   .L012		;  dim _BitOp_P0_P1_Dir  =  u
    357  1100
    358  1100				   .L013		;  dim _Bit0_P0_Dir_Up  =  u
    359  1100
    360  1100				   .L014		;  dim _Bit1_P0_Dir_Down  =  u
    361  1100
    362  1100				   .L015		;  dim _Bit2_P0_Dir_Left  =  u
    363  1100
    364  1100				   .L016		;  dim _Bit3_P0_Dir_Right  =  u
    365  1100
    366  1100				   .L017		;  dim _Bit4_P1_Dir_Up  =  u
    367  1100
    368  1100				   .L018		;  dim _Bit5_P1_Dir_Down  =  u
    369  1100
    370  1100				   .L019		;  dim _Bit6_P1_Dir_Left  =  u
    371  1100
    372  1100				   .L020		;  dim _Bit7_P1_Dir_Right  =  u
    373  1100
    374  1100				   .
    375  1100							; 
    376  1100
    377  1100				   .
    378  1100							; 
    379  1100
    380  1100				   .
    381  1100							; 
    382  1100
    383  1100				   .
    384  1100							; 
    385  1100
    386  1100				   .L021		;  dim _BitOp_01  =  y
    387  1100
    388  1100				   .L022		;  dim _Bit0_Reset_Restrainer	=  y
    389  1100
    390  1100				   .L023		;  dim _Bit3_vblank  =  y
    391  1100
    392  1100				   .L024		;  dim _Bit5_Direction_Changed  =  y
    393  1100
    394  1100				   .L025		;  dim _Bit6_Flip_P0  =  y
    395  1100
    396  1100				   .
    397  1100							; 
    398  1100
    399  1100				   .
    400  1100							; 
    401  1100
    402  1100				   .
    403  1100							; 
    404  1100
    405  1100				   .
    406  1100							; 
    407  1100
    408  1100				   .L026		;  dim rand16	=  z
    409  1100
    410  1100				   .
    411  1100							; 
    412  1100
    413  1100				   .
    414  1100							; 
    415  1100
    416  1100				   .
    417  1100							; 
    418  1100
    419  1100				   .
    420  1100							; 
    421  1100
    422  1100				   .
    423  1100							; 
    424  1100
    425  1100				   .
    426  1100							; 
    427  1100
    428  1100				   .
    429  1100							; 
    430  1100
    431  1100				   .L027		;  const pfres = 23
    432  1100
    433  1100				   .
    434  1100							; 
    435  1100
    436  1100				   .
    437  1100							; 
    438  1100
    439  1100				   .
    440  1100							; 
    441  1100
    442  1100				   .
    443  1100							; 
    444  1100
    445  1100				   .
    446  1100							; 
    447  1100
    448  1100				   .
    449  1100							; 
    450  1100
    451  1100				   .
    452  1100							; 
    453  1100
    454  1100				   .
    455  1100							; 
    456  1100
    457  1100				   .
    458  1100							; 
    459  1100
    460  1100				   .
    461  1100							; 
    462  1100
    463  1100				   .
    464  1100							; 
    465  1100
    466  1100				   .__Start_Restart
    467  1100							; __Start_Restart
    468  1100
    469  1100				   .
    470  1100							; 
    471  1100
    472  1100				   .
    473  1100							; 
    474  1100
    475  1100				   .
    476  1100							; 
    477  1100
    478  1100				   .
    479  1100							; 
    480  1100
    481  1100				   .
    482  1100							; 
    483  1100
    484  1100				   .
    485  1100							; 
    486  1100
    487  1100				   .L028		;  AUDV0  =  0  :  AUDV1  =  0
    488  1100
    489  1100		       a9 00		      LDA	#0
    490  1102		       85 19		      STA	AUDV0
    491  1104		       85 1a		      STA	AUDV1
    492  1106				   .
    493  1106							; 
    494  1106
    495  1106				   .
    496  1106							; 
    497  1106
    498  1106				   .
    499  1106							; 
    500  1106
    501  1106				   .
    502  1106							; 
    503  1106
    504  1106				   .
    505  1106							; 
    506  1106
    507  1106				   .
    508  1106							; 
    509  1106
    510  1106				   .
    511  1106							; 
    512  1106
    513  1106				   .
    514  1106							; 
    515  1106
    516  1106				   .L029		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    517  1106
    518  1106		       a9 00		      LDA	#0
    519  1108		       85 d4		      STA	a
    520  110a		       85 d5		      STA	b
    521  110c		       85 d6		      STA	c
    522  110e		       85 d7		      STA	d
    523  1110		       85 d8		      STA	e
    524  1112		       85 d9		      STA	f
    525  1114		       85 da		      STA	g
    526  1116		       85 db		      STA	h
    527  1118		       85 dc		      STA	i
    528  111a				   .L030		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    529  111a
    530  111a		       a9 00		      LDA	#0
    531  111c		       85 dd		      STA	j
    532  111e		       85 de		      STA	k
    533  1120		       85 df		      STA	l
    534  1122		       85 e0		      STA	m
    535  1124		       85 e1		      STA	n
    536  1126		       85 e2		      STA	o
    537  1128		       85 e3		      STA	p
    538  112a		       85 e4		      STA	q
    539  112c		       85 e5		      STA	r
    540  112e				   .L031		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0
    541  112e
    542  112e		       a9 00		      LDA	#0
    543  1130		       85 e6		      STA	s
    544  1132		       85 e7		      STA	t
    545  1134		       85 e8		      STA	u
    546  1136		       85 e9		      STA	v
    547  1138		       85 ea		      STA	w
    548  113a		       85 eb		      STA	x
    549  113c		       85 ec		      STA	y
    550  113e				   .
    551  113e							; 
    552  113e
    553  113e				   .
    554  113e							; 
    555  113e
    556  113e				   .
    557  113e							; 
    558  113e
    559  113e				   .
    560  113e							; 
    561  113e
    562  113e				   .
    563  113e							; 
    564  113e
    565  113e				   .
    566  113e							; 
    567  113e
    568  113e				   .L032		;  player0x  =  77  :	player0y  =  47
    569  113e
    570  113e		       a9 4d		      LDA	#77
    571  1140		       85 80		      STA	player0x
    572  1142		       a9 2f		      LDA	#47
    573  1144		       85 85		      STA	player0y
    574  1146				   .
    575  1146							; 
    576  1146
    577  1146				   .
    578  1146							; 
    579  1146
    580  1146				   .
    581  1146							; 
    582  1146
    583  1146				   .
    584  1146							; 
    585  1146
    586  1146				   .
    587  1146							; 
    588  1146
    589  1146				   .
    590  1146							; 
    591  1146
    592  1146				   .L033		;  player1x  =  77  :	player1y  =  83
    593  1146
    594  1146		       a9 4d		      LDA	#77
    595  1148		       85 81		      STA	player1x
    596  114a		       a9 53		      LDA	#83
    597  114c		       85 86		      STA	player1y
    598  114e				   .
    599  114e							; 
    600  114e
    601  114e				   .
    602  114e							; 
    603  114e
    604  114e				   .
    605  114e							; 
    606  114e
    607  114e				   .
    608  114e							; 
    609  114e
    610  114e				   .
    611  114e							; 
    612  114e
    613  114e				   .
    614  114e							; 
    615  114e
    616  114e				   .L034		;  COLUPF  =  $96
    617  114e
    618  114e		       a9 96		      LDA	#$96
    619  1150		       85 08		      STA	COLUPF
    620  1152				   .
    621  1152							; 
    622  1152
    623  1152				   .
    624  1152							; 
    625  1152
    626  1152				   .
    627  1152							; 
    628  1152
    629  1152				   .
    630  1152							; 
    631  1152
    632  1152				   .
    633  1152							; 
    634  1152
    635  1152				   .
    636  1152							; 
    637  1152
    638  1152				   .L035		;  COLUBK  =  0
    639  1152
    640  1152		       a9 00		      LDA	#0
    641  1154		       85 09		      STA	COLUBK
    642  1156				   .
    643  1156							; 
    644  1156
    645  1156				   .
    646  1156							; 
    647  1156
    648  1156				   .
    649  1156							; 
    650  1156
    651  1156				   .
    652  1156							; 
    653  1156
    654  1156				   .
    655  1156							; 
    656  1156
    657  1156				   .
    658  1156							; 
    659  1156
    660  1156				   .L036		;  _Bit2_P0_Dir_Left{2}  =  1
    661  1156
    662  1156		       a5 e8		      LDA	_Bit2_P0_Dir_Left
    663  1158		       09 04		      ORA	#4
    664  115a		       85 e8		      STA	_Bit2_P0_Dir_Left
    665  115c				   .
    666  115c							; 
    667  115c
    668  115c				   .
    669  115c							; 
    670  115c
    671  115c				   .
    672  115c							; 
    673  115c
    674  115c				   .
    675  115c							; 
    676  115c
    677  115c				   .
    678  115c							; 
    679  115c
    680  115c				   .
    681  115c							; 
    682  115c
    683  115c				   .L037		;  _Bit7_P1_Dir_Right{7}  =  1
    684  115c
    685  115c		       a5 e8		      LDA	_Bit7_P1_Dir_Right
    686  115e		       09 80		      ORA	#128
    687  1160		       85 e8		      STA	_Bit7_P1_Dir_Right
    688  1162				   .
    689  1162							; 
    690  1162
    691  1162				   .
    692  1162							; 
    693  1162
    694  1162				   .
    695  1162							; 
    696  1162
    697  1162				   .
    698  1162							; 
    699  1162
    700  1162				   .
    701  1162							; 
    702  1162
    703  1162				   .
    704  1162							; 
    705  1162
    706  1162				   .
    707  1162							; 
    708  1162
    709  1162				   .
    710  1162							; 
    711  1162
    712  1162				   .
    713  1162							; 
    714  1162
    715  1162				   .L038		;  _Bit0_Reset_Restrainer{0}  =  1
    716  1162
    717  1162		       a5 ec		      LDA	_Bit0_Reset_Restrainer
    718  1164		       09 01		      ORA	#1
    719  1166		       85 ec		      STA	_Bit0_Reset_Restrainer
    720  1168				   .
    721  1168							; 
    722  1168
    723  1168				   .
    724  1168							; 
    725  1168
    726  1168				   .
    727  1168							; 
    728  1168
    729  1168				   .
    730  1168							; 
    731  1168
    732  1168				   .
    733  1168							; 
    734  1168
    735  1168				   .
    736  1168							; 
    737  1168
    738  1168				   .
    739  1168							; 
    740  1168
    741  1168				   .L039		;  _Enemy_Rand_Look  =  50
    742  1168
    743  1168		       a9 32		      LDA	#50
    744  116a		       85 d9		      STA	_Enemy_Rand_Look
    745  116c				   .
    746  116c							; 
    747  116c
    748  116c				   .
    749  116c							; 
    750  116c
    751  116c				   .
    752  116c							; 
    753  116c
    754  116c				   .
    755  116c							; 
    756  116c
    757  116c				   .
    758  116c							; 
    759  116c
    760  116c				   .
    761  116c							; 
    762  116c
    763  116c				   .L040		;  playfield:
    764  116c
    765  116c					      ifconst	pfres
    766  116c		       a2 5b		      ldx	#(23>pfres)*(pfres*pfwidth-1)+(23<=pfres)*91
    767  116e				  -	      else
    768  116e				  -	      ldx	#((23*pfwidth-1)*((23*pfwidth-1)<47))+(47*((23*pfwidth-1)>=47))
    769  116e					      endif
    770  116e		       4c cd 91 	      jmp	pflabel0
    771  1171				   PF_data0
    772  1171		       ff ff		      .byte.b	%11111111, %11111111
    773  1173					      if	(pfwidth>2)
    774  1173		       ff ff		      .byte.b	%11111111, %11111111
    775  1175					      endif
    776  1175		       80 80		      .byte.b	%10000000, %10000000
    777  1177					      if	(pfwidth>2)
    778  1177		       80 80		      .byte.b	%10000000, %10000000
    779  1179					      endif
    780  1179		       80 80		      .byte.b	%10000000, %10000000
    781  117b					      if	(pfwidth>2)
    782  117b		       80 80		      .byte.b	%10000000, %10000000
    783  117d					      endif
    784  117d		       9c 9f		      .byte.b	%10011100, %10011111
    785  117f					      if	(pfwidth>2)
    786  117f		       9f 9c		      .byte.b	%10011111, %10011100
    787  1181					      endif
    788  1181		       80 00		      .byte.b	%10000000, %00000000
    789  1183					      if	(pfwidth>2)
    790  1183		       00 80		      .byte.b	%00000000, %10000000
    791  1185					      endif
    792  1185		       80 00		      .byte.b	%10000000, %00000000
    793  1187					      if	(pfwidth>2)
    794  1187		       00 80		      .byte.b	%00000000, %10000000
    795  1189					      endif
    796  1189		       9c f9		      .byte.b	%10011100, %11111001
    797  118b					      if	(pfwidth>2)
    798  118b		       f9 9c		      .byte.b	%11111001, %10011100
    799  118d					      endif
    800  118d		       80 81		      .byte.b	%10000000, %10000001
    801  118f					      if	(pfwidth>2)
    802  118f		       81 80		      .byte.b	%10000001, %10000000
    803  1191					      endif
    804  1191		       80 81		      .byte.b	%10000000, %10000001
    805  1193					      if	(pfwidth>2)
    806  1193		       81 80		      .byte.b	%10000001, %10000000
    807  1195					      endif
    808  1195		       fc 9f		      .byte.b	%11111100, %10011111
    809  1197					      if	(pfwidth>2)
    810  1197		       9f fc		      .byte.b	%10011111, %11111100
    811  1199					      endif
    812  1199		       80 00		      .byte.b	%10000000, %00000000
    813  119b					      if	(pfwidth>2)
    814  119b		       00 80		      .byte.b	%00000000, %10000000
    815  119d					      endif
    816  119d		       80 00		      .byte.b	%10000000, %00000000
    817  119f					      if	(pfwidth>2)
    818  119f		       00 80		      .byte.b	%00000000, %10000000
    819  11a1					      endif
    820  11a1		       9c 7f		      .byte.b	%10011100, %01111111
    821  11a3					      if	(pfwidth>2)
    822  11a3		       7f 9c		      .byte.b	%01111111, %10011100
    823  11a5					      endif
    824  11a5		       84 00		      .byte.b	%10000100, %00000000
    825  11a7					      if	(pfwidth>2)
    826  11a7		       00 84		      .byte.b	%00000000, %10000100
    827  11a9					      endif
    828  11a9		       84 00		      .byte.b	%10000100, %00000000
    829  11ab					      if	(pfwidth>2)
    830  11ab		       00 84		      .byte.b	%00000000, %10000100
    831  11ad					      endif
    832  11ad		       e4 f9		      .byte.b	%11100100, %11111001
    833  11af					      if	(pfwidth>2)
    834  11af		       f9 e4		      .byte.b	%11111001, %11100100
    835  11b1					      endif
    836  11b1		       80 81		      .byte.b	%10000000, %10000001
    837  11b3					      if	(pfwidth>2)
    838  11b3		       81 80		      .byte.b	%10000001, %10000000
    839  11b5					      endif
    840  11b5		       80 81		      .byte.b	%10000000, %10000001
    841  11b7					      if	(pfwidth>2)
    842  11b7		       81 80		      .byte.b	%10000001, %10000000
    843  11b9					      endif
    844  11b9		       9f 9f		      .byte.b	%10011111, %10011111
    845  11bb					      if	(pfwidth>2)
    846  11bb		       9f 9f		      .byte.b	%10011111, %10011111
    847  11bd					      endif
    848  11bd		       80 00		      .byte.b	%10000000, %00000000
    849  11bf					      if	(pfwidth>2)
    850  11bf		       00 80		      .byte.b	%00000000, %10000000
    851  11c1					      endif
    852  11c1		       80 00		      .byte.b	%10000000, %00000000
    853  11c3					      if	(pfwidth>2)
    854  11c3		       00 80		      .byte.b	%00000000, %10000000
    855  11c5					      endif
    856  11c5		       ff ff		      .byte.b	%11111111, %11111111
    857  11c7					      if	(pfwidth>2)
    858  11c7		       ff ff		      .byte.b	%11111111, %11111111
    859  11c9					      endif
    860  11c9		       ff ff		      .byte.b	%11111111, %11111111
    861  11cb					      if	(pfwidth>2)
    862  11cb		       ff ff		      .byte.b	%11111111, %11111111
    863  11cd					      endif
    864  11cd				   pflabel0
    865  11cd		       bd 71 91 	      lda	PF_data0,x
    866  11d0		       9d 24 10 	      sta	playfield-128,x
    867  11d3		       ca		      dex
    868  11d4		       10 f7		      bpl	pflabel0
    869  11d6				   .
    870  11d6							; 
    871  11d6
    872  11d6				   .
    873  11d6							; 
    874  11d6
    875  11d6				   .
    876  11d6							; 
    877  11d6
    878  11d6				   .
    879  11d6							; 
    880  11d6
    881  11d6				   .
    882  11d6							; 
    883  11d6
    884  11d6				   .
    885  11d6							; 
    886  11d6
    887  11d6				   .L041		;  drawscreen
    888  11d6
    889  11d6		       85 ee		      sta	temp7
    890  11d8		       a9 91		      lda	#>(ret_point1-1)
    891  11da		       48		      pha
    892  11db		       a9 ed		      lda	#<(ret_point1-1)
    893  11dd		       48		      pha
    894  11de		       a9 f5		      lda	#>(drawscreen-1)
    895  11e0		       48		      pha
    896  11e1		       a9 84		      lda	#<(drawscreen-1)
    897  11e3		       48		      pha
    898  11e4		       a5 ee		      lda	temp7
    899  11e6		       48		      pha
    900  11e7		       8a		      txa
    901  11e8		       48		      pha
    902  11e9		       a2 04		      ldx	#4
    903  11eb		       4c eb ff 	      jmp	BS_jsr
    904  11ee				   ret_point1
    905  11ee				   .
    906  11ee							; 
    907  11ee
    908  11ee				   .
    909  11ee							; 
    910  11ee
    911  11ee				   .L042		;  goto __Main_Loop bank2
    912  11ee
    913  11ee		       85 ee		      sta	temp7
    914  11f0		       a9 b0		      lda	#>(.__Main_Loop-1)
    915  11f2		       48		      pha
    916  11f3		       a9 ff		      lda	#<(.__Main_Loop-1)
    917  11f5		       48		      pha
    918  11f6		       a5 ee		      lda	temp7
    919  11f8		       48		      pha
    920  11f9		       8a		      txa
    921  11fa		       48		      pha
    922  11fb		       a2 02		      ldx	#2
    923  11fd		       4c eb ff 	      jmp	BS_jsr
    924  1200				   .
    925  1200							; 
    926  1200
    927  1200				   .
    928  1200							; 
    929  1200
    930  1200				   .
    931  1200							; 
    932  1200
    933  1200				   .
    934  1200							; 
    935  1200
    936  1200				   .
    937  1200							; 
    938  1200
    939  1200				   .L043		;  bank 2
    940  1200
    941  1200					      if	ECHO1
      3540 bytes of ROM space left in bank 1
    942  1200					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
    943  1200					      endif
    944  1200		       00 01	   ECHO1      =	1
    945  1fd4					      ORG	$1FF4-bscode_length
    946  1fd4					      RORG	$9FF4-bscode_length
    947  1fd4		       a2 ff	   start_bank1 ldx	#$ff
    948  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
    949  1fd6				  -	      stx	FASTFETCH
    950  1fd6					      endif
    951  1fd6		       9a		      txs
    952  1fd7				  -	      if	bankswitch == 64
    953  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
    954  1fd7					      else
    955  1fd7		       a9 f3		      lda	#>(start-1)
    956  1fd9					      endif
    957  1fd9		       48		      pha
    958  1fda		       a9 4f		      lda	#<(start-1)
    959  1fdc		       48		      pha
    960  1fdd		       48		      pha
    961  1fde		       8a		      txa
    962  1fdf		       48		      pha
    963  1fe0		       ba		      tsx
    964  1fe1					      if	bankswitch != 64
    965  1fe1		       b5 04		      lda	4,x	; get high byte of return address
    966  1fe3		       2a		      rol
    967  1fe4		       2a		      rol
    968  1fe5		       2a		      rol
    969  1fe6		       2a		      rol
    970  1fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
    971  1fe9		       aa		      tax
    972  1fea		       e8		      inx
    973  1feb				  -	      else
    974  1feb				  -	      lda	4,x	; get high byte of return address
    975  1feb				  -	      tay
    976  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
    977  1feb				  -	      sta	4,x
    978  1feb				  -	      tya
    979  1feb				  -	      lsr
    980  1feb				  -	      lsr
    981  1feb				  -	      lsr
    982  1feb				  -	      lsr
    983  1feb				  -	      tax
    984  1feb				  -	      inx
    985  1feb					      endif
    986  1feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
    987  1fee		       68		      pla
    988  1fef		       aa		      tax
    989  1ff0		       68		      pla
    990  1ff1		       60		      rts
    991  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
    992  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
    993  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
    994  1ff2					      endif
    995  1ffc					      ORG	$1FFC
    996  1ffc					      RORG	$9FFC
    997  1ffc		       d4 9f		      .word.w	(start_bank1 & $ffff)
    998  1ffe		       d4 9f		      .word.w	(start_bank1 & $ffff)
    999  2000					      ORG	$2000
   1000  2000					      RORG	$B000
   1001  2000					      repeat	256
   1002  2000		       ff		      .byte.b	$ff
   1001  2000					      repend
   1002  2001		       ff		      .byte.b	$ff
   1001  2001					      repend
   1002  2002		       ff		      .byte.b	$ff
   1001  2002					      repend
   1002  2003		       ff		      .byte.b	$ff
   1001  2003					      repend
   1002  2004		       ff		      .byte.b	$ff
   1001  2004					      repend
   1002  2005		       ff		      .byte.b	$ff
   1001  2005					      repend
   1002  2006		       ff		      .byte.b	$ff
   1001  2006					      repend
   1002  2007		       ff		      .byte.b	$ff
   1001  2007					      repend
   1002  2008		       ff		      .byte.b	$ff
   1001  2008					      repend
   1002  2009		       ff		      .byte.b	$ff
   1001  2009					      repend
   1002  200a		       ff		      .byte.b	$ff
   1001  200a					      repend
   1002  200b		       ff		      .byte.b	$ff
   1001  200b					      repend
   1002  200c		       ff		      .byte.b	$ff
   1001  200c					      repend
   1002  200d		       ff		      .byte.b	$ff
   1001  200d					      repend
   1002  200e		       ff		      .byte.b	$ff
   1001  200e					      repend
   1002  200f		       ff		      .byte.b	$ff
   1001  200f					      repend
   1002  2010		       ff		      .byte.b	$ff
   1001  2010					      repend
   1002  2011		       ff		      .byte.b	$ff
   1001  2011					      repend
   1002  2012		       ff		      .byte.b	$ff
   1001  2012					      repend
   1002  2013		       ff		      .byte.b	$ff
   1001  2013					      repend
   1002  2014		       ff		      .byte.b	$ff
   1001  2014					      repend
   1002  2015		       ff		      .byte.b	$ff
   1001  2015					      repend
   1002  2016		       ff		      .byte.b	$ff
   1001  2016					      repend
   1002  2017		       ff		      .byte.b	$ff
   1001  2017					      repend
   1002  2018		       ff		      .byte.b	$ff
   1001  2018					      repend
   1002  2019		       ff		      .byte.b	$ff
   1001  2019					      repend
   1002  201a		       ff		      .byte.b	$ff
   1001  201a					      repend
   1002  201b		       ff		      .byte.b	$ff
   1001  201b					      repend
   1002  201c		       ff		      .byte.b	$ff
   1001  201c					      repend
   1002  201d		       ff		      .byte.b	$ff
   1001  201d					      repend
   1002  201e		       ff		      .byte.b	$ff
   1001  201e					      repend
   1002  201f		       ff		      .byte.b	$ff
   1001  201f					      repend
   1002  2020		       ff		      .byte.b	$ff
   1001  2020					      repend
   1002  2021		       ff		      .byte.b	$ff
   1001  2021					      repend
   1002  2022		       ff		      .byte.b	$ff
   1001  2022					      repend
   1002  2023		       ff		      .byte.b	$ff
   1001  2023					      repend
   1002  2024		       ff		      .byte.b	$ff
   1001  2024					      repend
   1002  2025		       ff		      .byte.b	$ff
   1001  2025					      repend
   1002  2026		       ff		      .byte.b	$ff
   1001  2026					      repend
   1002  2027		       ff		      .byte.b	$ff
   1001  2027					      repend
   1002  2028		       ff		      .byte.b	$ff
   1001  2028					      repend
   1002  2029		       ff		      .byte.b	$ff
   1001  2029					      repend
   1002  202a		       ff		      .byte.b	$ff
   1001  202a					      repend
   1002  202b		       ff		      .byte.b	$ff
   1001  202b					      repend
   1002  202c		       ff		      .byte.b	$ff
   1001  202c					      repend
   1002  202d		       ff		      .byte.b	$ff
   1001  202d					      repend
   1002  202e		       ff		      .byte.b	$ff
   1001  202e					      repend
   1002  202f		       ff		      .byte.b	$ff
   1001  202f					      repend
   1002  2030		       ff		      .byte.b	$ff
   1001  2030					      repend
   1002  2031		       ff		      .byte.b	$ff
   1001  2031					      repend
   1002  2032		       ff		      .byte.b	$ff
   1001  2032					      repend
   1002  2033		       ff		      .byte.b	$ff
   1001  2033					      repend
   1002  2034		       ff		      .byte.b	$ff
   1001  2034					      repend
   1002  2035		       ff		      .byte.b	$ff
   1001  2035					      repend
   1002  2036		       ff		      .byte.b	$ff
   1001  2036					      repend
   1002  2037		       ff		      .byte.b	$ff
   1001  2037					      repend
   1002  2038		       ff		      .byte.b	$ff
   1001  2038					      repend
   1002  2039		       ff		      .byte.b	$ff
   1001  2039					      repend
   1002  203a		       ff		      .byte.b	$ff
   1001  203a					      repend
   1002  203b		       ff		      .byte.b	$ff
   1001  203b					      repend
   1002  203c		       ff		      .byte.b	$ff
   1001  203c					      repend
   1002  203d		       ff		      .byte.b	$ff
   1001  203d					      repend
   1002  203e		       ff		      .byte.b	$ff
   1001  203e					      repend
   1002  203f		       ff		      .byte.b	$ff
   1001  203f					      repend
   1002  2040		       ff		      .byte.b	$ff
   1001  2040					      repend
   1002  2041		       ff		      .byte.b	$ff
   1001  2041					      repend
   1002  2042		       ff		      .byte.b	$ff
   1001  2042					      repend
   1002  2043		       ff		      .byte.b	$ff
   1001  2043					      repend
   1002  2044		       ff		      .byte.b	$ff
   1001  2044					      repend
   1002  2045		       ff		      .byte.b	$ff
   1001  2045					      repend
   1002  2046		       ff		      .byte.b	$ff
   1001  2046					      repend
   1002  2047		       ff		      .byte.b	$ff
   1001  2047					      repend
   1002  2048		       ff		      .byte.b	$ff
   1001  2048					      repend
   1002  2049		       ff		      .byte.b	$ff
   1001  2049					      repend
   1002  204a		       ff		      .byte.b	$ff
   1001  204a					      repend
   1002  204b		       ff		      .byte.b	$ff
   1001  204b					      repend
   1002  204c		       ff		      .byte.b	$ff
   1001  204c					      repend
   1002  204d		       ff		      .byte.b	$ff
   1001  204d					      repend
   1002  204e		       ff		      .byte.b	$ff
   1001  204e					      repend
   1002  204f		       ff		      .byte.b	$ff
   1001  204f					      repend
   1002  2050		       ff		      .byte.b	$ff
   1001  2050					      repend
   1002  2051		       ff		      .byte.b	$ff
   1001  2051					      repend
   1002  2052		       ff		      .byte.b	$ff
   1001  2052					      repend
   1002  2053		       ff		      .byte.b	$ff
   1001  2053					      repend
   1002  2054		       ff		      .byte.b	$ff
   1001  2054					      repend
   1002  2055		       ff		      .byte.b	$ff
   1001  2055					      repend
   1002  2056		       ff		      .byte.b	$ff
   1001  2056					      repend
   1002  2057		       ff		      .byte.b	$ff
   1001  2057					      repend
   1002  2058		       ff		      .byte.b	$ff
   1001  2058					      repend
   1002  2059		       ff		      .byte.b	$ff
   1001  2059					      repend
   1002  205a		       ff		      .byte.b	$ff
   1001  205a					      repend
   1002  205b		       ff		      .byte.b	$ff
   1001  205b					      repend
   1002  205c		       ff		      .byte.b	$ff
   1001  205c					      repend
   1002  205d		       ff		      .byte.b	$ff
   1001  205d					      repend
   1002  205e		       ff		      .byte.b	$ff
   1001  205e					      repend
   1002  205f		       ff		      .byte.b	$ff
   1001  205f					      repend
   1002  2060		       ff		      .byte.b	$ff
   1001  2060					      repend
   1002  2061		       ff		      .byte.b	$ff
   1001  2061					      repend
   1002  2062		       ff		      .byte.b	$ff
   1001  2062					      repend
   1002  2063		       ff		      .byte.b	$ff
   1001  2063					      repend
   1002  2064		       ff		      .byte.b	$ff
   1001  2064					      repend
   1002  2065		       ff		      .byte.b	$ff
   1001  2065					      repend
   1002  2066		       ff		      .byte.b	$ff
   1001  2066					      repend
   1002  2067		       ff		      .byte.b	$ff
   1001  2067					      repend
   1002  2068		       ff		      .byte.b	$ff
   1001  2068					      repend
   1002  2069		       ff		      .byte.b	$ff
   1001  2069					      repend
   1002  206a		       ff		      .byte.b	$ff
   1001  206a					      repend
   1002  206b		       ff		      .byte.b	$ff
   1001  206b					      repend
   1002  206c		       ff		      .byte.b	$ff
   1001  206c					      repend
   1002  206d		       ff		      .byte.b	$ff
   1001  206d					      repend
   1002  206e		       ff		      .byte.b	$ff
   1001  206e					      repend
   1002  206f		       ff		      .byte.b	$ff
   1001  206f					      repend
   1002  2070		       ff		      .byte.b	$ff
   1001  2070					      repend
   1002  2071		       ff		      .byte.b	$ff
   1001  2071					      repend
   1002  2072		       ff		      .byte.b	$ff
   1001  2072					      repend
   1002  2073		       ff		      .byte.b	$ff
   1001  2073					      repend
   1002  2074		       ff		      .byte.b	$ff
   1001  2074					      repend
   1002  2075		       ff		      .byte.b	$ff
   1001  2075					      repend
   1002  2076		       ff		      .byte.b	$ff
   1001  2076					      repend
   1002  2077		       ff		      .byte.b	$ff
   1001  2077					      repend
   1002  2078		       ff		      .byte.b	$ff
   1001  2078					      repend
   1002  2079		       ff		      .byte.b	$ff
   1001  2079					      repend
   1002  207a		       ff		      .byte.b	$ff
   1001  207a					      repend
   1002  207b		       ff		      .byte.b	$ff
   1001  207b					      repend
   1002  207c		       ff		      .byte.b	$ff
   1001  207c					      repend
   1002  207d		       ff		      .byte.b	$ff
   1001  207d					      repend
   1002  207e		       ff		      .byte.b	$ff
   1001  207e					      repend
   1002  207f		       ff		      .byte.b	$ff
   1001  207f					      repend
   1002  2080		       ff		      .byte.b	$ff
   1001  2080					      repend
   1002  2081		       ff		      .byte.b	$ff
   1001  2081					      repend
   1002  2082		       ff		      .byte.b	$ff
   1001  2082					      repend
   1002  2083		       ff		      .byte.b	$ff
   1001  2083					      repend
   1002  2084		       ff		      .byte.b	$ff
   1001  2084					      repend
   1002  2085		       ff		      .byte.b	$ff
   1001  2085					      repend
   1002  2086		       ff		      .byte.b	$ff
   1001  2086					      repend
   1002  2087		       ff		      .byte.b	$ff
   1001  2087					      repend
   1002  2088		       ff		      .byte.b	$ff
   1001  2088					      repend
   1002  2089		       ff		      .byte.b	$ff
   1001  2089					      repend
   1002  208a		       ff		      .byte.b	$ff
   1001  208a					      repend
   1002  208b		       ff		      .byte.b	$ff
   1001  208b					      repend
   1002  208c		       ff		      .byte.b	$ff
   1001  208c					      repend
   1002  208d		       ff		      .byte.b	$ff
   1001  208d					      repend
   1002  208e		       ff		      .byte.b	$ff
   1001  208e					      repend
   1002  208f		       ff		      .byte.b	$ff
   1001  208f					      repend
   1002  2090		       ff		      .byte.b	$ff
   1001  2090					      repend
   1002  2091		       ff		      .byte.b	$ff
   1001  2091					      repend
   1002  2092		       ff		      .byte.b	$ff
   1001  2092					      repend
   1002  2093		       ff		      .byte.b	$ff
   1001  2093					      repend
   1002  2094		       ff		      .byte.b	$ff
   1001  2094					      repend
   1002  2095		       ff		      .byte.b	$ff
   1001  2095					      repend
   1002  2096		       ff		      .byte.b	$ff
   1001  2096					      repend
   1002  2097		       ff		      .byte.b	$ff
   1001  2097					      repend
   1002  2098		       ff		      .byte.b	$ff
   1001  2098					      repend
   1002  2099		       ff		      .byte.b	$ff
   1001  2099					      repend
   1002  209a		       ff		      .byte.b	$ff
   1001  209a					      repend
   1002  209b		       ff		      .byte.b	$ff
   1001  209b					      repend
   1002  209c		       ff		      .byte.b	$ff
   1001  209c					      repend
   1002  209d		       ff		      .byte.b	$ff
   1001  209d					      repend
   1002  209e		       ff		      .byte.b	$ff
   1001  209e					      repend
   1002  209f		       ff		      .byte.b	$ff
   1001  209f					      repend
   1002  20a0		       ff		      .byte.b	$ff
   1001  20a0					      repend
   1002  20a1		       ff		      .byte.b	$ff
   1001  20a1					      repend
   1002  20a2		       ff		      .byte.b	$ff
   1001  20a2					      repend
   1002  20a3		       ff		      .byte.b	$ff
   1001  20a3					      repend
   1002  20a4		       ff		      .byte.b	$ff
   1001  20a4					      repend
   1002  20a5		       ff		      .byte.b	$ff
   1001  20a5					      repend
   1002  20a6		       ff		      .byte.b	$ff
   1001  20a6					      repend
   1002  20a7		       ff		      .byte.b	$ff
   1001  20a7					      repend
   1002  20a8		       ff		      .byte.b	$ff
   1001  20a8					      repend
   1002  20a9		       ff		      .byte.b	$ff
   1001  20a9					      repend
   1002  20aa		       ff		      .byte.b	$ff
   1001  20aa					      repend
   1002  20ab		       ff		      .byte.b	$ff
   1001  20ab					      repend
   1002  20ac		       ff		      .byte.b	$ff
   1001  20ac					      repend
   1002  20ad		       ff		      .byte.b	$ff
   1001  20ad					      repend
   1002  20ae		       ff		      .byte.b	$ff
   1001  20ae					      repend
   1002  20af		       ff		      .byte.b	$ff
   1001  20af					      repend
   1002  20b0		       ff		      .byte.b	$ff
   1001  20b0					      repend
   1002  20b1		       ff		      .byte.b	$ff
   1001  20b1					      repend
   1002  20b2		       ff		      .byte.b	$ff
   1001  20b2					      repend
   1002  20b3		       ff		      .byte.b	$ff
   1001  20b3					      repend
   1002  20b4		       ff		      .byte.b	$ff
   1001  20b4					      repend
   1002  20b5		       ff		      .byte.b	$ff
   1001  20b5					      repend
   1002  20b6		       ff		      .byte.b	$ff
   1001  20b6					      repend
   1002  20b7		       ff		      .byte.b	$ff
   1001  20b7					      repend
   1002  20b8		       ff		      .byte.b	$ff
   1001  20b8					      repend
   1002  20b9		       ff		      .byte.b	$ff
   1001  20b9					      repend
   1002  20ba		       ff		      .byte.b	$ff
   1001  20ba					      repend
   1002  20bb		       ff		      .byte.b	$ff
   1001  20bb					      repend
   1002  20bc		       ff		      .byte.b	$ff
   1001  20bc					      repend
   1002  20bd		       ff		      .byte.b	$ff
   1001  20bd					      repend
   1002  20be		       ff		      .byte.b	$ff
   1001  20be					      repend
   1002  20bf		       ff		      .byte.b	$ff
   1001  20bf					      repend
   1002  20c0		       ff		      .byte.b	$ff
   1001  20c0					      repend
   1002  20c1		       ff		      .byte.b	$ff
   1001  20c1					      repend
   1002  20c2		       ff		      .byte.b	$ff
   1001  20c2					      repend
   1002  20c3		       ff		      .byte.b	$ff
   1001  20c3					      repend
   1002  20c4		       ff		      .byte.b	$ff
   1001  20c4					      repend
   1002  20c5		       ff		      .byte.b	$ff
   1001  20c5					      repend
   1002  20c6		       ff		      .byte.b	$ff
   1001  20c6					      repend
   1002  20c7		       ff		      .byte.b	$ff
   1001  20c7					      repend
   1002  20c8		       ff		      .byte.b	$ff
   1001  20c8					      repend
   1002  20c9		       ff		      .byte.b	$ff
   1001  20c9					      repend
   1002  20ca		       ff		      .byte.b	$ff
   1001  20ca					      repend
   1002  20cb		       ff		      .byte.b	$ff
   1001  20cb					      repend
   1002  20cc		       ff		      .byte.b	$ff
   1001  20cc					      repend
   1002  20cd		       ff		      .byte.b	$ff
   1001  20cd					      repend
   1002  20ce		       ff		      .byte.b	$ff
   1001  20ce					      repend
   1002  20cf		       ff		      .byte.b	$ff
   1001  20cf					      repend
   1002  20d0		       ff		      .byte.b	$ff
   1001  20d0					      repend
   1002  20d1		       ff		      .byte.b	$ff
   1001  20d1					      repend
   1002  20d2		       ff		      .byte.b	$ff
   1001  20d2					      repend
   1002  20d3		       ff		      .byte.b	$ff
   1001  20d3					      repend
   1002  20d4		       ff		      .byte.b	$ff
   1001  20d4					      repend
   1002  20d5		       ff		      .byte.b	$ff
   1001  20d5					      repend
   1002  20d6		       ff		      .byte.b	$ff
   1001  20d6					      repend
   1002  20d7		       ff		      .byte.b	$ff
   1001  20d7					      repend
   1002  20d8		       ff		      .byte.b	$ff
   1001  20d8					      repend
   1002  20d9		       ff		      .byte.b	$ff
   1001  20d9					      repend
   1002  20da		       ff		      .byte.b	$ff
   1001  20da					      repend
   1002  20db		       ff		      .byte.b	$ff
   1001  20db					      repend
   1002  20dc		       ff		      .byte.b	$ff
   1001  20dc					      repend
   1002  20dd		       ff		      .byte.b	$ff
   1001  20dd					      repend
   1002  20de		       ff		      .byte.b	$ff
   1001  20de					      repend
   1002  20df		       ff		      .byte.b	$ff
   1001  20df					      repend
   1002  20e0		       ff		      .byte.b	$ff
   1001  20e0					      repend
   1002  20e1		       ff		      .byte.b	$ff
   1001  20e1					      repend
   1002  20e2		       ff		      .byte.b	$ff
   1001  20e2					      repend
   1002  20e3		       ff		      .byte.b	$ff
   1001  20e3					      repend
   1002  20e4		       ff		      .byte.b	$ff
   1001  20e4					      repend
   1002  20e5		       ff		      .byte.b	$ff
   1001  20e5					      repend
   1002  20e6		       ff		      .byte.b	$ff
   1001  20e6					      repend
   1002  20e7		       ff		      .byte.b	$ff
   1001  20e7					      repend
   1002  20e8		       ff		      .byte.b	$ff
   1001  20e8					      repend
   1002  20e9		       ff		      .byte.b	$ff
   1001  20e9					      repend
   1002  20ea		       ff		      .byte.b	$ff
   1001  20ea					      repend
   1002  20eb		       ff		      .byte.b	$ff
   1001  20eb					      repend
   1002  20ec		       ff		      .byte.b	$ff
   1001  20ec					      repend
   1002  20ed		       ff		      .byte.b	$ff
   1001  20ed					      repend
   1002  20ee		       ff		      .byte.b	$ff
   1001  20ee					      repend
   1002  20ef		       ff		      .byte.b	$ff
   1001  20ef					      repend
   1002  20f0		       ff		      .byte.b	$ff
   1001  20f0					      repend
   1002  20f1		       ff		      .byte.b	$ff
   1001  20f1					      repend
   1002  20f2		       ff		      .byte.b	$ff
   1001  20f2					      repend
   1002  20f3		       ff		      .byte.b	$ff
   1001  20f3					      repend
   1002  20f4		       ff		      .byte.b	$ff
   1001  20f4					      repend
   1002  20f5		       ff		      .byte.b	$ff
   1001  20f5					      repend
   1002  20f6		       ff		      .byte.b	$ff
   1001  20f6					      repend
   1002  20f7		       ff		      .byte.b	$ff
   1001  20f7					      repend
   1002  20f8		       ff		      .byte.b	$ff
   1001  20f8					      repend
   1002  20f9		       ff		      .byte.b	$ff
   1001  20f9					      repend
   1002  20fa		       ff		      .byte.b	$ff
   1001  20fa					      repend
   1002  20fb		       ff		      .byte.b	$ff
   1001  20fb					      repend
   1002  20fc		       ff		      .byte.b	$ff
   1001  20fc					      repend
   1002  20fd		       ff		      .byte.b	$ff
   1001  20fd					      repend
   1002  20fe		       ff		      .byte.b	$ff
   1001  20fe					      repend
   1002  20ff		       ff		      .byte.b	$ff
   1003  2100					      repend
   1004  2100				   .
   1005  2100							; 
   1006  2100
   1007  2100				   .
   1008  2100							; 
   1009  2100
   1010  2100				   .
   1011  2100							; 
   1012  2100
   1013  2100				   .
   1014  2100							; 
   1015  2100
   1016  2100				   .
   1017  2100							; 
   1018  2100
   1019  2100				   .
   1020  2100							; 
   1021  2100
   1022  2100				   .
   1023  2100							; 
   1024  2100
   1025  2100				   .
   1026  2100							; 
   1027  2100
   1028  2100				   .
   1029  2100							; 
   1030  2100
   1031  2100				   .
   1032  2100							; 
   1033  2100
   1034  2100				   .
   1035  2100							; 
   1036  2100
   1037  2100				   .__Main_Loop
   1038  2100							; __Main_Loop
   1039  2100
   1040  2100				   .
   1041  2100							; 
   1042  2100
   1043  2100				   .
   1044  2100							; 
   1045  2100
   1046  2100				   .
   1047  2100							; 
   1048  2100
   1049  2100				   .
   1050  2100							; 
   1051  2100
   1052  2100				   .
   1053  2100							; 
   1054  2100
   1055  2100				   .
   1056  2100							; 
   1057  2100
   1058  2100				   .
   1059  2100							; 
   1060  2100
   1061  2100				   .L044		;  COLUP0  =  $1E  :  COLUP1  =  $AE  :  scorecolor  =  $0A
   1062  2100
   1063  2100		       a9 1e		      LDA	#$1E
   1064  2102		       85 06		      STA	COLUP0
   1065  2104		       a9 ae		      LDA	#$AE
   1066  2106		       85 07		      STA	COLUP1
   1067  2108		       a9 0a		      LDA	#$0A
   1068  210a		       85 a3		      STA	scorecolor
   1069  210c				   .
   1070  210c							; 
   1071  210c
   1072  210c				   .
   1073  210c							; 
   1074  210c
   1075  210c				   .
   1076  210c							; 
   1077  210c
   1078  210c				   .
   1079  210c							; 
   1080  210c
   1081  210c				   .
   1082  210c							; 
   1083  210c
   1084  210c				   .
   1085  210c							; 
   1086  210c
   1087  210c				   .
   1088  210c							; 
   1089  210c
   1090  210c				   .L045		;  _Master_Counter  =	_Master_Counter  +  1
   1091  210c
   1092  210c		       e6 e0		      INC	_Master_Counter
   1093  210e				   .
   1094  210e							; 
   1095  210e
   1096  210e				   .L046		;  if _Master_Counter	<  4 then goto __Skip_Frame_Counter
   1097  210e
   1098  210e		       a5 e0		      LDA	_Master_Counter
   1099  2110		       c9 04		      CMP	#4
   1100  2112		       b0 03		      BCS	.skipL046
   1101  2114				   .condpart0
   1102  2114		       4c 27 b1 	      jmp	.__Skip_Frame_Counter
   1103  2117
   1104  2117				   .skipL046
   1105  2117				   .
   1106  2117							; 
   1107  2117
   1108  2117				   .L047		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
   1109  2117
   1110  2117		       e6 e1		      INC	_Frame_Counter
   1111  2119		       a9 00		      LDA	#0
   1112  211b		       85 e0		      STA	_Master_Counter
   1113  211d				   .
   1114  211d							; 
   1115  211d
   1116  211d				   .L048		;  if _Frame_Counter  =  4 then _Frame_Counter  =  0
   1117  211d
   1118  211d		       a5 e1		      LDA	_Frame_Counter
   1119  211f		       c9 04		      CMP	#4
   1120  2121		       d0 04		      BNE	.skipL048
   1121  2123				   .condpart1
   1122  2123		       a9 00		      LDA	#0
   1123  2125		       85 e1		      STA	_Frame_Counter
   1124  2127				   .skipL048
   1125  2127				   .
   1126  2127							; 
   1127  2127
   1128  2127				   .__Skip_Frame_Counter
   1129  2127							; __Skip_Frame_Counter
   1130  2127
   1131  2127				   .
   1132  2127							; 
   1133  2127
   1134  2127				   .
   1135  2127							; 
   1136  2127
   1137  2127				   .
   1138  2127							; 
   1139  2127
   1140  2127				   .
   1141  2127							; 
   1142  2127
   1143  2127				   .
   1144  2127							; 
   1145  2127
   1146  2127				   .
   1147  2127							; 
   1148  2127
   1149  2127				   .
   1150  2127							; 
   1151  2127
   1152  2127				   .L049		;  _Bit3_vblank{3}  =	1
   1153  2127
   1154  2127		       a5 ec		      LDA	_Bit3_vblank
   1155  2129		       09 08		      ORA	#8
   1156  212b		       85 ec		      STA	_Bit3_vblank
   1157  212d				   .
   1158  212d							; 
   1159  212d
   1160  212d				   .
   1161  212d							; 
   1162  212d
   1163  212d				   .
   1164  212d							; 
   1165  212d
   1166  212d				   .
   1167  212d							; 
   1168  212d
   1169  212d				   .
   1170  212d							; 
   1171  212d
   1172  212d				   .
   1173  212d							; 
   1174  212d
   1175  212d				   .
   1176  212d							; 
   1177  212d
   1178  212d				   .L050		;  if _Bit6_Flip_P0{6} then REFP0  =  8
   1179  212d
   1180  212d		       24 ec		      BIT	_Bit6_Flip_P0
   1181  212f		       50 04		      BVC	.skipL050
   1182  2131				   .condpart2
   1183  2131		       a9 08		      LDA	#8
   1184  2133		       85 0b		      STA	REFP0
   1185  2135				   .skipL050
   1186  2135				   .
   1187  2135							; 
   1188  2135
   1189  2135				   .
   1190  2135							; 
   1191  2135
   1192  2135				   .
   1193  2135							; 
   1194  2135
   1195  2135				   .
   1196  2135							; 
   1197  2135
   1198  2135				   .
   1199  2135							; 
   1200  2135
   1201  2135				   .
   1202  2135							; 
   1203  2135
   1204  2135				   .
   1205  2135							; 
   1206  2135
   1207  2135				   .
   1208  2135							; 
   1209  2135
   1210  2135				   .
   1211  2135							; 
   1212  2135
   1213  2135				   .L051		;  if _Bit5_Direction_Changed{5} then _Enemy_Counter  =  _Enemy_Counter  +  1
   1214  2135
   1215  2135		       a5 ec		      LDA	_Bit5_Direction_Changed
   1216  2137		       29 20		      AND	#32
   1217  2139		       f0 02		      BEQ	.skipL051
   1218  213b				   .condpart3
   1219  213b		       e6 d8		      INC	_Enemy_Counter
   1220  213d				   .skipL051
   1221  213d				   .
   1222  213d							; 
   1223  213d
   1224  213d				   .
   1225  213d							; 
   1226  213d
   1227  213d				   .
   1228  213d							; 
   1229  213d
   1230  213d				   .
   1231  213d							; 
   1232  213d
   1233  213d				   .
   1234  213d							; 
   1235  213d
   1236  213d				   .
   1237  213d							; 
   1238  213d
   1239  213d				   .
   1240  213d							; 
   1241  213d
   1242  213d				   .
   1243  213d							; 
   1244  213d
   1245  213d				   .
   1246  213d							; 
   1247  213d
   1248  213d				   .
   1249  213d							; 
   1250  213d
   1251  213d				   .L052		;  if !_Bit4_P1_Dir_Up{4} then goto __Skip_P1_Up
   1252  213d
   1253  213d		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   1254  213f		       29 10		      AND	#16
   1255  2141		       d0 03		      BNE	.skipL052
   1256  2143				   .condpart4
   1257  2143		       4c 31 b2 	      jmp	.__Skip_P1_Up
   1258  2146
   1259  2146				   .skipL052
   1260  2146				   .
   1261  2146							; 
   1262  2146
   1263  2146				   .
   1264  2146							; 
   1265  2146
   1266  2146				   .
   1267  2146							; 
   1268  2146
   1269  2146				   .
   1270  2146							; 
   1271  2146
   1272  2146				   .
   1273  2146							; 
   1274  2146
   1275  2146				   .L053		;  temp3  =   ( player1x - 17 )  / 4
   1276  2146
   1277  2146							; complex statement detected
   1278  2146		       a5 81		      LDA	player1x
   1279  2148		       38		      SEC
   1280  2149		       e9 11		      SBC	#17
   1281  214b		       4a		      lsr
   1282  214c		       4a		      lsr
   1283  214d		       85 9e		      STA	temp3
   1284  214f				   .
   1285  214f							; 
   1286  214f
   1287  214f				   .L054		;  temp6  =   ( player1y / 4 )  - 2
   1288  214f
   1289  214f							; complex statement detected
   1290  214f		       a5 86		      LDA	player1y
   1291  2151		       4a		      lsr
   1292  2152		       4a		      lsr
   1293  2153		       38		      SEC
   1294  2154		       e9 02		      SBC	#2
   1295  2156		       85 a1		      STA	temp6
   1296  2158				   .
   1297  2158							; 
   1298  2158
   1299  2158				   .L055		;  if pfread ( temp3 , temp6 )  then goto __Enemy_Cant_Move_Up
   1300  2158
   1301  2158		       a5 9e		      LDA	temp3
   1302  215a		       a4 a1		      LDY	temp6
   1303  215c		       85 ee		      sta	temp7
   1304  215e		       a9 b1		      lda	#>(ret_point2-1)
   1305  2160		       48		      pha
   1306  2161		       a9 73		      lda	#<(ret_point2-1)
   1307  2163		       48		      pha
   1308  2164		       a9 f3		      lda	#>(pfread-1)
   1309  2166		       48		      pha
   1310  2167		       a9 aa		      lda	#<(pfread-1)
   1311  2169		       48		      pha
   1312  216a		       a5 ee		      lda	temp7
   1313  216c		       48		      pha
   1314  216d		       8a		      txa
   1315  216e		       48		      pha
   1316  216f		       a2 04		      ldx	#4
   1317  2171		       4c eb ff 	      jmp	BS_jsr
   1318  2174				   ret_point2
   1319  2174		       d0 03		      BNE	.skipL055
   1320  2176				   .condpart5
   1321  2176		       4c a4 b1 	      jmp	.__Enemy_Cant_Move_Up
   1322  2179
   1323  2179				   .skipL055
   1324  2179				   .
   1325  2179							; 
   1326  2179
   1327  2179				   .L056		;  temp5  =  temp3  +	1
   1328  2179
   1329  2179		       a5 9e		      LDA	temp3
   1330  217b		       18		      CLC
   1331  217c		       69 01		      ADC	#1
   1332  217e		       85 a0		      STA	temp5
   1333  2180				   .
   1334  2180							; 
   1335  2180
   1336  2180				   .L057		;  if pfread ( temp5 , temp6 )  then goto __Enemy_Cant_Move_Up
   1337  2180
   1338  2180		       a5 a0		      LDA	temp5
   1339  2182		       a4 a1		      LDY	temp6
   1340  2184		       85 ee		      sta	temp7
   1341  2186		       a9 b1		      lda	#>(ret_point3-1)
   1342  2188		       48		      pha
   1343  2189		       a9 9b		      lda	#<(ret_point3-1)
   1344  218b		       48		      pha
   1345  218c		       a9 f3		      lda	#>(pfread-1)
   1346  218e		       48		      pha
   1347  218f		       a9 aa		      lda	#<(pfread-1)
   1348  2191		       48		      pha
   1349  2192		       a5 ee		      lda	temp7
   1350  2194		       48		      pha
   1351  2195		       8a		      txa
   1352  2196		       48		      pha
   1353  2197		       a2 04		      ldx	#4
   1354  2199		       4c eb ff 	      jmp	BS_jsr
   1355  219c				   ret_point3
   1356  219c		       d0 03		      BNE	.skipL057
   1357  219e				   .condpart6
   1358  219e		       4c a4 b1 	      jmp	.__Enemy_Cant_Move_Up
   1359  21a1
   1360  21a1				   .skipL057
   1361  21a1				   .
   1362  21a1							; 
   1363  21a1
   1364  21a1				   .L058		;  goto __Skip_to_P1_Move_Up
   1365  21a1
   1366  21a1		       4c b0 b1 	      jmp	.__Skip_to_P1_Move_Up
   1367  21a4
   1368  21a4				   .
   1369  21a4							; 
   1370  21a4
   1371  21a4				   .__Enemy_Cant_Move_Up
   1372  21a4							; __Enemy_Cant_Move_Up
   1373  21a4
   1374  21a4				   .
   1375  21a4							; 
   1376  21a4
   1377  21a4				   .
   1378  21a4							; 
   1379  21a4
   1380  21a4				   .
   1381  21a4							; 
   1382  21a4
   1383  21a4				   .
   1384  21a4							; 
   1385  21a4
   1386  21a4				   .
   1387  21a4							; 
   1388  21a4
   1389  21a4				   .L059		;  _Bit4_P1_Dir_Up{4}	=  0
   1390  21a4
   1391  21a4		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   1392  21a6		       29 ef		      AND	#239
   1393  21a8		       85 e8		      STA	_Bit4_P1_Dir_Up
   1394  21aa				   .
   1395  21aa							; 
   1396  21aa
   1397  21aa				   .L060		;  gosub __Check_P1_LR
   1398  21aa
   1399  21aa		       20 64 b5 	      jsr	.__Check_P1_LR
   1400  21ad
   1401  21ad				   .
   1402  21ad							; 
   1403  21ad
   1404  21ad				   .L061		;  goto __Clear_Direction
   1405  21ad
   1406  21ad		       4c 12 b5 	      jmp	.__Clear_Direction
   1407  21b0
   1408  21b0				   .
   1409  21b0							; 
   1410  21b0
   1411  21b0				   .__Skip_to_P1_Move_Up
   1412  21b0							; __Skip_to_P1_Move_Up
   1413  21b0
   1414  21b0				   .
   1415  21b0							; 
   1416  21b0
   1417  21b0				   .
   1418  21b0							; 
   1419  21b0
   1420  21b0				   .
   1421  21b0							; 
   1422  21b0
   1423  21b0				   .
   1424  21b0							; 
   1425  21b0
   1426  21b0				   .L062		;  temp5  =   ( temp3 * 4 )  + 17
   1427  21b0
   1428  21b0							; complex statement detected
   1429  21b0		       a5 9e		      LDA	temp3
   1430  21b2		       0a		      asl
   1431  21b3		       0a		      asl
   1432  21b4		       18		      CLC
   1433  21b5		       69 11		      ADC	#17
   1434  21b7		       85 a0		      STA	temp5
   1435  21b9				   .
   1436  21b9							; 
   1437  21b9
   1438  21b9				   .L063		;  if temp5  <>  player1x then goto __Skip_P1_Up
   1439  21b9
   1440  21b9		       a5 a0		      LDA	temp5
   1441  21bb		       c5 81		      CMP	player1x
   1442  21bd		       f0 03		      BEQ	.skipL063
   1443  21bf				   .condpart7
   1444  21bf		       4c 31 b2 	      jmp	.__Skip_P1_Up
   1445  21c2
   1446  21c2				   .skipL063
   1447  21c2				   .
   1448  21c2							; 
   1449  21c2
   1450  21c2				   .L064		;  _P1_U_D  =	_P1_U_D  -  0.52
   1451  21c2
   1452  21c2		       a5 d7		      LDA	d
   1453  21c4		       38		      SEC
   1454  21c5		       e9 85		      SBC	#133
   1455  21c7		       85 d7		      STA	d
   1456  21c9		       a5 86		      LDA	_P1_U_D
   1457  21cb		       e9 00		      SBC	#0
   1458  21cd		       85 86		      STA	_P1_U_D
   1459  21cf				   .
   1460  21cf							; 
   1461  21cf
   1462  21cf				   .
   1463  21cf							; 
   1464  21cf
   1465  21cf				   .
   1466  21cf							; 
   1467  21cf
   1468  21cf				   .
   1469  21cf							; 
   1470  21cf
   1471  21cf				   .
   1472  21cf							; 
   1473  21cf
   1474  21cf				   .
   1475  21cf							; 
   1476  21cf
   1477  21cf				   .
   1478  21cf							; 
   1479  21cf
   1480  21cf				   .
   1481  21cf							; 
   1482  21cf
   1483  21cf				   .L065		;  if _Bit5_Direction_Changed{5} then goto __Skip_Enemy_Look_Up
   1484  21cf
   1485  21cf		       a5 ec		      LDA	_Bit5_Direction_Changed
   1486  21d1		       29 20		      AND	#32
   1487  21d3		       f0 03		      BEQ	.skipL065
   1488  21d5				   .condpart8
   1489  21d5		       4c 19 b2 	      jmp	.__Skip_Enemy_Look_Up
   1490  21d8
   1491  21d8				   .skipL065
   1492  21d8				   .
   1493  21d8							; 
   1494  21d8
   1495  21d8				   .L066		;  temp5  =  rand
   1496  21d8
   1497  21d8		       a5 a2		      lda	rand
   1498  21da		       4a		      lsr
   1499  21db					      ifconst	rand16
   1500  21db		       26 ed		      rol	rand16
   1501  21dd					      endif
   1502  21dd		       90 02		      bcc	*+4
   1503  21df		       49 b4		      eor	#$B4
   1504  21e1		       85 a2		      sta	rand
   1505  21e3					      ifconst	rand16
   1506  21e3		       45 ed		      eor	rand16
   1507  21e5					      endif
   1508  21e5		       85 a0		      STA	temp5
   1509  21e7				   .
   1510  21e7							; 
   1511  21e7
   1512  21e7				   .L067		;  temp6  =   (  (  ( player1y - 7 )  / 4 )  * 4 )  + 7
   1513  21e7
   1514  21e7							; complex statement detected
   1515  21e7		       a5 86		      LDA	player1y
   1516  21e9		       38		      SEC
   1517  21ea		       e9 07		      SBC	#7
   1518  21ec		       4a		      lsr
   1519  21ed		       4a		      lsr
   1520  21ee		       0a		      asl
   1521  21ef		       0a		      asl
   1522  21f0		       18		      CLC
   1523  21f1		       69 07		      ADC	#7
   1524  21f3		       85 a1		      STA	temp6
   1525  21f5				   .
   1526  21f5							; 
   1527  21f5
   1528  21f5				   .L068		;  if temp5  <  _Enemy_Rand_Look then if temp6  =  player1y then gosub __Check_P1_LR  :  if _Bit5_Direction_Changed{5} then _Bit4_P1_Dir_Up{4}  =  0  :  goto __Clear_Direction
   1529  21f5
   1530  21f5		       a5 a0		      LDA	temp5
   1531  21f7		       c5 d9		      CMP	_Enemy_Rand_Look
   1532  21f9		       b0 18		      BCS	.skipL068
   1533  21fb				   .condpart9
   1534  21fb		       a5 a1		      LDA	temp6
   1535  21fd		       c5 86		      CMP	player1y
   1536  21ff		       d0 12		      BNE	.skip9then
   1537  2201				   .condpart10
   1538  2201		       20 64 b5 	      jsr	.__Check_P1_LR
   1539  2204		       a5 ec		      LDA	_Bit5_Direction_Changed
   1540  2206		       29 20		      AND	#32
   1541  2208		       f0 09		      BEQ	.skip10then
   1542  220a				   .condpart11
   1543  220a		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   1544  220c		       29 ef		      AND	#239
   1545  220e		       85 e8		      STA	_Bit4_P1_Dir_Up
   1546  2210		       4c 12 b5 	      jmp	.__Clear_Direction
   1547  2213
   1548  2213				   .skip10then
   1549  2213				   .skip9then
   1550  2213				   .skipL068
   1551  2213				   .
   1552  2213							; 
   1553  2213
   1554  2213				   .L069		;  _Bit5_Direction_Changed{5}	=  0
   1555  2213
   1556  2213		       a5 ec		      LDA	_Bit5_Direction_Changed
   1557  2215		       29 df		      AND	#223
   1558  2217		       85 ec		      STA	_Bit5_Direction_Changed
   1559  2219				   .
   1560  2219							; 
   1561  2219
   1562  2219				   .__Skip_Enemy_Look_Up
   1563  2219							; __Skip_Enemy_Look_Up
   1564  2219
   1565  2219				   .
   1566  2219							; 
   1567  2219
   1568  2219				   .
   1569  2219							; 
   1570  2219
   1571  2219				   .
   1572  2219							; 
   1573  2219
   1574  2219				   .
   1575  2219							; 
   1576  2219
   1577  2219				   .L070		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %00001111
   1578  2219
   1579  2219		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   1580  221b		       29 0f		      AND	#%00001111
   1581  221d		       85 e8		      STA	_BitOp_P0_P1_Dir
   1582  221f				   .
   1583  221f							; 
   1584  221f
   1585  221f				   .L071		;  _Bit4_P1_Dir_Up{4}	=  1
   1586  221f
   1587  221f		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   1588  2221		       09 10		      ORA	#16
   1589  2223		       85 e8		      STA	_Bit4_P1_Dir_Up
   1590  2225				   .
   1591  2225							; 
   1592  2225
   1593  2225				   .
   1594  2225							; 
   1595  2225
   1596  2225				   .
   1597  2225							; 
   1598  2225
   1599  2225				   .
   1600  2225							; 
   1601  2225
   1602  2225				   .L072		;  player1:
   1603  2225
   1604  2225		       a2 b4		      LDX	#<playerL072_1
   1605  2227		       86 8c		      STX	player1pointerlo
   1606  2229		       a9 f9		      LDA	#>playerL072_1
   1607  222b		       85 8d		      STA	player1pointerhi
   1608  222d		       a9 06		      LDA	#6
   1609  222f		       85 8f		      STA	player1height
   1610  2231				   .
   1611  2231							; 
   1612  2231
   1613  2231				   .__Skip_P1_Up
   1614  2231							; __Skip_P1_Up
   1615  2231
   1616  2231				   .
   1617  2231							; 
   1618  2231
   1619  2231				   .
   1620  2231							; 
   1621  2231
   1622  2231				   .
   1623  2231							; 
   1624  2231
   1625  2231				   .
   1626  2231							; 
   1627  2231
   1628  2231				   .
   1629  2231							; 
   1630  2231
   1631  2231				   .
   1632  2231							; 
   1633  2231
   1634  2231				   .
   1635  2231							; 
   1636  2231
   1637  2231				   .
   1638  2231							; 
   1639  2231
   1640  2231				   .
   1641  2231							; 
   1642  2231
   1643  2231				   .
   1644  2231							; 
   1645  2231
   1646  2231				   .L073		;  if !_Bit5_P1_Dir_Down{5} then goto __Skip_P1_Down
   1647  2231
   1648  2231		       a5 e8		      LDA	_Bit5_P1_Dir_Down
   1649  2233		       29 20		      AND	#32
   1650  2235		       d0 03		      BNE	.skipL073
   1651  2237				   .condpart12
   1652  2237		       4c 28 b3 	      jmp	.__Skip_P1_Down
   1653  223a
   1654  223a				   .skipL073
   1655  223a				   .
   1656  223a							; 
   1657  223a
   1658  223a				   .
   1659  223a							; 
   1660  223a
   1661  223a				   .
   1662  223a							; 
   1663  223a
   1664  223a				   .
   1665  223a							; 
   1666  223a
   1667  223a				   .
   1668  223a							; 
   1669  223a
   1670  223a				   .L074		;  temp3  =   ( player1x - 17 )  / 4
   1671  223a
   1672  223a							; complex statement detected
   1673  223a		       a5 81		      LDA	player1x
   1674  223c		       38		      SEC
   1675  223d		       e9 11		      SBC	#17
   1676  223f		       4a		      lsr
   1677  2240		       4a		      lsr
   1678  2241		       85 9e		      STA	temp3
   1679  2243				   .
   1680  2243							; 
   1681  2243
   1682  2243				   .L075		;  temp6  =   (  ( player1y - 3 )  / 4 )   +  1
   1683  2243
   1684  2243							; complex statement detected
   1685  2243		       a5 86		      LDA	player1y
   1686  2245		       38		      SEC
   1687  2246		       e9 03		      SBC	#3
   1688  2248		       4a		      lsr
   1689  2249		       4a		      lsr
   1690  224a		       18		      CLC
   1691  224b		       69 01		      ADC	#1
   1692  224d		       85 a1		      STA	temp6
   1693  224f				   .
   1694  224f							; 
   1695  224f
   1696  224f				   .L076		;  if pfread ( temp3 , temp6 )  then goto __Enemy_Cant_Move_Down
   1697  224f
   1698  224f		       a5 9e		      LDA	temp3
   1699  2251		       a4 a1		      LDY	temp6
   1700  2253		       85 ee		      sta	temp7
   1701  2255		       a9 b2		      lda	#>(ret_point4-1)
   1702  2257		       48		      pha
   1703  2258		       a9 6a		      lda	#<(ret_point4-1)
   1704  225a		       48		      pha
   1705  225b		       a9 f3		      lda	#>(pfread-1)
   1706  225d		       48		      pha
   1707  225e		       a9 aa		      lda	#<(pfread-1)
   1708  2260		       48		      pha
   1709  2261		       a5 ee		      lda	temp7
   1710  2263		       48		      pha
   1711  2264		       8a		      txa
   1712  2265		       48		      pha
   1713  2266		       a2 04		      ldx	#4
   1714  2268		       4c eb ff 	      jmp	BS_jsr
   1715  226b				   ret_point4
   1716  226b		       d0 03		      BNE	.skipL076
   1717  226d				   .condpart13
   1718  226d		       4c 9b b2 	      jmp	.__Enemy_Cant_Move_Down
   1719  2270
   1720  2270				   .skipL076
   1721  2270				   .
   1722  2270							; 
   1723  2270
   1724  2270				   .L077		;  temp5  =  temp3  +	1
   1725  2270
   1726  2270		       a5 9e		      LDA	temp3
   1727  2272		       18		      CLC
   1728  2273		       69 01		      ADC	#1
   1729  2275		       85 a0		      STA	temp5
   1730  2277				   .
   1731  2277							; 
   1732  2277
   1733  2277				   .L078		;  if pfread ( temp5 , temp6 )  then goto __Enemy_Cant_Move_Down
   1734  2277
   1735  2277		       a5 a0		      LDA	temp5
   1736  2279		       a4 a1		      LDY	temp6
   1737  227b		       85 ee		      sta	temp7
   1738  227d		       a9 b2		      lda	#>(ret_point5-1)
   1739  227f		       48		      pha
   1740  2280		       a9 92		      lda	#<(ret_point5-1)
   1741  2282		       48		      pha
   1742  2283		       a9 f3		      lda	#>(pfread-1)
   1743  2285		       48		      pha
   1744  2286		       a9 aa		      lda	#<(pfread-1)
   1745  2288		       48		      pha
   1746  2289		       a5 ee		      lda	temp7
   1747  228b		       48		      pha
   1748  228c		       8a		      txa
   1749  228d		       48		      pha
   1750  228e		       a2 04		      ldx	#4
   1751  2290		       4c eb ff 	      jmp	BS_jsr
   1752  2293				   ret_point5
   1753  2293		       d0 03		      BNE	.skipL078
   1754  2295				   .condpart14
   1755  2295		       4c 9b b2 	      jmp	.__Enemy_Cant_Move_Down
   1756  2298
   1757  2298				   .skipL078
   1758  2298				   .
   1759  2298							; 
   1760  2298
   1761  2298				   .L079		;  goto __Skip_to_P1_Move_Down
   1762  2298
   1763  2298		       4c a7 b2 	      jmp	.__Skip_to_P1_Move_Down
   1764  229b
   1765  229b				   .
   1766  229b							; 
   1767  229b
   1768  229b				   .__Enemy_Cant_Move_Down
   1769  229b							; __Enemy_Cant_Move_Down
   1770  229b
   1771  229b				   .
   1772  229b							; 
   1773  229b
   1774  229b				   .
   1775  229b							; 
   1776  229b
   1777  229b				   .
   1778  229b							; 
   1779  229b
   1780  229b				   .
   1781  229b							; 
   1782  229b
   1783  229b				   .
   1784  229b							; 
   1785  229b
   1786  229b				   .L080		;  _Bit5_P1_Dir_Down{5}  =  0
   1787  229b
   1788  229b		       a5 e8		      LDA	_Bit5_P1_Dir_Down
   1789  229d		       29 df		      AND	#223
   1790  229f		       85 e8		      STA	_Bit5_P1_Dir_Down
   1791  22a1				   .
   1792  22a1							; 
   1793  22a1
   1794  22a1				   .L081		;  gosub __Check_P1_LR
   1795  22a1
   1796  22a1		       20 64 b5 	      jsr	.__Check_P1_LR
   1797  22a4
   1798  22a4				   .
   1799  22a4							; 
   1800  22a4
   1801  22a4				   .L082		;  goto __Clear_Direction
   1802  22a4
   1803  22a4		       4c 12 b5 	      jmp	.__Clear_Direction
   1804  22a7
   1805  22a7				   .
   1806  22a7							; 
   1807  22a7
   1808  22a7				   .__Skip_to_P1_Move_Down
   1809  22a7							; __Skip_to_P1_Move_Down
   1810  22a7
   1811  22a7				   .
   1812  22a7							; 
   1813  22a7
   1814  22a7				   .
   1815  22a7							; 
   1816  22a7
   1817  22a7				   .
   1818  22a7							; 
   1819  22a7
   1820  22a7				   .
   1821  22a7							; 
   1822  22a7
   1823  22a7				   .L083		;  temp5  =   ( temp3 * 4 )  + 17
   1824  22a7
   1825  22a7							; complex statement detected
   1826  22a7		       a5 9e		      LDA	temp3
   1827  22a9		       0a		      asl
   1828  22aa		       0a		      asl
   1829  22ab		       18		      CLC
   1830  22ac		       69 11		      ADC	#17
   1831  22ae		       85 a0		      STA	temp5
   1832  22b0				   .
   1833  22b0							; 
   1834  22b0
   1835  22b0				   .L084		;  if temp5  <>  player1x then goto __Skip_P1_Down
   1836  22b0
   1837  22b0		       a5 a0		      LDA	temp5
   1838  22b2		       c5 81		      CMP	player1x
   1839  22b4		       f0 03		      BEQ	.skipL084
   1840  22b6				   .condpart15
   1841  22b6		       4c 28 b3 	      jmp	.__Skip_P1_Down
   1842  22b9
   1843  22b9				   .skipL084
   1844  22b9				   .
   1845  22b9							; 
   1846  22b9
   1847  22b9				   .L085		;  _P1_U_D  =	_P1_U_D  +  0.52
   1848  22b9
   1849  22b9		       a5 d7		      LDA	d
   1850  22bb		       18		      CLC
   1851  22bc		       69 85		      ADC	#133
   1852  22be		       85 d7		      STA	d
   1853  22c0		       a5 86		      LDA	_P1_U_D
   1854  22c2		       69 00		      ADC	#0
   1855  22c4		       85 86		      STA	_P1_U_D
   1856  22c6				   .
   1857  22c6							; 
   1858  22c6
   1859  22c6				   .
   1860  22c6							; 
   1861  22c6
   1862  22c6				   .
   1863  22c6							; 
   1864  22c6
   1865  22c6				   .
   1866  22c6							; 
   1867  22c6
   1868  22c6				   .
   1869  22c6							; 
   1870  22c6
   1871  22c6				   .
   1872  22c6							; 
   1873  22c6
   1874  22c6				   .
   1875  22c6							; 
   1876  22c6
   1877  22c6				   .
   1878  22c6							; 
   1879  22c6
   1880  22c6				   .L086		;  if _Bit5_Direction_Changed{5} then goto __Skip_Enemy_Look_Down
   1881  22c6
   1882  22c6		       a5 ec		      LDA	_Bit5_Direction_Changed
   1883  22c8		       29 20		      AND	#32
   1884  22ca		       f0 03		      BEQ	.skipL086
   1885  22cc				   .condpart16
   1886  22cc		       4c 10 b3 	      jmp	.__Skip_Enemy_Look_Down
   1887  22cf
   1888  22cf				   .skipL086
   1889  22cf				   .
   1890  22cf							; 
   1891  22cf
   1892  22cf				   .L087		;  temp5  =  rand
   1893  22cf
   1894  22cf		       a5 a2		      lda	rand
   1895  22d1		       4a		      lsr
   1896  22d2					      ifconst	rand16
   1897  22d2		       26 ed		      rol	rand16
   1898  22d4					      endif
   1899  22d4		       90 02		      bcc	*+4
   1900  22d6		       49 b4		      eor	#$B4
   1901  22d8		       85 a2		      sta	rand
   1902  22da					      ifconst	rand16
   1903  22da		       45 ed		      eor	rand16
   1904  22dc					      endif
   1905  22dc		       85 a0		      STA	temp5
   1906  22de				   .
   1907  22de							; 
   1908  22de
   1909  22de				   .L088		;  temp6  =   (  (  ( player1y - 7 )  / 4 )  * 4 )  + 7
   1910  22de
   1911  22de							; complex statement detected
   1912  22de		       a5 86		      LDA	player1y
   1913  22e0		       38		      SEC
   1914  22e1		       e9 07		      SBC	#7
   1915  22e3		       4a		      lsr
   1916  22e4		       4a		      lsr
   1917  22e5		       0a		      asl
   1918  22e6		       0a		      asl
   1919  22e7		       18		      CLC
   1920  22e8		       69 07		      ADC	#7
   1921  22ea		       85 a1		      STA	temp6
   1922  22ec				   .
   1923  22ec							; 
   1924  22ec
   1925  22ec				   .L089		;  if temp5  <  _Enemy_Rand_Look then if temp6  =  player1y then gosub __Check_P1_LR  :  if _Bit5_Direction_Changed{5} then _Bit5_P1_Dir_Down{5}  =  0  :  goto __Clear_Direction
   1926  22ec
   1927  22ec		       a5 a0		      LDA	temp5
   1928  22ee		       c5 d9		      CMP	_Enemy_Rand_Look
   1929  22f0		       b0 18		      BCS	.skipL089
   1930  22f2				   .condpart17
   1931  22f2		       a5 a1		      LDA	temp6
   1932  22f4		       c5 86		      CMP	player1y
   1933  22f6		       d0 12		      BNE	.skip17then
   1934  22f8				   .condpart18
   1935  22f8		       20 64 b5 	      jsr	.__Check_P1_LR
   1936  22fb		       a5 ec		      LDA	_Bit5_Direction_Changed
   1937  22fd		       29 20		      AND	#32
   1938  22ff		       f0 09		      BEQ	.skip18then
   1939  2301				   .condpart19
   1940  2301		       a5 e8		      LDA	_Bit5_P1_Dir_Down
   1941  2303		       29 df		      AND	#223
   1942  2305		       85 e8		      STA	_Bit5_P1_Dir_Down
   1943  2307		       4c 12 b5 	      jmp	.__Clear_Direction
   1944  230a
   1945  230a				   .skip18then
   1946  230a				   .skip17then
   1947  230a				   .skipL089
   1948  230a				   .
   1949  230a							; 
   1950  230a
   1951  230a				   .L090		;  _Bit5_Direction_Changed{5}	=  0
   1952  230a
   1953  230a		       a5 ec		      LDA	_Bit5_Direction_Changed
   1954  230c		       29 df		      AND	#223
   1955  230e		       85 ec		      STA	_Bit5_Direction_Changed
   1956  2310				   .
   1957  2310							; 
   1958  2310
   1959  2310				   .__Skip_Enemy_Look_Down
   1960  2310							; __Skip_Enemy_Look_Down
   1961  2310
   1962  2310				   .
   1963  2310							; 
   1964  2310
   1965  2310				   .
   1966  2310							; 
   1967  2310
   1968  2310				   .
   1969  2310							; 
   1970  2310
   1971  2310				   .
   1972  2310							; 
   1973  2310
   1974  2310				   .L091		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %00001111
   1975  2310
   1976  2310		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   1977  2312		       29 0f		      AND	#%00001111
   1978  2314		       85 e8		      STA	_BitOp_P0_P1_Dir
   1979  2316				   .
   1980  2316							; 
   1981  2316
   1982  2316				   .L092		;  _Bit5_P1_Dir_Down{5}  =  1
   1983  2316
   1984  2316		       a5 e8		      LDA	_Bit5_P1_Dir_Down
   1985  2318		       09 20		      ORA	#32
   1986  231a		       85 e8		      STA	_Bit5_P1_Dir_Down
   1987  231c				   .
   1988  231c							; 
   1989  231c
   1990  231c				   .
   1991  231c							; 
   1992  231c
   1993  231c				   .
   1994  231c							; 
   1995  231c
   1996  231c				   .
   1997  231c							; 
   1998  231c
   1999  231c				   .L093		;  player1:
   2000  231c
   2001  231c		       a2 bb		      LDX	#<playerL093_1
   2002  231e		       86 8c		      STX	player1pointerlo
   2003  2320		       a9 f9		      LDA	#>playerL093_1
   2004  2322		       85 8d		      STA	player1pointerhi
   2005  2324		       a9 06		      LDA	#6
   2006  2326		       85 8f		      STA	player1height
   2007  2328				   .
   2008  2328							; 
   2009  2328
   2010  2328				   .__Skip_P1_Down
   2011  2328							; __Skip_P1_Down
   2012  2328
   2013  2328				   .
   2014  2328							; 
   2015  2328
   2016  2328				   .
   2017  2328							; 
   2018  2328
   2019  2328				   .
   2020  2328							; 
   2021  2328
   2022  2328				   .
   2023  2328							; 
   2024  2328
   2025  2328				   .
   2026  2328							; 
   2027  2328
   2028  2328				   .
   2029  2328							; 
   2030  2328
   2031  2328				   .
   2032  2328							; 
   2033  2328
   2034  2328				   .
   2035  2328							; 
   2036  2328
   2037  2328				   .
   2038  2328							; 
   2039  2328
   2040  2328				   .
   2041  2328							; 
   2042  2328
   2043  2328				   .L094		;  if !_Bit6_P1_Dir_Left{6} then goto __Skip_P1_Left
   2044  2328
   2045  2328		       24 e8		      BIT	_Bit6_P1_Dir_Left
   2046  232a		       70 03		      BVS	.skipL094
   2047  232c				   .condpart20
   2048  232c		       4c 1d b4 	      jmp	.__Skip_P1_Left
   2049  232f
   2050  232f				   .skipL094
   2051  232f				   .
   2052  232f							; 
   2053  232f
   2054  232f				   .
   2055  232f							; 
   2056  232f
   2057  232f				   .
   2058  232f							; 
   2059  232f
   2060  232f				   .
   2061  232f							; 
   2062  232f
   2063  232f				   .
   2064  232f							; 
   2065  232f
   2066  232f				   .L095		;  temp5  =   (  ( player1x - 14 )  / 4 )   -	1
   2067  232f
   2068  232f							; complex statement detected
   2069  232f		       a5 81		      LDA	player1x
   2070  2331		       38		      SEC
   2071  2332		       e9 0e		      SBC	#14
   2072  2334		       4a		      lsr
   2073  2335		       4a		      lsr
   2074  2336		       38		      SEC
   2075  2337		       e9 01		      SBC	#1
   2076  2339		       85 a0		      STA	temp5
   2077  233b				   .
   2078  233b							; 
   2079  233b
   2080  233b				   .L096		;  temp6  =   ( player1y - 7 )  / 4
   2081  233b
   2082  233b							; complex statement detected
   2083  233b		       a5 86		      LDA	player1y
   2084  233d		       38		      SEC
   2085  233e		       e9 07		      SBC	#7
   2086  2340		       4a		      lsr
   2087  2341		       4a		      lsr
   2088  2342		       85 a1		      STA	temp6
   2089  2344				   .
   2090  2344							; 
   2091  2344
   2092  2344				   .L097		;  if pfread ( temp5 , temp6 )  then goto __Enemy_Cant_Move_Left
   2093  2344
   2094  2344		       a5 a0		      LDA	temp5
   2095  2346		       a4 a1		      LDY	temp6
   2096  2348		       85 ee		      sta	temp7
   2097  234a		       a9 b3		      lda	#>(ret_point6-1)
   2098  234c		       48		      pha
   2099  234d		       a9 5f		      lda	#<(ret_point6-1)
   2100  234f		       48		      pha
   2101  2350		       a9 f3		      lda	#>(pfread-1)
   2102  2352		       48		      pha
   2103  2353		       a9 aa		      lda	#<(pfread-1)
   2104  2355		       48		      pha
   2105  2356		       a5 ee		      lda	temp7
   2106  2358		       48		      pha
   2107  2359		       8a		      txa
   2108  235a		       48		      pha
   2109  235b		       a2 04		      ldx	#4
   2110  235d		       4c eb ff 	      jmp	BS_jsr
   2111  2360				   ret_point6
   2112  2360		       d0 03		      BNE	.skipL097
   2113  2362				   .condpart21
   2114  2362		       4c 90 b3 	      jmp	.__Enemy_Cant_Move_Left
   2115  2365
   2116  2365				   .skipL097
   2117  2365				   .
   2118  2365							; 
   2119  2365
   2120  2365				   .L098		;  temp3  =  temp6  +	1
   2121  2365
   2122  2365		       a5 a1		      LDA	temp6
   2123  2367		       18		      CLC
   2124  2368		       69 01		      ADC	#1
   2125  236a		       85 9e		      STA	temp3
   2126  236c				   .
   2127  236c							; 
   2128  236c
   2129  236c				   .L099		;  if pfread ( temp5 , temp3 )  then goto __Enemy_Cant_Move_Left
   2130  236c
   2131  236c		       a5 a0		      LDA	temp5
   2132  236e		       a4 9e		      LDY	temp3
   2133  2370		       85 ee		      sta	temp7
   2134  2372		       a9 b3		      lda	#>(ret_point7-1)
   2135  2374		       48		      pha
   2136  2375		       a9 87		      lda	#<(ret_point7-1)
   2137  2377		       48		      pha
   2138  2378		       a9 f3		      lda	#>(pfread-1)
   2139  237a		       48		      pha
   2140  237b		       a9 aa		      lda	#<(pfread-1)
   2141  237d		       48		      pha
   2142  237e		       a5 ee		      lda	temp7
   2143  2380		       48		      pha
   2144  2381		       8a		      txa
   2145  2382		       48		      pha
   2146  2383		       a2 04		      ldx	#4
   2147  2385		       4c eb ff 	      jmp	BS_jsr
   2148  2388				   ret_point7
   2149  2388		       d0 03		      BNE	.skipL099
   2150  238a				   .condpart22
   2151  238a		       4c 90 b3 	      jmp	.__Enemy_Cant_Move_Left
   2152  238d
   2153  238d				   .skipL099
   2154  238d				   .
   2155  238d							; 
   2156  238d
   2157  238d				   .L0100		;  goto __Skip_to_P1_Move_Left
   2158  238d
   2159  238d		       4c 9c b3 	      jmp	.__Skip_to_P1_Move_Left
   2160  2390
   2161  2390				   .
   2162  2390							; 
   2163  2390
   2164  2390				   .__Enemy_Cant_Move_Left
   2165  2390							; __Enemy_Cant_Move_Left
   2166  2390
   2167  2390				   .
   2168  2390							; 
   2169  2390
   2170  2390				   .
   2171  2390							; 
   2172  2390
   2173  2390				   .
   2174  2390							; 
   2175  2390
   2176  2390				   .
   2177  2390							; 
   2178  2390
   2179  2390				   .
   2180  2390							; 
   2181  2390
   2182  2390				   .L0101		;  _Bit6_P1_Dir_Left{6}  =  0
   2183  2390
   2184  2390		       a5 e8		      LDA	_Bit6_P1_Dir_Left
   2185  2392		       29 bf		      AND	#191
   2186  2394		       85 e8		      STA	_Bit6_P1_Dir_Left
   2187  2396				   .
   2188  2396							; 
   2189  2396
   2190  2396				   .L0102		;  gosub __Check_P1_UD
   2191  2396
   2192  2396		       20 fb b6 	      jsr	.__Check_P1_UD
   2193  2399
   2194  2399				   .
   2195  2399							; 
   2196  2399
   2197  2399				   .L0103		;  goto __Clear_Direction
   2198  2399
   2199  2399		       4c 12 b5 	      jmp	.__Clear_Direction
   2200  239c
   2201  239c				   .
   2202  239c							; 
   2203  239c
   2204  239c				   .__Skip_to_P1_Move_Left
   2205  239c							; __Skip_to_P1_Move_Left
   2206  239c
   2207  239c				   .
   2208  239c							; 
   2209  239c
   2210  239c				   .
   2211  239c							; 
   2212  239c
   2213  239c				   .
   2214  239c							; 
   2215  239c
   2216  239c				   .
   2217  239c							; 
   2218  239c
   2219  239c				   .L0104		;  temp5  =   ( temp6 * 4 )  + 7
   2220  239c
   2221  239c							; complex statement detected
   2222  239c		       a5 a1		      LDA	temp6
   2223  239e		       0a		      asl
   2224  239f		       0a		      asl
   2225  23a0		       18		      CLC
   2226  23a1		       69 07		      ADC	#7
   2227  23a3		       85 a0		      STA	temp5
   2228  23a5				   .
   2229  23a5							; 
   2230  23a5
   2231  23a5				   .L0105		;  if temp5  <>  player1y then goto __Skip_P1_Left
   2232  23a5
   2233  23a5		       a5 a0		      LDA	temp5
   2234  23a7		       c5 86		      CMP	player1y
   2235  23a9		       f0 03		      BEQ	.skipL0105
   2236  23ab				   .condpart23
   2237  23ab		       4c 1d b4 	      jmp	.__Skip_P1_Left
   2238  23ae
   2239  23ae				   .skipL0105
   2240  23ae				   .
   2241  23ae							; 
   2242  23ae
   2243  23ae				   .L0106		;  _P1_L_R  =	_P1_L_R  -  0.52
   2244  23ae
   2245  23ae		       a5 d6		      LDA	c
   2246  23b0		       38		      SEC
   2247  23b1		       e9 85		      SBC	#133
   2248  23b3		       85 d6		      STA	c
   2249  23b5		       a5 81		      LDA	_P1_L_R
   2250  23b7		       e9 00		      SBC	#0
   2251  23b9		       85 81		      STA	_P1_L_R
   2252  23bb				   .
   2253  23bb							; 
   2254  23bb
   2255  23bb				   .
   2256  23bb							; 
   2257  23bb
   2258  23bb				   .
   2259  23bb							; 
   2260  23bb
   2261  23bb				   .
   2262  23bb							; 
   2263  23bb
   2264  23bb				   .
   2265  23bb							; 
   2266  23bb
   2267  23bb				   .
   2268  23bb							; 
   2269  23bb
   2270  23bb				   .
   2271  23bb							; 
   2272  23bb
   2273  23bb				   .
   2274  23bb							; 
   2275  23bb
   2276  23bb				   .L0107		;  if _Bit5_Direction_Changed{5} then goto __Skip_Enemy_Look_Left
   2277  23bb
   2278  23bb		       a5 ec		      LDA	_Bit5_Direction_Changed
   2279  23bd		       29 20		      AND	#32
   2280  23bf		       f0 03		      BEQ	.skipL0107
   2281  23c1				   .condpart24
   2282  23c1		       4c 05 b4 	      jmp	.__Skip_Enemy_Look_Left
   2283  23c4
   2284  23c4				   .skipL0107
   2285  23c4				   .
   2286  23c4							; 
   2287  23c4
   2288  23c4				   .L0108		;  temp5  =  rand
   2289  23c4
   2290  23c4		       a5 a2		      lda	rand
   2291  23c6		       4a		      lsr
   2292  23c7					      ifconst	rand16
   2293  23c7		       26 ed		      rol	rand16
   2294  23c9					      endif
   2295  23c9		       90 02		      bcc	*+4
   2296  23cb		       49 b4		      eor	#$B4
   2297  23cd		       85 a2		      sta	rand
   2298  23cf					      ifconst	rand16
   2299  23cf		       45 ed		      eor	rand16
   2300  23d1					      endif
   2301  23d1		       85 a0		      STA	temp5
   2302  23d3				   .
   2303  23d3							; 
   2304  23d3
   2305  23d3				   .L0109		;  if temp5  <  _Enemy_Rand_Look then temp5  =   (  (	( player1x - 17 )  / 4 )  * 4 )  + 17  :  if temp5  =  player1x then gosub __Check_P1_UD  :  if _Bit5_Direction_Changed{5} then _Bit6_P1_Dir_Left{6}  =  0  :  goto __Clear_Direction
   2306  23d3
   2307  23d3		       a5 a0		      LDA	temp5
   2308  23d5		       c5 d9		      CMP	_Enemy_Rand_Look
   2309  23d7		       b0 26		      BCS	.skipL0109
   2310  23d9				   .condpart25
   2311  23d9							; complex statement detected
   2312  23d9		       a5 81		      LDA	player1x
   2313  23db		       38		      SEC
   2314  23dc		       e9 11		      SBC	#17
   2315  23de		       4a		      lsr
   2316  23df		       4a		      lsr
   2317  23e0		       0a		      asl
   2318  23e1		       0a		      asl
   2319  23e2		       18		      CLC
   2320  23e3		       69 11		      ADC	#17
   2321  23e5		       85 a0		      STA	temp5
   2322  23e7		       a5 a0		      LDA	temp5
   2323  23e9		       c5 81		      CMP	player1x
   2324  23eb		       d0 12		      BNE	.skip25then
   2325  23ed				   .condpart26
   2326  23ed		       20 fb b6 	      jsr	.__Check_P1_UD
   2327  23f0		       a5 ec		      LDA	_Bit5_Direction_Changed
   2328  23f2		       29 20		      AND	#32
   2329  23f4		       f0 09		      BEQ	.skip26then
   2330  23f6				   .condpart27
   2331  23f6		       a5 e8		      LDA	_Bit6_P1_Dir_Left
   2332  23f8		       29 bf		      AND	#191
   2333  23fa		       85 e8		      STA	_Bit6_P1_Dir_Left
   2334  23fc		       4c 12 b5 	      jmp	.__Clear_Direction
   2335  23ff
   2336  23ff				   .skip26then
   2337  23ff				   .skip25then
   2338  23ff				   .skipL0109
   2339  23ff				   .
   2340  23ff							; 
   2341  23ff
   2342  23ff				   .L0110		;  _Bit5_Direction_Changed{5}	=  0
   2343  23ff
   2344  23ff		       a5 ec		      LDA	_Bit5_Direction_Changed
   2345  2401		       29 df		      AND	#223
   2346  2403		       85 ec		      STA	_Bit5_Direction_Changed
   2347  2405				   .
   2348  2405							; 
   2349  2405
   2350  2405				   .__Skip_Enemy_Look_Left
   2351  2405							; __Skip_Enemy_Look_Left
   2352  2405
   2353  2405				   .
   2354  2405							; 
   2355  2405
   2356  2405				   .
   2357  2405							; 
   2358  2405
   2359  2405				   .
   2360  2405							; 
   2361  2405
   2362  2405				   .
   2363  2405							; 
   2364  2405
   2365  2405				   .L0111		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %00001111
   2366  2405
   2367  2405		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   2368  2407		       29 0f		      AND	#%00001111
   2369  2409		       85 e8		      STA	_BitOp_P0_P1_Dir
   2370  240b				   .
   2371  240b							; 
   2372  240b
   2373  240b				   .L0112		;  _Bit6_P1_Dir_Left{6}  =  1
   2374  240b
   2375  240b		       a5 e8		      LDA	_Bit6_P1_Dir_Left
   2376  240d		       09 40		      ORA	#64
   2377  240f		       85 e8		      STA	_Bit6_P1_Dir_Left
   2378  2411				   .
   2379  2411							; 
   2380  2411
   2381  2411				   .
   2382  2411							; 
   2383  2411
   2384  2411				   .
   2385  2411							; 
   2386  2411
   2387  2411				   .
   2388  2411							; 
   2389  2411
   2390  2411				   .L0113		;  player1:
   2391  2411
   2392  2411		       a2 c2		      LDX	#<playerL0113_1
   2393  2413		       86 8c		      STX	player1pointerlo
   2394  2415		       a9 f9		      LDA	#>playerL0113_1
   2395  2417		       85 8d		      STA	player1pointerhi
   2396  2419		       a9 06		      LDA	#6
   2397  241b		       85 8f		      STA	player1height
   2398  241d				   .
   2399  241d							; 
   2400  241d
   2401  241d				   .__Skip_P1_Left
   2402  241d							; __Skip_P1_Left
   2403  241d
   2404  241d				   .
   2405  241d							; 
   2406  241d
   2407  241d				   .
   2408  241d							; 
   2409  241d
   2410  241d				   .
   2411  241d							; 
   2412  241d
   2413  241d				   .
   2414  241d							; 
   2415  241d
   2416  241d				   .
   2417  241d							; 
   2418  241d
   2419  241d				   .
   2420  241d							; 
   2421  241d
   2422  241d				   .
   2423  241d							; 
   2424  241d
   2425  241d				   .
   2426  241d							; 
   2427  241d
   2428  241d				   .
   2429  241d							; 
   2430  241d
   2431  241d				   .
   2432  241d							; 
   2433  241d
   2434  241d				   .L0114		;  if !_Bit7_P1_Dir_Right{7} then goto __Skip_P1_Right
   2435  241d
   2436  241d		       24 e8		      BIT	_Bit7_P1_Dir_Right
   2437  241f		       30 03		      BMI	.skipL0114
   2438  2421				   .condpart28
   2439  2421		       4c 12 b5 	      jmp	.__Skip_P1_Right
   2440  2424
   2441  2424				   .skipL0114
   2442  2424				   .
   2443  2424							; 
   2444  2424
   2445  2424				   .
   2446  2424							; 
   2447  2424
   2448  2424				   .
   2449  2424							; 
   2450  2424
   2451  2424				   .
   2452  2424							; 
   2453  2424
   2454  2424				   .
   2455  2424							; 
   2456  2424
   2457  2424				   .L0115		;  temp5  =   (  ( player1x - 13 )  / 4 )  + 1
   2458  2424
   2459  2424							; complex statement detected
   2460  2424		       a5 81		      LDA	player1x
   2461  2426		       38		      SEC
   2462  2427		       e9 0d		      SBC	#13
   2463  2429		       4a		      lsr
   2464  242a		       4a		      lsr
   2465  242b		       18		      CLC
   2466  242c		       69 01		      ADC	#1
   2467  242e		       85 a0		      STA	temp5
   2468  2430				   .
   2469  2430							; 
   2470  2430
   2471  2430				   .L0116		;  temp6  =   (  ( player1y - 7 )  / 4 ) 
   2472  2430
   2473  2430							; complex statement detected
   2474  2430		       a5 86		      LDA	player1y
   2475  2432		       38		      SEC
   2476  2433		       e9 07		      SBC	#7
   2477  2435		       4a		      lsr
   2478  2436		       4a		      lsr
   2479  2437		       85 a1		      STA	temp6
   2480  2439				   .
   2481  2439							; 
   2482  2439
   2483  2439				   .L0117		;  if pfread ( temp5 , temp6 )  then goto __Enemy_Cant_Move_Right
   2484  2439
   2485  2439		       a5 a0		      LDA	temp5
   2486  243b		       a4 a1		      LDY	temp6
   2487  243d		       85 ee		      sta	temp7
   2488  243f		       a9 b4		      lda	#>(ret_point8-1)
   2489  2441		       48		      pha
   2490  2442		       a9 54		      lda	#<(ret_point8-1)
   2491  2444		       48		      pha
   2492  2445		       a9 f3		      lda	#>(pfread-1)
   2493  2447		       48		      pha
   2494  2448		       a9 aa		      lda	#<(pfread-1)
   2495  244a		       48		      pha
   2496  244b		       a5 ee		      lda	temp7
   2497  244d		       48		      pha
   2498  244e		       8a		      txa
   2499  244f		       48		      pha
   2500  2450		       a2 04		      ldx	#4
   2501  2452		       4c eb ff 	      jmp	BS_jsr
   2502  2455				   ret_point8
   2503  2455		       d0 03		      BNE	.skipL0117
   2504  2457				   .condpart29
   2505  2457		       4c 85 b4 	      jmp	.__Enemy_Cant_Move_Right
   2506  245a
   2507  245a				   .skipL0117
   2508  245a				   .
   2509  245a							; 
   2510  245a
   2511  245a				   .L0118		;  temp3  =   ( temp6 )  + 1
   2512  245a
   2513  245a							; complex statement detected
   2514  245a		       a5 a1		      LDA	temp6
   2515  245c		       18		      CLC
   2516  245d		       69 01		      ADC	#1
   2517  245f		       85 9e		      STA	temp3
   2518  2461				   .
   2519  2461							; 
   2520  2461
   2521  2461				   .L0119		;  if pfread ( temp5 , temp3 )  then goto __Enemy_Cant_Move_Right
   2522  2461
   2523  2461		       a5 a0		      LDA	temp5
   2524  2463		       a4 9e		      LDY	temp3
   2525  2465		       85 ee		      sta	temp7
   2526  2467		       a9 b4		      lda	#>(ret_point9-1)
   2527  2469		       48		      pha
   2528  246a		       a9 7c		      lda	#<(ret_point9-1)
   2529  246c		       48		      pha
   2530  246d		       a9 f3		      lda	#>(pfread-1)
   2531  246f		       48		      pha
   2532  2470		       a9 aa		      lda	#<(pfread-1)
   2533  2472		       48		      pha
   2534  2473		       a5 ee		      lda	temp7
   2535  2475		       48		      pha
   2536  2476		       8a		      txa
   2537  2477		       48		      pha
   2538  2478		       a2 04		      ldx	#4
   2539  247a		       4c eb ff 	      jmp	BS_jsr
   2540  247d				   ret_point9
   2541  247d		       d0 03		      BNE	.skipL0119
   2542  247f				   .condpart30
   2543  247f		       4c 85 b4 	      jmp	.__Enemy_Cant_Move_Right
   2544  2482
   2545  2482				   .skipL0119
   2546  2482				   .
   2547  2482							; 
   2548  2482
   2549  2482				   .L0120		;  goto __Skip_to_P1_Move_Right
   2550  2482
   2551  2482		       4c 91 b4 	      jmp	.__Skip_to_P1_Move_Right
   2552  2485
   2553  2485				   .
   2554  2485							; 
   2555  2485
   2556  2485				   .__Enemy_Cant_Move_Right
   2557  2485							; __Enemy_Cant_Move_Right
   2558  2485
   2559  2485				   .
   2560  2485							; 
   2561  2485
   2562  2485				   .
   2563  2485							; 
   2564  2485
   2565  2485				   .
   2566  2485							; 
   2567  2485
   2568  2485				   .
   2569  2485							; 
   2570  2485
   2571  2485				   .
   2572  2485							; 
   2573  2485
   2574  2485				   .L0121		;  _Bit7_P1_Dir_Right{7}  =  0
   2575  2485
   2576  2485		       a5 e8		      LDA	_Bit7_P1_Dir_Right
   2577  2487		       29 7f		      AND	#127
   2578  2489		       85 e8		      STA	_Bit7_P1_Dir_Right
   2579  248b				   .
   2580  248b							; 
   2581  248b
   2582  248b				   .L0122		;  gosub __Check_P1_UD
   2583  248b
   2584  248b		       20 fb b6 	      jsr	.__Check_P1_UD
   2585  248e
   2586  248e				   .
   2587  248e							; 
   2588  248e
   2589  248e				   .L0123		;  goto __Clear_Direction
   2590  248e
   2591  248e		       4c 12 b5 	      jmp	.__Clear_Direction
   2592  2491
   2593  2491				   .
   2594  2491							; 
   2595  2491
   2596  2491				   .__Skip_to_P1_Move_Right
   2597  2491							; __Skip_to_P1_Move_Right
   2598  2491
   2599  2491				   .
   2600  2491							; 
   2601  2491
   2602  2491				   .
   2603  2491							; 
   2604  2491
   2605  2491				   .
   2606  2491							; 
   2607  2491
   2608  2491				   .
   2609  2491							; 
   2610  2491
   2611  2491				   .L0124		;  temp5  =   ( temp6 * 4 )  + 7
   2612  2491
   2613  2491							; complex statement detected
   2614  2491		       a5 a1		      LDA	temp6
   2615  2493		       0a		      asl
   2616  2494		       0a		      asl
   2617  2495		       18		      CLC
   2618  2496		       69 07		      ADC	#7
   2619  2498		       85 a0		      STA	temp5
   2620  249a				   .
   2621  249a							; 
   2622  249a
   2623  249a				   .L0125		;  if temp5  <>  player1y then goto __Skip_P1_Right
   2624  249a
   2625  249a		       a5 a0		      LDA	temp5
   2626  249c		       c5 86		      CMP	player1y
   2627  249e		       f0 03		      BEQ	.skipL0125
   2628  24a0				   .condpart31
   2629  24a0		       4c 12 b5 	      jmp	.__Skip_P1_Right
   2630  24a3
   2631  24a3				   .skipL0125
   2632  24a3				   .
   2633  24a3							; 
   2634  24a3
   2635  24a3				   .L0126		;  _P1_L_R  =	_P1_L_R  +  0.52
   2636  24a3
   2637  24a3		       a5 d6		      LDA	c
   2638  24a5		       18		      CLC
   2639  24a6		       69 85		      ADC	#133
   2640  24a8		       85 d6		      STA	c
   2641  24aa		       a5 81		      LDA	_P1_L_R
   2642  24ac		       69 00		      ADC	#0
   2643  24ae		       85 81		      STA	_P1_L_R
   2644  24b0				   .
   2645  24b0							; 
   2646  24b0
   2647  24b0				   .
   2648  24b0							; 
   2649  24b0
   2650  24b0				   .
   2651  24b0							; 
   2652  24b0
   2653  24b0				   .
   2654  24b0							; 
   2655  24b0
   2656  24b0				   .
   2657  24b0							; 
   2658  24b0
   2659  24b0				   .
   2660  24b0							; 
   2661  24b0
   2662  24b0				   .
   2663  24b0							; 
   2664  24b0
   2665  24b0				   .
   2666  24b0							; 
   2667  24b0
   2668  24b0				   .L0127		;  if _Bit5_Direction_Changed{5} then goto __Skip_Enemy_Look_Right
   2669  24b0
   2670  24b0		       a5 ec		      LDA	_Bit5_Direction_Changed
   2671  24b2		       29 20		      AND	#32
   2672  24b4		       f0 03		      BEQ	.skipL0127
   2673  24b6				   .condpart32
   2674  24b6		       4c fa b4 	      jmp	.__Skip_Enemy_Look_Right
   2675  24b9
   2676  24b9				   .skipL0127
   2677  24b9				   .
   2678  24b9							; 
   2679  24b9
   2680  24b9				   .L0128		;  temp5  =  rand
   2681  24b9
   2682  24b9		       a5 a2		      lda	rand
   2683  24bb		       4a		      lsr
   2684  24bc					      ifconst	rand16
   2685  24bc		       26 ed		      rol	rand16
   2686  24be					      endif
   2687  24be		       90 02		      bcc	*+4
   2688  24c0		       49 b4		      eor	#$B4
   2689  24c2		       85 a2		      sta	rand
   2690  24c4					      ifconst	rand16
   2691  24c4		       45 ed		      eor	rand16
   2692  24c6					      endif
   2693  24c6		       85 a0		      STA	temp5
   2694  24c8				   .
   2695  24c8							; 
   2696  24c8
   2697  24c8				   .L0129		;  if temp5  <  _Enemy_Rand_Look then temp5  =   (  (	( player1x - 17 )  / 4 )  * 4 )  + 17  :  if temp5  =  player1x then gosub __Check_P1_UD  :  if _Bit5_Direction_Changed{5} then _Bit7_P1_Dir_Right{7}  =  0  :	goto __Clear_Direction
   2698  24c8
   2699  24c8		       a5 a0		      LDA	temp5
   2700  24ca		       c5 d9		      CMP	_Enemy_Rand_Look
   2701  24cc		       b0 26		      BCS	.skipL0129
   2702  24ce				   .condpart33
   2703  24ce							; complex statement detected
   2704  24ce		       a5 81		      LDA	player1x
   2705  24d0		       38		      SEC
   2706  24d1		       e9 11		      SBC	#17
   2707  24d3		       4a		      lsr
   2708  24d4		       4a		      lsr
   2709  24d5		       0a		      asl
   2710  24d6		       0a		      asl
   2711  24d7		       18		      CLC
   2712  24d8		       69 11		      ADC	#17
   2713  24da		       85 a0		      STA	temp5
   2714  24dc		       a5 a0		      LDA	temp5
   2715  24de		       c5 81		      CMP	player1x
   2716  24e0		       d0 12		      BNE	.skip33then
   2717  24e2				   .condpart34
   2718  24e2		       20 fb b6 	      jsr	.__Check_P1_UD
   2719  24e5		       a5 ec		      LDA	_Bit5_Direction_Changed
   2720  24e7		       29 20		      AND	#32
   2721  24e9		       f0 09		      BEQ	.skip34then
   2722  24eb				   .condpart35
   2723  24eb		       a5 e8		      LDA	_Bit7_P1_Dir_Right
   2724  24ed		       29 7f		      AND	#127
   2725  24ef		       85 e8		      STA	_Bit7_P1_Dir_Right
   2726  24f1		       4c 12 b5 	      jmp	.__Clear_Direction
   2727  24f4
   2728  24f4				   .skip34then
   2729  24f4				   .skip33then
   2730  24f4				   .skipL0129
   2731  24f4				   .
   2732  24f4							; 
   2733  24f4
   2734  24f4				   .L0130		;  _Bit5_Direction_Changed{5}	=  0
   2735  24f4
   2736  24f4		       a5 ec		      LDA	_Bit5_Direction_Changed
   2737  24f6		       29 df		      AND	#223
   2738  24f8		       85 ec		      STA	_Bit5_Direction_Changed
   2739  24fa				   .
   2740  24fa							; 
   2741  24fa
   2742  24fa				   .__Skip_Enemy_Look_Right
   2743  24fa							; __Skip_Enemy_Look_Right
   2744  24fa
   2745  24fa				   .
   2746  24fa							; 
   2747  24fa
   2748  24fa				   .
   2749  24fa							; 
   2750  24fa
   2751  24fa				   .
   2752  24fa							; 
   2753  24fa
   2754  24fa				   .
   2755  24fa							; 
   2756  24fa
   2757  24fa				   .L0131		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %00001111
   2758  24fa
   2759  24fa		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   2760  24fc		       29 0f		      AND	#%00001111
   2761  24fe		       85 e8		      STA	_BitOp_P0_P1_Dir
   2762  2500				   .
   2763  2500							; 
   2764  2500
   2765  2500				   .L0132		;  _Bit7_P1_Dir_Right{7}  =  1
   2766  2500
   2767  2500		       a5 e8		      LDA	_Bit7_P1_Dir_Right
   2768  2502		       09 80		      ORA	#128
   2769  2504		       85 e8		      STA	_Bit7_P1_Dir_Right
   2770  2506				   .
   2771  2506							; 
   2772  2506
   2773  2506				   .
   2774  2506							; 
   2775  2506
   2776  2506				   .
   2777  2506							; 
   2778  2506
   2779  2506				   .
   2780  2506							; 
   2781  2506
   2782  2506				   .L0133		;  player1:
   2783  2506
   2784  2506		       a2 c9		      LDX	#<playerL0133_1
   2785  2508		       86 8c		      STX	player1pointerlo
   2786  250a		       a9 f9		      LDA	#>playerL0133_1
   2787  250c		       85 8d		      STA	player1pointerhi
   2788  250e		       a9 06		      LDA	#6
   2789  2510		       85 8f		      STA	player1height
   2790  2512				   .
   2791  2512							; 
   2792  2512
   2793  2512				   .__Skip_P1_Right
   2794  2512							; __Skip_P1_Right
   2795  2512
   2796  2512				   .
   2797  2512							; 
   2798  2512
   2799  2512				   .
   2800  2512							; 
   2801  2512
   2802  2512				   .
   2803  2512							; 
   2804  2512
   2805  2512				   .
   2806  2512							; 
   2807  2512
   2808  2512				   .
   2809  2512							; 
   2810  2512
   2811  2512				   .
   2812  2512							; 
   2813  2512
   2814  2512				   .
   2815  2512							; 
   2816  2512
   2817  2512				   .__Clear_Direction
   2818  2512							; __Clear_Direction
   2819  2512
   2820  2512				   .
   2821  2512							; 
   2822  2512
   2823  2512				   .
   2824  2512							; 
   2825  2512
   2826  2512				   .
   2827  2512							; 
   2828  2512
   2829  2512				   .
   2830  2512							; 
   2831  2512
   2832  2512				   .
   2833  2512							; 
   2834  2512
   2835  2512				   .L0134		;  if _Enemy_Counter  =  3 then _Bit5_Direction_Changed{5}  =	0  :  _Enemy_Counter  =  0
   2836  2512
   2837  2512		       a5 d8		      LDA	_Enemy_Counter
   2838  2514		       c9 03		      CMP	#3
   2839  2516		       d0 0a		      BNE	.skipL0134
   2840  2518				   .condpart36
   2841  2518		       a5 ec		      LDA	_Bit5_Direction_Changed
   2842  251a		       29 df		      AND	#223
   2843  251c		       85 ec		      STA	_Bit5_Direction_Changed
   2844  251e		       a9 00		      LDA	#0
   2845  2520		       85 d8		      STA	_Enemy_Counter
   2846  2522				   .skipL0134
   2847  2522				   .
   2848  2522							; 
   2849  2522
   2850  2522				   .
   2851  2522							; 
   2852  2522
   2853  2522				   .
   2854  2522							; 
   2855  2522
   2856  2522				   .
   2857  2522							; 
   2858  2522
   2859  2522				   .
   2860  2522							; 
   2861  2522
   2862  2522				   .
   2863  2522							; 
   2864  2522
   2865  2522				   .
   2866  2522							; 
   2867  2522
   2868  2522				   .L0135		;  drawscreen
   2869  2522
   2870  2522		       85 ee		      sta	temp7
   2871  2524		       a9 b5		      lda	#>(ret_point10-1)
   2872  2526		       48		      pha
   2873  2527		       a9 39		      lda	#<(ret_point10-1)
   2874  2529		       48		      pha
   2875  252a		       a9 f5		      lda	#>(drawscreen-1)
   2876  252c		       48		      pha
   2877  252d		       a9 84		      lda	#<(drawscreen-1)
   2878  252f		       48		      pha
   2879  2530		       a5 ee		      lda	temp7
   2880  2532		       48		      pha
   2881  2533		       8a		      txa
   2882  2534		       48		      pha
   2883  2535		       a2 04		      ldx	#4
   2884  2537		       4c eb ff 	      jmp	BS_jsr
   2885  253a				   ret_point10
   2886  253a				   .
   2887  253a							; 
   2888  253a
   2889  253a				   .
   2890  253a							; 
   2891  253a
   2892  253a				   .
   2893  253a							; 
   2894  253a
   2895  253a				   .
   2896  253a							; 
   2897  253a
   2898  253a				   .
   2899  253a							; 
   2900  253a
   2901  253a				   .
   2902  253a							; 
   2903  253a
   2904  253a				   .
   2905  253a							; 
   2906  253a
   2907  253a				   .
   2908  253a							; 
   2909  253a
   2910  253a				   .
   2911  253a							; 
   2912  253a
   2913  253a				   .
   2914  253a							; 
   2915  253a
   2916  253a				   .
   2917  253a							; 
   2918  253a
   2919  253a				   .
   2920  253a							; 
   2921  253a
   2922  253a				   .
   2923  253a							; 
   2924  253a
   2925  253a				   .
   2926  253a							; 
   2927  253a
   2928  253a				   .
   2929  253a							; 
   2930  253a
   2931  253a				   .L0136		;  if !switchreset then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Main_Loop
   2932  253a
   2933  253a		       a9 01		      lda	#1
   2934  253c		       2c 82 02 	      bit	SWCHB
   2935  253f		       f0 09		      BEQ	.skipL0136
   2936  2541				   .condpart37
   2937  2541		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   2938  2543		       29 fe		      AND	#254
   2939  2545		       85 ec		      STA	_Bit0_Reset_Restrainer
   2940  2547		       4c 00 b1 	      jmp	.__Main_Loop
   2941  254a
   2942  254a				   .skipL0136
   2943  254a				   .
   2944  254a							; 
   2945  254a
   2946  254a				   .
   2947  254a							; 
   2948  254a
   2949  254a				   .
   2950  254a							; 
   2951  254a
   2952  254a				   .
   2953  254a							; 
   2954  254a
   2955  254a				   .
   2956  254a							; 
   2957  254a
   2958  254a				   .L0137		;  if _Bit0_Reset_Restrainer{0} then goto __Main_Loop
   2959  254a
   2960  254a		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   2961  254c		       4a		      LSR
   2962  254d		       90 03		      BCC	.skipL0137
   2963  254f				   .condpart38
   2964  254f		       4c 00 b1 	      jmp	.__Main_Loop
   2965  2552
   2966  2552				   .skipL0137
   2967  2552				   .
   2968  2552							; 
   2969  2552
   2970  2552				   .
   2971  2552							; 
   2972  2552
   2973  2552				   .
   2974  2552							; 
   2975  2552
   2976  2552				   .
   2977  2552							; 
   2978  2552
   2979  2552				   .L0138		;  goto __Start_Restart bank1
   2980  2552
   2981  2552		       85 ee		      sta	temp7
   2982  2554		       a9 90		      lda	#>(.__Start_Restart-1)
   2983  2556		       48		      pha
   2984  2557		       a9 ff		      lda	#<(.__Start_Restart-1)
   2985  2559		       48		      pha
   2986  255a		       a5 ee		      lda	temp7
   2987  255c		       48		      pha
   2988  255d		       8a		      txa
   2989  255e		       48		      pha
   2990  255f		       a2 01		      ldx	#1
   2991  2561		       4c eb ff 	      jmp	BS_jsr
   2992  2564				   .
   2993  2564							; 
   2994  2564
   2995  2564				   .
   2996  2564							; 
   2997  2564
   2998  2564				   .
   2999  2564							; 
   3000  2564
   3001  2564				   .
   3002  2564							; 
   3003  2564
   3004  2564				   .
   3005  2564							; 
   3006  2564
   3007  2564				   .
   3008  2564							; 
   3009  2564
   3010  2564				   .
   3011  2564							; 
   3012  2564
   3013  2564				   .
   3014  2564							; 
   3015  2564
   3016  2564				   .
   3017  2564							; 
   3018  2564
   3019  2564				   .
   3020  2564							; 
   3021  2564
   3022  2564				   .
   3023  2564							; 
   3024  2564
   3025  2564				   .
   3026  2564							; 
   3027  2564
   3028  2564				   .
   3029  2564							; 
   3030  2564
   3031  2564				   .
   3032  2564							; 
   3033  2564
   3034  2564				   .
   3035  2564							; 
   3036  2564
   3037  2564				   .
   3038  2564							; 
   3039  2564
   3040  2564				   .
   3041  2564							; 
   3042  2564
   3043  2564				   .
   3044  2564							; 
   3045  2564
   3046  2564				   .
   3047  2564							; 
   3048  2564
   3049  2564				   .
   3050  2564							; 
   3051  2564
   3052  2564				   .
   3053  2564							; 
   3054  2564
   3055  2564				   .__Check_P1_LR
   3056  2564							; __Check_P1_LR
   3057  2564
   3058  2564				   .
   3059  2564							; 
   3060  2564
   3061  2564				   .
   3062  2564							; 
   3063  2564
   3064  2564				   .
   3065  2564							; 
   3066  2564
   3067  2564				   .
   3068  2564							; 
   3069  2564
   3070  2564				   .
   3071  2564							; 
   3072  2564
   3073  2564				   .L0139		;  _Bit5_Direction_Changed{5}	=  0
   3074  2564
   3075  2564		       a5 ec		      LDA	_Bit5_Direction_Changed
   3076  2566		       29 df		      AND	#223
   3077  2568		       85 ec		      STA	_Bit5_Direction_Changed
   3078  256a				   .
   3079  256a							; 
   3080  256a
   3081  256a				   .L0140		;  temp5  =  rand  :  if temp5  <  128 then goto __Skip_LR_Check
   3082  256a
   3083  256a		       a5 a2		      lda	rand
   3084  256c		       4a		      lsr
   3085  256d					      ifconst	rand16
   3086  256d		       26 ed		      rol	rand16
   3087  256f					      endif
   3088  256f		       90 02		      bcc	*+4
   3089  2571		       49 b4		      eor	#$B4
   3090  2573		       85 a2		      sta	rand
   3091  2575					      ifconst	rand16
   3092  2575		       45 ed		      eor	rand16
   3093  2577					      endif
   3094  2577		       85 a0		      STA	temp5
   3095  2579		       a5 a0		      LDA	temp5
   3096  257b		       c9 80		      CMP	#128
   3097  257d		       b0 03		      BCS	.skipL0140
   3098  257f				   .condpart39
   3099  257f		       4c f9 b5 	      jmp	.__Skip_LR_Check
   3100  2582
   3101  2582				   .skipL0140
   3102  2582				   .
   3103  2582							; 
   3104  2582
   3105  2582				   .
   3106  2582							; 
   3107  2582
   3108  2582				   .
   3109  2582							; 
   3110  2582
   3111  2582				   .
   3112  2582							; 
   3113  2582
   3114  2582				   .L0141		;  temp5  =   (  ( player1x - 17 )  / 4 )   -	1
   3115  2582
   3116  2582							; complex statement detected
   3117  2582		       a5 81		      LDA	player1x
   3118  2584		       38		      SEC
   3119  2585		       e9 11		      SBC	#17
   3120  2587		       4a		      lsr
   3121  2588		       4a		      lsr
   3122  2589		       38		      SEC
   3123  258a		       e9 01		      SBC	#1
   3124  258c		       85 a0		      STA	temp5
   3125  258e				   .
   3126  258e							; 
   3127  258e
   3128  258e				   .L0142		;  temp6  =   ( player1y - 7 )  / 4
   3129  258e
   3130  258e							; complex statement detected
   3131  258e		       a5 86		      LDA	player1y
   3132  2590		       38		      SEC
   3133  2591		       e9 07		      SBC	#7
   3134  2593		       4a		      lsr
   3135  2594		       4a		      lsr
   3136  2595		       85 a1		      STA	temp6
   3137  2597				   .
   3138  2597							; 
   3139  2597
   3140  2597				   .L0143		;  if pfread ( temp5 , temp6 )  then goto __Skip_LR_Check
   3141  2597
   3142  2597		       a5 a0		      LDA	temp5
   3143  2599		       a4 a1		      LDY	temp6
   3144  259b		       85 ee		      sta	temp7
   3145  259d		       a9 b5		      lda	#>(ret_point11-1)
   3146  259f		       48		      pha
   3147  25a0		       a9 b2		      lda	#<(ret_point11-1)
   3148  25a2		       48		      pha
   3149  25a3		       a9 f3		      lda	#>(pfread-1)
   3150  25a5		       48		      pha
   3151  25a6		       a9 aa		      lda	#<(pfread-1)
   3152  25a8		       48		      pha
   3153  25a9		       a5 ee		      lda	temp7
   3154  25ab		       48		      pha
   3155  25ac		       8a		      txa
   3156  25ad		       48		      pha
   3157  25ae		       a2 04		      ldx	#4
   3158  25b0		       4c eb ff 	      jmp	BS_jsr
   3159  25b3				   ret_point11
   3160  25b3		       d0 03		      BNE	.skipL0143
   3161  25b5				   .condpart40
   3162  25b5		       4c f9 b5 	      jmp	.__Skip_LR_Check
   3163  25b8
   3164  25b8				   .skipL0143
   3165  25b8				   .
   3166  25b8							; 
   3167  25b8
   3168  25b8				   .L0144		;  temp3  =  temp6  +	1
   3169  25b8
   3170  25b8		       a5 a1		      LDA	temp6
   3171  25ba		       18		      CLC
   3172  25bb		       69 01		      ADC	#1
   3173  25bd		       85 9e		      STA	temp3
   3174  25bf				   .
   3175  25bf							; 
   3176  25bf
   3177  25bf				   .L0145		;  if pfread ( temp5 , temp3 )  then goto __Skip_LR_Check
   3178  25bf
   3179  25bf		       a5 a0		      LDA	temp5
   3180  25c1		       a4 9e		      LDY	temp3
   3181  25c3		       85 ee		      sta	temp7
   3182  25c5		       a9 b5		      lda	#>(ret_point12-1)
   3183  25c7		       48		      pha
   3184  25c8		       a9 da		      lda	#<(ret_point12-1)
   3185  25ca		       48		      pha
   3186  25cb		       a9 f3		      lda	#>(pfread-1)
   3187  25cd		       48		      pha
   3188  25ce		       a9 aa		      lda	#<(pfread-1)
   3189  25d0		       48		      pha
   3190  25d1		       a5 ee		      lda	temp7
   3191  25d3		       48		      pha
   3192  25d4		       8a		      txa
   3193  25d5		       48		      pha
   3194  25d6		       a2 04		      ldx	#4
   3195  25d8		       4c eb ff 	      jmp	BS_jsr
   3196  25db				   ret_point12
   3197  25db		       d0 03		      BNE	.skipL0145
   3198  25dd				   .condpart41
   3199  25dd		       4c f9 b5 	      jmp	.__Skip_LR_Check
   3200  25e0
   3201  25e0				   .skipL0145
   3202  25e0				   .
   3203  25e0							; 
   3204  25e0
   3205  25e0				   .L0146		;  _Bit6_P1_Dir_Left{6}  =  1	:  _Bit5_Direction_Changed{5}  =  1  :	return
   3206  25e0
   3207  25e0		       a5 e8		      LDA	_Bit6_P1_Dir_Left
   3208  25e2		       09 40		      ORA	#64
   3209  25e4		       85 e8		      STA	_Bit6_P1_Dir_Left
   3210  25e6		       a5 ec		      LDA	_Bit5_Direction_Changed
   3211  25e8		       09 20		      ORA	#32
   3212  25ea		       85 ec		      STA	_Bit5_Direction_Changed
   3213  25ec		       ba		      tsx
   3214  25ed		       b5 02		      lda	2,x	; check return address
   3215  25ef		       49 b5		      eor	#(>*)	; vs. current PCH
   3216  25f1		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3217  25f3		       f0 03		      beq	*+5	; if equal, do normal return
   3218  25f5		       4c dd ff 	      JMP	BS_return
   3219  25f8		       60		      RTS
   3220  25f9				   .
   3221  25f9							; 
   3222  25f9
   3223  25f9				   .__Skip_LR_Check
   3224  25f9							; __Skip_LR_Check
   3225  25f9
   3226  25f9				   .
   3227  25f9							; 
   3228  25f9
   3229  25f9				   .
   3230  25f9							; 
   3231  25f9
   3232  25f9				   .
   3233  25f9							; 
   3234  25f9
   3235  25f9				   .
   3236  25f9							; 
   3237  25f9
   3238  25f9				   .L0147		;  temp5  =   (  ( player1x - 13 )  / 4 )  + 1
   3239  25f9
   3240  25f9							; complex statement detected
   3241  25f9		       a5 81		      LDA	player1x
   3242  25fb		       38		      SEC
   3243  25fc		       e9 0d		      SBC	#13
   3244  25fe		       4a		      lsr
   3245  25ff		       4a		      lsr
   3246  2600		       18		      CLC
   3247  2601		       69 01		      ADC	#1
   3248  2603		       85 a0		      STA	temp5
   3249  2605				   .
   3250  2605							; 
   3251  2605
   3252  2605				   .L0148		;  temp6  =   (  ( player1y - 7 )  / 4 ) 
   3253  2605
   3254  2605							; complex statement detected
   3255  2605		       a5 86		      LDA	player1y
   3256  2607		       38		      SEC
   3257  2608		       e9 07		      SBC	#7
   3258  260a		       4a		      lsr
   3259  260b		       4a		      lsr
   3260  260c		       85 a1		      STA	temp6
   3261  260e				   .
   3262  260e							; 
   3263  260e
   3264  260e				   .L0149		;  if pfread ( temp5 , temp6 )  then goto __Skip_R_Check
   3265  260e
   3266  260e		       a5 a0		      LDA	temp5
   3267  2610		       a4 a1		      LDY	temp6
   3268  2612		       85 ee		      sta	temp7
   3269  2614		       a9 b6		      lda	#>(ret_point13-1)
   3270  2616		       48		      pha
   3271  2617		       a9 29		      lda	#<(ret_point13-1)
   3272  2619		       48		      pha
   3273  261a		       a9 f3		      lda	#>(pfread-1)
   3274  261c		       48		      pha
   3275  261d		       a9 aa		      lda	#<(pfread-1)
   3276  261f		       48		      pha
   3277  2620		       a5 ee		      lda	temp7
   3278  2622		       48		      pha
   3279  2623		       8a		      txa
   3280  2624		       48		      pha
   3281  2625		       a2 04		      ldx	#4
   3282  2627		       4c eb ff 	      jmp	BS_jsr
   3283  262a				   ret_point13
   3284  262a		       d0 03		      BNE	.skipL0149
   3285  262c				   .condpart42
   3286  262c		       4c 70 b6 	      jmp	.__Skip_R_Check
   3287  262f
   3288  262f				   .skipL0149
   3289  262f				   .
   3290  262f							; 
   3291  262f
   3292  262f				   .L0150		;  temp3  =   ( temp6 )  + 1
   3293  262f
   3294  262f							; complex statement detected
   3295  262f		       a5 a1		      LDA	temp6
   3296  2631		       18		      CLC
   3297  2632		       69 01		      ADC	#1
   3298  2634		       85 9e		      STA	temp3
   3299  2636				   .
   3300  2636							; 
   3301  2636
   3302  2636				   .L0151		;  if pfread ( temp5 , temp3 )  then goto __Skip_R_Check
   3303  2636
   3304  2636		       a5 a0		      LDA	temp5
   3305  2638		       a4 9e		      LDY	temp3
   3306  263a		       85 ee		      sta	temp7
   3307  263c		       a9 b6		      lda	#>(ret_point14-1)
   3308  263e		       48		      pha
   3309  263f		       a9 51		      lda	#<(ret_point14-1)
   3310  2641		       48		      pha
   3311  2642		       a9 f3		      lda	#>(pfread-1)
   3312  2644		       48		      pha
   3313  2645		       a9 aa		      lda	#<(pfread-1)
   3314  2647		       48		      pha
   3315  2648		       a5 ee		      lda	temp7
   3316  264a		       48		      pha
   3317  264b		       8a		      txa
   3318  264c		       48		      pha
   3319  264d		       a2 04		      ldx	#4
   3320  264f		       4c eb ff 	      jmp	BS_jsr
   3321  2652				   ret_point14
   3322  2652		       d0 03		      BNE	.skipL0151
   3323  2654				   .condpart43
   3324  2654		       4c 70 b6 	      jmp	.__Skip_R_Check
   3325  2657
   3326  2657				   .skipL0151
   3327  2657				   .
   3328  2657							; 
   3329  2657
   3330  2657				   .L0152		;  _Bit7_P1_Dir_Right{7}  =  1  :  _Bit5_Direction_Changed{5}	=  1  :  return
   3331  2657
   3332  2657		       a5 e8		      LDA	_Bit7_P1_Dir_Right
   3333  2659		       09 80		      ORA	#128
   3334  265b		       85 e8		      STA	_Bit7_P1_Dir_Right
   3335  265d		       a5 ec		      LDA	_Bit5_Direction_Changed
   3336  265f		       09 20		      ORA	#32
   3337  2661		       85 ec		      STA	_Bit5_Direction_Changed
   3338  2663		       ba		      tsx
   3339  2664		       b5 02		      lda	2,x	; check return address
   3340  2666		       49 b6		      eor	#(>*)	; vs. current PCH
   3341  2668		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3342  266a		       f0 03		      beq	*+5	; if equal, do normal return
   3343  266c		       4c dd ff 	      JMP	BS_return
   3344  266f		       60		      RTS
   3345  2670				   .
   3346  2670							; 
   3347  2670
   3348  2670				   .__Skip_R_Check
   3349  2670							; __Skip_R_Check
   3350  2670
   3351  2670				   .
   3352  2670							; 
   3353  2670
   3354  2670				   .
   3355  2670							; 
   3356  2670
   3357  2670				   .
   3358  2670							; 
   3359  2670
   3360  2670				   .
   3361  2670							; 
   3362  2670
   3363  2670				   .L0153		;  temp5  =   (  ( player1x - 17 )  / 4 )   -	1
   3364  2670
   3365  2670							; complex statement detected
   3366  2670		       a5 81		      LDA	player1x
   3367  2672		       38		      SEC
   3368  2673		       e9 11		      SBC	#17
   3369  2675		       4a		      lsr
   3370  2676		       4a		      lsr
   3371  2677		       38		      SEC
   3372  2678		       e9 01		      SBC	#1
   3373  267a		       85 a0		      STA	temp5
   3374  267c				   .
   3375  267c							; 
   3376  267c
   3377  267c				   .L0154		;  temp6  =   ( player1y - 7 )  / 4
   3378  267c
   3379  267c							; complex statement detected
   3380  267c		       a5 86		      LDA	player1y
   3381  267e		       38		      SEC
   3382  267f		       e9 07		      SBC	#7
   3383  2681		       4a		      lsr
   3384  2682		       4a		      lsr
   3385  2683		       85 a1		      STA	temp6
   3386  2685				   .
   3387  2685							; 
   3388  2685
   3389  2685				   .L0155		;  if pfread ( temp5 , temp6 )  then return
   3390  2685
   3391  2685		       a5 a0		      LDA	temp5
   3392  2687		       a4 a1		      LDY	temp6
   3393  2689		       85 ee		      sta	temp7
   3394  268b		       a9 b6		      lda	#>(ret_point15-1)
   3395  268d		       48		      pha
   3396  268e		       a9 a0		      lda	#<(ret_point15-1)
   3397  2690		       48		      pha
   3398  2691		       a9 f3		      lda	#>(pfread-1)
   3399  2693		       48		      pha
   3400  2694		       a9 aa		      lda	#<(pfread-1)
   3401  2696		       48		      pha
   3402  2697		       a5 ee		      lda	temp7
   3403  2699		       48		      pha
   3404  269a		       8a		      txa
   3405  269b		       48		      pha
   3406  269c		       a2 04		      ldx	#4
   3407  269e		       4c eb ff 	      jmp	BS_jsr
   3408  26a1				   ret_point15
   3409  26a1		       d0 0d		      BNE	.skipL0155
   3410  26a3				   .condpart44
   3411  26a3		       ba		      tsx
   3412  26a4		       b5 02		      lda	2,x	; check return address
   3413  26a6		       49 b6		      eor	#(>*)	; vs. current PCH
   3414  26a8		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3415  26aa		       f0 03		      beq	*+5	; if equal, do normal return
   3416  26ac		       4c dd ff 	      JMP	BS_return
   3417  26af		       60		      RTS
   3418  26b0				   .skipL0155
   3419  26b0				   .
   3420  26b0							; 
   3421  26b0
   3422  26b0				   .L0156		;  temp3  =  temp6  +	1
   3423  26b0
   3424  26b0		       a5 a1		      LDA	temp6
   3425  26b2		       18		      CLC
   3426  26b3		       69 01		      ADC	#1
   3427  26b5		       85 9e		      STA	temp3
   3428  26b7				   .
   3429  26b7							; 
   3430  26b7
   3431  26b7				   .L0157		;  if pfread ( temp5 , temp3 )  then return
   3432  26b7
   3433  26b7		       a5 a0		      LDA	temp5
   3434  26b9		       a4 9e		      LDY	temp3
   3435  26bb		       85 ee		      sta	temp7
   3436  26bd		       a9 b6		      lda	#>(ret_point16-1)
   3437  26bf		       48		      pha
   3438  26c0		       a9 d2		      lda	#<(ret_point16-1)
   3439  26c2		       48		      pha
   3440  26c3		       a9 f3		      lda	#>(pfread-1)
   3441  26c5		       48		      pha
   3442  26c6		       a9 aa		      lda	#<(pfread-1)
   3443  26c8		       48		      pha
   3444  26c9		       a5 ee		      lda	temp7
   3445  26cb		       48		      pha
   3446  26cc		       8a		      txa
   3447  26cd		       48		      pha
   3448  26ce		       a2 04		      ldx	#4
   3449  26d0		       4c eb ff 	      jmp	BS_jsr
   3450  26d3				   ret_point16
   3451  26d3		       d0 0d		      BNE	.skipL0157
   3452  26d5				   .condpart45
   3453  26d5		       ba		      tsx
   3454  26d6		       b5 02		      lda	2,x	; check return address
   3455  26d8		       49 b6		      eor	#(>*)	; vs. current PCH
   3456  26da		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3457  26dc		       f0 03		      beq	*+5	; if equal, do normal return
   3458  26de		       4c dd ff 	      JMP	BS_return
   3459  26e1		       60		      RTS
   3460  26e2				   .skipL0157
   3461  26e2				   .
   3462  26e2							; 
   3463  26e2
   3464  26e2				   .L0158		;  _Bit6_P1_Dir_Left{6}  =  1	:  _Bit5_Direction_Changed{5}  =  1  :	return
   3465  26e2
   3466  26e2		       a5 e8		      LDA	_Bit6_P1_Dir_Left
   3467  26e4		       09 40		      ORA	#64
   3468  26e6		       85 e8		      STA	_Bit6_P1_Dir_Left
   3469  26e8		       a5 ec		      LDA	_Bit5_Direction_Changed
   3470  26ea		       09 20		      ORA	#32
   3471  26ec		       85 ec		      STA	_Bit5_Direction_Changed
   3472  26ee		       ba		      tsx
   3473  26ef		       b5 02		      lda	2,x	; check return address
   3474  26f1		       49 b6		      eor	#(>*)	; vs. current PCH
   3475  26f3		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3476  26f5		       f0 03		      beq	*+5	; if equal, do normal return
   3477  26f7		       4c dd ff 	      JMP	BS_return
   3478  26fa		       60		      RTS
   3479  26fb				   .
   3480  26fb							; 
   3481  26fb
   3482  26fb				   .
   3483  26fb							; 
   3484  26fb
   3485  26fb				   .
   3486  26fb							; 
   3487  26fb
   3488  26fb				   .
   3489  26fb							; 
   3490  26fb
   3491  26fb				   .
   3492  26fb							; 
   3493  26fb
   3494  26fb				   .
   3495  26fb							; 
   3496  26fb
   3497  26fb				   .
   3498  26fb							; 
   3499  26fb
   3500  26fb				   .__Check_P1_UD
   3501  26fb							; __Check_P1_UD
   3502  26fb
   3503  26fb				   .
   3504  26fb							; 
   3505  26fb
   3506  26fb				   .
   3507  26fb							; 
   3508  26fb
   3509  26fb				   .
   3510  26fb							; 
   3511  26fb
   3512  26fb				   .
   3513  26fb							; 
   3514  26fb
   3515  26fb				   .
   3516  26fb							; 
   3517  26fb
   3518  26fb				   .L0159		;  _Bit5_Direction_Changed{5}	=  0
   3519  26fb
   3520  26fb		       a5 ec		      LDA	_Bit5_Direction_Changed
   3521  26fd		       29 df		      AND	#223
   3522  26ff		       85 ec		      STA	_Bit5_Direction_Changed
   3523  2701				   .
   3524  2701							; 
   3525  2701
   3526  2701				   .L0160		;  temp5  =  rand  :  if temp5  <  128 then goto __Skip_UD_Check
   3527  2701
   3528  2701		       a5 a2		      lda	rand
   3529  2703		       4a		      lsr
   3530  2704					      ifconst	rand16
   3531  2704		       26 ed		      rol	rand16
   3532  2706					      endif
   3533  2706		       90 02		      bcc	*+4
   3534  2708		       49 b4		      eor	#$B4
   3535  270a		       85 a2		      sta	rand
   3536  270c					      ifconst	rand16
   3537  270c		       45 ed		      eor	rand16
   3538  270e					      endif
   3539  270e		       85 a0		      STA	temp5
   3540  2710		       a5 a0		      LDA	temp5
   3541  2712		       c9 80		      CMP	#128
   3542  2714		       b0 03		      BCS	.skipL0160
   3543  2716				   .condpart46
   3544  2716		       4c 8d b7 	      jmp	.__Skip_UD_Check
   3545  2719
   3546  2719				   .skipL0160
   3547  2719				   .
   3548  2719							; 
   3549  2719
   3550  2719				   .
   3551  2719							; 
   3552  2719
   3553  2719				   .
   3554  2719							; 
   3555  2719
   3556  2719				   .
   3557  2719							; 
   3558  2719
   3559  2719				   .L0161		;  temp3  =   ( player1x - 17 )  / 4
   3560  2719
   3561  2719							; complex statement detected
   3562  2719		       a5 81		      LDA	player1x
   3563  271b		       38		      SEC
   3564  271c		       e9 11		      SBC	#17
   3565  271e		       4a		      lsr
   3566  271f		       4a		      lsr
   3567  2720		       85 9e		      STA	temp3
   3568  2722				   .
   3569  2722							; 
   3570  2722
   3571  2722				   .L0162		;  temp6  =   ( player1y / 4 )  - 2
   3572  2722
   3573  2722							; complex statement detected
   3574  2722		       a5 86		      LDA	player1y
   3575  2724		       4a		      lsr
   3576  2725		       4a		      lsr
   3577  2726		       38		      SEC
   3578  2727		       e9 02		      SBC	#2
   3579  2729		       85 a1		      STA	temp6
   3580  272b				   .
   3581  272b							; 
   3582  272b
   3583  272b				   .L0163		;  if pfread ( temp3 , temp6 )  then goto __Skip_UD_Check
   3584  272b
   3585  272b		       a5 9e		      LDA	temp3
   3586  272d		       a4 a1		      LDY	temp6
   3587  272f		       85 ee		      sta	temp7
   3588  2731		       a9 b7		      lda	#>(ret_point17-1)
   3589  2733		       48		      pha
   3590  2734		       a9 46		      lda	#<(ret_point17-1)
   3591  2736		       48		      pha
   3592  2737		       a9 f3		      lda	#>(pfread-1)
   3593  2739		       48		      pha
   3594  273a		       a9 aa		      lda	#<(pfread-1)
   3595  273c		       48		      pha
   3596  273d		       a5 ee		      lda	temp7
   3597  273f		       48		      pha
   3598  2740		       8a		      txa
   3599  2741		       48		      pha
   3600  2742		       a2 04		      ldx	#4
   3601  2744		       4c eb ff 	      jmp	BS_jsr
   3602  2747				   ret_point17
   3603  2747		       d0 03		      BNE	.skipL0163
   3604  2749				   .condpart47
   3605  2749		       4c 8d b7 	      jmp	.__Skip_UD_Check
   3606  274c
   3607  274c				   .skipL0163
   3608  274c				   .
   3609  274c							; 
   3610  274c
   3611  274c				   .L0164		;  temp5  =  temp3  +	1
   3612  274c
   3613  274c		       a5 9e		      LDA	temp3
   3614  274e		       18		      CLC
   3615  274f		       69 01		      ADC	#1
   3616  2751		       85 a0		      STA	temp5
   3617  2753				   .
   3618  2753							; 
   3619  2753
   3620  2753				   .L0165		;  if pfread ( temp5 , temp6 )  then goto __Skip_UD_Check
   3621  2753
   3622  2753		       a5 a0		      LDA	temp5
   3623  2755		       a4 a1		      LDY	temp6
   3624  2757		       85 ee		      sta	temp7
   3625  2759		       a9 b7		      lda	#>(ret_point18-1)
   3626  275b		       48		      pha
   3627  275c		       a9 6e		      lda	#<(ret_point18-1)
   3628  275e		       48		      pha
   3629  275f		       a9 f3		      lda	#>(pfread-1)
   3630  2761		       48		      pha
   3631  2762		       a9 aa		      lda	#<(pfread-1)
   3632  2764		       48		      pha
   3633  2765		       a5 ee		      lda	temp7
   3634  2767		       48		      pha
   3635  2768		       8a		      txa
   3636  2769		       48		      pha
   3637  276a		       a2 04		      ldx	#4
   3638  276c		       4c eb ff 	      jmp	BS_jsr
   3639  276f				   ret_point18
   3640  276f		       d0 03		      BNE	.skipL0165
   3641  2771				   .condpart48
   3642  2771		       4c 8d b7 	      jmp	.__Skip_UD_Check
   3643  2774
   3644  2774				   .skipL0165
   3645  2774				   .
   3646  2774							; 
   3647  2774
   3648  2774				   .L0166		;  _Bit4_P1_Dir_Up{4}	=  1  :  _Bit5_Direction_Changed{5} = 1  :  return
   3649  2774
   3650  2774		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   3651  2776		       09 10		      ORA	#16
   3652  2778		       85 e8		      STA	_Bit4_P1_Dir_Up
   3653  277a		       a5 ec		      LDA	_Bit5_Direction_Changed
   3654  277c		       09 20		      ORA	#32
   3655  277e		       85 ec		      STA	_Bit5_Direction_Changed
   3656  2780		       ba		      tsx
   3657  2781		       b5 02		      lda	2,x	; check return address
   3658  2783		       49 b7		      eor	#(>*)	; vs. current PCH
   3659  2785		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3660  2787		       f0 03		      beq	*+5	; if equal, do normal return
   3661  2789		       4c dd ff 	      JMP	BS_return
   3662  278c		       60		      RTS
   3663  278d				   .
   3664  278d							; 
   3665  278d
   3666  278d				   .__Skip_UD_Check
   3667  278d							; __Skip_UD_Check
   3668  278d
   3669  278d				   .
   3670  278d							; 
   3671  278d
   3672  278d				   .
   3673  278d							; 
   3674  278d
   3675  278d				   .
   3676  278d							; 
   3677  278d
   3678  278d				   .
   3679  278d							; 
   3680  278d
   3681  278d				   .L0167		;  temp3  =   ( player1x - 17 )  / 4
   3682  278d
   3683  278d							; complex statement detected
   3684  278d		       a5 81		      LDA	player1x
   3685  278f		       38		      SEC
   3686  2790		       e9 11		      SBC	#17
   3687  2792		       4a		      lsr
   3688  2793		       4a		      lsr
   3689  2794		       85 9e		      STA	temp3
   3690  2796				   .
   3691  2796							; 
   3692  2796
   3693  2796				   .L0168		;  temp6  =   ( player1y / 4 )   +  1
   3694  2796
   3695  2796							; complex statement detected
   3696  2796		       a5 86		      LDA	player1y
   3697  2798		       4a		      lsr
   3698  2799		       4a		      lsr
   3699  279a		       18		      CLC
   3700  279b		       69 01		      ADC	#1
   3701  279d		       85 a1		      STA	temp6
   3702  279f				   .
   3703  279f							; 
   3704  279f
   3705  279f				   .L0169		;  if pfread ( temp3 , temp6 )  then goto __Skip_U_Check
   3706  279f
   3707  279f		       a5 9e		      LDA	temp3
   3708  27a1		       a4 a1		      LDY	temp6
   3709  27a3		       85 ee		      sta	temp7
   3710  27a5		       a9 b7		      lda	#>(ret_point19-1)
   3711  27a7		       48		      pha
   3712  27a8		       a9 ba		      lda	#<(ret_point19-1)
   3713  27aa		       48		      pha
   3714  27ab		       a9 f3		      lda	#>(pfread-1)
   3715  27ad		       48		      pha
   3716  27ae		       a9 aa		      lda	#<(pfread-1)
   3717  27b0		       48		      pha
   3718  27b1		       a5 ee		      lda	temp7
   3719  27b3		       48		      pha
   3720  27b4		       8a		      txa
   3721  27b5		       48		      pha
   3722  27b6		       a2 04		      ldx	#4
   3723  27b8		       4c eb ff 	      jmp	BS_jsr
   3724  27bb				   ret_point19
   3725  27bb		       d0 03		      BNE	.skipL0169
   3726  27bd				   .condpart49
   3727  27bd		       4c 01 b8 	      jmp	.__Skip_U_Check
   3728  27c0
   3729  27c0				   .skipL0169
   3730  27c0				   .
   3731  27c0							; 
   3732  27c0
   3733  27c0				   .L0170		;  temp5  =  temp3  +	1
   3734  27c0
   3735  27c0		       a5 9e		      LDA	temp3
   3736  27c2		       18		      CLC
   3737  27c3		       69 01		      ADC	#1
   3738  27c5		       85 a0		      STA	temp5
   3739  27c7				   .
   3740  27c7							; 
   3741  27c7
   3742  27c7				   .L0171		;  if pfread ( temp5 , temp6 )  then goto __Skip_U_Check
   3743  27c7
   3744  27c7		       a5 a0		      LDA	temp5
   3745  27c9		       a4 a1		      LDY	temp6
   3746  27cb		       85 ee		      sta	temp7
   3747  27cd		       a9 b7		      lda	#>(ret_point20-1)
   3748  27cf		       48		      pha
   3749  27d0		       a9 e2		      lda	#<(ret_point20-1)
   3750  27d2		       48		      pha
   3751  27d3		       a9 f3		      lda	#>(pfread-1)
   3752  27d5		       48		      pha
   3753  27d6		       a9 aa		      lda	#<(pfread-1)
   3754  27d8		       48		      pha
   3755  27d9		       a5 ee		      lda	temp7
   3756  27db		       48		      pha
   3757  27dc		       8a		      txa
   3758  27dd		       48		      pha
   3759  27de		       a2 04		      ldx	#4
   3760  27e0		       4c eb ff 	      jmp	BS_jsr
   3761  27e3				   ret_point20
   3762  27e3		       d0 03		      BNE	.skipL0171
   3763  27e5				   .condpart50
   3764  27e5		       4c 01 b8 	      jmp	.__Skip_U_Check
   3765  27e8
   3766  27e8				   .skipL0171
   3767  27e8				   .
   3768  27e8							; 
   3769  27e8
   3770  27e8				   .L0172		;  _Bit5_P1_Dir_Down{5}  =  1	:  _Bit5_Direction_Changed{5}  =  1  :	return
   3771  27e8
   3772  27e8		       a5 e8		      LDA	_Bit5_P1_Dir_Down
   3773  27ea		       09 20		      ORA	#32
   3774  27ec		       85 e8		      STA	_Bit5_P1_Dir_Down
   3775  27ee		       a5 ec		      LDA	_Bit5_Direction_Changed
   3776  27f0		       09 20		      ORA	#32
   3777  27f2		       85 ec		      STA	_Bit5_Direction_Changed
   3778  27f4		       ba		      tsx
   3779  27f5		       b5 02		      lda	2,x	; check return address
   3780  27f7		       49 b7		      eor	#(>*)	; vs. current PCH
   3781  27f9		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3782  27fb		       f0 03		      beq	*+5	; if equal, do normal return
   3783  27fd		       4c dd ff 	      JMP	BS_return
   3784  2800		       60		      RTS
   3785  2801				   .
   3786  2801							; 
   3787  2801
   3788  2801				   .__Skip_U_Check
   3789  2801							; __Skip_U_Check
   3790  2801
   3791  2801				   .
   3792  2801							; 
   3793  2801
   3794  2801				   .
   3795  2801							; 
   3796  2801
   3797  2801				   .
   3798  2801							; 
   3799  2801
   3800  2801				   .
   3801  2801							; 
   3802  2801
   3803  2801				   .L0173		;  temp3  =   ( player1x - 17 )  / 4
   3804  2801
   3805  2801							; complex statement detected
   3806  2801		       a5 81		      LDA	player1x
   3807  2803		       38		      SEC
   3808  2804		       e9 11		      SBC	#17
   3809  2806		       4a		      lsr
   3810  2807		       4a		      lsr
   3811  2808		       85 9e		      STA	temp3
   3812  280a				   .
   3813  280a							; 
   3814  280a
   3815  280a				   .L0174		;  temp6  =   ( player1y / 4 )  - 2
   3816  280a
   3817  280a							; complex statement detected
   3818  280a		       a5 86		      LDA	player1y
   3819  280c		       4a		      lsr
   3820  280d		       4a		      lsr
   3821  280e		       38		      SEC
   3822  280f		       e9 02		      SBC	#2
   3823  2811		       85 a1		      STA	temp6
   3824  2813				   .
   3825  2813							; 
   3826  2813
   3827  2813				   .L0175		;  if pfread ( temp3 , temp6 )  then return
   3828  2813
   3829  2813		       a5 9e		      LDA	temp3
   3830  2815		       a4 a1		      LDY	temp6
   3831  2817		       85 ee		      sta	temp7
   3832  2819		       a9 b8		      lda	#>(ret_point21-1)
   3833  281b		       48		      pha
   3834  281c		       a9 2e		      lda	#<(ret_point21-1)
   3835  281e		       48		      pha
   3836  281f		       a9 f3		      lda	#>(pfread-1)
   3837  2821		       48		      pha
   3838  2822		       a9 aa		      lda	#<(pfread-1)
   3839  2824		       48		      pha
   3840  2825		       a5 ee		      lda	temp7
   3841  2827		       48		      pha
   3842  2828		       8a		      txa
   3843  2829		       48		      pha
   3844  282a		       a2 04		      ldx	#4
   3845  282c		       4c eb ff 	      jmp	BS_jsr
   3846  282f				   ret_point21
   3847  282f		       d0 0d		      BNE	.skipL0175
   3848  2831				   .condpart51
   3849  2831		       ba		      tsx
   3850  2832		       b5 02		      lda	2,x	; check return address
   3851  2834		       49 b8		      eor	#(>*)	; vs. current PCH
   3852  2836		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3853  2838		       f0 03		      beq	*+5	; if equal, do normal return
   3854  283a		       4c dd ff 	      JMP	BS_return
   3855  283d		       60		      RTS
   3856  283e				   .skipL0175
   3857  283e				   .
   3858  283e							; 
   3859  283e
   3860  283e				   .L0176		;  temp5  =  temp3  +	1
   3861  283e
   3862  283e		       a5 9e		      LDA	temp3
   3863  2840		       18		      CLC
   3864  2841		       69 01		      ADC	#1
   3865  2843		       85 a0		      STA	temp5
   3866  2845				   .
   3867  2845							; 
   3868  2845
   3869  2845				   .L0177		;  if pfread ( temp5 , temp6 )  then return
   3870  2845
   3871  2845		       a5 a0		      LDA	temp5
   3872  2847		       a4 a1		      LDY	temp6
   3873  2849		       85 ee		      sta	temp7
   3874  284b		       a9 b8		      lda	#>(ret_point22-1)
   3875  284d		       48		      pha
   3876  284e		       a9 60		      lda	#<(ret_point22-1)
   3877  2850		       48		      pha
   3878  2851		       a9 f3		      lda	#>(pfread-1)
   3879  2853		       48		      pha
   3880  2854		       a9 aa		      lda	#<(pfread-1)
   3881  2856		       48		      pha
   3882  2857		       a5 ee		      lda	temp7
   3883  2859		       48		      pha
   3884  285a		       8a		      txa
   3885  285b		       48		      pha
   3886  285c		       a2 04		      ldx	#4
   3887  285e		       4c eb ff 	      jmp	BS_jsr
   3888  2861				   ret_point22
   3889  2861		       d0 0d		      BNE	.skipL0177
   3890  2863				   .condpart52
   3891  2863		       ba		      tsx
   3892  2864		       b5 02		      lda	2,x	; check return address
   3893  2866		       49 b8		      eor	#(>*)	; vs. current PCH
   3894  2868		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3895  286a		       f0 03		      beq	*+5	; if equal, do normal return
   3896  286c		       4c dd ff 	      JMP	BS_return
   3897  286f		       60		      RTS
   3898  2870				   .skipL0177
   3899  2870				   .
   3900  2870							; 
   3901  2870
   3902  2870				   .L0178		;  _Bit4_P1_Dir_Up{4}	=  1  :  _Bit5_Direction_Changed{5}  =	1  :  return
   3903  2870
   3904  2870		       a5 e8		      LDA	_Bit4_P1_Dir_Up
   3905  2872		       09 10		      ORA	#16
   3906  2874		       85 e8		      STA	_Bit4_P1_Dir_Up
   3907  2876		       a5 ec		      LDA	_Bit5_Direction_Changed
   3908  2878		       09 20		      ORA	#32
   3909  287a		       85 ec		      STA	_Bit5_Direction_Changed
   3910  287c		       ba		      tsx
   3911  287d		       b5 02		      lda	2,x	; check return address
   3912  287f		       49 b8		      eor	#(>*)	; vs. current PCH
   3913  2881		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   3914  2883		       f0 03		      beq	*+5	; if equal, do normal return
   3915  2885		       4c dd ff 	      JMP	BS_return
   3916  2888		       60		      RTS
   3917  2889				   .
   3918  2889							; 
   3919  2889
   3920  2889				   .
   3921  2889							; 
   3922  2889
   3923  2889				   .
   3924  2889							; 
   3925  2889
   3926  2889				   .L0179		;  bank 3
   3927  2889
   3928  2889					      if	ECHO2
      1867 bytes of ROM space left in bank 2
   3929  2889					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   3930  2889					      endif
   3931  2889		       00 01	   ECHO2      =	1
   3932  2fd4					      ORG	$2FF4-bscode_length
   3933  2fd4					      RORG	$BFF4-bscode_length
   3934  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   3935  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3936  2fd6				  -	      stx	FASTFETCH
   3937  2fd6					      endif
   3938  2fd6		       9a		      txs
   3939  2fd7				  -	      if	bankswitch == 64
   3940  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3941  2fd7					      else
   3942  2fd7		       a9 f3		      lda	#>(start-1)
   3943  2fd9					      endif
   3944  2fd9		       48		      pha
   3945  2fda		       a9 4f		      lda	#<(start-1)
   3946  2fdc		       48		      pha
   3947  2fdd		       48		      pha
   3948  2fde		       8a		      txa
   3949  2fdf		       48		      pha
   3950  2fe0		       ba		      tsx
   3951  2fe1					      if	bankswitch != 64
   3952  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   3953  2fe3		       2a		      rol
   3954  2fe4		       2a		      rol
   3955  2fe5		       2a		      rol
   3956  2fe6		       2a		      rol
   3957  2fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3958  2fe9		       aa		      tax
   3959  2fea		       e8		      inx
   3960  2feb				  -	      else
   3961  2feb				  -	      lda	4,x	; get high byte of return address
   3962  2feb				  -	      tay
   3963  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3964  2feb				  -	      sta	4,x
   3965  2feb				  -	      tya
   3966  2feb				  -	      lsr
   3967  2feb				  -	      lsr
   3968  2feb				  -	      lsr
   3969  2feb				  -	      lsr
   3970  2feb				  -	      tax
   3971  2feb				  -	      inx
   3972  2feb					      endif
   3973  2feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   3974  2fee		       68		      pla
   3975  2fef		       aa		      tax
   3976  2ff0		       68		      pla
   3977  2ff1		       60		      rts
   3978  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3979  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3980  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3981  2ff2					      endif
   3982  2ffc					      ORG	$2FFC
   3983  2ffc					      RORG	$BFFC
   3984  2ffc		       d4 bf		      .word.w	(start_bank2 & $ffff)
   3985  2ffe		       d4 bf		      .word.w	(start_bank2 & $ffff)
   3986  3000					      ORG	$3000
   3987  3000					      RORG	$D000
   3988  3000					      repeat	256
   3989  3000		       ff		      .byte.b	$ff
   3988  3000					      repend
   3989  3001		       ff		      .byte.b	$ff
   3988  3001					      repend
   3989  3002		       ff		      .byte.b	$ff
   3988  3002					      repend
   3989  3003		       ff		      .byte.b	$ff
   3988  3003					      repend
   3989  3004		       ff		      .byte.b	$ff
   3988  3004					      repend
   3989  3005		       ff		      .byte.b	$ff
   3988  3005					      repend
   3989  3006		       ff		      .byte.b	$ff
   3988  3006					      repend
   3989  3007		       ff		      .byte.b	$ff
   3988  3007					      repend
   3989  3008		       ff		      .byte.b	$ff
   3988  3008					      repend
   3989  3009		       ff		      .byte.b	$ff
   3988  3009					      repend
   3989  300a		       ff		      .byte.b	$ff
   3988  300a					      repend
   3989  300b		       ff		      .byte.b	$ff
   3988  300b					      repend
   3989  300c		       ff		      .byte.b	$ff
   3988  300c					      repend
   3989  300d		       ff		      .byte.b	$ff
   3988  300d					      repend
   3989  300e		       ff		      .byte.b	$ff
   3988  300e					      repend
   3989  300f		       ff		      .byte.b	$ff
   3988  300f					      repend
   3989  3010		       ff		      .byte.b	$ff
   3988  3010					      repend
   3989  3011		       ff		      .byte.b	$ff
   3988  3011					      repend
   3989  3012		       ff		      .byte.b	$ff
   3988  3012					      repend
   3989  3013		       ff		      .byte.b	$ff
   3988  3013					      repend
   3989  3014		       ff		      .byte.b	$ff
   3988  3014					      repend
   3989  3015		       ff		      .byte.b	$ff
   3988  3015					      repend
   3989  3016		       ff		      .byte.b	$ff
   3988  3016					      repend
   3989  3017		       ff		      .byte.b	$ff
   3988  3017					      repend
   3989  3018		       ff		      .byte.b	$ff
   3988  3018					      repend
   3989  3019		       ff		      .byte.b	$ff
   3988  3019					      repend
   3989  301a		       ff		      .byte.b	$ff
   3988  301a					      repend
   3989  301b		       ff		      .byte.b	$ff
   3988  301b					      repend
   3989  301c		       ff		      .byte.b	$ff
   3988  301c					      repend
   3989  301d		       ff		      .byte.b	$ff
   3988  301d					      repend
   3989  301e		       ff		      .byte.b	$ff
   3988  301e					      repend
   3989  301f		       ff		      .byte.b	$ff
   3988  301f					      repend
   3989  3020		       ff		      .byte.b	$ff
   3988  3020					      repend
   3989  3021		       ff		      .byte.b	$ff
   3988  3021					      repend
   3989  3022		       ff		      .byte.b	$ff
   3988  3022					      repend
   3989  3023		       ff		      .byte.b	$ff
   3988  3023					      repend
   3989  3024		       ff		      .byte.b	$ff
   3988  3024					      repend
   3989  3025		       ff		      .byte.b	$ff
   3988  3025					      repend
   3989  3026		       ff		      .byte.b	$ff
   3988  3026					      repend
   3989  3027		       ff		      .byte.b	$ff
   3988  3027					      repend
   3989  3028		       ff		      .byte.b	$ff
   3988  3028					      repend
   3989  3029		       ff		      .byte.b	$ff
   3988  3029					      repend
   3989  302a		       ff		      .byte.b	$ff
   3988  302a					      repend
   3989  302b		       ff		      .byte.b	$ff
   3988  302b					      repend
   3989  302c		       ff		      .byte.b	$ff
   3988  302c					      repend
   3989  302d		       ff		      .byte.b	$ff
   3988  302d					      repend
   3989  302e		       ff		      .byte.b	$ff
   3988  302e					      repend
   3989  302f		       ff		      .byte.b	$ff
   3988  302f					      repend
   3989  3030		       ff		      .byte.b	$ff
   3988  3030					      repend
   3989  3031		       ff		      .byte.b	$ff
   3988  3031					      repend
   3989  3032		       ff		      .byte.b	$ff
   3988  3032					      repend
   3989  3033		       ff		      .byte.b	$ff
   3988  3033					      repend
   3989  3034		       ff		      .byte.b	$ff
   3988  3034					      repend
   3989  3035		       ff		      .byte.b	$ff
   3988  3035					      repend
   3989  3036		       ff		      .byte.b	$ff
   3988  3036					      repend
   3989  3037		       ff		      .byte.b	$ff
   3988  3037					      repend
   3989  3038		       ff		      .byte.b	$ff
   3988  3038					      repend
   3989  3039		       ff		      .byte.b	$ff
   3988  3039					      repend
   3989  303a		       ff		      .byte.b	$ff
   3988  303a					      repend
   3989  303b		       ff		      .byte.b	$ff
   3988  303b					      repend
   3989  303c		       ff		      .byte.b	$ff
   3988  303c					      repend
   3989  303d		       ff		      .byte.b	$ff
   3988  303d					      repend
   3989  303e		       ff		      .byte.b	$ff
   3988  303e					      repend
   3989  303f		       ff		      .byte.b	$ff
   3988  303f					      repend
   3989  3040		       ff		      .byte.b	$ff
   3988  3040					      repend
   3989  3041		       ff		      .byte.b	$ff
   3988  3041					      repend
   3989  3042		       ff		      .byte.b	$ff
   3988  3042					      repend
   3989  3043		       ff		      .byte.b	$ff
   3988  3043					      repend
   3989  3044		       ff		      .byte.b	$ff
   3988  3044					      repend
   3989  3045		       ff		      .byte.b	$ff
   3988  3045					      repend
   3989  3046		       ff		      .byte.b	$ff
   3988  3046					      repend
   3989  3047		       ff		      .byte.b	$ff
   3988  3047					      repend
   3989  3048		       ff		      .byte.b	$ff
   3988  3048					      repend
   3989  3049		       ff		      .byte.b	$ff
   3988  3049					      repend
   3989  304a		       ff		      .byte.b	$ff
   3988  304a					      repend
   3989  304b		       ff		      .byte.b	$ff
   3988  304b					      repend
   3989  304c		       ff		      .byte.b	$ff
   3988  304c					      repend
   3989  304d		       ff		      .byte.b	$ff
   3988  304d					      repend
   3989  304e		       ff		      .byte.b	$ff
   3988  304e					      repend
   3989  304f		       ff		      .byte.b	$ff
   3988  304f					      repend
   3989  3050		       ff		      .byte.b	$ff
   3988  3050					      repend
   3989  3051		       ff		      .byte.b	$ff
   3988  3051					      repend
   3989  3052		       ff		      .byte.b	$ff
   3988  3052					      repend
   3989  3053		       ff		      .byte.b	$ff
   3988  3053					      repend
   3989  3054		       ff		      .byte.b	$ff
   3988  3054					      repend
   3989  3055		       ff		      .byte.b	$ff
   3988  3055					      repend
   3989  3056		       ff		      .byte.b	$ff
   3988  3056					      repend
   3989  3057		       ff		      .byte.b	$ff
   3988  3057					      repend
   3989  3058		       ff		      .byte.b	$ff
   3988  3058					      repend
   3989  3059		       ff		      .byte.b	$ff
   3988  3059					      repend
   3989  305a		       ff		      .byte.b	$ff
   3988  305a					      repend
   3989  305b		       ff		      .byte.b	$ff
   3988  305b					      repend
   3989  305c		       ff		      .byte.b	$ff
   3988  305c					      repend
   3989  305d		       ff		      .byte.b	$ff
   3988  305d					      repend
   3989  305e		       ff		      .byte.b	$ff
   3988  305e					      repend
   3989  305f		       ff		      .byte.b	$ff
   3988  305f					      repend
   3989  3060		       ff		      .byte.b	$ff
   3988  3060					      repend
   3989  3061		       ff		      .byte.b	$ff
   3988  3061					      repend
   3989  3062		       ff		      .byte.b	$ff
   3988  3062					      repend
   3989  3063		       ff		      .byte.b	$ff
   3988  3063					      repend
   3989  3064		       ff		      .byte.b	$ff
   3988  3064					      repend
   3989  3065		       ff		      .byte.b	$ff
   3988  3065					      repend
   3989  3066		       ff		      .byte.b	$ff
   3988  3066					      repend
   3989  3067		       ff		      .byte.b	$ff
   3988  3067					      repend
   3989  3068		       ff		      .byte.b	$ff
   3988  3068					      repend
   3989  3069		       ff		      .byte.b	$ff
   3988  3069					      repend
   3989  306a		       ff		      .byte.b	$ff
   3988  306a					      repend
   3989  306b		       ff		      .byte.b	$ff
   3988  306b					      repend
   3989  306c		       ff		      .byte.b	$ff
   3988  306c					      repend
   3989  306d		       ff		      .byte.b	$ff
   3988  306d					      repend
   3989  306e		       ff		      .byte.b	$ff
   3988  306e					      repend
   3989  306f		       ff		      .byte.b	$ff
   3988  306f					      repend
   3989  3070		       ff		      .byte.b	$ff
   3988  3070					      repend
   3989  3071		       ff		      .byte.b	$ff
   3988  3071					      repend
   3989  3072		       ff		      .byte.b	$ff
   3988  3072					      repend
   3989  3073		       ff		      .byte.b	$ff
   3988  3073					      repend
   3989  3074		       ff		      .byte.b	$ff
   3988  3074					      repend
   3989  3075		       ff		      .byte.b	$ff
   3988  3075					      repend
   3989  3076		       ff		      .byte.b	$ff
   3988  3076					      repend
   3989  3077		       ff		      .byte.b	$ff
   3988  3077					      repend
   3989  3078		       ff		      .byte.b	$ff
   3988  3078					      repend
   3989  3079		       ff		      .byte.b	$ff
   3988  3079					      repend
   3989  307a		       ff		      .byte.b	$ff
   3988  307a					      repend
   3989  307b		       ff		      .byte.b	$ff
   3988  307b					      repend
   3989  307c		       ff		      .byte.b	$ff
   3988  307c					      repend
   3989  307d		       ff		      .byte.b	$ff
   3988  307d					      repend
   3989  307e		       ff		      .byte.b	$ff
   3988  307e					      repend
   3989  307f		       ff		      .byte.b	$ff
   3988  307f					      repend
   3989  3080		       ff		      .byte.b	$ff
   3988  3080					      repend
   3989  3081		       ff		      .byte.b	$ff
   3988  3081					      repend
   3989  3082		       ff		      .byte.b	$ff
   3988  3082					      repend
   3989  3083		       ff		      .byte.b	$ff
   3988  3083					      repend
   3989  3084		       ff		      .byte.b	$ff
   3988  3084					      repend
   3989  3085		       ff		      .byte.b	$ff
   3988  3085					      repend
   3989  3086		       ff		      .byte.b	$ff
   3988  3086					      repend
   3989  3087		       ff		      .byte.b	$ff
   3988  3087					      repend
   3989  3088		       ff		      .byte.b	$ff
   3988  3088					      repend
   3989  3089		       ff		      .byte.b	$ff
   3988  3089					      repend
   3989  308a		       ff		      .byte.b	$ff
   3988  308a					      repend
   3989  308b		       ff		      .byte.b	$ff
   3988  308b					      repend
   3989  308c		       ff		      .byte.b	$ff
   3988  308c					      repend
   3989  308d		       ff		      .byte.b	$ff
   3988  308d					      repend
   3989  308e		       ff		      .byte.b	$ff
   3988  308e					      repend
   3989  308f		       ff		      .byte.b	$ff
   3988  308f					      repend
   3989  3090		       ff		      .byte.b	$ff
   3988  3090					      repend
   3989  3091		       ff		      .byte.b	$ff
   3988  3091					      repend
   3989  3092		       ff		      .byte.b	$ff
   3988  3092					      repend
   3989  3093		       ff		      .byte.b	$ff
   3988  3093					      repend
   3989  3094		       ff		      .byte.b	$ff
   3988  3094					      repend
   3989  3095		       ff		      .byte.b	$ff
   3988  3095					      repend
   3989  3096		       ff		      .byte.b	$ff
   3988  3096					      repend
   3989  3097		       ff		      .byte.b	$ff
   3988  3097					      repend
   3989  3098		       ff		      .byte.b	$ff
   3988  3098					      repend
   3989  3099		       ff		      .byte.b	$ff
   3988  3099					      repend
   3989  309a		       ff		      .byte.b	$ff
   3988  309a					      repend
   3989  309b		       ff		      .byte.b	$ff
   3988  309b					      repend
   3989  309c		       ff		      .byte.b	$ff
   3988  309c					      repend
   3989  309d		       ff		      .byte.b	$ff
   3988  309d					      repend
   3989  309e		       ff		      .byte.b	$ff
   3988  309e					      repend
   3989  309f		       ff		      .byte.b	$ff
   3988  309f					      repend
   3989  30a0		       ff		      .byte.b	$ff
   3988  30a0					      repend
   3989  30a1		       ff		      .byte.b	$ff
   3988  30a1					      repend
   3989  30a2		       ff		      .byte.b	$ff
   3988  30a2					      repend
   3989  30a3		       ff		      .byte.b	$ff
   3988  30a3					      repend
   3989  30a4		       ff		      .byte.b	$ff
   3988  30a4					      repend
   3989  30a5		       ff		      .byte.b	$ff
   3988  30a5					      repend
   3989  30a6		       ff		      .byte.b	$ff
   3988  30a6					      repend
   3989  30a7		       ff		      .byte.b	$ff
   3988  30a7					      repend
   3989  30a8		       ff		      .byte.b	$ff
   3988  30a8					      repend
   3989  30a9		       ff		      .byte.b	$ff
   3988  30a9					      repend
   3989  30aa		       ff		      .byte.b	$ff
   3988  30aa					      repend
   3989  30ab		       ff		      .byte.b	$ff
   3988  30ab					      repend
   3989  30ac		       ff		      .byte.b	$ff
   3988  30ac					      repend
   3989  30ad		       ff		      .byte.b	$ff
   3988  30ad					      repend
   3989  30ae		       ff		      .byte.b	$ff
   3988  30ae					      repend
   3989  30af		       ff		      .byte.b	$ff
   3988  30af					      repend
   3989  30b0		       ff		      .byte.b	$ff
   3988  30b0					      repend
   3989  30b1		       ff		      .byte.b	$ff
   3988  30b1					      repend
   3989  30b2		       ff		      .byte.b	$ff
   3988  30b2					      repend
   3989  30b3		       ff		      .byte.b	$ff
   3988  30b3					      repend
   3989  30b4		       ff		      .byte.b	$ff
   3988  30b4					      repend
   3989  30b5		       ff		      .byte.b	$ff
   3988  30b5					      repend
   3989  30b6		       ff		      .byte.b	$ff
   3988  30b6					      repend
   3989  30b7		       ff		      .byte.b	$ff
   3988  30b7					      repend
   3989  30b8		       ff		      .byte.b	$ff
   3988  30b8					      repend
   3989  30b9		       ff		      .byte.b	$ff
   3988  30b9					      repend
   3989  30ba		       ff		      .byte.b	$ff
   3988  30ba					      repend
   3989  30bb		       ff		      .byte.b	$ff
   3988  30bb					      repend
   3989  30bc		       ff		      .byte.b	$ff
   3988  30bc					      repend
   3989  30bd		       ff		      .byte.b	$ff
   3988  30bd					      repend
   3989  30be		       ff		      .byte.b	$ff
   3988  30be					      repend
   3989  30bf		       ff		      .byte.b	$ff
   3988  30bf					      repend
   3989  30c0		       ff		      .byte.b	$ff
   3988  30c0					      repend
   3989  30c1		       ff		      .byte.b	$ff
   3988  30c1					      repend
   3989  30c2		       ff		      .byte.b	$ff
   3988  30c2					      repend
   3989  30c3		       ff		      .byte.b	$ff
   3988  30c3					      repend
   3989  30c4		       ff		      .byte.b	$ff
   3988  30c4					      repend
   3989  30c5		       ff		      .byte.b	$ff
   3988  30c5					      repend
   3989  30c6		       ff		      .byte.b	$ff
   3988  30c6					      repend
   3989  30c7		       ff		      .byte.b	$ff
   3988  30c7					      repend
   3989  30c8		       ff		      .byte.b	$ff
   3988  30c8					      repend
   3989  30c9		       ff		      .byte.b	$ff
   3988  30c9					      repend
   3989  30ca		       ff		      .byte.b	$ff
   3988  30ca					      repend
   3989  30cb		       ff		      .byte.b	$ff
   3988  30cb					      repend
   3989  30cc		       ff		      .byte.b	$ff
   3988  30cc					      repend
   3989  30cd		       ff		      .byte.b	$ff
   3988  30cd					      repend
   3989  30ce		       ff		      .byte.b	$ff
   3988  30ce					      repend
   3989  30cf		       ff		      .byte.b	$ff
   3988  30cf					      repend
   3989  30d0		       ff		      .byte.b	$ff
   3988  30d0					      repend
   3989  30d1		       ff		      .byte.b	$ff
   3988  30d1					      repend
   3989  30d2		       ff		      .byte.b	$ff
   3988  30d2					      repend
   3989  30d3		       ff		      .byte.b	$ff
   3988  30d3					      repend
   3989  30d4		       ff		      .byte.b	$ff
   3988  30d4					      repend
   3989  30d5		       ff		      .byte.b	$ff
   3988  30d5					      repend
   3989  30d6		       ff		      .byte.b	$ff
   3988  30d6					      repend
   3989  30d7		       ff		      .byte.b	$ff
   3988  30d7					      repend
   3989  30d8		       ff		      .byte.b	$ff
   3988  30d8					      repend
   3989  30d9		       ff		      .byte.b	$ff
   3988  30d9					      repend
   3989  30da		       ff		      .byte.b	$ff
   3988  30da					      repend
   3989  30db		       ff		      .byte.b	$ff
   3988  30db					      repend
   3989  30dc		       ff		      .byte.b	$ff
   3988  30dc					      repend
   3989  30dd		       ff		      .byte.b	$ff
   3988  30dd					      repend
   3989  30de		       ff		      .byte.b	$ff
   3988  30de					      repend
   3989  30df		       ff		      .byte.b	$ff
   3988  30df					      repend
   3989  30e0		       ff		      .byte.b	$ff
   3988  30e0					      repend
   3989  30e1		       ff		      .byte.b	$ff
   3988  30e1					      repend
   3989  30e2		       ff		      .byte.b	$ff
   3988  30e2					      repend
   3989  30e3		       ff		      .byte.b	$ff
   3988  30e3					      repend
   3989  30e4		       ff		      .byte.b	$ff
   3988  30e4					      repend
   3989  30e5		       ff		      .byte.b	$ff
   3988  30e5					      repend
   3989  30e6		       ff		      .byte.b	$ff
   3988  30e6					      repend
   3989  30e7		       ff		      .byte.b	$ff
   3988  30e7					      repend
   3989  30e8		       ff		      .byte.b	$ff
   3988  30e8					      repend
   3989  30e9		       ff		      .byte.b	$ff
   3988  30e9					      repend
   3989  30ea		       ff		      .byte.b	$ff
   3988  30ea					      repend
   3989  30eb		       ff		      .byte.b	$ff
   3988  30eb					      repend
   3989  30ec		       ff		      .byte.b	$ff
   3988  30ec					      repend
   3989  30ed		       ff		      .byte.b	$ff
   3988  30ed					      repend
   3989  30ee		       ff		      .byte.b	$ff
   3988  30ee					      repend
   3989  30ef		       ff		      .byte.b	$ff
   3988  30ef					      repend
   3989  30f0		       ff		      .byte.b	$ff
   3988  30f0					      repend
   3989  30f1		       ff		      .byte.b	$ff
   3988  30f1					      repend
   3989  30f2		       ff		      .byte.b	$ff
   3988  30f2					      repend
   3989  30f3		       ff		      .byte.b	$ff
   3988  30f3					      repend
   3989  30f4		       ff		      .byte.b	$ff
   3988  30f4					      repend
   3989  30f5		       ff		      .byte.b	$ff
   3988  30f5					      repend
   3989  30f6		       ff		      .byte.b	$ff
   3988  30f6					      repend
   3989  30f7		       ff		      .byte.b	$ff
   3988  30f7					      repend
   3989  30f8		       ff		      .byte.b	$ff
   3988  30f8					      repend
   3989  30f9		       ff		      .byte.b	$ff
   3988  30f9					      repend
   3989  30fa		       ff		      .byte.b	$ff
   3988  30fa					      repend
   3989  30fb		       ff		      .byte.b	$ff
   3988  30fb					      repend
   3989  30fc		       ff		      .byte.b	$ff
   3988  30fc					      repend
   3989  30fd		       ff		      .byte.b	$ff
   3988  30fd					      repend
   3989  30fe		       ff		      .byte.b	$ff
   3988  30fe					      repend
   3989  30ff		       ff		      .byte.b	$ff
   3990  3100					      repend
   3991  3100				   .
   3992  3100							; 
   3993  3100
   3994  3100				   .
   3995  3100							; 
   3996  3100
   3997  3100				   .
   3998  3100							; 
   3999  3100
   4000  3100				   .L0180		;  bank 4
   4001  3100
   4002  3100					      if	ECHO3
      3796 bytes of ROM space left in bank 3
   4003  3100					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   4004  3100					      endif
   4005  3100		       00 01	   ECHO3      =	1
   4006  3fd4					      ORG	$3FF4-bscode_length
   4007  3fd4					      RORG	$DFF4-bscode_length
   4008  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   4009  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   4010  3fd6				  -	      stx	FASTFETCH
   4011  3fd6					      endif
   4012  3fd6		       9a		      txs
   4013  3fd7				  -	      if	bankswitch == 64
   4014  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4015  3fd7					      else
   4016  3fd7		       a9 f3		      lda	#>(start-1)
   4017  3fd9					      endif
   4018  3fd9		       48		      pha
   4019  3fda		       a9 4f		      lda	#<(start-1)
   4020  3fdc		       48		      pha
   4021  3fdd		       48		      pha
   4022  3fde		       8a		      txa
   4023  3fdf		       48		      pha
   4024  3fe0		       ba		      tsx
   4025  3fe1					      if	bankswitch != 64
   4026  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   4027  3fe3		       2a		      rol
   4028  3fe4		       2a		      rol
   4029  3fe5		       2a		      rol
   4030  3fe6		       2a		      rol
   4031  3fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4032  3fe9		       aa		      tax
   4033  3fea		       e8		      inx
   4034  3feb				  -	      else
   4035  3feb				  -	      lda	4,x	; get high byte of return address
   4036  3feb				  -	      tay
   4037  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4038  3feb				  -	      sta	4,x
   4039  3feb				  -	      tya
   4040  3feb				  -	      lsr
   4041  3feb				  -	      lsr
   4042  3feb				  -	      lsr
   4043  3feb				  -	      lsr
   4044  3feb				  -	      tax
   4045  3feb				  -	      inx
   4046  3feb					      endif
   4047  3feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4048  3fee		       68		      pla
   4049  3fef		       aa		      tax
   4050  3ff0		       68		      pla
   4051  3ff1		       60		      rts
   4052  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4053  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4054  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4055  3ff2					      endif
   4056  3ffc					      ORG	$3FFC
   4057  3ffc					      RORG	$DFFC
   4058  3ffc		       d4 df		      .word.w	(start_bank3 & $ffff)
   4059  3ffe		       d4 df		      .word.w	(start_bank3 & $ffff)
   4060  4000					      ORG	$4000
   4061  4000					      RORG	$F000
   4062  4000					      repeat	256
   4063  4000		       ff		      .byte.b	$ff
   4062  4000					      repend
   4063  4001		       ff		      .byte.b	$ff
   4062  4001					      repend
   4063  4002		       ff		      .byte.b	$ff
   4062  4002					      repend
   4063  4003		       ff		      .byte.b	$ff
   4062  4003					      repend
   4063  4004		       ff		      .byte.b	$ff
   4062  4004					      repend
   4063  4005		       ff		      .byte.b	$ff
   4062  4005					      repend
   4063  4006		       ff		      .byte.b	$ff
   4062  4006					      repend
   4063  4007		       ff		      .byte.b	$ff
   4062  4007					      repend
   4063  4008		       ff		      .byte.b	$ff
   4062  4008					      repend
   4063  4009		       ff		      .byte.b	$ff
   4062  4009					      repend
   4063  400a		       ff		      .byte.b	$ff
   4062  400a					      repend
   4063  400b		       ff		      .byte.b	$ff
   4062  400b					      repend
   4063  400c		       ff		      .byte.b	$ff
   4062  400c					      repend
   4063  400d		       ff		      .byte.b	$ff
   4062  400d					      repend
   4063  400e		       ff		      .byte.b	$ff
   4062  400e					      repend
   4063  400f		       ff		      .byte.b	$ff
   4062  400f					      repend
   4063  4010		       ff		      .byte.b	$ff
   4062  4010					      repend
   4063  4011		       ff		      .byte.b	$ff
   4062  4011					      repend
   4063  4012		       ff		      .byte.b	$ff
   4062  4012					      repend
   4063  4013		       ff		      .byte.b	$ff
   4062  4013					      repend
   4063  4014		       ff		      .byte.b	$ff
   4062  4014					      repend
   4063  4015		       ff		      .byte.b	$ff
   4062  4015					      repend
   4063  4016		       ff		      .byte.b	$ff
   4062  4016					      repend
   4063  4017		       ff		      .byte.b	$ff
   4062  4017					      repend
   4063  4018		       ff		      .byte.b	$ff
   4062  4018					      repend
   4063  4019		       ff		      .byte.b	$ff
   4062  4019					      repend
   4063  401a		       ff		      .byte.b	$ff
   4062  401a					      repend
   4063  401b		       ff		      .byte.b	$ff
   4062  401b					      repend
   4063  401c		       ff		      .byte.b	$ff
   4062  401c					      repend
   4063  401d		       ff		      .byte.b	$ff
   4062  401d					      repend
   4063  401e		       ff		      .byte.b	$ff
   4062  401e					      repend
   4063  401f		       ff		      .byte.b	$ff
   4062  401f					      repend
   4063  4020		       ff		      .byte.b	$ff
   4062  4020					      repend
   4063  4021		       ff		      .byte.b	$ff
   4062  4021					      repend
   4063  4022		       ff		      .byte.b	$ff
   4062  4022					      repend
   4063  4023		       ff		      .byte.b	$ff
   4062  4023					      repend
   4063  4024		       ff		      .byte.b	$ff
   4062  4024					      repend
   4063  4025		       ff		      .byte.b	$ff
   4062  4025					      repend
   4063  4026		       ff		      .byte.b	$ff
   4062  4026					      repend
   4063  4027		       ff		      .byte.b	$ff
   4062  4027					      repend
   4063  4028		       ff		      .byte.b	$ff
   4062  4028					      repend
   4063  4029		       ff		      .byte.b	$ff
   4062  4029					      repend
   4063  402a		       ff		      .byte.b	$ff
   4062  402a					      repend
   4063  402b		       ff		      .byte.b	$ff
   4062  402b					      repend
   4063  402c		       ff		      .byte.b	$ff
   4062  402c					      repend
   4063  402d		       ff		      .byte.b	$ff
   4062  402d					      repend
   4063  402e		       ff		      .byte.b	$ff
   4062  402e					      repend
   4063  402f		       ff		      .byte.b	$ff
   4062  402f					      repend
   4063  4030		       ff		      .byte.b	$ff
   4062  4030					      repend
   4063  4031		       ff		      .byte.b	$ff
   4062  4031					      repend
   4063  4032		       ff		      .byte.b	$ff
   4062  4032					      repend
   4063  4033		       ff		      .byte.b	$ff
   4062  4033					      repend
   4063  4034		       ff		      .byte.b	$ff
   4062  4034					      repend
   4063  4035		       ff		      .byte.b	$ff
   4062  4035					      repend
   4063  4036		       ff		      .byte.b	$ff
   4062  4036					      repend
   4063  4037		       ff		      .byte.b	$ff
   4062  4037					      repend
   4063  4038		       ff		      .byte.b	$ff
   4062  4038					      repend
   4063  4039		       ff		      .byte.b	$ff
   4062  4039					      repend
   4063  403a		       ff		      .byte.b	$ff
   4062  403a					      repend
   4063  403b		       ff		      .byte.b	$ff
   4062  403b					      repend
   4063  403c		       ff		      .byte.b	$ff
   4062  403c					      repend
   4063  403d		       ff		      .byte.b	$ff
   4062  403d					      repend
   4063  403e		       ff		      .byte.b	$ff
   4062  403e					      repend
   4063  403f		       ff		      .byte.b	$ff
   4062  403f					      repend
   4063  4040		       ff		      .byte.b	$ff
   4062  4040					      repend
   4063  4041		       ff		      .byte.b	$ff
   4062  4041					      repend
   4063  4042		       ff		      .byte.b	$ff
   4062  4042					      repend
   4063  4043		       ff		      .byte.b	$ff
   4062  4043					      repend
   4063  4044		       ff		      .byte.b	$ff
   4062  4044					      repend
   4063  4045		       ff		      .byte.b	$ff
   4062  4045					      repend
   4063  4046		       ff		      .byte.b	$ff
   4062  4046					      repend
   4063  4047		       ff		      .byte.b	$ff
   4062  4047					      repend
   4063  4048		       ff		      .byte.b	$ff
   4062  4048					      repend
   4063  4049		       ff		      .byte.b	$ff
   4062  4049					      repend
   4063  404a		       ff		      .byte.b	$ff
   4062  404a					      repend
   4063  404b		       ff		      .byte.b	$ff
   4062  404b					      repend
   4063  404c		       ff		      .byte.b	$ff
   4062  404c					      repend
   4063  404d		       ff		      .byte.b	$ff
   4062  404d					      repend
   4063  404e		       ff		      .byte.b	$ff
   4062  404e					      repend
   4063  404f		       ff		      .byte.b	$ff
   4062  404f					      repend
   4063  4050		       ff		      .byte.b	$ff
   4062  4050					      repend
   4063  4051		       ff		      .byte.b	$ff
   4062  4051					      repend
   4063  4052		       ff		      .byte.b	$ff
   4062  4052					      repend
   4063  4053		       ff		      .byte.b	$ff
   4062  4053					      repend
   4063  4054		       ff		      .byte.b	$ff
   4062  4054					      repend
   4063  4055		       ff		      .byte.b	$ff
   4062  4055					      repend
   4063  4056		       ff		      .byte.b	$ff
   4062  4056					      repend
   4063  4057		       ff		      .byte.b	$ff
   4062  4057					      repend
   4063  4058		       ff		      .byte.b	$ff
   4062  4058					      repend
   4063  4059		       ff		      .byte.b	$ff
   4062  4059					      repend
   4063  405a		       ff		      .byte.b	$ff
   4062  405a					      repend
   4063  405b		       ff		      .byte.b	$ff
   4062  405b					      repend
   4063  405c		       ff		      .byte.b	$ff
   4062  405c					      repend
   4063  405d		       ff		      .byte.b	$ff
   4062  405d					      repend
   4063  405e		       ff		      .byte.b	$ff
   4062  405e					      repend
   4063  405f		       ff		      .byte.b	$ff
   4062  405f					      repend
   4063  4060		       ff		      .byte.b	$ff
   4062  4060					      repend
   4063  4061		       ff		      .byte.b	$ff
   4062  4061					      repend
   4063  4062		       ff		      .byte.b	$ff
   4062  4062					      repend
   4063  4063		       ff		      .byte.b	$ff
   4062  4063					      repend
   4063  4064		       ff		      .byte.b	$ff
   4062  4064					      repend
   4063  4065		       ff		      .byte.b	$ff
   4062  4065					      repend
   4063  4066		       ff		      .byte.b	$ff
   4062  4066					      repend
   4063  4067		       ff		      .byte.b	$ff
   4062  4067					      repend
   4063  4068		       ff		      .byte.b	$ff
   4062  4068					      repend
   4063  4069		       ff		      .byte.b	$ff
   4062  4069					      repend
   4063  406a		       ff		      .byte.b	$ff
   4062  406a					      repend
   4063  406b		       ff		      .byte.b	$ff
   4062  406b					      repend
   4063  406c		       ff		      .byte.b	$ff
   4062  406c					      repend
   4063  406d		       ff		      .byte.b	$ff
   4062  406d					      repend
   4063  406e		       ff		      .byte.b	$ff
   4062  406e					      repend
   4063  406f		       ff		      .byte.b	$ff
   4062  406f					      repend
   4063  4070		       ff		      .byte.b	$ff
   4062  4070					      repend
   4063  4071		       ff		      .byte.b	$ff
   4062  4071					      repend
   4063  4072		       ff		      .byte.b	$ff
   4062  4072					      repend
   4063  4073		       ff		      .byte.b	$ff
   4062  4073					      repend
   4063  4074		       ff		      .byte.b	$ff
   4062  4074					      repend
   4063  4075		       ff		      .byte.b	$ff
   4062  4075					      repend
   4063  4076		       ff		      .byte.b	$ff
   4062  4076					      repend
   4063  4077		       ff		      .byte.b	$ff
   4062  4077					      repend
   4063  4078		       ff		      .byte.b	$ff
   4062  4078					      repend
   4063  4079		       ff		      .byte.b	$ff
   4062  4079					      repend
   4063  407a		       ff		      .byte.b	$ff
   4062  407a					      repend
   4063  407b		       ff		      .byte.b	$ff
   4062  407b					      repend
   4063  407c		       ff		      .byte.b	$ff
   4062  407c					      repend
   4063  407d		       ff		      .byte.b	$ff
   4062  407d					      repend
   4063  407e		       ff		      .byte.b	$ff
   4062  407e					      repend
   4063  407f		       ff		      .byte.b	$ff
   4062  407f					      repend
   4063  4080		       ff		      .byte.b	$ff
   4062  4080					      repend
   4063  4081		       ff		      .byte.b	$ff
   4062  4081					      repend
   4063  4082		       ff		      .byte.b	$ff
   4062  4082					      repend
   4063  4083		       ff		      .byte.b	$ff
   4062  4083					      repend
   4063  4084		       ff		      .byte.b	$ff
   4062  4084					      repend
   4063  4085		       ff		      .byte.b	$ff
   4062  4085					      repend
   4063  4086		       ff		      .byte.b	$ff
   4062  4086					      repend
   4063  4087		       ff		      .byte.b	$ff
   4062  4087					      repend
   4063  4088		       ff		      .byte.b	$ff
   4062  4088					      repend
   4063  4089		       ff		      .byte.b	$ff
   4062  4089					      repend
   4063  408a		       ff		      .byte.b	$ff
   4062  408a					      repend
   4063  408b		       ff		      .byte.b	$ff
   4062  408b					      repend
   4063  408c		       ff		      .byte.b	$ff
   4062  408c					      repend
   4063  408d		       ff		      .byte.b	$ff
   4062  408d					      repend
   4063  408e		       ff		      .byte.b	$ff
   4062  408e					      repend
   4063  408f		       ff		      .byte.b	$ff
   4062  408f					      repend
   4063  4090		       ff		      .byte.b	$ff
   4062  4090					      repend
   4063  4091		       ff		      .byte.b	$ff
   4062  4091					      repend
   4063  4092		       ff		      .byte.b	$ff
   4062  4092					      repend
   4063  4093		       ff		      .byte.b	$ff
   4062  4093					      repend
   4063  4094		       ff		      .byte.b	$ff
   4062  4094					      repend
   4063  4095		       ff		      .byte.b	$ff
   4062  4095					      repend
   4063  4096		       ff		      .byte.b	$ff
   4062  4096					      repend
   4063  4097		       ff		      .byte.b	$ff
   4062  4097					      repend
   4063  4098		       ff		      .byte.b	$ff
   4062  4098					      repend
   4063  4099		       ff		      .byte.b	$ff
   4062  4099					      repend
   4063  409a		       ff		      .byte.b	$ff
   4062  409a					      repend
   4063  409b		       ff		      .byte.b	$ff
   4062  409b					      repend
   4063  409c		       ff		      .byte.b	$ff
   4062  409c					      repend
   4063  409d		       ff		      .byte.b	$ff
   4062  409d					      repend
   4063  409e		       ff		      .byte.b	$ff
   4062  409e					      repend
   4063  409f		       ff		      .byte.b	$ff
   4062  409f					      repend
   4063  40a0		       ff		      .byte.b	$ff
   4062  40a0					      repend
   4063  40a1		       ff		      .byte.b	$ff
   4062  40a1					      repend
   4063  40a2		       ff		      .byte.b	$ff
   4062  40a2					      repend
   4063  40a3		       ff		      .byte.b	$ff
   4062  40a3					      repend
   4063  40a4		       ff		      .byte.b	$ff
   4062  40a4					      repend
   4063  40a5		       ff		      .byte.b	$ff
   4062  40a5					      repend
   4063  40a6		       ff		      .byte.b	$ff
   4062  40a6					      repend
   4063  40a7		       ff		      .byte.b	$ff
   4062  40a7					      repend
   4063  40a8		       ff		      .byte.b	$ff
   4062  40a8					      repend
   4063  40a9		       ff		      .byte.b	$ff
   4062  40a9					      repend
   4063  40aa		       ff		      .byte.b	$ff
   4062  40aa					      repend
   4063  40ab		       ff		      .byte.b	$ff
   4062  40ab					      repend
   4063  40ac		       ff		      .byte.b	$ff
   4062  40ac					      repend
   4063  40ad		       ff		      .byte.b	$ff
   4062  40ad					      repend
   4063  40ae		       ff		      .byte.b	$ff
   4062  40ae					      repend
   4063  40af		       ff		      .byte.b	$ff
   4062  40af					      repend
   4063  40b0		       ff		      .byte.b	$ff
   4062  40b0					      repend
   4063  40b1		       ff		      .byte.b	$ff
   4062  40b1					      repend
   4063  40b2		       ff		      .byte.b	$ff
   4062  40b2					      repend
   4063  40b3		       ff		      .byte.b	$ff
   4062  40b3					      repend
   4063  40b4		       ff		      .byte.b	$ff
   4062  40b4					      repend
   4063  40b5		       ff		      .byte.b	$ff
   4062  40b5					      repend
   4063  40b6		       ff		      .byte.b	$ff
   4062  40b6					      repend
   4063  40b7		       ff		      .byte.b	$ff
   4062  40b7					      repend
   4063  40b8		       ff		      .byte.b	$ff
   4062  40b8					      repend
   4063  40b9		       ff		      .byte.b	$ff
   4062  40b9					      repend
   4063  40ba		       ff		      .byte.b	$ff
   4062  40ba					      repend
   4063  40bb		       ff		      .byte.b	$ff
   4062  40bb					      repend
   4063  40bc		       ff		      .byte.b	$ff
   4062  40bc					      repend
   4063  40bd		       ff		      .byte.b	$ff
   4062  40bd					      repend
   4063  40be		       ff		      .byte.b	$ff
   4062  40be					      repend
   4063  40bf		       ff		      .byte.b	$ff
   4062  40bf					      repend
   4063  40c0		       ff		      .byte.b	$ff
   4062  40c0					      repend
   4063  40c1		       ff		      .byte.b	$ff
   4062  40c1					      repend
   4063  40c2		       ff		      .byte.b	$ff
   4062  40c2					      repend
   4063  40c3		       ff		      .byte.b	$ff
   4062  40c3					      repend
   4063  40c4		       ff		      .byte.b	$ff
   4062  40c4					      repend
   4063  40c5		       ff		      .byte.b	$ff
   4062  40c5					      repend
   4063  40c6		       ff		      .byte.b	$ff
   4062  40c6					      repend
   4063  40c7		       ff		      .byte.b	$ff
   4062  40c7					      repend
   4063  40c8		       ff		      .byte.b	$ff
   4062  40c8					      repend
   4063  40c9		       ff		      .byte.b	$ff
   4062  40c9					      repend
   4063  40ca		       ff		      .byte.b	$ff
   4062  40ca					      repend
   4063  40cb		       ff		      .byte.b	$ff
   4062  40cb					      repend
   4063  40cc		       ff		      .byte.b	$ff
   4062  40cc					      repend
   4063  40cd		       ff		      .byte.b	$ff
   4062  40cd					      repend
   4063  40ce		       ff		      .byte.b	$ff
   4062  40ce					      repend
   4063  40cf		       ff		      .byte.b	$ff
   4062  40cf					      repend
   4063  40d0		       ff		      .byte.b	$ff
   4062  40d0					      repend
   4063  40d1		       ff		      .byte.b	$ff
   4062  40d1					      repend
   4063  40d2		       ff		      .byte.b	$ff
   4062  40d2					      repend
   4063  40d3		       ff		      .byte.b	$ff
   4062  40d3					      repend
   4063  40d4		       ff		      .byte.b	$ff
   4062  40d4					      repend
   4063  40d5		       ff		      .byte.b	$ff
   4062  40d5					      repend
   4063  40d6		       ff		      .byte.b	$ff
   4062  40d6					      repend
   4063  40d7		       ff		      .byte.b	$ff
   4062  40d7					      repend
   4063  40d8		       ff		      .byte.b	$ff
   4062  40d8					      repend
   4063  40d9		       ff		      .byte.b	$ff
   4062  40d9					      repend
   4063  40da		       ff		      .byte.b	$ff
   4062  40da					      repend
   4063  40db		       ff		      .byte.b	$ff
   4062  40db					      repend
   4063  40dc		       ff		      .byte.b	$ff
   4062  40dc					      repend
   4063  40dd		       ff		      .byte.b	$ff
   4062  40dd					      repend
   4063  40de		       ff		      .byte.b	$ff
   4062  40de					      repend
   4063  40df		       ff		      .byte.b	$ff
   4062  40df					      repend
   4063  40e0		       ff		      .byte.b	$ff
   4062  40e0					      repend
   4063  40e1		       ff		      .byte.b	$ff
   4062  40e1					      repend
   4063  40e2		       ff		      .byte.b	$ff
   4062  40e2					      repend
   4063  40e3		       ff		      .byte.b	$ff
   4062  40e3					      repend
   4063  40e4		       ff		      .byte.b	$ff
   4062  40e4					      repend
   4063  40e5		       ff		      .byte.b	$ff
   4062  40e5					      repend
   4063  40e6		       ff		      .byte.b	$ff
   4062  40e6					      repend
   4063  40e7		       ff		      .byte.b	$ff
   4062  40e7					      repend
   4063  40e8		       ff		      .byte.b	$ff
   4062  40e8					      repend
   4063  40e9		       ff		      .byte.b	$ff
   4062  40e9					      repend
   4063  40ea		       ff		      .byte.b	$ff
   4062  40ea					      repend
   4063  40eb		       ff		      .byte.b	$ff
   4062  40eb					      repend
   4063  40ec		       ff		      .byte.b	$ff
   4062  40ec					      repend
   4063  40ed		       ff		      .byte.b	$ff
   4062  40ed					      repend
   4063  40ee		       ff		      .byte.b	$ff
   4062  40ee					      repend
   4063  40ef		       ff		      .byte.b	$ff
   4062  40ef					      repend
   4063  40f0		       ff		      .byte.b	$ff
   4062  40f0					      repend
   4063  40f1		       ff		      .byte.b	$ff
   4062  40f1					      repend
   4063  40f2		       ff		      .byte.b	$ff
   4062  40f2					      repend
   4063  40f3		       ff		      .byte.b	$ff
   4062  40f3					      repend
   4063  40f4		       ff		      .byte.b	$ff
   4062  40f4					      repend
   4063  40f5		       ff		      .byte.b	$ff
   4062  40f5					      repend
   4063  40f6		       ff		      .byte.b	$ff
   4062  40f6					      repend
   4063  40f7		       ff		      .byte.b	$ff
   4062  40f7					      repend
   4063  40f8		       ff		      .byte.b	$ff
   4062  40f8					      repend
   4063  40f9		       ff		      .byte.b	$ff
   4062  40f9					      repend
   4063  40fa		       ff		      .byte.b	$ff
   4062  40fa					      repend
   4063  40fb		       ff		      .byte.b	$ff
   4062  40fb					      repend
   4063  40fc		       ff		      .byte.b	$ff
   4062  40fc					      repend
   4063  40fd		       ff		      .byte.b	$ff
   4062  40fd					      repend
   4063  40fe		       ff		      .byte.b	$ff
   4062  40fe					      repend
   4063  40ff		       ff		      .byte.b	$ff
   4064  4100					      repend
   4065  4100							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4066  4100
   4067  4100							; This is a 2-line kernel!
   4068  4100					      ifnconst	vertical_reflect
   4069  4100				   kernel
   4070  4100					      endif
   4071  4100		       85 02		      sta	WSYNC
   4072  4102		       a9 ff		      lda	#255
   4073  4104		       8d 96 02 	      sta	TIM64T
   4074  4107
   4075  4107		       a9 01		      lda	#1
   4076  4109		       85 27		      sta	VDELBL
   4077  410b		       85 25		      sta	VDELP0
   4078  410d		       a6 92		      ldx	ballheight
   4079  410f		       e8		      inx
   4080  4110		       e8		      inx
   4081  4111		       86 9f		      stx	temp4
   4082  4113		       a5 86		      lda	player1y
   4083  4115		       85 9e		      sta	temp3
   4084  4117
   4085  4117				  -	      ifconst	shakescreen
   4086  4117				  -	      jsr	doshakescreen
   4087  4117					      else
   4088  4117		       a6 90		      ldx	missile0height
   4089  4119		       e8		      inx
   4090  411a					      endif
   4091  411a
   4092  411a		       e8		      inx
   4093  411b		       86 f6		      stx	stack1
   4094  411d
   4095  411d		       a5 89		      lda	bally
   4096  411f		       85 f7		      sta	stack2
   4097  4121
   4098  4121		       a5 85		      lda	player0y
   4099  4123		       a2 00		      ldx	#0
   4100  4125		       85 02		      sta	WSYNC
   4101  4127		       86 1b		      stx	GRP0
   4102  4129		       86 1c		      stx	GRP1
   4103  412b		       86 0e		      stx	PF1L
   4104  412d		       86 0f		      stx	PF2
   4105  412f		       86 2c		      stx	CXCLR
   4106  4131				  -	      ifconst	readpaddle
   4107  4131				  -	      stx	paddle
   4108  4131					      else
      0  4131					      sleep	3
      1  4131				   .CYCLES    SET	3
      2  4131
      3  4131				  -	      IF	.CYCLES < 2
      4  4131				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4131				  -	      ERR
      6  4131					      ENDIF
      7  4131
      8  4131					      IF	.CYCLES & 1
      9  4131					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4131		       04 00		      nop	0
     11  4133				  -	      ELSE
     12  4133				  -	      bit	VSYNC
     13  4133					      ENDIF
     14  4133				   .CYCLES    SET	.CYCLES - 3
     15  4133					      ENDIF
     16  4133
     17  4133				  -	      REPEAT	.CYCLES / 2
     18  4133				  -	      nop
     19  4133					      REPEND
   4110  4133					      endif
   4111  4133
   4112  4133		       95 9d		      sta	temp2,x
   4113  4135
   4114  4135							;store these so they can be retrieved later
   4115  4135				  -	      ifnconst	pfres
   4116  4135				  -	      ldx	#128-44+(4-pfwidth)*12
   4117  4135					      else
   4118  4135		       a2 28		      ldx	#132-pfres*pfwidth
   4119  4137					      endif
   4120  4137
   4121  4137		       c6 85		      dec	player0y
   4122  4139
   4123  4139		       a5 91		      lda	missile0y
   4124  413b		       85 a0		      sta	temp5
   4125  413d		       a5 88		      lda	missile1y
   4126  413f		       85 a1		      sta	temp6
   4127  4141
   4128  4141		       a5 ef		      lda	playfieldpos
   4129  4143		       85 9c		      sta	temp1
   4130  4145
   4131  4145				  -	      ifconst	pfrowheight
   4132  4145				  -	      lda	#pfrowheight+2
   4133  4145					      else
   4134  4145				  -	      ifnconst	pfres
   4135  4145				  -	      lda	#10
   4136  4145					      else
   4137  4145		       a9 06		      lda	#(96/pfres)+2	; try to come close to the real size
   4138  4147					      endif
   4139  4147					      endif
   4140  4147		       18		      clc
   4141  4148		       e5 ef		      sbc	playfieldpos
   4142  414a		       85 ef		      sta	playfieldpos
   4143  414c		       4c 78 f1 	      jmp	.startkernel
   4144  414f
   4145  414f				   .skipDrawP0
   4146  414f		       a9 00		      lda	#0
   4147  4151		       a8		      tay
   4148  4152		       4c aa f1 	      jmp	.continueP0
   4149  4155
   4150  4155				   .skipDrawP1
   4151  4155		       a9 00		      lda	#0
   4152  4157		       a8		      tay
   4153  4158		       4c 82 f1 	      jmp	.continueP1
   4154  415b
   4155  415b				   .kerloop		; enter at cycle 59??
   4156  415b
   4157  415b				   continuekernel
      0  415b					      sleep	2
      1  415b				   .CYCLES    SET	2
      2  415b
      3  415b				  -	      IF	.CYCLES < 2
      4  415b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  415b				  -	      ERR
      6  415b					      ENDIF
      7  415b
      8  415b				  -	      IF	.CYCLES & 1
      9  415b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  415b				  -	      nop	0
     11  415b				  -	      ELSE
     12  415b				  -	      bit	VSYNC
     13  415b				  -	      ENDIF
     14  415b				  -.CYCLES    SET	.CYCLES - 3
     15  415b					      ENDIF
     16  415b
     17  415b					      REPEAT	.CYCLES / 2
     18  415b		       ea		      nop
     19  415c					      REPEND
   4159  415c				   continuekernel2
   4160  415c		       a5 92		      lda	ballheight
   4161  415e
   4162  415e					      ifconst	pfres
   4163  415e		       bc 7c 10 	      ldy	playfield+pfres*pfwidth-132,x
   4164  4161		       84 0e		      sty	PF1L	;3
   4165  4163		       bc 7d 10 	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   4166  4166		       84 0f		      sty	PF2L	;3
   4167  4168		       bc 7f 10 	      ldy	playfield+pfres*pfwidth-129,x
   4168  416b		       84 0e		      sty	PF1R	; 3 too early?
   4169  416d		       bc 7e 10 	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   4170  4170		       84 0f		      sty	PF2R	;3
   4171  4172				  -	      else
   4172  4172				  -	      ldy	playfield-48+pfwidth*12+44-128,x
   4173  4172				  -	      sty	PF1L	;3
   4174  4172				  -	      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   4175  4172				  -	      sty	PF2L	;3
   4176  4172				  -	      ldy	playfield-48+pfwidth*12+47-128,x	;4
   4177  4172				  -	      sty	PF1R	; 3 too early?
   4178  4172				  -	      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   4179  4172				  -	      sty	PF2R	;3
   4180  4172					      endif
   4181  4172
   4182  4172							; should be playfield+$38 for width=2
   4183  4172
   4184  4172		       c7 89		      dcp	bally
   4185  4174		       2a		      rol
   4186  4175		       2a		      rol
   4187  4176							; rol
   4188  4176							; rol
   4189  4176				   goback
   4190  4176		       85 1f		      sta	ENABL
   4191  4178				   .startkernel
   4192  4178		       a5 8f		      lda	player1height	;3
   4193  417a		       c7 86		      dcp	player1y	;5
   4194  417c		       90 d7		      bcc	.skipDrawP1	;2
   4195  417e		       a4 86		      ldy	player1y	;3
   4196  4180		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   4197  4182							; so it doesn't cross a page boundary!
   4198  4182
   4199  4182				   .continueP1
   4200  4182		       85 1c		      sta	GRP1	;3
   4201  4184
   4202  4184					      ifnconst	player1colors
   4203  4184		       a5 87		      lda	missile1height	;3
   4204  4186		       c7 88		      dcp	missile1y	;5
   4205  4188		       2a		      rol		;2
   4206  4189		       2a		      rol		;2
   4207  418a		       85 1e		      sta	ENAM1	;3
   4208  418c				  -	      else
   4209  418c				  -	      lda	(player1color),y
   4210  418c				  -	      sta	COLUP1
   4211  418c				  -	      ifnconst	playercolors
   4212  418c				  -	      sleep	7
   4213  418c				  -	      else
   4214  418c				  -	      lda.w	player0colorstore
   4215  418c				  -	      sta	COLUP0
   4216  418c				  -	      endif
   4217  418c					      endif
   4218  418c
   4219  418c					      ifconst	pfres
   4220  418c		       bd 7c 10 	      lda	playfield+pfres*pfwidth-132,x
   4221  418f		       85 0e		      sta	PF1L	;3
   4222  4191		       bd 7d 10 	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   4223  4194		       85 0f		      sta	PF2L	;3
   4224  4196		       bd 7f 10 	      lda	playfield+pfres*pfwidth-129,x
   4225  4199		       85 0e		      sta	PF1R	; 3 too early?
   4226  419b		       bd 7e 10 	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   4227  419e		       85 0f		      sta	PF2R	;3
   4228  41a0				  -	      else
   4229  41a0				  -	      lda	playfield-48+pfwidth*12+44-128,x	;4
   4230  41a0				  -	      sta	PF1L	;3
   4231  41a0				  -	      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   4232  41a0				  -	      sta	PF2L	;3
   4233  41a0				  -	      lda	playfield-48+pfwidth*12+47-128,x	;4
   4234  41a0				  -	      sta	PF1R	; 3 too early?
   4235  41a0				  -	      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   4236  41a0				  -	      sta	PF2R	;3
   4237  41a0					      endif
   4238  41a0							; sleep 3
   4239  41a0
   4240  41a0		       a5 8e		      lda	player0height
   4241  41a2		       c7 85		      dcp	player0y
   4242  41a4		       90 a9		      bcc	.skipDrawP0
   4243  41a6		       a4 85		      ldy	player0y
   4244  41a8		       b1 8a		      lda	(player0pointer),y
   4245  41aa				   .continueP0
   4246  41aa		       85 1b		      sta	GRP0
   4247  41ac
   4248  41ac				  -	      ifnconst	no_blank_lines
   4249  41ac				  -	      ifnconst	playercolors
   4250  41ac				  -	      lda	missile0height	;3
   4251  41ac				  -	      dcp	missile0y	;5
   4252  41ac				  -	      sbc	stack1
   4253  41ac				  -	      sta	ENAM0	;3
   4254  41ac				  -	      else
   4255  41ac				  -	      lda	(player0color),y
   4256  41ac				  -	      sta	player0colorstore
   4257  41ac				  -	      sleep	6
   4258  41ac				  -	      endif
   4259  41ac				  -	      dec	temp1
   4260  41ac				  -	      bne	continuekernel
   4261  41ac					      else
   4262  41ac		       c6 9c		      dec	temp1
   4263  41ae		       f0 09		      beq	altkernel2
   4264  41b0				  -	      ifconst	readpaddle
   4265  41b0				  -	      ldy	currentpaddle
   4266  41b0				  -	      lda	INPT0,y
   4267  41b0				  -	      bpl	noreadpaddle
   4268  41b0				  -	      inc	paddle
   4269  41b0				  -	      jmp	continuekernel2
   4270  41b0				  -noreadpaddle
   4271  41b0				  -	      sleep	2
   4272  41b0				  -	      jmp	continuekernel
   4273  41b0					      else
   4274  41b0					      ifnconst	playercolors
   4275  41b0				  -	      ifconst	PFcolors
   4276  41b0				  -	      txa
   4277  41b0				  -	      tay
   4278  41b0				  -	      lda	(pfcolortable),y
   4279  41b0				  -	      ifnconst	backgroundchange
   4280  41b0				  -	      sta	COLUPF
   4281  41b0				  -	      else
   4282  41b0				  -	      sta	COLUBK
   4283  41b0				  -	      endif
   4284  41b0				  -	      jmp	continuekernel
   4285  41b0					      else
   4286  41b0				  -	      ifconst	kernelmacrodef
   4287  41b0				  -	      kernelmacro
   4288  41b0					      else
      0  41b0					      sleep	12
      1  41b0				   .CYCLES    SET	12
      2  41b0
      3  41b0				  -	      IF	.CYCLES < 2
      4  41b0				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41b0				  -	      ERR
      6  41b0					      ENDIF
      7  41b0
      8  41b0				  -	      IF	.CYCLES & 1
      9  41b0				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41b0				  -	      nop	0
     11  41b0				  -	      ELSE
     12  41b0				  -	      bit	VSYNC
     13  41b0				  -	      ENDIF
     14  41b0				  -.CYCLES    SET	.CYCLES - 3
     15  41b0					      ENDIF
     16  41b0
     17  41b0					      REPEAT	.CYCLES / 2
     18  41b0		       ea		      nop
     17  41b0					      REPEND
     18  41b1		       ea		      nop
     17  41b1					      REPEND
     18  41b2		       ea		      nop
     17  41b2					      REPEND
     18  41b3		       ea		      nop
     17  41b3					      REPEND
     18  41b4		       ea		      nop
     17  41b4					      REPEND
     18  41b5		       ea		      nop
     19  41b6					      REPEND
   4290  41b6					      endif
   4291  41b6					      endif
   4292  41b6				  -	      else
   4293  41b6				  -	      lda	(player0color),y
   4294  41b6				  -	      sta	player0colorstore
   4295  41b6				  -	      sleep	4
   4296  41b6					      endif
   4297  41b6		       4c 5b f1 	      jmp	continuekernel
   4298  41b9					      endif
   4299  41b9				   altkernel2
   4300  41b9		       8a		      txa
   4301  41ba					      ifnconst	vertical_reflect
   4302  41ba		       cb fc		      sbx	#256-pfwidth
   4303  41bc				  -	      else
   4304  41bc				  -	      sbx	#256-pfwidth/2
   4305  41bc					      endif
   4306  41bc		       30 1b		      bmi	lastkernelline
   4307  41be				  -	      ifconst	pfrowheight
   4308  41be				  -	      lda	#pfrowheight
   4309  41be					      else
   4310  41be				  -	      ifnconst	pfres
   4311  41be				  -	      lda	#8
   4312  41be					      else
   4313  41be		       a9 04		      lda	#(96/pfres)	; try to come close to the real size
   4314  41c0					      endif
   4315  41c0					      endif
   4316  41c0		       85 9c		      sta	temp1
   4317  41c2		       4c 5b f1 	      jmp	continuekernel
   4318  41c5					      endif
   4319  41c5
   4320  41c5				   altkernel
   4321  41c5
   4322  41c5				  -	      ifconst	PFmaskvalue
   4323  41c5				  -	      lda	#PFmaskvalue
   4324  41c5					      else
   4325  41c5		       a9 00		      lda	#0
   4326  41c7					      endif
   4327  41c7		       85 0e		      sta	PF1L
   4328  41c9		       85 0f		      sta	PF2
   4329  41cb
   4330  41cb
   4331  41cb							;sleep 3
   4332  41cb
   4333  41cb							;28 cycles to fix things
   4334  41cb							;minus 11=17
   4335  41cb
   4336  41cb							; lax temp4
   4337  41cb							; clc
   4338  41cb		       8a		      txa
   4339  41cc					      ifnconst	vertical_reflect
   4340  41cc		       cb fc		      sbx	#256-pfwidth
   4341  41ce				  -	      else
   4342  41ce				  -	      sbx	#256-pfwidth/2
   4343  41ce					      endif
   4344  41ce
   4345  41ce		       30 09		      bmi	lastkernelline
   4346  41d0
   4347  41d0				  -	      ifconst	PFcolorandheight
   4348  41d0				  -	      ifconst	pfres
   4349  41d0				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   4350  41d0				  -	      else
   4351  41d0				  -	      ldy	playfieldcolorandheight-87,x
   4352  41d0				  -	      endif
   4353  41d0				  -	      ifnconst	backgroundchange
   4354  41d0				  -	      sty	COLUPF
   4355  41d0				  -	      else
   4356  41d0				  -	      sty	COLUBK
   4357  41d0				  -	      endif
   4358  41d0				  -	      ifconst	pfres
   4359  41d0				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   4360  41d0				  -	      else
   4361  41d0				  -	      lda	playfieldcolorandheight-88,x
   4362  41d0				  -	      endif
   4363  41d0				  -	      sta.w	temp1
   4364  41d0					      endif
   4365  41d0				  -	      ifconst	PFheights
   4366  41d0				  -	      lsr
   4367  41d0				  -	      lsr
   4368  41d0				  -	      tay
   4369  41d0				  -	      lda	(pfheighttable),y
   4370  41d0				  -	      sta.w	temp1
   4371  41d0					      endif
   4372  41d0				  -	      ifconst	PFcolors
   4373  41d0				  -	      tay
   4374  41d0				  -	      lda	(pfcolortable),y
   4375  41d0				  -	      ifnconst	backgroundchange
   4376  41d0				  -	      sta	COLUPF
   4377  41d0				  -	      else
   4378  41d0				  -	      sta	COLUBK
   4379  41d0				  -	      endif
   4380  41d0				  -	      ifconst	pfrowheight
   4381  41d0				  -	      lda	#pfrowheight
   4382  41d0				  -	      else
   4383  41d0				  -	      ifnconst	pfres
   4384  41d0				  -	      lda	#8
   4385  41d0				  -	      else
   4386  41d0				  -	      lda	#(96/pfres)	; try to come close to the real size
   4387  41d0				  -	      endif
   4388  41d0				  -	      endif
   4389  41d0				  -	      sta	temp1
   4390  41d0					      endif
   4391  41d0					      ifnconst	PFcolorandheight
   4392  41d0					      ifnconst	PFcolors
   4393  41d0					      ifnconst	PFheights
   4394  41d0				  -	      ifnconst	no_blank_lines
   4395  41d0				  -			; read paddle 0
   4396  41d0				  -			; lo-res paddle read
   4397  41d0				  -			; bit INPT0
   4398  41d0				  -			; bmi paddleskipread
   4399  41d0				  -			; inc paddle0
   4400  41d0				  -			;donepaddleskip
   4401  41d0				  -	      sleep	10
   4402  41d0				  -	      ifconst	pfrowheight
   4403  41d0				  -	      lda	#pfrowheight
   4404  41d0				  -	      else
   4405  41d0				  -	      ifnconst	pfres
   4406  41d0				  -	      lda	#8
   4407  41d0				  -	      else
   4408  41d0				  -	      lda	#(96/pfres)	; try to come close to the real size
   4409  41d0				  -	      endif
   4410  41d0				  -	      endif
   4411  41d0				  -	      sta	temp1
   4412  41d0					      endif
   4413  41d0					      endif
   4414  41d0					      endif
   4415  41d0					      endif
   4416  41d0
   4417  41d0
   4418  41d0		       a5 92		      lda	ballheight
   4419  41d2		       c7 89		      dcp	bally
   4420  41d4		       e5 9f		      sbc	temp4
   4421  41d6
   4422  41d6
   4423  41d6		       4c 76 f1 	      jmp	goback
   4424  41d9
   4425  41d9
   4426  41d9				  -	      ifnconst	no_blank_lines
   4427  41d9				  -lastkernelline
   4428  41d9				  -	      ifnconst	PFcolors
   4429  41d9				  -	      sleep	10
   4430  41d9				  -	      else
   4431  41d9				  -	      ldy	#124
   4432  41d9				  -	      lda	(pfcolortable),y
   4433  41d9				  -	      sta	COLUPF
   4434  41d9				  -	      endif
   4435  41d9				  -
   4436  41d9				  -	      ifconst	PFheights
   4437  41d9				  -	      ldx	#1
   4438  41d9				  -			;sleep 4
   4439  41d9				  -	      sleep	3	; this was over 1 cycle
   4440  41d9				  -	      else
   4441  41d9				  -	      ldx	playfieldpos
   4442  41d9				  -			;sleep 3
   4443  41d9				  -	      sleep	2	; this was over 1 cycle
   4444  41d9				  -	      endif
   4445  41d9				  -
   4446  41d9				  -	      jmp	enterlastkernel
   4447  41d9				  -
   4448  41d9					      else
   4449  41d9				   lastkernelline
   4450  41d9
   4451  41d9				  -	      ifconst	PFheights
   4452  41d9				  -	      ldx	#1
   4453  41d9				  -			;sleep 5
   4454  41d9				  -	      sleep	4	; this was over 1 cycle
   4455  41d9					      else
   4456  41d9		       a6 ef		      ldx	playfieldpos
   4457  41db							;sleep 4
      0  41db					      sleep	3	; this was over 1 cycle
      1  41db				   .CYCLES    SET	3
      2  41db
      3  41db				  -	      IF	.CYCLES < 2
      4  41db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41db				  -	      ERR
      6  41db					      ENDIF
      7  41db
      8  41db					      IF	.CYCLES & 1
      9  41db					      IFNCONST	NO_ILLEGAL_OPCODES
     10  41db		       04 00		      nop	0
     11  41dd				  -	      ELSE
     12  41dd				  -	      bit	VSYNC
     13  41dd					      ENDIF
     14  41dd				   .CYCLES    SET	.CYCLES - 3
     15  41dd					      ENDIF
     16  41dd
     17  41dd				  -	      REPEAT	.CYCLES / 2
     18  41dd				  -	      nop
     19  41dd					      REPEND
   4459  41dd					      endif
   4460  41dd
   4461  41dd		       e0 00		      cpx	#0
   4462  41df		       d0 26		      bne	.enterfromNBL
   4463  41e1		       4c 68 f2 	      jmp	no_blank_lines_bailout
   4464  41e4					      endif
   4465  41e4
   4466  41e4					      if	((<*)>$d5)
   4467  4200		       00 00 00 00*	      align	256
   4468  4200					      endif
   4469  4200							; this is a kludge to prevent page wrapping - fix!!!
   4470  4200
   4471  4200				   .skipDrawlastP1
   4472  4200		       a9 00		      lda	#0
   4473  4202		       a8		      tay		; added so we don't cross a page
   4474  4203		       4c 2d f2 	      jmp	.continuelastP1
   4475  4206
   4476  4206				   .endkerloop		; enter at cycle 59??
   4477  4206
   4478  4206		       ea		      nop
   4479  4207
   4480  4207				   .enterfromNBL
   4481  4207					      ifconst	pfres
   4482  4207		       ac fc 10 	      ldy.w	playfield+pfres*pfwidth-4
   4483  420a		       84 0e		      sty	PF1L	;3
   4484  420c		       ac fd 10 	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   4485  420f		       84 0f		      sty	PF2L	;3
   4486  4211		       ac ff 10 	      ldy.w	playfield+pfres*pfwidth-1
   4487  4214		       84 0e		      sty	PF1R	; possibly too early?
   4488  4216		       ac fe 10 	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   4489  4219		       84 0f		      sty	PF2R	;3
   4490  421b				  -	      else
   4491  421b				  -	      ldy.w	playfield-48+pfwidth*12+44
   4492  421b				  -	      sty	PF1L	;3
   4493  421b				  -	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   4494  421b				  -	      sty	PF2L	;3
   4495  421b				  -	      ldy.w	playfield-48+pfwidth*12+47
   4496  421b				  -	      sty	PF1R	; possibly too early?
   4497  421b				  -	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   4498  421b				  -	      sty	PF2R	;3
   4499  421b					      endif
   4500  421b
   4501  421b				   enterlastkernel
   4502  421b		       a5 92		      lda	ballheight
   4503  421d
   4504  421d							; tya
   4505  421d		       c7 89		      dcp	bally
   4506  421f							; sleep 4
   4507  421f
   4508  421f							; sbc stack3
   4509  421f		       2a		      rol
   4510  4220		       2a		      rol
   4511  4221		       85 1f		      sta	ENABL
   4512  4223
   4513  4223		       a5 8f		      lda	player1height	;3
   4514  4225		       c7 86		      dcp	player1y	;5
   4515  4227		       90 d7		      bcc	.skipDrawlastP1
   4516  4229		       a4 86		      ldy	player1y	;3
   4517  422b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   4518  422d							; so it doesn't cross a page boundary!
   4519  422d
   4520  422d				   .continuelastP1
   4521  422d		       85 1c		      sta	GRP1	;3
   4522  422f
   4523  422f					      ifnconst	player1colors
   4524  422f		       a5 87		      lda	missile1height	;3
   4525  4231		       c7 88		      dcp	missile1y	;5
   4526  4233				  -	      else
   4527  4233				  -	      lda	(player1color),y
   4528  4233				  -	      sta	COLUP1
   4529  4233					      endif
   4530  4233
   4531  4233		       ca		      dex
   4532  4234							;dec temp4 ; might try putting this above PF writes
   4533  4234		       f0 34		      beq	endkernel
   4534  4236
   4535  4236
   4536  4236					      ifconst	pfres
   4537  4236		       ac fc 10 	      ldy.w	playfield+pfres*pfwidth-4
   4538  4239		       84 0e		      sty	PF1L	;3
   4539  423b		       ac fd 10 	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   4540  423e		       84 0f		      sty	PF2L	;3
   4541  4240		       ac ff 10 	      ldy.w	playfield+pfres*pfwidth-1
   4542  4243		       84 0e		      sty	PF1R	; possibly too early?
   4543  4245		       ac fe 10 	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   4544  4248		       84 0f		      sty	PF2R	;3
   4545  424a				  -	      else
   4546  424a				  -	      ldy.w	playfield-48+pfwidth*12+44
   4547  424a				  -	      sty	PF1L	;3
   4548  424a				  -	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   4549  424a				  -	      sty	PF2L	;3
   4550  424a				  -	      ldy.w	playfield-48+pfwidth*12+47
   4551  424a				  -	      sty	PF1R	; possibly too early?
   4552  424a				  -	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   4553  424a				  -	      sty	PF2R	;3
   4554  424a					      endif
   4555  424a
   4556  424a					      ifnconst	player1colors
   4557  424a		       2a		      rol		;2
   4558  424b		       2a		      rol		;2
   4559  424c		       85 1e		      sta	ENAM1	;3
   4560  424e				  -	      else
   4561  424e				  -	      ifnconst	playercolors
   4562  424e				  -	      sleep	7
   4563  424e				  -	      else
   4564  424e				  -	      lda.w	player0colorstore
   4565  424e				  -	      sta	COLUP0
   4566  424e				  -	      endif
   4567  424e					      endif
   4568  424e
   4569  424e		       ad 8e 00 	      lda.w	player0height
   4570  4251		       c7 85		      dcp	player0y
   4571  4253		       90 0d		      bcc	.skipDrawlastP0
   4572  4255		       a4 85		      ldy	player0y
   4573  4257		       b1 8a		      lda	(player0pointer),y
   4574  4259				   .continuelastP0
   4575  4259		       85 1b		      sta	GRP0
   4576  425b
   4577  425b
   4578  425b
   4579  425b				  -	      ifnconst	no_blank_lines
   4580  425b				  -	      lda	missile0height	;3
   4581  425b				  -	      dcp	missile0y	;5
   4582  425b				  -	      sbc	stack1
   4583  425b				  -	      sta	ENAM0	;3
   4584  425b				  -	      jmp	.endkerloop
   4585  425b					      else
   4586  425b				  -	      ifconst	readpaddle
   4587  425b				  -	      ldy	currentpaddle
   4588  425b				  -	      lda	INPT0,y
   4589  425b				  -	      bpl	noreadpaddle2
   4590  425b				  -	      inc	paddle
   4591  425b				  -	      jmp	.endkerloop
   4592  425b				  -noreadpaddle2
   4593  425b				  -	      sleep	4
   4594  425b				  -	      jmp	.endkerloop
   4595  425b					      else		; no_blank_lines and no paddle reading
   4596  425b		       68		      pla
   4597  425c		       48		      pha		; 14 cycles in 4 bytes
   4598  425d		       68		      pla
   4599  425e		       48		      pha
   4600  425f							; sleep 14
   4601  425f		       4c 06 f2 	      jmp	.endkerloop
   4602  4262					      endif
   4603  4262					      endif
   4604  4262
   4605  4262
   4606  4262							; ifconst donepaddleskip
   4607  4262							;paddleskipread
   4608  4262							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   4609  4262							; plus we get a lo-res paddle read
   4610  4262							; bmi donepaddleskip
   4611  4262							; endif
   4612  4262
   4613  4262				   .skipDrawlastP0
   4614  4262		       a9 00		      lda	#0
   4615  4264		       a8		      tay
   4616  4265		       4c 59 f2 	      jmp	.continuelastP0
   4617  4268
   4618  4268					      ifconst	no_blank_lines
   4619  4268				   no_blank_lines_bailout
   4620  4268		       a2 00		      ldx	#0
   4621  426a					      endif
   4622  426a
   4623  426a				   endkernel
   4624  426a							; 6 digit score routine
   4625  426a		       86 0e		      stx	PF1
   4626  426c		       86 0f		      stx	PF2
   4627  426e		       86 0d		      stx	PF0
   4628  4270		       18		      clc
   4629  4271
   4630  4271				  -	      ifconst	pfrowheight
   4631  4271				  -	      lda	#pfrowheight+2
   4632  4271					      else
   4633  4271				  -	      ifnconst	pfres
   4634  4271				  -	      lda	#10
   4635  4271					      else
   4636  4271		       a9 06		      lda	#(96/pfres)+2	; try to come close to the real size
   4637  4273					      endif
   4638  4273					      endif
   4639  4273
   4640  4273		       e5 ef		      sbc	playfieldpos
   4641  4275		       85 ef		      sta	playfieldpos
   4642  4277		       8a		      txa
   4643  4278
   4644  4278				  -	      ifconst	shakescreen
   4645  4278				  -	      bit	shakescreen
   4646  4278				  -	      bmi	noshakescreen2
   4647  4278				  -	      ldx	#$3D
   4648  4278				  -noshakescreen2
   4649  4278					      endif
   4650  4278
   4651  4278		       95 02		      sta	WSYNC,x
   4652  427a
   4653  427a							; STA WSYNC ;first one, need one more
   4654  427a		       85 0b		      sta	REFP0
   4655  427c		       85 0c		      sta	REFP1
   4656  427e		       85 1b		      STA	GRP0
   4657  4280		       85 1c		      STA	GRP1
   4658  4282							; STA PF1
   4659  4282							; STA PF2
   4660  4282		       85 2b		      sta	HMCLR
   4661  4284		       85 1d		      sta	ENAM0
   4662  4286		       85 1e		      sta	ENAM1
   4663  4288		       85 1f		      sta	ENABL
   4664  428a
   4665  428a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   4666  428c		       85 85		      sta	player0y
   4667  428e		       a5 9e		      lda	temp3
   4668  4290		       85 86		      sta	player1y
   4669  4292					      ifnconst	player1colors
   4670  4292		       a5 a1		      lda	temp6
   4671  4294		       85 88		      sta	missile1y
   4672  4296					      endif
   4673  4296					      ifnconst	playercolors
   4674  4296					      ifnconst	readpaddle
   4675  4296		       a5 a0		      lda	temp5
   4676  4298		       85 91		      sta	missile0y
   4677  429a					      endif
   4678  429a					      endif
   4679  429a		       a5 f7		      lda	stack2
   4680  429c		       85 89		      sta	bally
   4681  429e
   4682  429e							; strangely, this isn't required any more. might have
   4683  429e							; resulted from the no_blank_lines score bounce fix
   4684  429e							;ifconst no_blank_lines
   4685  429e							;sta WSYNC
   4686  429e							;endif
   4687  429e
   4688  429e		       ad 84 02 	      lda	INTIM
   4689  42a1		       18		      clc
   4690  42a2					      ifnconst	vblank_time
   4691  42a2		       69 8e		      adc	#43+12+87
   4692  42a4				  -	      else
   4693  42a4				  -	      adc	#vblank_time+12+87
   4694  42a4				  -
   4695  42a4					      endif
   4696  42a4							; sta WSYNC
   4697  42a4		       8d 96 02 	      sta	TIM64T
   4698  42a7
   4699  42a7				  -	      ifconst	minikernel
   4700  42a7				  -	      jsr	minikernel
   4701  42a7					      endif
   4702  42a7
   4703  42a7							; now reassign temp vars for score pointers
   4704  42a7
   4705  42a7							; score pointers contain:
   4706  42a7							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   4707  42a7							; swap lo2->temp1
   4708  42a7							; swap lo4->temp3
   4709  42a7							; swap lo6->temp5
   4710  42a7					      ifnconst	noscore
   4711  42a7		       a5 97		      lda	scorepointers+1
   4712  42a9							; ldy temp1
   4713  42a9		       85 9c		      sta	temp1
   4714  42ab							; sty scorepointers+1
   4715  42ab
   4716  42ab		       a5 99		      lda	scorepointers+3
   4717  42ad							; ldy temp3
   4718  42ad		       85 9e		      sta	temp3
   4719  42af							; sty scorepointers+3
   4720  42af
   4721  42af
   4722  42af		       85 2b		      sta	HMCLR
   4723  42b1		       ba		      tsx
   4724  42b2		       86 f6		      stx	stack1
   4725  42b4		       a2 e0		      ldx	#$E0
   4726  42b6		       86 20		      stx	HMP0
   4727  42b8
   4728  42b8		       a5 a3		      LDA	scorecolor
   4729  42ba		       85 06		      STA	COLUP0
   4730  42bc		       85 07		      STA	COLUP1
   4731  42be				  -	      ifconst	scorefade
   4732  42be				  -	      STA	stack2
   4733  42be					      endif
   4734  42be				  -	      ifconst	pfscore
   4735  42be				  -	      lda	pfscorecolor
   4736  42be				  -	      sta	COLUPF
   4737  42be					      endif
   4738  42be		       85 02		      sta	WSYNC
   4739  42c0		       a2 00		      ldx	#0
   4740  42c2		       86 1b		      STx	GRP0
   4741  42c4		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   4742  42c6
   4743  42c6		       a5 9b		      lda	scorepointers+5
   4744  42c8							; ldy temp5
   4745  42c8		       95 a0		      sta	temp5,x
   4746  42ca							; sty scorepointers+5
   4747  42ca		       a9 ff		      lda	#>scoretable
   4748  42cc		       85 97		      sta	scorepointers+1
   4749  42ce		       85 99		      sta	scorepointers+3
   4750  42d0		       85 9b		      sta	scorepointers+5
   4751  42d2		       85 9d		      sta	temp2
   4752  42d4		       85 9f		      sta	temp4
   4753  42d6		       85 a1		      sta	temp6
   4754  42d8		       a0 07		      LDY	#7
   4755  42da		       84 25		      STY	VDELP0
   4756  42dc		       85 10		      STA	RESP0
   4757  42de		       85 11		      STA	RESP1
   4758  42e0
   4759  42e0
   4760  42e0		       a9 03		      LDA	#$03
   4761  42e2		       85 04		      STA	NUSIZ0
   4762  42e4		       85 05		      STA	NUSIZ1
   4763  42e6		       85 26		      STA	VDELP1
   4764  42e8		       a9 f0		      LDA	#$F0
   4765  42ea		       85 21		      STA	HMP1
   4766  42ec		       b1 96		      lda	(scorepointers),y
   4767  42ee		       85 1b		      sta	GRP0
   4768  42f0		       85 2a		      STA	HMOVE	; cycle 73 ?
   4769  42f2		       4c 08 f3 	      jmp	beginscore
   4770  42f5
   4771  42f5
   4772  42f5					      if	((<*)>$d4)
   4773  4300		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   4774  4300					      endif
   4775  4300
   4776  4300				   loop2
   4777  4300		       b1 96		      lda	(scorepointers),y	;+5 68 204
   4778  4302		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   4779  4304				  -	      ifconst	pfscore
   4780  4304				  -	      lda.w	pfscore1
   4781  4304				  -	      sta	PF1
   4782  4304					      else
   4783  4304				  -	      ifconst	scorefade
   4784  4304				  -	      sleep	2
   4785  4304				  -	      dec	stack2	; decrement the temporary scorecolor
   4786  4304					      else
      0  4304					      sleep	7
      1  4304				   .CYCLES    SET	7
      2  4304
      3  4304				  -	      IF	.CYCLES < 2
      4  4304				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4304				  -	      ERR
      6  4304					      ENDIF
      7  4304
      8  4304					      IF	.CYCLES & 1
      9  4304					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4304		       04 00		      nop	0
     11  4306				  -	      ELSE
     12  4306				  -	      bit	VSYNC
     13  4306					      ENDIF
     14  4306				   .CYCLES    SET	.CYCLES - 3
     15  4306					      ENDIF
     16  4306
     17  4306					      REPEAT	.CYCLES / 2
     18  4306		       ea		      nop
     17  4306					      REPEND
     18  4307		       ea		      nop
     19  4308					      REPEND
   4788  4308					      endif
   4789  4308					      endif
   4790  4308							; cycle 0
   4791  4308				   beginscore
   4792  4308		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   4793  430a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   4794  430c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   4795  430e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   4796  4310		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   4797  4312		       9a		      txs
   4798  4313		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   4799  4315				  -	      ifconst	scorefade
   4800  4315				  -	      lda	stack2
   4801  4315					      else
      0  4315					      sleep	3
      1  4315				   .CYCLES    SET	3
      2  4315
      3  4315				  -	      IF	.CYCLES < 2
      4  4315				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4315				  -	      ERR
      6  4315					      ENDIF
      7  4315
      8  4315					      IF	.CYCLES & 1
      9  4315					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4315		       04 00		      nop	0
     11  4317				  -	      ELSE
     12  4317				  -	      bit	VSYNC
     13  4317					      ENDIF
     14  4317				   .CYCLES    SET	.CYCLES - 3
     15  4317					      ENDIF
     16  4317
     17  4317				  -	      REPEAT	.CYCLES / 2
     18  4317				  -	      nop
     19  4317					      REPEND
   4803  4317					      endif
   4804  4317
   4805  4317				  -	      ifconst	pfscore
   4806  4317				  -	      lda	pfscore2
   4807  4317				  -	      sta	PF1
   4808  4317					      else
   4809  4317				  -	      ifconst	scorefade
   4810  4317				  -	      sta	COLUP0
   4811  4317				  -	      sta	COLUP1
   4812  4317					      else
      0  4317					      sleep	6
      1  4317				   .CYCLES    SET	6
      2  4317
      3  4317				  -	      IF	.CYCLES < 2
      4  4317				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4317				  -	      ERR
      6  4317					      ENDIF
      7  4317
      8  4317				  -	      IF	.CYCLES & 1
      9  4317				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4317				  -	      nop	0
     11  4317				  -	      ELSE
     12  4317				  -	      bit	VSYNC
     13  4317				  -	      ENDIF
     14  4317				  -.CYCLES    SET	.CYCLES - 3
     15  4317					      ENDIF
     16  4317
     17  4317					      REPEAT	.CYCLES / 2
     18  4317		       ea		      nop
     17  4317					      REPEND
     18  4318		       ea		      nop
     17  4318					      REPEND
     18  4319		       ea		      nop
     19  431a					      REPEND
   4814  431a					      endif
   4815  431a					      endif
   4816  431a
   4817  431a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   4818  431c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   4819  431e		       ba		      tsx
   4820  431f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   4821  4321		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   4822  4323		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   4823  4325		       88		      dey
   4824  4326		       10 d8		      bpl	loop2	;+2 60 180
   4825  4328
   4826  4328		       a6 f6		      ldx	stack1
   4827  432a		       9a		      txs
   4828  432b							; lda scorepointers+1
   4829  432b		       a4 9c		      ldy	temp1
   4830  432d							; sta temp1
   4831  432d		       84 97		      sty	scorepointers+1
   4832  432f
   4833  432f		       a9 00		      LDA	#0
   4834  4331		       85 0e		      sta	PF1
   4835  4333		       85 1b		      STA	GRP0
   4836  4335		       85 1c		      STA	GRP1
   4837  4337		       85 25		      STA	VDELP0
   4838  4339		       85 26		      STA	VDELP1	;do we need these
   4839  433b		       85 04		      STA	NUSIZ0
   4840  433d		       85 05		      STA	NUSIZ1
   4841  433f
   4842  433f							; lda scorepointers+3
   4843  433f		       a4 9e		      ldy	temp3
   4844  4341							; sta temp3
   4845  4341		       84 99		      sty	scorepointers+3
   4846  4343
   4847  4343							; lda scorepointers+5
   4848  4343		       a4 a0		      ldy	temp5
   4849  4345							; sta temp5
   4850  4345		       84 9b		      sty	scorepointers+5
   4851  4347					      endif		;noscore
   4852  4347				  -	      ifconst	readpaddle
   4853  4347				  -	      lda	#%11000010
   4854  4347					      else
   4855  4347				  -	      ifconst	qtcontroller
   4856  4347				  -	      lda	qtcontroller
   4857  4347				  -	      lsr		; bit 0 in carry
   4858  4347				  -	      lda	#4
   4859  4347				  -	      ror		; carry into top of A
   4860  4347					      else
   4861  4347		       a9 02		      lda	#2
   4862  4349					      endif		; qtcontroller
   4863  4349					      endif		; readpaddle
   4864  4349		       85 02		      sta	WSYNC
   4865  434b		       85 01		      sta	VBLANK
      0  434d					      RETURN
      1  434d				  -	      ifnconst	bankswitch
      2  434d				  -	      rts
      3  434d					      else
      4  434d		       4c dd ff 	      jmp	BS_return
      5  4350					      endif
   4867  4350				  -	      ifconst	shakescreen
   4868  4350				  -doshakescreen
   4869  4350				  -	      bit	shakescreen
   4870  4350				  -	      bmi	noshakescreen
   4871  4350				  -	      sta	WSYNC
   4872  4350				  -noshakescreen
   4873  4350				  -	      ldx	missile0height
   4874  4350				  -	      inx
   4875  4350				  -	      rts
   4876  4350					      endif
   4877  4350
   4878  4350							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4879  4350
   4880  4350				   start
   4881  4350		       78		      sei
   4882  4351		       d8		      cld
   4883  4352		       a0 00		      ldy	#0
   4884  4354		       a5 d0		      lda	$D0
   4885  4356		       c9 2c		      cmp	#$2C	;check RAM location #1
   4886  4358		       d0 07		      bne	MachineIs2600
   4887  435a		       a5 d1		      lda	$D1
   4888  435c		       c9 a9		      cmp	#$A9	;check RAM location #2
   4889  435e		       d0 01		      bne	MachineIs2600
   4890  4360		       88		      dey
   4891  4361				   MachineIs2600
   4892  4361		       a2 00		      ldx	#0
   4893  4363		       8a		      txa
   4894  4364				   clearmem
   4895  4364		       e8		      inx
   4896  4365		       9a		      txs
   4897  4366		       48		      pha
   4898  4367		       d0 fb		      bne	clearmem
   4899  4369		       84 9c		      sty	temp1
   4900  436b					      ifnconst	multisprite
   4901  436b				  -	      ifconst	pfrowheight
   4902  436b				  -	      lda	#pfrowheight
   4903  436b					      else
   4904  436b					      ifconst	pfres
   4905  436b		       a9 04		      lda	#(96/pfres)
   4906  436d				  -	      else
   4907  436d				  -	      lda	#8
   4908  436d					      endif
   4909  436d					      endif
   4910  436d		       85 ef		      sta	playfieldpos
   4911  436f					      endif
   4912  436f		       a2 05		      ldx	#5
   4913  4371				   initscore
   4914  4371		       a9 74		      lda	#<scoretable
   4915  4373		       95 96		      sta	scorepointers,x
   4916  4375		       ca		      dex
   4917  4376		       10 f9		      bpl	initscore
   4918  4378		       a9 01		      lda	#1
   4919  437a		       85 0a		      sta	CTRLPF
   4920  437c		       0d 84 02 	      ora	INTIM
   4921  437f		       85 a2		      sta	rand
   4922  4381
   4923  4381				  -	      ifconst	multisprite
   4924  4381				  -	      jsr	multisprite_setup
   4925  4381					      endif
   4926  4381
   4927  4381				  -	      ifnconst	bankswitch
   4928  4381				  -	      jmp	game
   4929  4381					      else
   4930  4381		       a9 90		      lda	#>(game-1)
   4931  4383		       48		      pha
   4932  4384		       a9 ff		      lda	#<(game-1)
   4933  4386		       48		      pha
   4934  4387		       48		      pha
   4935  4388		       48		      pha
   4936  4389		       a2 01		      ldx	#1
   4937  438b		       4c eb ff 	      jmp	BS_jsr
   4938  438e					      endif
   4939  438e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4940  438e
   4941  438e							; playfield drawing routines
   4942  438e							; you get a 32x12 bitmapped display in a single color :)
   4943  438e							; 0-31 and 0-11
   4944  438e
   4945  438e				   pfclear		; clears playfield - or fill with pattern
   4946  438e					      ifconst	pfres
   4947  438e		       a2 5b		      ldx	#pfres*pfwidth-1
   4948  4390				  -	      else
   4949  4390				  -	      ldx	#47-(4-pfwidth)*12	; will this work?
   4950  4390					      endif
   4951  4390				   pfclear_loop
   4952  4390				  -	      ifnconst	superchip
   4953  4390				  -	      sta	playfield,x
   4954  4390					      else
   4955  4390		       9d 24 10 	      sta	playfield-128,x
   4956  4393					      endif
   4957  4393		       ca		      dex
   4958  4394		       10 fa		      bpl	pfclear_loop
      0  4396					      RETURN
      1  4396				  -	      ifnconst	bankswitch
      2  4396				  -	      rts
      3  4396					      else
      4  4396		       4c dd ff 	      jmp	BS_return
      5  4399					      endif
   4960  4399
   4961  4399				   setuppointers
   4962  4399		       86 9d		      stx	temp2	; store on.off.flip value
   4963  439b		       aa		      tax		; put x-value in x 
   4964  439c		       4a		      lsr
   4965  439d		       4a		      lsr
   4966  439e		       4a		      lsr		; divide x pos by 8 
   4967  439f		       85 9c		      sta	temp1
   4968  43a1		       98		      tya
   4969  43a2		       0a		      asl
   4970  43a3					      if	pfwidth=4
   4971  43a3		       0a		      asl		; multiply y pos by 4
   4972  43a4					      endif		; else multiply by 2
   4973  43a4		       18		      clc
   4974  43a5		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   4975  43a7		       a8		      tay		; put the value in y
   4976  43a8		       a5 9d		      lda	temp2	; restore on.off.flip value
   4977  43aa		       60		      rts
   4978  43ab
   4979  43ab				   pfread
   4980  43ab							;x=xvalue, y=yvalue
   4981  43ab		       20 99 f3 	      jsr	setuppointers
   4982  43ae		       bd 43 f4 	      lda	setbyte,x
   4983  43b1		       39 a4 10 	      and	playfield,y
   4984  43b4		       5d 43 f4 	      eor	setbyte,x
   4985  43b7							; beq readzero
   4986  43b7							; lda #1
   4987  43b7							; readzero
      0  43b7					      RETURN
      1  43b7				  -	      ifnconst	bankswitch
      2  43b7				  -	      rts
      3  43b7					      else
      4  43b7		       4c dd ff 	      jmp	BS_return
      5  43ba					      endif
   4989  43ba
   4990  43ba				   pfpixel
   4991  43ba							;x=xvalue, y=yvalue, a=0,1,2
   4992  43ba		       20 99 f3 	      jsr	setuppointers
   4993  43bd
   4994  43bd					      ifconst	bankswitch
   4995  43bd		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   4996  43bf		       f0 0f		      beq	pixelon_r	; if "on" go to on
   4997  43c1		       4a		      lsr
   4998  43c2		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   4999  43c4		       b9 a4 10 	      lda	playfield,y	; if here, it's "flip"
   5000  43c7		       5d 43 f4 	      eor	setbyte,x
   5001  43ca					      ifconst	superchip
   5002  43ca		       99 24 10 	      sta	playfield-128,y
   5003  43cd				  -	      else
   5004  43cd				  -	      sta	playfield,y
   5005  43cd					      endif
      0  43cd					      RETURN
      1  43cd				  -	      ifnconst	bankswitch
      2  43cd				  -	      rts
      3  43cd					      else
      4  43cd		       4c dd ff 	      jmp	BS_return
      5  43d0					      endif
   5007  43d0				   pixelon_r
   5008  43d0		       b9 a4 10 	      lda	playfield,y
   5009  43d3		       1d 43 f4 	      ora	setbyte,x
   5010  43d6					      ifconst	superchip
   5011  43d6		       99 24 10 	      sta	playfield-128,y
   5012  43d9				  -	      else
   5013  43d9				  -	      sta	playfield,y
   5014  43d9					      endif
      0  43d9					      RETURN
      1  43d9				  -	      ifnconst	bankswitch
      2  43d9				  -	      rts
      3  43d9					      else
      4  43d9		       4c dd ff 	      jmp	BS_return
      5  43dc					      endif
   5016  43dc				   pixeloff_r
   5017  43dc		       bd 43 f4 	      lda	setbyte,x
   5018  43df		       49 ff		      eor	#$ff
   5019  43e1		       39 a4 10 	      and	playfield,y
   5020  43e4					      ifconst	superchip
   5021  43e4		       99 24 10 	      sta	playfield-128,y
   5022  43e7				  -	      else
   5023  43e7				  -	      sta	playfield,y
   5024  43e7					      endif
      0  43e7					      RETURN
      1  43e7				  -	      ifnconst	bankswitch
      2  43e7				  -	      rts
      3  43e7					      else
      4  43e7		       4c dd ff 	      jmp	BS_return
      5  43ea					      endif
   5026  43ea
   5027  43ea				  -	      else
   5028  43ea				  -	      jmp	plotpoint
   5029  43ea					      endif
   5030  43ea
   5031  43ea				   pfhline
   5032  43ea							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   5033  43ea		       20 99 f3 	      jsr	setuppointers
   5034  43ed		       4c f7 f3 	      jmp	noinc
   5035  43f0				   keepgoing
   5036  43f0		       e8		      inx
   5037  43f1		       8a		      txa
   5038  43f2		       29 07		      and	#7
   5039  43f4		       d0 01		      bne	noinc
   5040  43f6		       c8		      iny
   5041  43f7				   noinc
   5042  43f7		       20 1c f4 	      jsr	plotpoint
   5043  43fa		       e4 9e		      cpx	temp3
   5044  43fc		       30 f2		      bmi	keepgoing
      0  43fe					      RETURN
      1  43fe				  -	      ifnconst	bankswitch
      2  43fe				  -	      rts
      3  43fe					      else
      4  43fe		       4c dd ff 	      jmp	BS_return
      5  4401					      endif
   5046  4401
   5047  4401				   pfvline
   5048  4401							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   5049  4401		       20 99 f3 	      jsr	setuppointers
   5050  4404		       84 9c		      sty	temp1	; store memory location offset
   5051  4406		       e6 9e		      inc	temp3	; increase final x by 1 
   5052  4408		       a5 9e		      lda	temp3
   5053  440a		       0a		      asl
   5054  440b					      if	pfwidth=4
   5055  440b		       0a		      asl		; multiply by 4
   5056  440c					      endif		; else multiply by 2
   5057  440c		       85 9e		      sta	temp3	; store it
   5058  440e							; Thanks to Michael Rideout for fixing a bug in this code
   5059  440e							; right now, temp1=y=starting memory location, temp3=final
   5060  440e							; x should equal original x value
   5061  440e				   keepgoingy
   5062  440e		       20 1c f4 	      jsr	plotpoint
   5063  4411		       c8		      iny
   5064  4412		       c8		      iny
   5065  4413					      if	pfwidth=4
   5066  4413		       c8		      iny
   5067  4414		       c8		      iny
   5068  4415					      endif
   5069  4415		       c4 9e		      cpy	temp3
   5070  4417		       30 f5		      bmi	keepgoingy
      0  4419					      RETURN
      1  4419				  -	      ifnconst	bankswitch
      2  4419				  -	      rts
      3  4419					      else
      4  4419		       4c dd ff 	      jmp	BS_return
      5  441c					      endif
   5072  441c
   5073  441c				   plotpoint
   5074  441c		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   5075  441e		       f0 0d		      beq	pixelon	; if "on" go to on
   5076  4420		       4a		      lsr
   5077  4421		       b0 14		      bcs	pixeloff	; value is 1 if true
   5078  4423		       b9 a4 10 	      lda	playfield,y	; if here, it's "flip"
   5079  4426		       5d 43 f4 	      eor	setbyte,x
   5080  4429					      ifconst	superchip
   5081  4429		       99 24 10 	      sta	playfield-128,y
   5082  442c				  -	      else
   5083  442c				  -	      sta	playfield,y
   5084  442c					      endif
   5085  442c		       60		      rts
   5086  442d				   pixelon
   5087  442d		       b9 a4 10 	      lda	playfield,y
   5088  4430		       1d 43 f4 	      ora	setbyte,x
   5089  4433					      ifconst	superchip
   5090  4433		       99 24 10 	      sta	playfield-128,y
   5091  4436				  -	      else
   5092  4436				  -	      sta	playfield,y
   5093  4436					      endif
   5094  4436		       60		      rts
   5095  4437				   pixeloff
   5096  4437		       bd 43 f4 	      lda	setbyte,x
   5097  443a		       49 ff		      eor	#$ff
   5098  443c		       39 a4 10 	      and	playfield,y
   5099  443f					      ifconst	superchip
   5100  443f		       99 24 10 	      sta	playfield-128,y
   5101  4442				  -	      else
   5102  4442				  -	      sta	playfield,y
   5103  4442					      endif
   5104  4442		       60		      rts
   5105  4443
   5106  4443				   setbyte
   5107  4443					      ifnconst	pfcenter
   5108  4443		       80		      .byte.b	$80
   5109  4444		       40		      .byte.b	$40
   5110  4445		       20		      .byte.b	$20
   5111  4446		       10		      .byte.b	$10
   5112  4447		       08		      .byte.b	$08
   5113  4448		       04		      .byte.b	$04
   5114  4449		       02		      .byte.b	$02
   5115  444a		       01		      .byte.b	$01
   5116  444b					      endif
   5117  444b		       01		      .byte.b	$01
   5118  444c		       02		      .byte.b	$02
   5119  444d		       04		      .byte.b	$04
   5120  444e		       08		      .byte.b	$08
   5121  444f		       10		      .byte.b	$10
   5122  4450		       20		      .byte.b	$20
   5123  4451		       40		      .byte.b	$40
   5124  4452		       80		      .byte.b	$80
   5125  4453		       80		      .byte.b	$80
   5126  4454		       40		      .byte.b	$40
   5127  4455		       20		      .byte.b	$20
   5128  4456		       10		      .byte.b	$10
   5129  4457		       08		      .byte.b	$08
   5130  4458		       04		      .byte.b	$04
   5131  4459		       02		      .byte.b	$02
   5132  445a		       01		      .byte.b	$01
   5133  445b		       01		      .byte.b	$01
   5134  445c		       02		      .byte.b	$02
   5135  445d		       04		      .byte.b	$04
   5136  445e		       08		      .byte.b	$08
   5137  445f		       10		      .byte.b	$10
   5138  4460		       20		      .byte.b	$20
   5139  4461		       40		      .byte.b	$40
   5140  4462		       80		      .byte.b	$80
   5141  4463							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5142  4463
   5143  4463				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   5144  4463		       d0 2a		      bne	notleft
   5145  4465							;left
   5146  4465					      ifconst	pfres
   5147  4465		       a2 5c		      ldx	#pfres*4
   5148  4467				  -	      else
   5149  4467				  -	      ldx	#48
   5150  4467					      endif
   5151  4467				   leftloop
   5152  4467		       bd a3 10 	      lda	playfield-1,x
   5153  446a		       4a		      lsr
   5154  446b
   5155  446b					      ifconst	superchip
   5156  446b		       bd a2 10 	      lda	playfield-2,x
   5157  446e		       2a		      rol
   5158  446f		       9d 22 10 	      sta	playfield-130,x
   5159  4472		       bd a1 10 	      lda	playfield-3,x
   5160  4475		       6a		      ror
   5161  4476		       9d 21 10 	      sta	playfield-131,x
   5162  4479		       bd a0 10 	      lda	playfield-4,x
   5163  447c		       2a		      rol
   5164  447d		       9d 20 10 	      sta	playfield-132,x
   5165  4480		       bd a3 10 	      lda	playfield-1,x
   5166  4483		       6a		      ror
   5167  4484		       9d 23 10 	      sta	playfield-129,x
   5168  4487				  -	      else
   5169  4487				  -	      rol	playfield-2,x
   5170  4487				  -	      ror	playfield-3,x
   5171  4487				  -	      rol	playfield-4,x
   5172  4487				  -	      ror	playfield-1,x
   5173  4487					      endif
   5174  4487
   5175  4487		       8a		      txa
   5176  4488		       cb 04		      sbx	#4
   5177  448a		       d0 db		      bne	leftloop
      0  448c					      RETURN
      1  448c				  -	      ifnconst	bankswitch
      2  448c				  -	      rts
      3  448c					      else
      4  448c		       4c dd ff 	      jmp	BS_return
      5  448f					      endif
   5179  448f
   5180  448f				   notleft
   5181  448f		       4a		      lsr
   5182  4490		       90 2a		      bcc	notright
   5183  4492							;right
   5184  4492
   5185  4492					      ifconst	pfres
   5186  4492		       a2 5c		      ldx	#pfres*4
   5187  4494				  -	      else
   5188  4494				  -	      ldx	#48
   5189  4494					      endif
   5190  4494				   rightloop
   5191  4494		       bd a0 10 	      lda	playfield-4,x
   5192  4497		       4a		      lsr
   5193  4498					      ifconst	superchip
   5194  4498		       bd a1 10 	      lda	playfield-3,x
   5195  449b		       2a		      rol
   5196  449c		       9d 21 10 	      sta	playfield-131,x
   5197  449f		       bd a2 10 	      lda	playfield-2,x
   5198  44a2		       6a		      ror
   5199  44a3		       9d 22 10 	      sta	playfield-130,x
   5200  44a6		       bd a3 10 	      lda	playfield-1,x
   5201  44a9		       2a		      rol
   5202  44aa		       9d 23 10 	      sta	playfield-129,x
   5203  44ad		       bd a0 10 	      lda	playfield-4,x
   5204  44b0		       6a		      ror
   5205  44b1		       9d 20 10 	      sta	playfield-132,x
   5206  44b4				  -	      else
   5207  44b4				  -	      rol	playfield-3,x
   5208  44b4				  -	      ror	playfield-2,x
   5209  44b4				  -	      rol	playfield-1,x
   5210  44b4				  -	      ror	playfield-4,x
   5211  44b4					      endif
   5212  44b4		       8a		      txa
   5213  44b5		       cb 04		      sbx	#4
   5214  44b7		       d0 db		      bne	rightloop
      0  44b9					      RETURN
      1  44b9				  -	      ifnconst	bankswitch
      2  44b9				  -	      rts
      3  44b9					      else
      4  44b9		       4c dd ff 	      jmp	BS_return
      5  44bc					      endif
   5216  44bc
   5217  44bc				   notright
   5218  44bc		       4a		      lsr
   5219  44bd		       90 5b		      bcc	notup
   5220  44bf							;up
   5221  44bf		       4a		      lsr
   5222  44c0		       90 02		      bcc	onedecup
   5223  44c2		       c6 ef		      dec	playfieldpos
   5224  44c4				   onedecup
   5225  44c4		       c6 ef		      dec	playfieldpos
   5226  44c6		       f0 02		      beq	shiftdown
   5227  44c8		       10 4d		      bpl	noshiftdown2
   5228  44ca				   shiftdown
   5229  44ca				  -	      ifconst	pfrowheight
   5230  44ca				  -	      lda	#pfrowheight
   5231  44ca					      else
   5232  44ca				  -	      ifnconst	pfres
   5233  44ca				  -	      lda	#8
   5234  44ca					      else
   5235  44ca		       a9 04		      lda	#(96/pfres)	; try to come close to the real size
   5236  44cc					      endif
   5237  44cc					      endif
   5238  44cc
   5239  44cc		       85 ef		      sta	playfieldpos
   5240  44ce		       ad a7 10 	      lda	playfield+3
   5241  44d1		       85 9f		      sta	temp4
   5242  44d3		       ad a6 10 	      lda	playfield+2
   5243  44d6		       85 9e		      sta	temp3
   5244  44d8		       ad a5 10 	      lda	playfield+1
   5245  44db		       85 9d		      sta	temp2
   5246  44dd		       ad a4 10 	      lda	playfield
   5247  44e0		       85 9c		      sta	temp1
   5248  44e2		       a2 00		      ldx	#0
   5249  44e4				   up2
   5250  44e4		       bd a8 10 	      lda	playfield+4,x
   5251  44e7					      ifconst	superchip
   5252  44e7		       9d 24 10 	      sta	playfield-128,x
   5253  44ea		       bd a9 10 	      lda	playfield+5,x
   5254  44ed		       9d 25 10 	      sta	playfield-127,x
   5255  44f0		       bd aa 10 	      lda	playfield+6,x
   5256  44f3		       9d 26 10 	      sta	playfield-126,x
   5257  44f6		       bd ab 10 	      lda	playfield+7,x
   5258  44f9		       9d 27 10 	      sta	playfield-125,x
   5259  44fc				  -	      else
   5260  44fc				  -	      sta	playfield,x
   5261  44fc				  -	      lda	playfield+5,x
   5262  44fc				  -	      sta	playfield+1,x
   5263  44fc				  -	      lda	playfield+6,x
   5264  44fc				  -	      sta	playfield+2,x
   5265  44fc				  -	      lda	playfield+7,x
   5266  44fc				  -	      sta	playfield+3,x
   5267  44fc					      endif
   5268  44fc		       8a		      txa
   5269  44fd		       cb fc		      sbx	#252
   5270  44ff					      ifconst	pfres
   5271  44ff		       e0 58		      cpx	#(pfres-1)*4
   5272  4501				  -	      else
   5273  4501				  -	      cpx	#44
   5274  4501					      endif
   5275  4501		       d0 e1		      bne	up2
   5276  4503
   5277  4503		       a5 9f		      lda	temp4
   5278  4505
   5279  4505					      ifconst	superchip
   5280  4505					      ifconst	pfres
   5281  4505		       8d 7f 10 	      sta	playfield+pfres*4-129
   5282  4508		       a5 9e		      lda	temp3
   5283  450a		       8d 7e 10 	      sta	playfield+pfres*4-130
   5284  450d		       a5 9d		      lda	temp2
   5285  450f		       8d 7d 10 	      sta	playfield+pfres*4-131
   5286  4512		       a5 9c		      lda	temp1
   5287  4514		       8d 7c 10 	      sta	playfield+pfres*4-132
   5288  4517				  -	      else
   5289  4517				  -	      sta	playfield+47-128
   5290  4517				  -	      lda	temp3
   5291  4517				  -	      sta	playfield+46-128
   5292  4517				  -	      lda	temp2
   5293  4517				  -	      sta	playfield+45-128
   5294  4517				  -	      lda	temp1
   5295  4517				  -	      sta	playfield+44-128
   5296  4517					      endif
   5297  4517				  -	      else
   5298  4517				  -	      ifconst	pfres
   5299  4517				  -	      sta	playfield+pfres*4-1
   5300  4517				  -	      lda	temp3
   5301  4517				  -	      sta	playfield+pfres*4-2
   5302  4517				  -	      lda	temp2
   5303  4517				  -	      sta	playfield+pfres*4-3
   5304  4517				  -	      lda	temp1
   5305  4517				  -	      sta	playfield+pfres*4-4
   5306  4517				  -	      else
   5307  4517				  -	      sta	playfield+47
   5308  4517				  -	      lda	temp3
   5309  4517				  -	      sta	playfield+46
   5310  4517				  -	      lda	temp2
   5311  4517				  -	      sta	playfield+45
   5312  4517				  -	      lda	temp1
   5313  4517				  -	      sta	playfield+44
   5314  4517				  -	      endif
   5315  4517					      endif
   5316  4517				   noshiftdown2
      0  4517					      RETURN
      1  4517				  -	      ifnconst	bankswitch
      2  4517				  -	      rts
      3  4517					      else
      4  4517		       4c dd ff 	      jmp	BS_return
      5  451a					      endif
   5318  451a
   5319  451a
   5320  451a				   notup
   5321  451a							;down
   5322  451a		       4a		      lsr
   5323  451b		       b0 02		      bcs	oneincup
   5324  451d		       e6 ef		      inc	playfieldpos
   5325  451f				   oneincup
   5326  451f		       e6 ef		      inc	playfieldpos
   5327  4521		       a5 ef		      lda	playfieldpos
   5328  4523
   5329  4523				  -	      ifconst	pfrowheight
   5330  4523				  -	      cmp	#pfrowheight+1
   5331  4523					      else
   5332  4523				  -	      ifnconst	pfres
   5333  4523				  -	      cmp	#9
   5334  4523					      else
   5335  4523		       c9 05		      cmp	#(96/pfres)+1	; try to come close to the real size
   5336  4525					      endif
   5337  4525					      endif
   5338  4525
   5339  4525		       90 4b		      bcc	noshiftdown
   5340  4527		       a9 01		      lda	#1
   5341  4529		       85 ef		      sta	playfieldpos
   5342  452b
   5343  452b					      ifconst	pfres
   5344  452b		       ad ff 10 	      lda	playfield+pfres*4-1
   5345  452e		       85 9f		      sta	temp4
   5346  4530		       ad fe 10 	      lda	playfield+pfres*4-2
   5347  4533		       85 9e		      sta	temp3
   5348  4535		       ad fd 10 	      lda	playfield+pfres*4-3
   5349  4538		       85 9d		      sta	temp2
   5350  453a		       ad fc 10 	      lda	playfield+pfres*4-4
   5351  453d				  -	      else
   5352  453d				  -	      lda	playfield+47
   5353  453d				  -	      sta	temp4
   5354  453d				  -	      lda	playfield+46
   5355  453d				  -	      sta	temp3
   5356  453d				  -	      lda	playfield+45
   5357  453d				  -	      sta	temp2
   5358  453d				  -	      lda	playfield+44
   5359  453d					      endif
   5360  453d
   5361  453d		       85 9c		      sta	temp1
   5362  453f
   5363  453f					      ifconst	pfres
   5364  453f		       a2 58		      ldx	#(pfres-1)*4
   5365  4541				  -	      else
   5366  4541				  -	      ldx	#44
   5367  4541					      endif
   5368  4541				   down2
   5369  4541		       bd a3 10 	      lda	playfield-1,x
   5370  4544					      ifconst	superchip
   5371  4544		       9d 27 10 	      sta	playfield-125,x
   5372  4547		       bd a2 10 	      lda	playfield-2,x
   5373  454a		       9d 26 10 	      sta	playfield-126,x
   5374  454d		       bd a1 10 	      lda	playfield-3,x
   5375  4550		       9d 25 10 	      sta	playfield-127,x
   5376  4553		       bd a0 10 	      lda	playfield-4,x
   5377  4556		       9d 24 10 	      sta	playfield-128,x
   5378  4559				  -	      else
   5379  4559				  -	      sta	playfield+3,x
   5380  4559				  -	      lda	playfield-2,x
   5381  4559				  -	      sta	playfield+2,x
   5382  4559				  -	      lda	playfield-3,x
   5383  4559				  -	      sta	playfield+1,x
   5384  4559				  -	      lda	playfield-4,x
   5385  4559				  -	      sta	playfield,x
   5386  4559					      endif
   5387  4559		       8a		      txa
   5388  455a		       cb 04		      sbx	#4
   5389  455c		       d0 e3		      bne	down2
   5390  455e
   5391  455e		       a5 9f		      lda	temp4
   5392  4560					      ifconst	superchip
   5393  4560		       8d 27 10 	      sta	playfield-125
   5394  4563		       a5 9e		      lda	temp3
   5395  4565		       8d 26 10 	      sta	playfield-126
   5396  4568		       a5 9d		      lda	temp2
   5397  456a		       8d 25 10 	      sta	playfield-127
   5398  456d		       a5 9c		      lda	temp1
   5399  456f		       8d 24 10 	      sta	playfield-128
   5400  4572				  -	      else
   5401  4572				  -	      sta	playfield+3
   5402  4572				  -	      lda	temp3
   5403  4572				  -	      sta	playfield+2
   5404  4572				  -	      lda	temp2
   5405  4572				  -	      sta	playfield+1
   5406  4572				  -	      lda	temp1
   5407  4572				  -	      sta	playfield
   5408  4572					      endif
   5409  4572				   noshiftdown
      0  4572					      RETURN
      1  4572				  -	      ifnconst	bankswitch
      2  4572				  -	      rts
      3  4572					      else
      4  4572		       4c dd ff 	      jmp	BS_return
      5  4575					      endif
   5411  4575							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5412  4575
   5413  4575							;standard routines needed for pretty much all games
   5414  4575							; just the random number generator is left - maybe we should remove this asm file altogether?
   5415  4575							; repositioning code and score pointer setup moved to overscan
   5416  4575							; read switches, joysticks now compiler generated (more efficient)
   5417  4575
   5418  4575				   randomize
   5419  4575		       a5 a2		      lda	rand
   5420  4577		       4a		      lsr
   5421  4578					      ifconst	rand16
   5422  4578		       26 ed		      rol	rand16
   5423  457a					      endif
   5424  457a		       90 02		      bcc	noeor
   5425  457c		       49 b4		      eor	#$B4
   5426  457e				   noeor
   5427  457e		       85 a2		      sta	rand
   5428  4580					      ifconst	rand16
   5429  4580		       45 ed		      eor	rand16
   5430  4582					      endif
      0  4582					      RETURN
      1  4582				  -	      ifnconst	bankswitch
      2  4582				  -	      rts
      3  4582					      else
      4  4582		       4c dd ff 	      jmp	BS_return
      5  4585					      endif
   5432  4585							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5433  4585
   5434  4585				   drawscreen
   5435  4585				  -	      ifconst	debugscore
   5436  4585				  -	      ldx	#14
   5437  4585				  -	      lda	INTIM	; display # cycles left in the score
   5438  4585				  -
   5439  4585				  -	      ifconst	mincycles
   5440  4585				  -	      lda	mincycles
   5441  4585				  -	      cmp	INTIM
   5442  4585				  -	      lda	mincycles
   5443  4585				  -	      bcc	nochange
   5444  4585				  -	      lda	INTIM
   5445  4585				  -	      sta	mincycles
   5446  4585				  -nochange
   5447  4585				  -	      endif
   5448  4585				  -
   5449  4585				  -			; cmp #$2B
   5450  4585				  -			; bcs no_cycles_left
   5451  4585				  -	      bmi	cycles_left
   5452  4585				  -	      ldx	#64
   5453  4585				  -	      eor	#$ff	;make negative
   5454  4585				  -cycles_left
   5455  4585				  -	      stx	scorecolor
   5456  4585				  -	      and	#$7f	; clear sign bit
   5457  4585				  -	      tax
   5458  4585				  -	      lda	scorebcd,x
   5459  4585				  -	      sta	score+2
   5460  4585				  -	      lda	scorebcd1,x
   5461  4585				  -	      sta	score+1
   5462  4585				  -	      jmp	done_debugscore
   5463  4585				  -scorebcd
   5464  4585				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   5465  4585				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   5466  4585				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   5467  4585				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   5468  4585				  -scorebcd1
   5469  4585				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   5470  4585				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   5471  4585				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   5472  4585				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   5473  4585				  -done_debugscore
   5474  4585					      endif
   5475  4585
   5476  4585				  -	      ifconst	debugcycles
   5477  4585				  -	      lda	INTIM	; if we go over, it mucks up the background color
   5478  4585				  -			; cmp #$2B
   5479  4585				  -			; BCC overscan
   5480  4585				  -	      bmi	overscan
   5481  4585				  -	      sta	COLUBK
   5482  4585				  -	      bcs	doneoverscan
   5483  4585					      endif
   5484  4585
   5485  4585				   overscan
   5486  4585				  -	      ifconst	interlaced
   5487  4585				  -	      PHP
   5488  4585				  -	      PLA
   5489  4585				  -	      EOR	#4	; flip interrupt bit
   5490  4585				  -	      PHA
   5491  4585				  -	      PLP
   5492  4585				  -	      AND	#4	; isolate the interrupt bit
   5493  4585				  -	      TAX		; save it for later
   5494  4585					      endif
   5495  4585
   5496  4585				   overscanloop
   5497  4585		       ad 84 02 	      lda	INTIM	;wait for sync
   5498  4588		       30 fb		      bmi	overscanloop
   5499  458a				   doneoverscan
   5500  458a
   5501  458a							;do VSYNC
   5502  458a
   5503  458a				  -	      ifconst	interlaced
   5504  458a				  -	      CPX	#4
   5505  458a				  -	      BNE	oddframevsync
   5506  458a					      endif
   5507  458a
   5508  458a		       a9 02		      lda	#2
   5509  458c		       85 02		      sta	WSYNC
   5510  458e		       85 00		      sta	VSYNC
   5511  4590		       85 02		      STA	WSYNC
   5512  4592		       85 02		      STA	WSYNC
   5513  4594		       4a		      lsr
   5514  4595		       85 02		      STA	WSYNC
   5515  4597		       85 00		      STA	VSYNC
   5516  4599		       85 01		      sta	VBLANK
   5517  459b					      ifnconst	overscan_time
   5518  459b		       a9 a5		      lda	#37+128
   5519  459d				  -	      else
   5520  459d				  -	      lda	#overscan_time+128
   5521  459d					      endif
   5522  459d		       8d 96 02 	      sta	TIM64T
   5523  45a0
   5524  45a0				  -	      ifconst	interlaced
   5525  45a0				  -	      jmp	postsync
   5526  45a0				  -
   5527  45a0				  -oddframevsync
   5528  45a0				  -	      sta	WSYNC
   5529  45a0				  -
   5530  45a0				  -	      LDA	($80,X)	; 11 waste
   5531  45a0				  -	      LDA	($80,X)	; 11 waste
   5532  45a0				  -	      LDA	($80,X)	; 11 waste
   5533  45a0				  -
   5534  45a0				  -	      lda	#2
   5535  45a0				  -	      sta	VSYNC
   5536  45a0				  -	      sta	WSYNC
   5537  45a0				  -	      sta	WSYNC
   5538  45a0				  -	      sta	WSYNC
   5539  45a0				  -
   5540  45a0				  -	      LDA	($80,X)	; 11 waste
   5541  45a0				  -	      LDA	($80,X)	; 11 waste
   5542  45a0				  -	      LDA	($80,X)	; 11 waste
   5543  45a0				  -
   5544  45a0				  -	      lda	#0
   5545  45a0				  -	      sta	VSYNC
   5546  45a0				  -	      sta	VBLANK
   5547  45a0				  -	      ifnconst	overscan_time
   5548  45a0				  -	      lda	#37+128
   5549  45a0				  -	      else
   5550  45a0				  -	      lda	#overscan_time+128
   5551  45a0				  -	      endif
   5552  45a0				  -	      sta	TIM64T
   5553  45a0				  -
   5554  45a0				  -postsync
   5555  45a0					      endif
   5556  45a0
   5557  45a0				  -	      ifconst	legacy
   5558  45a0				  -	      if	legacy < 100
   5559  45a0				  -	      ldx	#4
   5560  45a0				  -adjustloop
   5561  45a0				  -	      lda	player0x,x
   5562  45a0				  -	      sec
   5563  45a0				  -	      sbc	#14	;?
   5564  45a0				  -	      sta	player0x,x
   5565  45a0				  -	      dex
   5566  45a0				  -	      bpl	adjustloop
   5567  45a0				  -	      endif
   5568  45a0					      endif
   5569  45a0				  -	      if	((<*)>$e9)&&((<*)<$fa)
   5570  45a0				  -	      repeat	($fa-(<*))
   5571  45a0				  -	      nop
   5572  45a0				  -	      repend
   5573  45a0					      endif
   5574  45a0		       85 02		      sta	WSYNC
   5575  45a2		       a2 04		      ldx	#4
      0  45a4					      SLEEP	3
      1  45a4				   .CYCLES    SET	3
      2  45a4
      3  45a4				  -	      IF	.CYCLES < 2
      4  45a4				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  45a4				  -	      ERR
      6  45a4					      ENDIF
      7  45a4
      8  45a4					      IF	.CYCLES & 1
      9  45a4					      IFNCONST	NO_ILLEGAL_OPCODES
     10  45a4		       04 00		      nop	0
     11  45a6				  -	      ELSE
     12  45a6				  -	      bit	VSYNC
     13  45a6					      ENDIF
     14  45a6				   .CYCLES    SET	.CYCLES - 3
     15  45a6					      ENDIF
     16  45a6
     17  45a6				  -	      REPEAT	.CYCLES / 2
     18  45a6				  -	      nop
     19  45a6					      REPEND
   5577  45a6				   HorPosLoop		; 5
   5578  45a6		       b5 80		      lda	player0x,X	;+4 9
   5579  45a8		       38		      sec		;+2 11
   5580  45a9				   DivideLoop
   5581  45a9		       e9 0f		      sbc	#15
   5582  45ab		       b0 fc		      bcs	DivideLoop	;+4 15
   5583  45ad		       95 9c		      sta	temp1,X	;+4 19
   5584  45af		       95 10		      sta	RESP0,X	;+4 23
   5585  45b1		       85 02		      sta	WSYNC
   5586  45b3		       ca		      dex
   5587  45b4		       10 f0		      bpl	HorPosLoop	;+5 5
   5588  45b6							; 4
   5589  45b6
   5590  45b6		       a2 04		      ldx	#4
   5591  45b8		       b4 9c		      ldy	temp1,X
   5592  45ba		       b9 19 f5 	      lda	repostable-256,Y
   5593  45bd		       95 20		      sta	HMP0,X	;+14 18
   5594  45bf
   5595  45bf		       ca		      dex
   5596  45c0		       b4 9c		      ldy	temp1,X
   5597  45c2		       b9 19 f5 	      lda	repostable-256,Y
   5598  45c5		       95 20		      sta	HMP0,X	;+14 32
   5599  45c7
   5600  45c7		       ca		      dex
   5601  45c8		       b4 9c		      ldy	temp1,X
   5602  45ca		       b9 19 f5 	      lda	repostable-256,Y
   5603  45cd		       95 20		      sta	HMP0,X	;+14 46
   5604  45cf
   5605  45cf		       ca		      dex
   5606  45d0		       b4 9c		      ldy	temp1,X
   5607  45d2		       b9 19 f5 	      lda	repostable-256,Y
   5608  45d5		       95 20		      sta	HMP0,X	;+14 60
   5609  45d7
   5610  45d7		       ca		      dex
   5611  45d8		       b4 9c		      ldy	temp1,X
   5612  45da		       b9 19 f5 	      lda	repostable-256,Y
   5613  45dd		       95 20		      sta	HMP0,X	;+14 74
   5614  45df
   5615  45df		       85 02		      sta	WSYNC
   5616  45e1
   5617  45e1		       85 2a		      sta	HMOVE	;+3 3
   5618  45e3
   5619  45e3
   5620  45e3				  -	      ifconst	legacy
   5621  45e3				  -	      if	legacy < 100
   5622  45e3				  -	      ldx	#4
   5623  45e3				  -adjustloop2
   5624  45e3				  -	      lda	player0x,x
   5625  45e3				  -	      clc
   5626  45e3				  -	      adc	#14	;?
   5627  45e3				  -	      sta	player0x,x
   5628  45e3				  -	      dex
   5629  45e3				  -	      bpl	adjustloop2
   5630  45e3				  -	      endif
   5631  45e3					      endif
   5632  45e3
   5633  45e3
   5634  45e3
   5635  45e3
   5636  45e3							;set score pointers
   5637  45e3		       a7 95		      lax	score+2
   5638  45e5		       20 19 f6 	      jsr	scorepointerset
   5639  45e8		       84 9b		      sty	scorepointers+5
   5640  45ea		       86 98		      stx	scorepointers+2
   5641  45ec		       a7 94		      lax	score+1
   5642  45ee		       20 19 f6 	      jsr	scorepointerset
   5643  45f1		       84 9a		      sty	scorepointers+4
   5644  45f3		       86 97		      stx	scorepointers+1
   5645  45f5		       a7 93		      lax	score
   5646  45f7		       20 19 f6 	      jsr	scorepointerset
   5647  45fa		       84 99		      sty	scorepointers+3
   5648  45fc		       86 96		      stx	scorepointers
   5649  45fe
   5650  45fe				   vblk
   5651  45fe							; run possible vblank bB code
   5652  45fe					      ifconst	vblank_bB_code
   5653  45fe		       20 28 f6 	      jsr	vblank_bB_code
   5654  4601					      endif
   5655  4601				   vblk2
   5656  4601		       ad 84 02 	      LDA	INTIM
   5657  4604		       30 fb		      bmi	vblk2
   5658  4606		       4c 00 f1 	      jmp	kernel
   5659  4609
   5660  4609
   5661  4609		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   5662  4612		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   5663  4619				   repostable
   5664  4619
   5665  4619				   scorepointerset
   5666  4619		       29 0f		      and	#$0F
   5667  461b		       0a		      asl
   5668  461c		       0a		      asl
   5669  461d		       0a		      asl
   5670  461e		       69 74		      adc	#<scoretable
   5671  4620		       a8		      tay
   5672  4621		       8a		      txa
   5673  4622							; and #$F0
   5674  4622							; lsr
   5675  4622		       4b f0		      asr	#$F0
   5676  4624		       69 74		      adc	#<scoretable
   5677  4626		       aa		      tax
   5678  4627		       60		      rts
   5679  4628							;bB.asm
   5680  4628							; bB.asm file is split here
   5681  4628				   .
   5682  4628							; 
   5683  4628
   5684  4628				   .
   5685  4628							; 
   5686  4628
   5687  4628				   .
   5688  4628							; 
   5689  4628
   5690  4628				   .
   5691  4628							; 
   5692  4628
   5693  4628				   .
   5694  4628							; 
   5695  4628
   5696  4628				   .
   5697  4628							; 
   5698  4628
   5699  4628				   .
   5700  4628							; 
   5701  4628
   5702  4628				   .L0181		;  vblank
   5703  4628
   5704  4628				   vblank_bB_code
   5705  4628				   .
   5706  4628							; 
   5707  4628
   5708  4628				   .L0182		;  if !_Bit3_vblank{3} then goto __Done_Player_Section
   5709  4628
   5710  4628		       a5 ec		      LDA	_Bit3_vblank
   5711  462a		       29 08		      AND	#8
   5712  462c		       d0 03		      BNE	.skipL0182
   5713  462e				   .condpart53
   5714  462e		       4c c0 f8 	      jmp	.__Done_Player_Section
   5715  4631
   5716  4631				   .skipL0182
   5717  4631				   .
   5718  4631							; 
   5719  4631
   5720  4631				   .
   5721  4631							; 
   5722  4631
   5723  4631				   .
   5724  4631							; 
   5725  4631
   5726  4631				   .
   5727  4631							; 
   5728  4631
   5729  4631				   .
   5730  4631							; 
   5731  4631
   5732  4631				   .
   5733  4631							; 
   5734  4631
   5735  4631				   .
   5736  4631							; 
   5737  4631
   5738  4631				   .
   5739  4631							; 
   5740  4631
   5741  4631				   .
   5742  4631							; 
   5743  4631
   5744  4631				   .
   5745  4631							; 
   5746  4631
   5747  4631				   .L0183		;  if _Bit0_P0_Dir_Up{0} then goto __Test_P0_Up
   5748  4631
   5749  4631		       a5 e8		      LDA	_Bit0_P0_Dir_Up
   5750  4633		       4a		      LSR
   5751  4634		       90 03		      BCC	.skipL0183
   5752  4636				   .condpart54
   5753  4636		       4c 46 f6 	      jmp	.__Test_P0_Up
   5754  4639
   5755  4639				   .skipL0183
   5756  4639				   .
   5757  4639							; 
   5758  4639
   5759  4639				   .L0184		;  if joy0up then goto __Test_P0_Up
   5760  4639
   5761  4639		       a9 10		      lda	#$10
   5762  463b		       2c 80 02 	      bit	SWCHA
   5763  463e		       d0 03		      BNE	.skipL0184
   5764  4640				   .condpart55
   5765  4640		       4c 46 f6 	      jmp	.__Test_P0_Up
   5766  4643
   5767  4643				   .skipL0184
   5768  4643				   .
   5769  4643							; 
   5770  4643
   5771  4643				   .L0185		;  goto __Skip_Joy0_Up
   5772  4643
   5773  4643		       4c cf f6 	      jmp	.__Skip_Joy0_Up
   5774  4646
   5775  4646				   .
   5776  4646							; 
   5777  4646
   5778  4646				   .__Test_P0_Up
   5779  4646							; __Test_P0_Up
   5780  4646
   5781  4646				   .
   5782  4646							; 
   5783  4646
   5784  4646				   .
   5785  4646							; 
   5786  4646
   5787  4646				   .
   5788  4646							; 
   5789  4646
   5790  4646				   .
   5791  4646							; 
   5792  4646
   5793  4646				   .
   5794  4646							; 
   5795  4646
   5796  4646				   .L0186		;  temp3  =   ( player0x - 17 )  / 4
   5797  4646
   5798  4646							; complex statement detected
   5799  4646		       a5 80		      LDA	player0x
   5800  4648		       38		      SEC
   5801  4649		       e9 11		      SBC	#17
   5802  464b		       4a		      lsr
   5803  464c		       4a		      lsr
   5804  464d		       85 9e		      STA	temp3
   5805  464f				   .
   5806  464f							; 
   5807  464f
   5808  464f				   .L0187		;  temp6  =   ( player0y / 4 )  - 2
   5809  464f
   5810  464f							; complex statement detected
   5811  464f		       a5 85		      LDA	player0y
   5812  4651		       4a		      lsr
   5813  4652		       4a		      lsr
   5814  4653		       38		      SEC
   5815  4654		       e9 02		      SBC	#2
   5816  4656		       85 a1		      STA	temp6
   5817  4658				   .
   5818  4658							; 
   5819  4658
   5820  4658				   .L0188		;  if pfread ( temp3 , temp6 )  then goto __Cant_Move_Up
   5821  4658
   5822  4658		       a5 9e		      LDA	temp3
   5823  465a		       a4 a1		      LDY	temp6
   5824  465c		       20 ab f3 	      jsr	pfread
   5825  465f		       d0 03		      BNE	.skipL0188
   5826  4661				   .condpart56
   5827  4661		       4c 7a f6 	      jmp	.__Cant_Move_Up
   5828  4664
   5829  4664				   .skipL0188
   5830  4664				   .
   5831  4664							; 
   5832  4664
   5833  4664				   .L0189		;  temp5  =  temp3  +	1
   5834  4664
   5835  4664		       a5 9e		      LDA	temp3
   5836  4666		       18		      CLC
   5837  4667		       69 01		      ADC	#1
   5838  4669		       85 a0		      STA	temp5
   5839  466b				   .
   5840  466b							; 
   5841  466b
   5842  466b				   .L0190		;  if pfread ( temp5 , temp6 )  then goto __Cant_Move_Up
   5843  466b
   5844  466b		       a5 a0		      LDA	temp5
   5845  466d		       a4 a1		      LDY	temp6
   5846  466f		       20 ab f3 	      jsr	pfread
   5847  4672		       d0 03		      BNE	.skipL0190
   5848  4674				   .condpart57
   5849  4674		       4c 7a f6 	      jmp	.__Cant_Move_Up
   5850  4677
   5851  4677				   .skipL0190
   5852  4677				   .
   5853  4677							; 
   5854  4677
   5855  4677				   .L0191		;  goto __P0_Move_Up
   5856  4677
   5857  4677		       4c 8b f6 	      jmp	.__P0_Move_Up
   5858  467a
   5859  467a				   .
   5860  467a							; 
   5861  467a
   5862  467a				   .__Cant_Move_Up
   5863  467a							; __Cant_Move_Up
   5864  467a
   5865  467a				   .
   5866  467a							; 
   5867  467a
   5868  467a				   .
   5869  467a							; 
   5870  467a
   5871  467a				   .
   5872  467a							; 
   5873  467a
   5874  467a				   .
   5875  467a							; 
   5876  467a
   5877  467a				   .
   5878  467a							; 
   5879  467a
   5880  467a				   .
   5881  467a							; 
   5882  467a
   5883  467a				   .L0192		;  if _Bit0_P0_Dir_Up{0} then gosub __Frame_U_01
   5884  467a
   5885  467a		       a5 e8		      LDA	_Bit0_P0_Dir_Up
   5886  467c		       4a		      LSR
   5887  467d		       90 03		      BCC	.skipL0192
   5888  467f				   .condpart58
   5889  467f		       20 37 f9 	      jsr	.__Frame_U_01
   5890  4682
   5891  4682				   .skipL0192
   5892  4682				   .
   5893  4682							; 
   5894  4682
   5895  4682				   .L0193		;  _Bit0_P0_Dir_Up{0}	=  0
   5896  4682
   5897  4682		       a5 e8		      LDA	_Bit0_P0_Dir_Up
   5898  4684		       29 fe		      AND	#254
   5899  4686		       85 e8		      STA	_Bit0_P0_Dir_Up
   5900  4688				   .
   5901  4688							; 
   5902  4688
   5903  4688				   .L0194		;  goto __Skip_Joy0_Up
   5904  4688
   5905  4688		       4c cf f6 	      jmp	.__Skip_Joy0_Up
   5906  468b
   5907  468b				   .
   5908  468b							; 
   5909  468b
   5910  468b				   .__P0_Move_Up
   5911  468b							; __P0_Move_Up
   5912  468b
   5913  468b				   .
   5914  468b							; 
   5915  468b
   5916  468b				   .
   5917  468b							; 
   5918  468b
   5919  468b				   .
   5920  468b							; 
   5921  468b
   5922  468b				   .
   5923  468b							; 
   5924  468b
   5925  468b				   .L0195		;  temp5  =   ( temp3 * 4 )  + 17
   5926  468b
   5927  468b							; complex statement detected
   5928  468b		       a5 9e		      LDA	temp3
   5929  468d		       0a		      asl
   5930  468e		       0a		      asl
   5931  468f		       18		      CLC
   5932  4690		       69 11		      ADC	#17
   5933  4692		       85 a0		      STA	temp5
   5934  4694				   .
   5935  4694							; 
   5936  4694
   5937  4694				   .L0196		;  if temp5  <>  player0x then goto __Skip_Joy0_Up
   5938  4694
   5939  4694		       a5 a0		      LDA	temp5
   5940  4696		       c5 80		      CMP	player0x
   5941  4698		       f0 03		      BEQ	.skipL0196
   5942  469a				   .condpart59
   5943  469a		       4c cf f6 	      jmp	.__Skip_Joy0_Up
   5944  469d
   5945  469d				   .skipL0196
   5946  469d				   .
   5947  469d							; 
   5948  469d
   5949  469d				   .L0197		;  _P0_U_D  =	_P0_U_D  -  0.85
   5950  469d
   5951  469d		       a5 d5		      LDA	b
   5952  469f		       38		      SEC
   5953  46a0		       e9 d9		      SBC	#217
   5954  46a2		       85 d5		      STA	b
   5955  46a4		       a5 85		      LDA	_P0_U_D
   5956  46a6		       e9 00		      SBC	#0
   5957  46a8		       85 85		      STA	_P0_U_D
   5958  46aa				   .
   5959  46aa							; 
   5960  46aa
   5961  46aa				   .
   5962  46aa							; 
   5963  46aa
   5964  46aa				   .
   5965  46aa							; 
   5966  46aa
   5967  46aa				   .
   5968  46aa							; 
   5969  46aa
   5970  46aa				   .L0198		;  on _Frame_Counter gosub __Frame_U_00 __Frame_U_01 __Frame_U_02 __Frame_U_01
   5971  46aa
   5972  46aa		       a9 f6		      lda	#>(ongosub0-1)
   5973  46ac		       48		      PHA
   5974  46ad		       a9 c2		      lda	#<(ongosub0-1)
   5975  46af		       48		      PHA
   5976  46b0		       a6 e1		      LDX	_Frame_Counter
   5977  46b2		       bd bb f6 	      LDA	.L0198jumptablehi,x
   5978  46b5		       48		      PHA
   5979  46b6		       bd bf f6 	      LDA	.L0198jumptablelo,x
   5980  46b9		       48		      PHA
   5981  46ba		       60		      RTS
   5982  46bb				   .L0198jumptablehi
   5983  46bb		       f9		      .byte.b	>(.__Frame_U_00-1)
   5984  46bc		       f9		      .byte.b	>(.__Frame_U_01-1)
   5985  46bd		       f9		      .byte.b	>(.__Frame_U_02-1)
   5986  46be		       f9		      .byte.b	>(.__Frame_U_01-1)
   5987  46bf				   .L0198jumptablelo
   5988  46bf		       1d		      .byte.b	<(.__Frame_U_00-1)
   5989  46c0		       36		      .byte.b	<(.__Frame_U_01-1)
   5990  46c1		       4f		      .byte.b	<(.__Frame_U_02-1)
   5991  46c2		       36		      .byte.b	<(.__Frame_U_01-1)
   5992  46c3				   ongosub0
   5993  46c3				   .
   5994  46c3							; 
   5995  46c3
   5996  46c3				   .
   5997  46c3							; 
   5998  46c3
   5999  46c3				   .
   6000  46c3							; 
   6001  46c3
   6002  46c3				   .
   6003  46c3							; 
   6004  46c3
   6005  46c3				   .L0199		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %11110000
   6006  46c3
   6007  46c3		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   6008  46c5		       29 f0		      AND	#%11110000
   6009  46c7		       85 e8		      STA	_BitOp_P0_P1_Dir
   6010  46c9				   .
   6011  46c9							; 
   6012  46c9
   6013  46c9				   .L0200		;  _Bit0_P0_Dir_Up{0}	=  1
   6014  46c9
   6015  46c9		       a5 e8		      LDA	_Bit0_P0_Dir_Up
   6016  46cb		       09 01		      ORA	#1
   6017  46cd		       85 e8		      STA	_Bit0_P0_Dir_Up
   6018  46cf				   .
   6019  46cf							; 
   6020  46cf
   6021  46cf				   .__Skip_Joy0_Up
   6022  46cf							; __Skip_Joy0_Up
   6023  46cf
   6024  46cf				   .
   6025  46cf							; 
   6026  46cf
   6027  46cf				   .
   6028  46cf							; 
   6029  46cf
   6030  46cf				   .
   6031  46cf							; 
   6032  46cf
   6033  46cf				   .
   6034  46cf							; 
   6035  46cf
   6036  46cf				   .
   6037  46cf							; 
   6038  46cf
   6039  46cf				   .
   6040  46cf							; 
   6041  46cf
   6042  46cf				   .
   6043  46cf							; 
   6044  46cf
   6045  46cf				   .
   6046  46cf							; 
   6047  46cf
   6048  46cf				   .
   6049  46cf							; 
   6050  46cf
   6051  46cf				   .
   6052  46cf							; 
   6053  46cf
   6054  46cf				   .
   6055  46cf							; 
   6056  46cf
   6057  46cf				   .L0201		;  if _Bit1_P0_Dir_Down{1} then goto __Test_P0_Down
   6058  46cf
   6059  46cf		       a5 e8		      LDA	_Bit1_P0_Dir_Down
   6060  46d1		       29 02		      AND	#2
   6061  46d3		       f0 03		      BEQ	.skipL0201
   6062  46d5				   .condpart60
   6063  46d5		       4c e5 f6 	      jmp	.__Test_P0_Down
   6064  46d8
   6065  46d8				   .skipL0201
   6066  46d8				   .
   6067  46d8							; 
   6068  46d8
   6069  46d8				   .L0202		;  if joy0down then goto __Test_P0_Down
   6070  46d8
   6071  46d8		       a9 20		      lda	#$20
   6072  46da		       2c 80 02 	      bit	SWCHA
   6073  46dd		       d0 03		      BNE	.skipL0202
   6074  46df				   .condpart61
   6075  46df		       4c e5 f6 	      jmp	.__Test_P0_Down
   6076  46e2
   6077  46e2				   .skipL0202
   6078  46e2				   .
   6079  46e2							; 
   6080  46e2
   6081  46e2				   .L0203		;  goto __Skip_Joy0_Down
   6082  46e2
   6083  46e2		       4c 72 f7 	      jmp	.__Skip_Joy0_Down
   6084  46e5
   6085  46e5				   .
   6086  46e5							; 
   6087  46e5
   6088  46e5				   .__Test_P0_Down
   6089  46e5							; __Test_P0_Down
   6090  46e5
   6091  46e5				   .
   6092  46e5							; 
   6093  46e5
   6094  46e5				   .
   6095  46e5							; 
   6096  46e5
   6097  46e5				   .
   6098  46e5							; 
   6099  46e5
   6100  46e5				   .
   6101  46e5							; 
   6102  46e5
   6103  46e5				   .
   6104  46e5							; 
   6105  46e5
   6106  46e5				   .L0204		;  temp3  =   ( player0x - 17 )  / 4
   6107  46e5
   6108  46e5							; complex statement detected
   6109  46e5		       a5 80		      LDA	player0x
   6110  46e7		       38		      SEC
   6111  46e8		       e9 11		      SBC	#17
   6112  46ea		       4a		      lsr
   6113  46eb		       4a		      lsr
   6114  46ec		       85 9e		      STA	temp3
   6115  46ee				   .
   6116  46ee							; 
   6117  46ee
   6118  46ee				   .L0205		;  temp6  =   (  ( player0y - 3 )  / 4 )   +  1
   6119  46ee
   6120  46ee							; complex statement detected
   6121  46ee		       a5 85		      LDA	player0y
   6122  46f0		       38		      SEC
   6123  46f1		       e9 03		      SBC	#3
   6124  46f3		       4a		      lsr
   6125  46f4		       4a		      lsr
   6126  46f5		       18		      CLC
   6127  46f6		       69 01		      ADC	#1
   6128  46f8		       85 a1		      STA	temp6
   6129  46fa				   .
   6130  46fa							; 
   6131  46fa
   6132  46fa				   .L0206		;  if pfread ( temp3 , temp6 )  then goto __Cant_Move_Down
   6133  46fa
   6134  46fa		       a5 9e		      LDA	temp3
   6135  46fc		       a4 a1		      LDY	temp6
   6136  46fe		       20 ab f3 	      jsr	pfread
   6137  4701		       d0 03		      BNE	.skipL0206
   6138  4703				   .condpart62
   6139  4703		       4c 1c f7 	      jmp	.__Cant_Move_Down
   6140  4706
   6141  4706				   .skipL0206
   6142  4706				   .
   6143  4706							; 
   6144  4706
   6145  4706				   .L0207		;  temp5  =  temp3  +	1
   6146  4706
   6147  4706		       a5 9e		      LDA	temp3
   6148  4708		       18		      CLC
   6149  4709		       69 01		      ADC	#1
   6150  470b		       85 a0		      STA	temp5
   6151  470d				   .
   6152  470d							; 
   6153  470d
   6154  470d				   .L0208		;  if pfread ( temp5 , temp6 )  then goto __Cant_Move_Down
   6155  470d
   6156  470d		       a5 a0		      LDA	temp5
   6157  470f		       a4 a1		      LDY	temp6
   6158  4711		       20 ab f3 	      jsr	pfread
   6159  4714		       d0 03		      BNE	.skipL0208
   6160  4716				   .condpart63
   6161  4716		       4c 1c f7 	      jmp	.__Cant_Move_Down
   6162  4719
   6163  4719				   .skipL0208
   6164  4719				   .
   6165  4719							; 
   6166  4719
   6167  4719				   .L0209		;  goto __P0_Move_Down
   6168  4719
   6169  4719		       4c 2e f7 	      jmp	.__P0_Move_Down
   6170  471c
   6171  471c				   .
   6172  471c							; 
   6173  471c
   6174  471c				   .__Cant_Move_Down
   6175  471c							; __Cant_Move_Down
   6176  471c
   6177  471c				   .
   6178  471c							; 
   6179  471c
   6180  471c				   .
   6181  471c							; 
   6182  471c
   6183  471c				   .
   6184  471c							; 
   6185  471c
   6186  471c				   .
   6187  471c							; 
   6188  471c
   6189  471c				   .
   6190  471c							; 
   6191  471c
   6192  471c				   .
   6193  471c							; 
   6194  471c
   6195  471c				   .L0210		;  if _Bit1_P0_Dir_Down{1} then gosub __Frame_D_01
   6196  471c
   6197  471c		       a5 e8		      LDA	_Bit1_P0_Dir_Down
   6198  471e		       29 02		      AND	#2
   6199  4720		       f0 03		      BEQ	.skipL0210
   6200  4722				   .condpart64
   6201  4722		       20 82 f9 	      jsr	.__Frame_D_01
   6202  4725
   6203  4725				   .skipL0210
   6204  4725				   .
   6205  4725							; 
   6206  4725
   6207  4725				   .L0211		;  _Bit1_P0_Dir_Down{1}  =  0
   6208  4725
   6209  4725		       a5 e8		      LDA	_Bit1_P0_Dir_Down
   6210  4727		       29 fd		      AND	#253
   6211  4729		       85 e8		      STA	_Bit1_P0_Dir_Down
   6212  472b				   .
   6213  472b							; 
   6214  472b
   6215  472b				   .L0212		;  goto __Skip_Joy0_Down
   6216  472b
   6217  472b		       4c 72 f7 	      jmp	.__Skip_Joy0_Down
   6218  472e
   6219  472e				   .
   6220  472e							; 
   6221  472e
   6222  472e				   .__P0_Move_Down
   6223  472e							; __P0_Move_Down
   6224  472e
   6225  472e				   .
   6226  472e							; 
   6227  472e
   6228  472e				   .
   6229  472e							; 
   6230  472e
   6231  472e				   .
   6232  472e							; 
   6233  472e
   6234  472e				   .
   6235  472e							; 
   6236  472e
   6237  472e				   .L0213		;  temp5  =   ( temp3 * 4 )   +  17
   6238  472e
   6239  472e							; complex statement detected
   6240  472e		       a5 9e		      LDA	temp3
   6241  4730		       0a		      asl
   6242  4731		       0a		      asl
   6243  4732		       18		      CLC
   6244  4733		       69 11		      ADC	#17
   6245  4735		       85 a0		      STA	temp5
   6246  4737				   .
   6247  4737							; 
   6248  4737
   6249  4737				   .L0214		;  if temp5  <>  player0x then goto __Skip_Joy0_Down
   6250  4737
   6251  4737		       a5 a0		      LDA	temp5
   6252  4739		       c5 80		      CMP	player0x
   6253  473b		       f0 03		      BEQ	.skipL0214
   6254  473d				   .condpart65
   6255  473d		       4c 72 f7 	      jmp	.__Skip_Joy0_Down
   6256  4740
   6257  4740				   .skipL0214
   6258  4740				   .
   6259  4740							; 
   6260  4740
   6261  4740				   .L0215		;  _P0_U_D  =	_P0_U_D  +  0.85
   6262  4740
   6263  4740		       a5 d5		      LDA	b
   6264  4742		       18		      CLC
   6265  4743		       69 d9		      ADC	#217
   6266  4745		       85 d5		      STA	b
   6267  4747		       a5 85		      LDA	_P0_U_D
   6268  4749		       69 00		      ADC	#0
   6269  474b		       85 85		      STA	_P0_U_D
   6270  474d				   .
   6271  474d							; 
   6272  474d
   6273  474d				   .
   6274  474d							; 
   6275  474d
   6276  474d				   .
   6277  474d							; 
   6278  474d
   6279  474d				   .
   6280  474d							; 
   6281  474d
   6282  474d				   .L0216		;  on _Frame_Counter gosub __Frame_D_00 __Frame_D_01 __Frame_D_02 __Frame_D_01
   6283  474d
   6284  474d		       a9 f7		      lda	#>(ongosub1-1)
   6285  474f		       48		      PHA
   6286  4750		       a9 65		      lda	#<(ongosub1-1)
   6287  4752		       48		      PHA
   6288  4753		       a6 e1		      LDX	_Frame_Counter
   6289  4755		       bd 5e f7 	      LDA	.L0216jumptablehi,x
   6290  4758		       48		      PHA
   6291  4759		       bd 62 f7 	      LDA	.L0216jumptablelo,x
   6292  475c		       48		      PHA
   6293  475d		       60		      RTS
   6294  475e				   .L0216jumptablehi
   6295  475e		       f9		      .byte.b	>(.__Frame_D_00-1)
   6296  475f		       f9		      .byte.b	>(.__Frame_D_01-1)
   6297  4760		       f9		      .byte.b	>(.__Frame_D_02-1)
   6298  4761		       f9		      .byte.b	>(.__Frame_D_01-1)
   6299  4762				   .L0216jumptablelo
   6300  4762		       68		      .byte.b	<(.__Frame_D_00-1)
   6301  4763		       81		      .byte.b	<(.__Frame_D_01-1)
   6302  4764		       9a		      .byte.b	<(.__Frame_D_02-1)
   6303  4765		       81		      .byte.b	<(.__Frame_D_01-1)
   6304  4766				   ongosub1
   6305  4766				   .
   6306  4766							; 
   6307  4766
   6308  4766				   .
   6309  4766							; 
   6310  4766
   6311  4766				   .
   6312  4766							; 
   6313  4766
   6314  4766				   .
   6315  4766							; 
   6316  4766
   6317  4766				   .L0217		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %11110000
   6318  4766
   6319  4766		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   6320  4768		       29 f0		      AND	#%11110000
   6321  476a		       85 e8		      STA	_BitOp_P0_P1_Dir
   6322  476c				   .
   6323  476c							; 
   6324  476c
   6325  476c				   .L0218		;  _Bit1_P0_Dir_Down{1}  =  1
   6326  476c
   6327  476c		       a5 e8		      LDA	_Bit1_P0_Dir_Down
   6328  476e		       09 02		      ORA	#2
   6329  4770		       85 e8		      STA	_Bit1_P0_Dir_Down
   6330  4772				   .
   6331  4772							; 
   6332  4772
   6333  4772				   .__Skip_Joy0_Down
   6334  4772							; __Skip_Joy0_Down
   6335  4772
   6336  4772				   .
   6337  4772							; 
   6338  4772
   6339  4772				   .
   6340  4772							; 
   6341  4772
   6342  4772				   .
   6343  4772							; 
   6344  4772
   6345  4772				   .
   6346  4772							; 
   6347  4772
   6348  4772				   .
   6349  4772							; 
   6350  4772
   6351  4772				   .
   6352  4772							; 
   6353  4772
   6354  4772				   .
   6355  4772							; 
   6356  4772
   6357  4772				   .
   6358  4772							; 
   6359  4772
   6360  4772				   .
   6361  4772							; 
   6362  4772
   6363  4772				   .
   6364  4772							; 
   6365  4772
   6366  4772				   .
   6367  4772							; 
   6368  4772
   6369  4772				   .L0219		;  if _Bit2_P0_Dir_Left{2} then goto __Test_P0_Left
   6370  4772
   6371  4772		       a5 e8		      LDA	_Bit2_P0_Dir_Left
   6372  4774		       29 04		      AND	#4
   6373  4776		       f0 03		      BEQ	.skipL0219
   6374  4778				   .condpart66
   6375  4778		       4c 86 f7 	      jmp	.__Test_P0_Left
   6376  477b
   6377  477b				   .skipL0219
   6378  477b				   .
   6379  477b							; 
   6380  477b
   6381  477b				   .L0220		;  if joy0left then goto __Test_P0_Left
   6382  477b
   6383  477b		       2c 80 02 	      bit	SWCHA
   6384  477e		       70 03		      BVS	.skipL0220
   6385  4780				   .condpart67
   6386  4780		       4c 86 f7 	      jmp	.__Test_P0_Left
   6387  4783
   6388  4783				   .skipL0220
   6389  4783				   .
   6390  4783							; 
   6391  4783
   6392  4783				   .L0221		;  goto __Skip_Joy0_Left
   6393  4783
   6394  4783		       4c 19 f8 	      jmp	.__Skip_Joy0_Left
   6395  4786
   6396  4786				   .
   6397  4786							; 
   6398  4786
   6399  4786				   .__Test_P0_Left
   6400  4786							; __Test_P0_Left
   6401  4786
   6402  4786				   .
   6403  4786							; 
   6404  4786
   6405  4786				   .
   6406  4786							; 
   6407  4786
   6408  4786				   .
   6409  4786							; 
   6410  4786
   6411  4786				   .
   6412  4786							; 
   6413  4786
   6414  4786				   .
   6415  4786							; 
   6416  4786
   6417  4786				   .L0222		;  temp5  =   (  ( player0x - 14 )  / 4 )  - 1
   6418  4786
   6419  4786							; complex statement detected
   6420  4786		       a5 80		      LDA	player0x
   6421  4788		       38		      SEC
   6422  4789		       e9 0e		      SBC	#14
   6423  478b		       4a		      lsr
   6424  478c		       4a		      lsr
   6425  478d		       38		      SEC
   6426  478e		       e9 01		      SBC	#1
   6427  4790		       85 a0		      STA	temp5
   6428  4792				   .
   6429  4792							; 
   6430  4792
   6431  4792				   .L0223		;  temp6  =   ( player0y - 7 )  / 4
   6432  4792
   6433  4792							; complex statement detected
   6434  4792		       a5 85		      LDA	player0y
   6435  4794		       38		      SEC
   6436  4795		       e9 07		      SBC	#7
   6437  4797		       4a		      lsr
   6438  4798		       4a		      lsr
   6439  4799		       85 a1		      STA	temp6
   6440  479b				   .
   6441  479b							; 
   6442  479b
   6443  479b				   .L0224		;  if pfread ( temp5 , temp6 )  then goto __Cant_Move_Left
   6444  479b
   6445  479b		       a5 a0		      LDA	temp5
   6446  479d		       a4 a1		      LDY	temp6
   6447  479f		       20 ab f3 	      jsr	pfread
   6448  47a2		       d0 03		      BNE	.skipL0224
   6449  47a4				   .condpart68
   6450  47a4		       4c bd f7 	      jmp	.__Cant_Move_Left
   6451  47a7
   6452  47a7				   .skipL0224
   6453  47a7				   .
   6454  47a7							; 
   6455  47a7
   6456  47a7				   .L0225		;  temp3  =  temp6  +	1
   6457  47a7
   6458  47a7		       a5 a1		      LDA	temp6
   6459  47a9		       18		      CLC
   6460  47aa		       69 01		      ADC	#1
   6461  47ac		       85 9e		      STA	temp3
   6462  47ae				   .
   6463  47ae							; 
   6464  47ae
   6465  47ae				   .L0226		;  if pfread ( temp5 , temp3 )  then goto __Cant_Move_Left
   6466  47ae
   6467  47ae		       a5 a0		      LDA	temp5
   6468  47b0		       a4 9e		      LDY	temp3
   6469  47b2		       20 ab f3 	      jsr	pfread
   6470  47b5		       d0 03		      BNE	.skipL0226
   6471  47b7				   .condpart69
   6472  47b7		       4c bd f7 	      jmp	.__Cant_Move_Left
   6473  47ba
   6474  47ba				   .skipL0226
   6475  47ba				   .
   6476  47ba							; 
   6477  47ba
   6478  47ba				   .L0227		;  goto __P0_Move_Left
   6479  47ba
   6480  47ba		       4c cf f7 	      jmp	.__P0_Move_Left
   6481  47bd
   6482  47bd				   .
   6483  47bd							; 
   6484  47bd
   6485  47bd				   .__Cant_Move_Left
   6486  47bd							; __Cant_Move_Left
   6487  47bd
   6488  47bd				   .
   6489  47bd							; 
   6490  47bd
   6491  47bd				   .
   6492  47bd							; 
   6493  47bd
   6494  47bd				   .
   6495  47bd							; 
   6496  47bd
   6497  47bd				   .
   6498  47bd							; 
   6499  47bd
   6500  47bd				   .
   6501  47bd							; 
   6502  47bd
   6503  47bd				   .
   6504  47bd							; 
   6505  47bd
   6506  47bd				   .L0228		;  if _Bit2_P0_Dir_Left{2} then gosub __Frame_LR_01
   6507  47bd
   6508  47bd		       a5 e8		      LDA	_Bit2_P0_Dir_Left
   6509  47bf		       29 04		      AND	#4
   6510  47c1		       f0 03		      BEQ	.skipL0228
   6511  47c3				   .condpart70
   6512  47c3		       20 ec f8 	      jsr	.__Frame_LR_01
   6513  47c6
   6514  47c6				   .skipL0228
   6515  47c6				   .
   6516  47c6							; 
   6517  47c6
   6518  47c6				   .L0229		;  _Bit2_P0_Dir_Left{2}  =  0
   6519  47c6
   6520  47c6		       a5 e8		      LDA	_Bit2_P0_Dir_Left
   6521  47c8		       29 fb		      AND	#251
   6522  47ca		       85 e8		      STA	_Bit2_P0_Dir_Left
   6523  47cc				   .
   6524  47cc							; 
   6525  47cc
   6526  47cc				   .L0230		;  goto __Skip_Joy0_Left
   6527  47cc
   6528  47cc		       4c 19 f8 	      jmp	.__Skip_Joy0_Left
   6529  47cf
   6530  47cf				   .
   6531  47cf							; 
   6532  47cf
   6533  47cf				   .__P0_Move_Left
   6534  47cf							; __P0_Move_Left
   6535  47cf
   6536  47cf				   .
   6537  47cf							; 
   6538  47cf
   6539  47cf				   .
   6540  47cf							; 
   6541  47cf
   6542  47cf				   .
   6543  47cf							; 
   6544  47cf
   6545  47cf				   .
   6546  47cf							; 
   6547  47cf
   6548  47cf				   .L0231		;  temp5  =   ( temp6 * 4 )  + 7
   6549  47cf
   6550  47cf							; complex statement detected
   6551  47cf		       a5 a1		      LDA	temp6
   6552  47d1		       0a		      asl
   6553  47d2		       0a		      asl
   6554  47d3		       18		      CLC
   6555  47d4		       69 07		      ADC	#7
   6556  47d6		       85 a0		      STA	temp5
   6557  47d8				   .
   6558  47d8							; 
   6559  47d8
   6560  47d8				   .L0232		;  if temp5  <>  player0y then goto __Skip_Joy0_Left
   6561  47d8
   6562  47d8		       a5 a0		      LDA	temp5
   6563  47da		       c5 85		      CMP	player0y
   6564  47dc		       f0 03		      BEQ	.skipL0232
   6565  47de				   .condpart71
   6566  47de		       4c 19 f8 	      jmp	.__Skip_Joy0_Left
   6567  47e1
   6568  47e1				   .skipL0232
   6569  47e1				   .
   6570  47e1							; 
   6571  47e1
   6572  47e1				   .L0233		;  _P0_L_R  =	_P0_L_R  -  0.85
   6573  47e1
   6574  47e1		       a5 d4		      LDA	a
   6575  47e3		       38		      SEC
   6576  47e4		       e9 d9		      SBC	#217
   6577  47e6		       85 d4		      STA	a
   6578  47e8		       a5 80		      LDA	_P0_L_R
   6579  47ea		       e9 00		      SBC	#0
   6580  47ec		       85 80		      STA	_P0_L_R
   6581  47ee				   .
   6582  47ee							; 
   6583  47ee
   6584  47ee				   .
   6585  47ee							; 
   6586  47ee
   6587  47ee				   .
   6588  47ee							; 
   6589  47ee
   6590  47ee				   .
   6591  47ee							; 
   6592  47ee
   6593  47ee				   .L0234		;  on _Frame_Counter gosub __Frame_LR_00 __Frame_LR_01 __Frame_LR_02 __Frame_LR_01
   6594  47ee
   6595  47ee		       a9 f8		      lda	#>(ongosub2-1)
   6596  47f0		       48		      PHA
   6597  47f1		       a9 06		      lda	#<(ongosub2-1)
   6598  47f3		       48		      PHA
   6599  47f4		       a6 e1		      LDX	_Frame_Counter
   6600  47f6		       bd ff f7 	      LDA	.L0234jumptablehi,x
   6601  47f9		       48		      PHA
   6602  47fa		       bd 03 f8 	      LDA	.L0234jumptablelo,x
   6603  47fd		       48		      PHA
   6604  47fe		       60		      RTS
   6605  47ff				   .L0234jumptablehi
   6606  47ff		       f8		      .byte.b	>(.__Frame_LR_00-1)
   6607  4800		       f8		      .byte.b	>(.__Frame_LR_01-1)
   6608  4801		       f9		      .byte.b	>(.__Frame_LR_02-1)
   6609  4802		       f8		      .byte.b	>(.__Frame_LR_01-1)
   6610  4803				   .L0234jumptablelo
   6611  4803		       d2		      .byte.b	<(.__Frame_LR_00-1)
   6612  4804		       eb		      .byte.b	<(.__Frame_LR_01-1)
   6613  4805		       04		      .byte.b	<(.__Frame_LR_02-1)
   6614  4806		       eb		      .byte.b	<(.__Frame_LR_01-1)
   6615  4807				   ongosub2
   6616  4807				   .
   6617  4807							; 
   6618  4807
   6619  4807				   .
   6620  4807							; 
   6621  4807
   6622  4807				   .
   6623  4807							; 
   6624  4807
   6625  4807				   .
   6626  4807							; 
   6627  4807
   6628  4807				   .L0235		;  _Bit6_Flip_P0{6}  =  1
   6629  4807
   6630  4807		       a5 ec		      LDA	_Bit6_Flip_P0
   6631  4809		       09 40		      ORA	#64
   6632  480b		       85 ec		      STA	_Bit6_Flip_P0
   6633  480d				   .
   6634  480d							; 
   6635  480d
   6636  480d				   .
   6637  480d							; 
   6638  480d
   6639  480d				   .
   6640  480d							; 
   6641  480d
   6642  480d				   .
   6643  480d							; 
   6644  480d
   6645  480d				   .L0236		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %11110000
   6646  480d
   6647  480d		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   6648  480f		       29 f0		      AND	#%11110000
   6649  4811		       85 e8		      STA	_BitOp_P0_P1_Dir
   6650  4813				   .
   6651  4813							; 
   6652  4813
   6653  4813				   .L0237		;  _Bit2_P0_Dir_Left{2}  =  1
   6654  4813
   6655  4813		       a5 e8		      LDA	_Bit2_P0_Dir_Left
   6656  4815		       09 04		      ORA	#4
   6657  4817		       85 e8		      STA	_Bit2_P0_Dir_Left
   6658  4819				   .
   6659  4819							; 
   6660  4819
   6661  4819				   .__Skip_Joy0_Left
   6662  4819							; __Skip_Joy0_Left
   6663  4819
   6664  4819				   .
   6665  4819							; 
   6666  4819
   6667  4819				   .
   6668  4819							; 
   6669  4819
   6670  4819				   .
   6671  4819							; 
   6672  4819
   6673  4819				   .
   6674  4819							; 
   6675  4819
   6676  4819				   .
   6677  4819							; 
   6678  4819
   6679  4819				   .
   6680  4819							; 
   6681  4819
   6682  4819				   .
   6683  4819							; 
   6684  4819
   6685  4819				   .
   6686  4819							; 
   6687  4819
   6688  4819				   .
   6689  4819							; 
   6690  4819
   6691  4819				   .
   6692  4819							; 
   6693  4819
   6694  4819				   .
   6695  4819							; 
   6696  4819
   6697  4819				   .L0238		;  if _Bit3_P0_Dir_Right{3} then goto __Test_P0_Right
   6698  4819
   6699  4819		       a5 e8		      LDA	_Bit3_P0_Dir_Right
   6700  481b		       29 08		      AND	#8
   6701  481d		       f0 03		      BEQ	.skipL0238
   6702  481f				   .condpart72
   6703  481f		       4c 2d f8 	      jmp	.__Test_P0_Right
   6704  4822
   6705  4822				   .skipL0238
   6706  4822				   .
   6707  4822							; 
   6708  4822
   6709  4822				   .L0239		;  if joy0right then goto __Test_P0_Right
   6710  4822
   6711  4822		       2c 80 02 	      bit	SWCHA
   6712  4825		       30 03		      BMI	.skipL0239
   6713  4827				   .condpart73
   6714  4827		       4c 2d f8 	      jmp	.__Test_P0_Right
   6715  482a
   6716  482a				   .skipL0239
   6717  482a				   .
   6718  482a							; 
   6719  482a
   6720  482a				   .L0240		;  goto __Skip_Joy0_Right
   6721  482a
   6722  482a		       4c c0 f8 	      jmp	.__Skip_Joy0_Right
   6723  482d
   6724  482d				   .
   6725  482d							; 
   6726  482d
   6727  482d				   .__Test_P0_Right
   6728  482d							; __Test_P0_Right
   6729  482d
   6730  482d				   .
   6731  482d							; 
   6732  482d
   6733  482d				   .
   6734  482d							; 
   6735  482d
   6736  482d				   .
   6737  482d							; 
   6738  482d
   6739  482d				   .
   6740  482d							; 
   6741  482d
   6742  482d				   .
   6743  482d							; 
   6744  482d
   6745  482d				   .L0241		;  temp5  =   (  ( player0x - 13 )  / 4 )  + 1
   6746  482d
   6747  482d							; complex statement detected
   6748  482d		       a5 80		      LDA	player0x
   6749  482f		       38		      SEC
   6750  4830		       e9 0d		      SBC	#13
   6751  4832		       4a		      lsr
   6752  4833		       4a		      lsr
   6753  4834		       18		      CLC
   6754  4835		       69 01		      ADC	#1
   6755  4837		       85 a0		      STA	temp5
   6756  4839				   .
   6757  4839							; 
   6758  4839
   6759  4839				   .L0242		;  temp6  =   (  ( player0y - 7 )  / 4 ) 
   6760  4839
   6761  4839							; complex statement detected
   6762  4839		       a5 85		      LDA	player0y
   6763  483b		       38		      SEC
   6764  483c		       e9 07		      SBC	#7
   6765  483e		       4a		      lsr
   6766  483f		       4a		      lsr
   6767  4840		       85 a1		      STA	temp6
   6768  4842				   .
   6769  4842							; 
   6770  4842
   6771  4842				   .L0243		;  if pfread ( temp5 , temp6 )  then goto __Cant_Move_Right
   6772  4842
   6773  4842		       a5 a0		      LDA	temp5
   6774  4844		       a4 a1		      LDY	temp6
   6775  4846		       20 ab f3 	      jsr	pfread
   6776  4849		       d0 03		      BNE	.skipL0243
   6777  484b				   .condpart74
   6778  484b		       4c 64 f8 	      jmp	.__Cant_Move_Right
   6779  484e
   6780  484e				   .skipL0243
   6781  484e				   .
   6782  484e							; 
   6783  484e
   6784  484e				   .L0244		;  temp3  =   ( temp6 )  + 1
   6785  484e
   6786  484e							; complex statement detected
   6787  484e		       a5 a1		      LDA	temp6
   6788  4850		       18		      CLC
   6789  4851		       69 01		      ADC	#1
   6790  4853		       85 9e		      STA	temp3
   6791  4855				   .
   6792  4855							; 
   6793  4855
   6794  4855				   .L0245		;  if pfread ( temp5 , temp3 )  then goto __Cant_Move_Right
   6795  4855
   6796  4855		       a5 a0		      LDA	temp5
   6797  4857		       a4 9e		      LDY	temp3
   6798  4859		       20 ab f3 	      jsr	pfread
   6799  485c		       d0 03		      BNE	.skipL0245
   6800  485e				   .condpart75
   6801  485e		       4c 64 f8 	      jmp	.__Cant_Move_Right
   6802  4861
   6803  4861				   .skipL0245
   6804  4861				   .
   6805  4861							; 
   6806  4861
   6807  4861				   .L0246		;  goto __P0_Move_Right
   6808  4861
   6809  4861		       4c 76 f8 	      jmp	.__P0_Move_Right
   6810  4864
   6811  4864				   .
   6812  4864							; 
   6813  4864
   6814  4864				   .__Cant_Move_Right
   6815  4864							; __Cant_Move_Right
   6816  4864
   6817  4864				   .
   6818  4864							; 
   6819  4864
   6820  4864				   .
   6821  4864							; 
   6822  4864
   6823  4864				   .
   6824  4864							; 
   6825  4864
   6826  4864				   .
   6827  4864							; 
   6828  4864
   6829  4864				   .
   6830  4864							; 
   6831  4864
   6832  4864				   .
   6833  4864							; 
   6834  4864
   6835  4864				   .L0247		;  if _Bit3_P0_Dir_Right{3} then gosub __Frame_LR_01
   6836  4864
   6837  4864		       a5 e8		      LDA	_Bit3_P0_Dir_Right
   6838  4866		       29 08		      AND	#8
   6839  4868		       f0 03		      BEQ	.skipL0247
   6840  486a				   .condpart76
   6841  486a		       20 ec f8 	      jsr	.__Frame_LR_01
   6842  486d
   6843  486d				   .skipL0247
   6844  486d				   .
   6845  486d							; 
   6846  486d
   6847  486d				   .L0248		;  _Bit3_P0_Dir_Right{3}  =  0
   6848  486d
   6849  486d		       a5 e8		      LDA	_Bit3_P0_Dir_Right
   6850  486f		       29 f7		      AND	#247
   6851  4871		       85 e8		      STA	_Bit3_P0_Dir_Right
   6852  4873				   .
   6853  4873							; 
   6854  4873
   6855  4873				   .L0249		;  goto __Skip_Joy0_Right
   6856  4873
   6857  4873		       4c c0 f8 	      jmp	.__Skip_Joy0_Right
   6858  4876
   6859  4876				   .
   6860  4876							; 
   6861  4876
   6862  4876				   .__P0_Move_Right
   6863  4876							; __P0_Move_Right
   6864  4876
   6865  4876				   .
   6866  4876							; 
   6867  4876
   6868  4876				   .
   6869  4876							; 
   6870  4876
   6871  4876				   .
   6872  4876							; 
   6873  4876
   6874  4876				   .
   6875  4876							; 
   6876  4876
   6877  4876				   .L0250		;  temp5  =   ( temp6 * 4 )  + 7
   6878  4876
   6879  4876							; complex statement detected
   6880  4876		       a5 a1		      LDA	temp6
   6881  4878		       0a		      asl
   6882  4879		       0a		      asl
   6883  487a		       18		      CLC
   6884  487b		       69 07		      ADC	#7
   6885  487d		       85 a0		      STA	temp5
   6886  487f				   .
   6887  487f							; 
   6888  487f
   6889  487f				   .L0251		;  if temp5  <>  player0y then goto __Skip_Joy0_Right
   6890  487f
   6891  487f		       a5 a0		      LDA	temp5
   6892  4881		       c5 85		      CMP	player0y
   6893  4883		       f0 03		      BEQ	.skipL0251
   6894  4885				   .condpart77
   6895  4885		       4c c0 f8 	      jmp	.__Skip_Joy0_Right
   6896  4888
   6897  4888				   .skipL0251
   6898  4888				   .
   6899  4888							; 
   6900  4888
   6901  4888				   .L0252		;  _P0_L_R  =	_P0_L_R  +  0.85
   6902  4888
   6903  4888		       a5 d4		      LDA	a
   6904  488a		       18		      CLC
   6905  488b		       69 d9		      ADC	#217
   6906  488d		       85 d4		      STA	a
   6907  488f		       a5 80		      LDA	_P0_L_R
   6908  4891		       69 00		      ADC	#0
   6909  4893		       85 80		      STA	_P0_L_R
   6910  4895				   .
   6911  4895							; 
   6912  4895
   6913  4895				   .
   6914  4895							; 
   6915  4895
   6916  4895				   .
   6917  4895							; 
   6918  4895
   6919  4895				   .
   6920  4895							; 
   6921  4895
   6922  4895				   .L0253		;  on _Frame_Counter gosub __Frame_LR_00 __Frame_LR_01 __Frame_LR_02 __Frame_LR_01
   6923  4895
   6924  4895		       a9 f8		      lda	#>(ongosub3-1)
   6925  4897		       48		      PHA
   6926  4898		       a9 ad		      lda	#<(ongosub3-1)
   6927  489a		       48		      PHA
   6928  489b		       a6 e1		      LDX	_Frame_Counter
   6929  489d		       bd a6 f8 	      LDA	.L0253jumptablehi,x
   6930  48a0		       48		      PHA
   6931  48a1		       bd aa f8 	      LDA	.L0253jumptablelo,x
   6932  48a4		       48		      PHA
   6933  48a5		       60		      RTS
   6934  48a6				   .L0253jumptablehi
   6935  48a6		       f8		      .byte.b	>(.__Frame_LR_00-1)
   6936  48a7		       f8		      .byte.b	>(.__Frame_LR_01-1)
   6937  48a8		       f9		      .byte.b	>(.__Frame_LR_02-1)
   6938  48a9		       f8		      .byte.b	>(.__Frame_LR_01-1)
   6939  48aa				   .L0253jumptablelo
   6940  48aa		       d2		      .byte.b	<(.__Frame_LR_00-1)
   6941  48ab		       eb		      .byte.b	<(.__Frame_LR_01-1)
   6942  48ac		       04		      .byte.b	<(.__Frame_LR_02-1)
   6943  48ad		       eb		      .byte.b	<(.__Frame_LR_01-1)
   6944  48ae				   ongosub3
   6945  48ae				   .
   6946  48ae							; 
   6947  48ae
   6948  48ae				   .
   6949  48ae							; 
   6950  48ae
   6951  48ae				   .
   6952  48ae							; 
   6953  48ae
   6954  48ae				   .
   6955  48ae							; 
   6956  48ae
   6957  48ae				   .L0254		;  _Bit6_Flip_P0{6}  =  0
   6958  48ae
   6959  48ae		       a5 ec		      LDA	_Bit6_Flip_P0
   6960  48b0		       29 bf		      AND	#191
   6961  48b2		       85 ec		      STA	_Bit6_Flip_P0
   6962  48b4				   .
   6963  48b4							; 
   6964  48b4
   6965  48b4				   .
   6966  48b4							; 
   6967  48b4
   6968  48b4				   .
   6969  48b4							; 
   6970  48b4
   6971  48b4				   .
   6972  48b4							; 
   6973  48b4
   6974  48b4				   .L0255		;  _BitOp_P0_P1_Dir  =  _BitOp_P0_P1_Dir  &  %11110000
   6975  48b4
   6976  48b4		       a5 e8		      LDA	_BitOp_P0_P1_Dir
   6977  48b6		       29 f0		      AND	#%11110000
   6978  48b8		       85 e8		      STA	_BitOp_P0_P1_Dir
   6979  48ba				   .
   6980  48ba							; 
   6981  48ba
   6982  48ba				   .L0256		;  _Bit3_P0_Dir_Right{3}  =  1
   6983  48ba
   6984  48ba		       a5 e8		      LDA	_Bit3_P0_Dir_Right
   6985  48bc		       09 08		      ORA	#8
   6986  48be		       85 e8		      STA	_Bit3_P0_Dir_Right
   6987  48c0				   .
   6988  48c0							; 
   6989  48c0
   6990  48c0				   .__Skip_Joy0_Right
   6991  48c0							; __Skip_Joy0_Right
   6992  48c0
   6993  48c0				   .
   6994  48c0							; 
   6995  48c0
   6996  48c0				   .__Done_Player_Section
   6997  48c0							; __Done_Player_Section
   6998  48c0
   6999  48c0				   .
   7000  48c0							; 
   7001  48c0
   7002  48c0				   .L0257		;  _Bit3_vblank{3}  =	0
   7003  48c0
   7004  48c0		       a5 ec		      LDA	_Bit3_vblank
   7005  48c2		       29 f7		      AND	#247
   7006  48c4		       85 ec		      STA	_Bit3_vblank
   7007  48c6				   .
   7008  48c6							; 
   7009  48c6
   7010  48c6				   .L0258		;  return
   7011  48c6
   7012  48c6		       ba		      tsx
   7013  48c7		       b5 02		      lda	2,x	; check return address
   7014  48c9		       49 f8		      eor	#(>*)	; vs. current PCH
   7015  48cb		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7016  48cd		       f0 03		      beq	*+5	; if equal, do normal return
   7017  48cf		       4c dd ff 	      JMP	BS_return
   7018  48d2		       60		      RTS
   7019  48d3				   .
   7020  48d3							; 
   7021  48d3
   7022  48d3				   .
   7023  48d3							; 
   7024  48d3
   7025  48d3				   .
   7026  48d3							; 
   7027  48d3
   7028  48d3				   .
   7029  48d3							; 
   7030  48d3
   7031  48d3				   .
   7032  48d3							; 
   7033  48d3
   7034  48d3				   .
   7035  48d3							; 
   7036  48d3
   7037  48d3				   .
   7038  48d3							; 
   7039  48d3
   7040  48d3				   .__Frame_LR_00
   7041  48d3							; __Frame_LR_00
   7042  48d3
   7043  48d3				   .L0259		;  player0:
   7044  48d3
   7045  48d3		       a2 d0		      LDX	#<playerL0259_0
   7046  48d5		       86 8a		      STX	player0pointerlo
   7047  48d7		       a9 f9		      LDA	#>playerL0259_0
   7048  48d9		       85 8b		      STA	player0pointerhi
   7049  48db		       a9 06		      LDA	#6
   7050  48dd		       85 8e		      STA	player0height
   7051  48df				   .
   7052  48df							; 
   7053  48df
   7054  48df				   .L0260		;  return
   7055  48df
   7056  48df		       ba		      tsx
   7057  48e0		       b5 02		      lda	2,x	; check return address
   7058  48e2		       49 f8		      eor	#(>*)	; vs. current PCH
   7059  48e4		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7060  48e6		       f0 03		      beq	*+5	; if equal, do normal return
   7061  48e8		       4c dd ff 	      JMP	BS_return
   7062  48eb		       60		      RTS
   7063  48ec				   .
   7064  48ec							; 
   7065  48ec
   7066  48ec				   .
   7067  48ec							; 
   7068  48ec
   7069  48ec				   .__Frame_LR_01
   7070  48ec							; __Frame_LR_01
   7071  48ec
   7072  48ec				   .L0261		;  player0:
   7073  48ec
   7074  48ec		       a2 d7		      LDX	#<playerL0261_0
   7075  48ee		       86 8a		      STX	player0pointerlo
   7076  48f0		       a9 f9		      LDA	#>playerL0261_0
   7077  48f2		       85 8b		      STA	player0pointerhi
   7078  48f4		       a9 06		      LDA	#6
   7079  48f6		       85 8e		      STA	player0height
   7080  48f8				   .
   7081  48f8							; 
   7082  48f8
   7083  48f8				   .L0262		;  return
   7084  48f8
   7085  48f8		       ba		      tsx
   7086  48f9		       b5 02		      lda	2,x	; check return address
   7087  48fb		       49 f8		      eor	#(>*)	; vs. current PCH
   7088  48fd		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7089  48ff		       f0 03		      beq	*+5	; if equal, do normal return
   7090  4901		       4c dd ff 	      JMP	BS_return
   7091  4904		       60		      RTS
   7092  4905				   .
   7093  4905							; 
   7094  4905
   7095  4905				   .
   7096  4905							; 
   7097  4905
   7098  4905				   .__Frame_LR_02
   7099  4905							; __Frame_LR_02
   7100  4905
   7101  4905				   .L0263		;  player0:
   7102  4905
   7103  4905		       a2 de		      LDX	#<playerL0263_0
   7104  4907		       86 8a		      STX	player0pointerlo
   7105  4909		       a9 f9		      LDA	#>playerL0263_0
   7106  490b		       85 8b		      STA	player0pointerhi
   7107  490d		       a9 06		      LDA	#6
   7108  490f		       85 8e		      STA	player0height
   7109  4911				   .
   7110  4911							; 
   7111  4911
   7112  4911				   .L0264		;  return
   7113  4911
   7114  4911		       ba		      tsx
   7115  4912		       b5 02		      lda	2,x	; check return address
   7116  4914		       49 f9		      eor	#(>*)	; vs. current PCH
   7117  4916		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7118  4918		       f0 03		      beq	*+5	; if equal, do normal return
   7119  491a		       4c dd ff 	      JMP	BS_return
   7120  491d		       60		      RTS
   7121  491e				   .
   7122  491e							; 
   7123  491e
   7124  491e				   .
   7125  491e							; 
   7126  491e
   7127  491e				   .
   7128  491e							; 
   7129  491e
   7130  491e				   .
   7131  491e							; 
   7132  491e
   7133  491e				   .
   7134  491e							; 
   7135  491e
   7136  491e				   .
   7137  491e							; 
   7138  491e
   7139  491e				   .__Frame_U_00
   7140  491e							; __Frame_U_00
   7141  491e
   7142  491e				   .L0265		;  player0:
   7143  491e
   7144  491e		       a2 e5		      LDX	#<playerL0265_0
   7145  4920		       86 8a		      STX	player0pointerlo
   7146  4922		       a9 f9		      LDA	#>playerL0265_0
   7147  4924		       85 8b		      STA	player0pointerhi
   7148  4926		       a9 06		      LDA	#6
   7149  4928		       85 8e		      STA	player0height
   7150  492a				   .
   7151  492a							; 
   7152  492a
   7153  492a				   .L0266		;  return
   7154  492a
   7155  492a		       ba		      tsx
   7156  492b		       b5 02		      lda	2,x	; check return address
   7157  492d		       49 f9		      eor	#(>*)	; vs. current PCH
   7158  492f		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7159  4931		       f0 03		      beq	*+5	; if equal, do normal return
   7160  4933		       4c dd ff 	      JMP	BS_return
   7161  4936		       60		      RTS
   7162  4937				   .
   7163  4937							; 
   7164  4937
   7165  4937				   .
   7166  4937							; 
   7167  4937
   7168  4937				   .__Frame_U_01
   7169  4937							; __Frame_U_01
   7170  4937
   7171  4937				   .L0267		;  player0:
   7172  4937
   7173  4937		       a2 ec		      LDX	#<playerL0267_0
   7174  4939		       86 8a		      STX	player0pointerlo
   7175  493b		       a9 f9		      LDA	#>playerL0267_0
   7176  493d		       85 8b		      STA	player0pointerhi
   7177  493f		       a9 06		      LDA	#6
   7178  4941		       85 8e		      STA	player0height
   7179  4943				   .
   7180  4943							; 
   7181  4943
   7182  4943				   .L0268		;  return
   7183  4943
   7184  4943		       ba		      tsx
   7185  4944		       b5 02		      lda	2,x	; check return address
   7186  4946		       49 f9		      eor	#(>*)	; vs. current PCH
   7187  4948		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7188  494a		       f0 03		      beq	*+5	; if equal, do normal return
   7189  494c		       4c dd ff 	      JMP	BS_return
   7190  494f		       60		      RTS
   7191  4950				   .
   7192  4950							; 
   7193  4950
   7194  4950				   .
   7195  4950							; 
   7196  4950
   7197  4950				   .__Frame_U_02
   7198  4950							; __Frame_U_02
   7199  4950
   7200  4950				   .L0269		;  player0:
   7201  4950
   7202  4950		       a2 f3		      LDX	#<playerL0269_0
   7203  4952		       86 8a		      STX	player0pointerlo
   7204  4954		       a9 f9		      LDA	#>playerL0269_0
   7205  4956		       85 8b		      STA	player0pointerhi
   7206  4958		       a9 06		      LDA	#6
   7207  495a		       85 8e		      STA	player0height
   7208  495c				   .
   7209  495c							; 
   7210  495c
   7211  495c				   .L0270		;  return
   7212  495c
   7213  495c		       ba		      tsx
   7214  495d		       b5 02		      lda	2,x	; check return address
   7215  495f		       49 f9		      eor	#(>*)	; vs. current PCH
   7216  4961		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7217  4963		       f0 03		      beq	*+5	; if equal, do normal return
   7218  4965		       4c dd ff 	      JMP	BS_return
   7219  4968		       60		      RTS
   7220  4969				   .
   7221  4969							; 
   7222  4969
   7223  4969				   .
   7224  4969							; 
   7225  4969
   7226  4969				   .
   7227  4969							; 
   7228  4969
   7229  4969				   .
   7230  4969							; 
   7231  4969
   7232  4969				   .
   7233  4969							; 
   7234  4969
   7235  4969				   .
   7236  4969							; 
   7237  4969
   7238  4969				   .__Frame_D_00
   7239  4969							; __Frame_D_00
   7240  4969
   7241  4969				   .L0271		;  player0:
   7242  4969
   7243  4969		       a2 00		      LDX	#<playerL0271_0
   7244  496b		       86 8a		      STX	player0pointerlo
   7245  496d		       a9 fa		      LDA	#>playerL0271_0
   7246  496f		       85 8b		      STA	player0pointerhi
   7247  4971		       a9 06		      LDA	#6
   7248  4973		       85 8e		      STA	player0height
   7249  4975				   .
   7250  4975							; 
   7251  4975
   7252  4975				   .L0272		;  return
   7253  4975
   7254  4975		       ba		      tsx
   7255  4976		       b5 02		      lda	2,x	; check return address
   7256  4978		       49 f9		      eor	#(>*)	; vs. current PCH
   7257  497a		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7258  497c		       f0 03		      beq	*+5	; if equal, do normal return
   7259  497e		       4c dd ff 	      JMP	BS_return
   7260  4981		       60		      RTS
   7261  4982				   .
   7262  4982							; 
   7263  4982
   7264  4982				   .
   7265  4982							; 
   7266  4982
   7267  4982				   .__Frame_D_01
   7268  4982							; __Frame_D_01
   7269  4982
   7270  4982				   .L0273		;  player0:
   7271  4982
   7272  4982		       a2 07		      LDX	#<playerL0273_0
   7273  4984		       86 8a		      STX	player0pointerlo
   7274  4986		       a9 fa		      LDA	#>playerL0273_0
   7275  4988		       85 8b		      STA	player0pointerhi
   7276  498a		       a9 06		      LDA	#6
   7277  498c		       85 8e		      STA	player0height
   7278  498e				   .
   7279  498e							; 
   7280  498e
   7281  498e				   .L0274		;  return
   7282  498e
   7283  498e		       ba		      tsx
   7284  498f		       b5 02		      lda	2,x	; check return address
   7285  4991		       49 f9		      eor	#(>*)	; vs. current PCH
   7286  4993		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7287  4995		       f0 03		      beq	*+5	; if equal, do normal return
   7288  4997		       4c dd ff 	      JMP	BS_return
   7289  499a		       60		      RTS
   7290  499b				   .
   7291  499b							; 
   7292  499b
   7293  499b				   .
   7294  499b							; 
   7295  499b
   7296  499b				   .__Frame_D_02
   7297  499b							; __Frame_D_02
   7298  499b
   7299  499b				   .L0275		;  player0:
   7300  499b
   7301  499b		       a2 0e		      LDX	#<playerL0275_0
   7302  499d		       86 8a		      STX	player0pointerlo
   7303  499f		       a9 fa		      LDA	#>playerL0275_0
   7304  49a1		       85 8b		      STA	player0pointerhi
   7305  49a3		       a9 06		      LDA	#6
   7306  49a5		       85 8e		      STA	player0height
   7307  49a7				   .
   7308  49a7							; 
   7309  49a7
   7310  49a7				   .L0276		;  return
   7311  49a7		       ba		      tsx
   7312  49a8		       b5 02		      lda	2,x	; check return address
   7313  49aa		       49 f9		      eor	#(>*)	; vs. current PCH
   7314  49ac		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   7315  49ae		       f0 03		      beq	*+5	; if equal, do normal return
   7316  49b0		       4c dd ff 	      JMP	BS_return
   7317  49b3		       60		      RTS
   7318  49b4				  -	      if	(<*) > (<(*+6))
   7319  49b4				  -	      repeat	($100-<*)
   7320  49b4				  -	      .byte	0
   7321  49b4				  -	      repend
   7322  49b4					      endif
   7323  49b4				   playerL072_1
   7324  49b4		       aa		      .byte.b	%10101010
   7325  49b5		       fe		      .byte.b	%11111110
   7326  49b6		       fe		      .byte.b	%11111110
   7327  49b7		       fe		      .byte.b	%11111110
   7328  49b8		       d6		      .byte.b	%11010110
   7329  49b9		       d6		      .byte.b	%11010110
   7330  49ba		       7c		      .byte.b	%01111100
   7331  49bb				  -	      if	(<*) > (<(*+6))
   7332  49bb				  -	      repeat	($100-<*)
   7333  49bb				  -	      .byte	0
   7334  49bb				  -	      repend
   7335  49bb					      endif
   7336  49bb				   playerL093_1
   7337  49bb		       aa		      .byte.b	%10101010
   7338  49bc		       fe		      .byte.b	%11111110
   7339  49bd		       d6		      .byte.b	%11010110
   7340  49be		       d6		      .byte.b	%11010110
   7341  49bf		       fe		      .byte.b	%11111110
   7342  49c0		       fe		      .byte.b	%11111110
   7343  49c1		       7c		      .byte.b	%01111100
   7344  49c2				  -	      if	(<*) > (<(*+6))
   7345  49c2				  -	      repeat	($100-<*)
   7346  49c2				  -	      .byte	0
   7347  49c2				  -	      repend
   7348  49c2					      endif
   7349  49c2				   playerL0113_1
   7350  49c2		       aa		      .byte.b	%10101010
   7351  49c3		       fe		      .byte.b	%11111110
   7352  49c4		       fe		      .byte.b	%11111110
   7353  49c5		       ae		      .byte.b	%10101110
   7354  49c6		       ae		      .byte.b	%10101110
   7355  49c7		       fe		      .byte.b	%11111110
   7356  49c8		       7c		      .byte.b	%01111100
   7357  49c9				  -	      if	(<*) > (<(*+6))
   7358  49c9				  -	      repeat	($100-<*)
   7359  49c9				  -	      .byte	0
   7360  49c9				  -	      repend
   7361  49c9					      endif
   7362  49c9				   playerL0133_1
   7363  49c9		       aa		      .byte.b	%10101010
   7364  49ca		       fe		      .byte.b	%11111110
   7365  49cb		       fe		      .byte.b	%11111110
   7366  49cc		       ea		      .byte.b	%11101010
   7367  49cd		       ea		      .byte.b	%11101010
   7368  49ce		       fe		      .byte.b	%11111110
   7369  49cf		       7c		      .byte.b	%01111100
   7370  49d0				  -	      if	(<*) > (<(*+6))
   7371  49d0				  -	      repeat	($100-<*)
   7372  49d0				  -	      .byte	0
   7373  49d0				  -	      repend
   7374  49d0					      endif
   7375  49d0				   playerL0259_0
   7376  49d0		       7c		      .byte.b	%01111100
   7377  49d1		       fe		      .byte.b	%11111110
   7378  49d2		       fe		      .byte.b	%11111110
   7379  49d3		       f0		      .byte.b	%11110000
   7380  49d4		       fe		      .byte.b	%11111110
   7381  49d5		       fe		      .byte.b	%11111110
   7382  49d6		       7c		      .byte.b	%01111100
   7383  49d7				  -	      if	(<*) > (<(*+6))
   7384  49d7				  -	      repeat	($100-<*)
   7385  49d7				  -	      .byte	0
   7386  49d7				  -	      repend
   7387  49d7					      endif
   7388  49d7				   playerL0261_0
   7389  49d7		       7c		      .byte.b	%01111100
   7390  49d8		       fe		      .byte.b	%11111110
   7391  49d9		       f8		      .byte.b	%11111000
   7392  49da		       e0		      .byte.b	%11100000
   7393  49db		       f8		      .byte.b	%11111000
   7394  49dc		       fe		      .byte.b	%11111110
   7395  49dd		       7c		      .byte.b	%01111100
   7396  49de				  -	      if	(<*) > (<(*+6))
   7397  49de				  -	      repeat	($100-<*)
   7398  49de				  -	      .byte	0
   7399  49de				  -	      repend
   7400  49de					      endif
   7401  49de				   playerL0263_0
   7402  49de		       7c		      .byte.b	%01111100
   7403  49df		       f8		      .byte.b	%11111000
   7404  49e0		       f0		      .byte.b	%11110000
   7405  49e1		       e0		      .byte.b	%11100000
   7406  49e2		       f0		      .byte.b	%11110000
   7407  49e3		       f8		      .byte.b	%11111000
   7408  49e4		       7c		      .byte.b	%01111100
   7409  49e5				  -	      if	(<*) > (<(*+6))
   7410  49e5				  -	      repeat	($100-<*)
   7411  49e5				  -	      .byte	0
   7412  49e5				  -	      repend
   7413  49e5					      endif
   7414  49e5				   playerL0265_0
   7415  49e5		       7c		      .byte.b	%01111100
   7416  49e6		       fe		      .byte.b	%11111110
   7417  49e7		       fe		      .byte.b	%11111110
   7418  49e8		       fe		      .byte.b	%11111110
   7419  49e9		       ee		      .byte.b	%11101110
   7420  49ea		       ee		      .byte.b	%11101110
   7421  49eb		       6c		      .byte.b	%01101100
   7422  49ec				  -	      if	(<*) > (<(*+6))
   7423  49ec				  -	      repeat	($100-<*)
   7424  49ec				  -	      .byte	0
   7425  49ec				  -	      repend
   7426  49ec					      endif
   7427  49ec				   playerL0267_0
   7428  49ec		       7c		      .byte.b	%01111100
   7429  49ed		       fe		      .byte.b	%11111110
   7430  49ee		       fe		      .byte.b	%11111110
   7431  49ef		       ee		      .byte.b	%11101110
   7432  49f0		       ee		      .byte.b	%11101110
   7433  49f1		       c6		      .byte.b	%11000110
   7434  49f2		       44		      .byte.b	%01000100
   7435  49f3				  -	      if	(<*) > (<(*+6))
   7436  49f3				  -	      repeat	($100-<*)
   7437  49f3				  -	      .byte	0
   7438  49f3				  -	      repend
   7439  49f3					      endif
   7440  49f3				   playerL0269_0
   7441  49f3		       7c		      .byte.b	%01111100
   7442  49f4		       fe		      .byte.b	%11111110
   7443  49f5		       fe		      .byte.b	%11111110
   7444  49f6		       ee		      .byte.b	%11101110
   7445  49f7		       c6		      .byte.b	%11000110
   7446  49f8		       82		      .byte.b	%10000010
   7447  49f9		       00		      .byte.b	%00000000
   7448  49fa					      if	(<*) > (<(*+6))
   7449  49fa					      repeat	($100-<*)
   7450  49fa		       00		      .byte.b	0
   7449  49fa					      repend
   7450  49fb		       00		      .byte.b	0
   7449  49fb					      repend
   7450  49fc		       00		      .byte.b	0
   7449  49fc					      repend
   7450  49fd		       00		      .byte.b	0
   7449  49fd					      repend
   7450  49fe		       00		      .byte.b	0
   7449  49fe					      repend
   7450  49ff		       00		      .byte.b	0
   7451  4a00					      repend
   7452  4a00					      endif
   7453  4a00				   playerL0271_0
   7454  4a00		       6c		      .byte.b	%01101100
   7455  4a01		       ee		      .byte.b	%11101110
   7456  4a02		       ee		      .byte.b	%11101110
   7457  4a03		       fe		      .byte.b	%11111110
   7458  4a04		       fe		      .byte.b	%11111110
   7459  4a05		       fe		      .byte.b	%11111110
   7460  4a06		       7c		      .byte.b	%01111100
   7461  4a07				  -	      if	(<*) > (<(*+6))
   7462  4a07				  -	      repeat	($100-<*)
   7463  4a07				  -	      .byte	0
   7464  4a07				  -	      repend
   7465  4a07					      endif
   7466  4a07				   playerL0273_0
   7467  4a07		       44		      .byte.b	%01000100
   7468  4a08		       c6		      .byte.b	%11000110
   7469  4a09		       ee		      .byte.b	%11101110
   7470  4a0a		       ee		      .byte.b	%11101110
   7471  4a0b		       fe		      .byte.b	%11111110
   7472  4a0c		       fe		      .byte.b	%11111110
   7473  4a0d		       7c		      .byte.b	%01111100
   7474  4a0e				  -	      if	(<*) > (<(*+6))
   7475  4a0e				  -	      repeat	($100-<*)
   7476  4a0e				  -	      .byte	0
   7477  4a0e				  -	      repend
   7478  4a0e					      endif
   7479  4a0e				   playerL0275_0
   7480  4a0e		       00		      .byte.b	%00000000
   7481  4a0f		       82		      .byte.b	%10000010
   7482  4a10		       c6		      .byte.b	%11000110
   7483  4a11		       ee		      .byte.b	%11101110
   7484  4a12		       fe		      .byte.b	%11111110
   7485  4a13		       fe		      .byte.b	%11111110
   7486  4a14		       7c		      .byte.b	%01111100
   7487  4a15					      if	ECHOFIRST
      1375 bytes of ROM space left in bank 4
   7488  4a15					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 4")
   7489  4a15					      endif
   7490  4a15		       00 01	   ECHOFIRST  =	1
   7491  4a15
   7492  4a15
   7493  4a15							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7494  4a15
   7495  4a15							; feel free to modify the score graphics - just keep each digit 8 high
   7496  4a15							; and keep the conditional compilation stuff intact
   7497  4a15				  -	      ifconst	ROM2k
   7498  4a15				  -	      ORG	$F7AC-8
   7499  4a15					      else
   7500  4a15					      ifconst	bankswitch
   7501  4a15				  -	      if	bankswitch == 8
   7502  4a15				  -	      ORG	$2F94-bscode_length
   7503  4a15				  -	      RORG	$FF94-bscode_length
   7504  4a15					      endif
   7505  4a15					      if	bankswitch == 16
   7506  4f74					      ORG	$4F94-bscode_length
   7507  4f74					      RORG	$FF94-bscode_length
   7508  4f74					      endif
   7509  4f74				  -	      if	bankswitch == 32
   7510  4f74				  -	      ORG	$8F94-bscode_length
   7511  4f74				  -	      RORG	$FF94-bscode_length
   7512  4f74					      endif
   7513  4f74				  -	      if	bankswitch == 64
   7514  4f74				  -	      ORG	$10F80-bscode_length
   7515  4f74				  -	      RORG	$1FF80-bscode_length
   7516  4f74					      endif
   7517  4f74				  -	      else
   7518  4f74				  -	      ORG	$FF9C
   7519  4f74					      endif
   7520  4f74					      endif
   7521  4f74
   7522  4f74							; font equates
   7523  4f74		       00 01	   .21stcentury =	1
   7524  4f74		       00 02	   alarmclock =	2
   7525  4f74		       00 03	   handwritten =	3
   7526  4f74		       00 04	   interrupted =	4
   7527  4f74		       00 05	   retroputer =	5
   7528  4f74		       00 06	   whimsey    =	6
   7529  4f74		       00 07	   tiny       =	7
   7530  4f74		       00 08	   hex	      =	8
   7531  4f74
   7532  4f74				  -	      ifconst	font
   7533  4f74				  -	      if	font == hex
   7534  4f74				  -	      ORG	. - 48
   7535  4f74				  -	      endif
   7536  4f74					      endif
   7537  4f74
   7538  4f74				   scoretable
   7539  4f74
   7540  4f74				  -	      ifconst	font
   7541  4f74				  -	      if	font == .21stcentury
   7542  4f74				  -	      include	"score_graphics.asm.21stcentury"
   7543  4f74				  -	      endif
   7544  4f74				  -	      if	font == alarmclock
   7545  4f74				  -	      include	"score_graphics.asm.alarmclock"
   7546  4f74				  -	      endif
   7547  4f74				  -	      if	font == handwritten
   7548  4f74				  -	      include	"score_graphics.asm.handwritten"
   7549  4f74				  -	      endif
   7550  4f74				  -	      if	font == interrupted
   7551  4f74				  -	      include	"score_graphics.asm.interrupted"
   7552  4f74				  -	      endif
   7553  4f74				  -	      if	font == retroputer
   7554  4f74				  -	      include	"score_graphics.asm.retroputer"
   7555  4f74				  -	      endif
   7556  4f74				  -	      if	font == whimsey
   7557  4f74				  -	      include	"score_graphics.asm.whimsey"
   7558  4f74				  -	      endif
   7559  4f74				  -	      if	font == tiny
   7560  4f74				  -	      include	"score_graphics.asm.tiny"
   7561  4f74				  -	      endif
   7562  4f74				  -	      if	font == hex
   7563  4f74				  -	      include	"score_graphics.asm.hex"
   7564  4f74				  -	      endif
   7565  4f74					      else		; default font
   7566  4f74
   7567  4f74		       3c		      .byte.b	%00111100
   7568  4f75		       66		      .byte.b	%01100110
   7569  4f76		       66		      .byte.b	%01100110
   7570  4f77		       66		      .byte.b	%01100110
   7571  4f78		       66		      .byte.b	%01100110
   7572  4f79		       66		      .byte.b	%01100110
   7573  4f7a		       66		      .byte.b	%01100110
   7574  4f7b		       3c		      .byte.b	%00111100
   7575  4f7c
   7576  4f7c		       7e		      .byte.b	%01111110
   7577  4f7d		       18		      .byte.b	%00011000
   7578  4f7e		       18		      .byte.b	%00011000
   7579  4f7f		       18		      .byte.b	%00011000
   7580  4f80		       18		      .byte.b	%00011000
   7581  4f81		       38		      .byte.b	%00111000
   7582  4f82		       18		      .byte.b	%00011000
   7583  4f83		       08		      .byte.b	%00001000
   7584  4f84
   7585  4f84		       7e		      .byte.b	%01111110
   7586  4f85		       60		      .byte.b	%01100000
   7587  4f86		       60		      .byte.b	%01100000
   7588  4f87		       3c		      .byte.b	%00111100
   7589  4f88		       06		      .byte.b	%00000110
   7590  4f89		       06		      .byte.b	%00000110
   7591  4f8a		       46		      .byte.b	%01000110
   7592  4f8b		       3c		      .byte.b	%00111100
   7593  4f8c
   7594  4f8c		       3c		      .byte.b	%00111100
   7595  4f8d		       46		      .byte.b	%01000110
   7596  4f8e		       06		      .byte.b	%00000110
   7597  4f8f		       06		      .byte.b	%00000110
   7598  4f90		       1c		      .byte.b	%00011100
   7599  4f91		       06		      .byte.b	%00000110
   7600  4f92		       46		      .byte.b	%01000110
   7601  4f93		       3c		      .byte.b	%00111100
   7602  4f94
   7603  4f94		       0c		      .byte.b	%00001100
   7604  4f95		       0c		      .byte.b	%00001100
   7605  4f96		       7e		      .byte.b	%01111110
   7606  4f97		       4c		      .byte.b	%01001100
   7607  4f98		       4c		      .byte.b	%01001100
   7608  4f99		       2c		      .byte.b	%00101100
   7609  4f9a		       1c		      .byte.b	%00011100
   7610  4f9b		       0c		      .byte.b	%00001100
   7611  4f9c
   7612  4f9c		       3c		      .byte.b	%00111100
   7613  4f9d		       46		      .byte.b	%01000110
   7614  4f9e		       06		      .byte.b	%00000110
   7615  4f9f		       06		      .byte.b	%00000110
   7616  4fa0		       3c		      .byte.b	%00111100
   7617  4fa1		       60		      .byte.b	%01100000
   7618  4fa2		       60		      .byte.b	%01100000
   7619  4fa3		       7e		      .byte.b	%01111110
   7620  4fa4
   7621  4fa4		       3c		      .byte.b	%00111100
   7622  4fa5		       66		      .byte.b	%01100110
   7623  4fa6		       66		      .byte.b	%01100110
   7624  4fa7		       66		      .byte.b	%01100110
   7625  4fa8		       7c		      .byte.b	%01111100
   7626  4fa9		       60		      .byte.b	%01100000
   7627  4faa		       62		      .byte.b	%01100010
   7628  4fab		       3c		      .byte.b	%00111100
   7629  4fac
   7630  4fac		       30		      .byte.b	%00110000
   7631  4fad		       30		      .byte.b	%00110000
   7632  4fae		       30		      .byte.b	%00110000
   7633  4faf		       18		      .byte.b	%00011000
   7634  4fb0		       0c		      .byte.b	%00001100
   7635  4fb1		       06		      .byte.b	%00000110
   7636  4fb2		       42		      .byte.b	%01000010
   7637  4fb3		       3e		      .byte.b	%00111110
   7638  4fb4
   7639  4fb4		       3c		      .byte.b	%00111100
   7640  4fb5		       66		      .byte.b	%01100110
   7641  4fb6		       66		      .byte.b	%01100110
   7642  4fb7		       66		      .byte.b	%01100110
   7643  4fb8		       3c		      .byte.b	%00111100
   7644  4fb9		       66		      .byte.b	%01100110
   7645  4fba		       66		      .byte.b	%01100110
   7646  4fbb		       3c		      .byte.b	%00111100
   7647  4fbc
   7648  4fbc		       3c		      .byte.b	%00111100
   7649  4fbd		       46		      .byte.b	%01000110
   7650  4fbe		       06		      .byte.b	%00000110
   7651  4fbf		       3e		      .byte.b	%00111110
   7652  4fc0		       66		      .byte.b	%01100110
   7653  4fc1		       66		      .byte.b	%01100110
   7654  4fc2		       66		      .byte.b	%01100110
   7655  4fc3		       3c		      .byte.b	%00111100
   7656  4fc4
   7657  4fc4					      ifnconst	DPC_kernel_options
   7658  4fc4
   7659  4fc4		       00		      .byte.b	%00000000
   7660  4fc5		       00		      .byte.b	%00000000
   7661  4fc6		       00		      .byte.b	%00000000
   7662  4fc7		       00		      .byte.b	%00000000
   7663  4fc8		       00		      .byte.b	%00000000
   7664  4fc9		       00		      .byte.b	%00000000
   7665  4fca		       00		      .byte.b	%00000000
   7666  4fcb		       00		      .byte.b	%00000000
   7667  4fcc
   7668  4fcc					      endif
   7669  4fcc
   7670  4fcc					      endif
   7671  4fcc
   7672  4fcc				  -	      ifconst	ROM2k
   7673  4fcc				  -	      ORG	$F7FC
   7674  4fcc					      else
   7675  4fcc					      ifconst	bankswitch
   7676  4fcc				  -	      if	bankswitch == 8
   7677  4fcc				  -	      ORG	$2FF4-bscode_length
   7678  4fcc				  -	      RORG	$FFF4-bscode_length
   7679  4fcc					      endif
   7680  4fcc					      if	bankswitch == 16
   7681  4fd4					      ORG	$4FF4-bscode_length
   7682  4fd4					      RORG	$FFF4-bscode_length
   7683  4fd4					      endif
   7684  4fd4				  -	      if	bankswitch == 32
   7685  4fd4				  -	      ORG	$8FF4-bscode_length
   7686  4fd4				  -	      RORG	$FFF4-bscode_length
   7687  4fd4					      endif
   7688  4fd4				  -	      if	bankswitch == 64
   7689  4fd4				  -	      ORG	$10FE0-bscode_length
   7690  4fd4				  -	      RORG	$1FFE0-bscode_length
   7691  4fd4					      endif
   7692  4fd4				  -	      else
   7693  4fd4				  -	      ORG	$FFFC
   7694  4fd4					      endif
   7695  4fd4					      endif
   7696  4fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7697  4fd4
   7698  4fd4							; every bank has this stuff at the same place
   7699  4fd4							; this code can switch to/from any bank at any entry point
   7700  4fd4							; and can preserve register values
   7701  4fd4							; note: lines not starting with a space are not placed in all banks
   7702  4fd4							;
   7703  4fd4							; line below tells the compiler how long this is - do not remove
   7704  4fd4							;size=32
   7705  4fd4
   7706  4fd4				   begin_bscode
   7707  4fd4		       a2 ff		      ldx	#$ff
   7708  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   7709  4fd6				  -	      stx	FASTFETCH
   7710  4fd6					      endif
   7711  4fd6		       9a		      txs
   7712  4fd7				  -	      if	bankswitch == 64
   7713  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   7714  4fd7					      else
   7715  4fd7		       a9 f3		      lda	#>(start-1)
   7716  4fd9					      endif
   7717  4fd9		       48		      pha
   7718  4fda		       a9 4f		      lda	#<(start-1)
   7719  4fdc		       48		      pha
   7720  4fdd
   7721  4fdd				   BS_return
   7722  4fdd		       48		      pha
   7723  4fde		       8a		      txa
   7724  4fdf		       48		      pha
   7725  4fe0		       ba		      tsx
   7726  4fe1
   7727  4fe1					      if	bankswitch != 64
   7728  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   7729  4fe3
   7730  4fe3		       2a		      rol
   7731  4fe4		       2a		      rol
   7732  4fe5		       2a		      rol
   7733  4fe6		       2a		      rol
   7734  4fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   7735  4fe9		       aa		      tax
   7736  4fea		       e8		      inx
   7737  4feb				  -	      else
   7738  4feb				  -	      lda	4,x	; get high byte of return address
   7739  4feb				  -	      tay
   7740  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   7741  4feb				  -	      sta	4,x
   7742  4feb				  -	      tya
   7743  4feb				  -	      lsr
   7744  4feb				  -	      lsr
   7745  4feb				  -	      lsr
   7746  4feb				  -	      lsr
   7747  4feb				  -	      tax
   7748  4feb				  -	      inx
   7749  4feb					      endif
   7750  4feb
   7751  4feb				   BS_jsr
   7752  4feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   7753  4fee		       68		      pla
   7754  4fef		       aa		      tax
   7755  4ff0		       68		      pla
   7756  4ff1		       60		      rts
   7757  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   7758  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   7759  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   7760  4ff2					      endif
   7761  4ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7762  4ff2
   7763  4ff2					      ifconst	bankswitch
   7764  4ff2				  -	      if	bankswitch == 8
   7765  4ff2				  -	      ORG	$2FFC
   7766  4ff2				  -	      RORG	$FFFC
   7767  4ff2					      endif
   7768  4ff2					      if	bankswitch == 16
   7769  4ffc					      ORG	$4FFC
   7770  4ffc					      RORG	$FFFC
   7771  4ffc					      endif
   7772  4ffc				  -	      if	bankswitch == 32
   7773  4ffc				  -	      ORG	$8FFC
   7774  4ffc				  -	      RORG	$FFFC
   7775  4ffc					      endif
   7776  4ffc				  -	      if	bankswitch == 64
   7777  4ffc				  -	      ORG	$10FF0
   7778  4ffc				  -	      RORG	$1FFF0
   7779  4ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   7780  4ffc				  -	      ORG	$10FF8
   7781  4ffc				  -	      RORG	$1FFF8
   7782  4ffc				  -	      ifconst	superchip
   7783  4ffc				  -	      .byte	"E","F","S","C"
   7784  4ffc				  -	      else
   7785  4ffc				  -	      .byte	"E","F","E","F"
   7786  4ffc				  -	      endif
   7787  4ffc				  -	      ORG	$10FFC
   7788  4ffc				  -	      RORG	$1FFFC
   7789  4ffc					      endif
   7790  4ffc				  -	      else
   7791  4ffc				  -	      ifconst	ROM2k
   7792  4ffc				  -	      ORG	$F7FC
   7793  4ffc				  -	      else
   7794  4ffc				  -	      ORG	$FFFC
   7795  4ffc				  -	      endif
   7796  4ffc					      endif
   7797  4ffc		       50 f3		      .word.w	(start & $ffff)
   7798  4ffe		       50 f3		      .word.w	(start & $ffff)
