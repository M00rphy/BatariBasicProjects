------- FILE e:\Documents\bB\demos\ex_multisprite_9_objects.bas.asm LEVEL 1 PASS 2
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"vcs.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; VCS.H
      4  5000 ????						; Version 1.05, 13/November/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_VCS =	105
      7  5000 ????
      8  5000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines hardware registers and memory mapping for the
     13  5000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  5000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  5000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  5000 ????						; with your views.  Please contribute, if you think you can improve this
     21  5000 ????						; file!
     22  5000 ????						;
     23  5000 ????						; Latest Revisions...
     24  5000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  5000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  5000 ????						;			    This will allow conditional code to verify VCS.H being
     27  5000 ????						;			    used for code assembly.
     28  5000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  5000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  5000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  5000 ????						;			 readability issue, and binary compatibility with disassembled
     32  5000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  5000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  5000 ????						;			 which was broken by the use of segments in this file, as
     35  5000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  5000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  5000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  5000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  5000 ????						;						   it is safe to leave it undefined, and the base address will
     40  5000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  5000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  5000 ????						;			  - register definitions are now generated through assignment
     43  5000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  5000 ????						;			    address architecture.
     45  5000 ????						; 1.0	22/MAR/2003		Initial release
     46  5000 ????
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????
     50  5000 ????						; TIA_BASE_ADDRESS
     51  5000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  5000 ????						; Normally 0, the base address should (externally, before including this file)
     53  5000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  5000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  5000 ????						; < $40 as a bankswitch.
     56  5000 ????
     57  5000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  5000 ????			  -TIA_BASE_ADDRESS =	0
     59  5000 ????				      ENDIF
     60  5000 ????
     61  5000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  5000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  5000 ????						; *OR* by declaring the label before including this file, eg:
     64  5000 ????						; TIA_BASE_ADDRESS = $40
     65  5000 ????						;   include "vcs.h"
     66  5000 ????
     67  5000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  5000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  5000 ????						; for the mirrored ROM hardware registers.
     70  5000 ????
     71  5000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  5000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  5000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  5000 ????
     75  5000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  5000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  5000 ????				      ENDIF
     78  5000 ????
     79  5000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  5000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  5000 ????				      ENDIF
     82  5000 ????
     83  5000 ????						;-------------------------------------------------------------------------------
     84  5000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  5000 ????				      SEG
    201  5000 ????
    202  5000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_multisprite_9_objects.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  5000 ????				      include	"macro.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????						; MACRO.H
      4  5000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  5000 ????
      6  5000 ????	       00 69	   VERSION_MACRO =	105
      7  5000 ????
      8  5000 ????						;
      9  5000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  5000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  5000 ????						;
     12  5000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  5000 ????						; It is distributed as a companion machine-specific support package
     14  5000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  5000 ????						; available at at http://www.atari2600.org/dasm
     16  5000 ????						;
     17  5000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  5000 ????						; contents, or would like to add something, please write to me
     19  5000 ????						; (atari2600@taswegian.com) with your contribution.
     20  5000 ????						;
     21  5000 ????						; Latest Revisions...
     22  5000 ????						;
     23  5000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  5000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  5000 ????						;			    used for code assembly.
     26  5000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  5000 ????						;
     28  5000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  5000 ????						;
     30  5000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  5000 ????						;			   (standardised macro for vertical synch code)
     32  5000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  5000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  5000 ????						; 1.0	22/MAR/2003		Initial release
     35  5000 ????
     36  5000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  5000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  5000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  5000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  5000 ????						;   registers and require them to be defined first).
     41  5000 ????
     42  5000 ????						; Available macros...
     43  5000 ????						;   SLEEP n		 - sleep for n cycles
     44  5000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  5000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  5000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  5000 ????
     48  5000 ????						;-------------------------------------------------------------------------------
     49  5000 ????						; SLEEP duration
     50  5000 ????						; Original author: Thomas Jentzsch
     51  5000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  5000 ????						; useful for code where precise timing is required.
     53  5000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  5000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  5000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  5000 ????
     57  5000 ????				      MAC	sleep
     58  5000 ????			   .CYCLES    SET	{1}
     59  5000 ????
     60  5000 ????				      IF	.CYCLES < 2
     61  5000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  5000 ????				      ERR
     63  5000 ????				      ENDIF
     64  5000 ????
     65  5000 ????				      IF	.CYCLES & 1
     66  5000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  5000 ????				      nop	0
     68  5000 ????				      ELSE
     69  5000 ????				      bit	VSYNC
     70  5000 ????				      ENDIF
     71  5000 ????			   .CYCLES    SET	.CYCLES - 3
     72  5000 ????				      ENDIF
     73  5000 ????
     74  5000 ????				      REPEAT	.CYCLES / 2
     75  5000 ????				      nop
     76  5000 ????				      REPEND
     77  5000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  5000 ????
     79  5000 ????						;-------------------------------------------------------------------------------
     80  5000 ????						; VERTICAL_SYNC
     81  5000 ????						; Original author: Manuel Polik
     82  5000 ????						; Inserts the code required for a proper 3 scannline 
     83  5000 ????						; vertical sync sequence
     84  5000 ????						;
     85  5000 ????						; Note: Alters the accumulator
     86  5000 ????						;
     87  5000 ????						; IN:
     88  5000 ????						; OUT: A = 1
     89  5000 ????
     90  5000 ????				      MAC	vertical_sync
     91  5000 ????				      LDA	#$02	; A = VSYNC enable
     92  5000 ????				      STA	WSYNC	; Finish current line
     93  5000 ????				      STA	VSYNC	; Start vertical sync
     94  5000 ????				      STA	WSYNC	; 1st line vertical sync
     95  5000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  5000 ????				      LSR		; A = VSYNC disable
     97  5000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  5000 ????				      STA	VSYNC	; Stop vertical sync
     99  5000 ????				      ENDM
    100  5000 ????
    101  5000 ????						;-------------------------------------------------------------------------------
    102  5000 ????						; CLEAN_START
    103  5000 ????						; Original author: Andrew Davie
    104  5000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  5000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  5000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  5000 ????						; Use as very first section of code on boot (ie: at reset)
    108  5000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  5000 ????
    110  5000 ????				      MAC	clean_start
    111  5000 ????				      sei
    112  5000 ????				      cld
    113  5000 ????
    114  5000 ????				      ldx	#0
    115  5000 ????				      txa
    116  5000 ????				      tay
    117  5000 ????			   .CLEAR_STACK dex
    118  5000 ????				      txs
    119  5000 ????				      pha
    120  5000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  5000 ????
    122  5000 ????				      ENDM
    123  5000 ????
    124  5000 ????						;-------------------------------------------------------
    125  5000 ????						; SET_POINTER
    126  5000 ????						; Original author: Manuel Rotschkar
    127  5000 ????						;
    128  5000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  5000 ????						;
    130  5000 ????						; Usage: SET_POINTER pointer, address
    131  5000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  5000 ????						;
    133  5000 ????						; Note: Alters the accumulator, NZ flags
    134  5000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  5000 ????						; IN 2: absolute address
    136  5000 ????
    137  5000 ????				      MAC	set_pointer
    138  5000 ????			   .POINTER   SET	{1}
    139  5000 ????			   .ADDRESS   SET	{2}
    140  5000 ????
    141  5000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  5000 ????				      STA	.POINTER	; Store in pointer
    143  5000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  5000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  5000 ????
    146  5000 ????				      ENDM
    147  5000 ????
    148  5000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_multisprite_9_objects.bas.asm
------- FILE multisprite.h LEVEL 2 PASS 2
      0  5000 ????				      include	"multisprite.h"
      1  5000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  5000 ????
      3  5000 ????	       00 80	   missile0x  =	$80
      4  5000 ????	       00 81	   missile1x  =	$81
      5  5000 ????	       00 82	   ballx      =	$82
      6  5000 ????
      7  5000 ????						; multisprite stuff below - 5 bytes each starting with spritex
      8  5000 ????
      9  5000 ????	       00 83	   SpriteIndex =	$83
     10  5000 ????
     11  5000 ????	       00 84	   player0x   =	$84
     12  5000 ????	       00 85	   NewSpriteX =	$85	;		X position
     13  5000 ????	       00 85	   player1x   =	$85
     14  5000 ????	       00 86	   player2x   =	$86
     15  5000 ????	       00 87	   player3x   =	$87
     16  5000 ????	       00 88	   player4x   =	$88
     17  5000 ????	       00 89	   player5x   =	$89
     18  5000 ????
     19  5000 ????	       00 8a	   objecty    =	$8A
     20  5000 ????	       00 8a	   missile0y  =	$8A
     21  5000 ????	       00 8b	   missile1y  =	$8B
     22  5000 ????	       00 8c	   bally      =	$8C
     23  5000 ????
     24  5000 ????	       00 8d	   player0y   =	$8D
     25  5000 ????	       00 8e	   NewSpriteY =	$8E	;		Y position
     26  5000 ????	       00 8e	   player1y   =	$8E
     27  5000 ????	       00 8f	   player2y   =	$8F
     28  5000 ????	       00 90	   player3y   =	$90
     29  5000 ????	       00 91	   player4y   =	$91
     30  5000 ????	       00 92	   player5y   =	$92
     31  5000 ????
     32  5000 ????	       00 93	   NewNUSIZ   =	$93
     33  5000 ????	       00 93	   _NUSIZ1    =	$93
     34  5000 ????	       00 94	   NUSIZ2     =	$94
     35  5000 ????	       00 95	   NUSIZ3     =	$95
     36  5000 ????	       00 96	   NUSIZ4     =	$96
     37  5000 ????	       00 97	   NUSIZ5     =	$97
     38  5000 ????
     39  5000 ????	       00 98	   NewCOLUP1  =	$98
     40  5000 ????	       00 98	   _COLUP1    =	$98
     41  5000 ????	       00 99	   COLUP2     =	$99
     42  5000 ????	       00 9a	   COLUP3     =	$9A
     43  5000 ????	       00 9b	   COLUP4     =	$9B
     44  5000 ????	       00 9c	   COLUP5     =	$9C
     45  5000 ????
     46  5000 ????	       00 9d	   SpriteGfxIndex =	$9D
     47  5000 ????
     48  5000 ????	       00 a2	   player0pointer =	$A2
     49  5000 ????	       00 a2	   player0pointerlo =	$A2
     50  5000 ????	       00 a3	   player0pointerhi =	$A3
     51  5000 ????
     52  5000 ????						;P0Top = temp5
     53  5000 ????	       00 cf	   P0Top      =	$CF	; changed to hard value to avoid dasm issues
     54  5000 ????	       00 a4	   P0Bottom   =	$A4
     55  5000 ????	       00 a5	   P1Bottom   =	$A5
     56  5000 ????
     57  5000 ????	       00 a6	   player1pointerlo =	$A6
     58  5000 ????	       00 a7	   player2pointerlo =	$A7
     59  5000 ????	       00 a8	   player3pointerlo =	$A8
     60  5000 ????	       00 a9	   player4pointerlo =	$A9
     61  5000 ????	       00 aa	   player5pointerlo =	$AA
     62  5000 ????
     63  5000 ????	       00 ab	   player1pointerhi =	$AB
     64  5000 ????	       00 ac	   player2pointerhi =	$AC
     65  5000 ????	       00 ad	   player3pointerhi =	$AD
     66  5000 ????	       00 ae	   player4pointerhi =	$AE
     67  5000 ????	       00 af	   player5pointerhi =	$AF
     68  5000 ????
     69  5000 ????	       00 b0	   player0height =	$B0
     70  5000 ????	       00 b1	   spriteheight =	$B1	; heights of multiplexed player sprite
     71  5000 ????	       00 b1	   player1height =	$B1
     72  5000 ????	       00 b2	   player2height =	$B2
     73  5000 ????	       00 b3	   player3height =	$B3
     74  5000 ????	       00 b4	   player4height =	$B4
     75  5000 ????	       00 b5	   player5height =	$B5
     76  5000 ????
     77  5000 ????	       00 b6	   PF1temp1   =	$B6
     78  5000 ????	       00 b7	   PF1temp2   =	$B7
     79  5000 ????	       00 b8	   PF2temp1   =	$B8
     80  5000 ????	       00 b9	   PF2temp2   =	$B9
     81  5000 ????
     82  5000 ????	       00 ba	   pfpixelheight =	$BA
     83  5000 ????
     84  5000 ????						; playfield is now a pointer to graphics
     85  5000 ????	       00 bb	   playfield  =	$BB
     86  5000 ????	       00 bb	   PF1pointer =	$BB
     87  5000 ????
     88  5000 ????	       00 bd	   PF2pointer =	$BD
     89  5000 ????
     90  5000 ????	       00 bf	   statusbarlength =	$BF
     91  5000 ????	       00 bf	   aux3       =	$BF
     92  5000 ????
     93  5000 ????	       00 c0	   lifecolor  =	$C0
     94  5000 ????	       00 c0	   pfscorecolor =	$C0
     95  5000 ????	       00 c0	   aux4       =	$C0
     96  5000 ????
     97  5000 ????						;P1display = temp2 ; temp2 and temp3
     98  5000 ????	       00 cc	   P1display  =	$cc	; changed to hard value to avoid dasm issues
     99  5000 ????	       00 c1	   lifepointer =	$c1
    100  5000 ????	       00 c2	   lives      =	$c2
    101  5000 ????	       00 c1	   pfscore1   =	$c1
    102  5000 ????	       00 c2	   pfscore2   =	$c2
    103  5000 ????	       00 c1	   aux5       =	$c1
    104  5000 ????	       00 c2	   aux6       =	$c2
    105  5000 ????
    106  5000 ????	       00 c3	   playfieldpos =	$C3
    107  5000 ????
    108  5000 ????						;RepoLine = temp4
    109  5000 ????	       00 ce	   RepoLine   =	$ce	; changed to hard value to avoid dasm issues
    110  5000 ????
    111  5000 ????	       00 c4	   pfheight   =	$C4
    112  5000 ????	       00 c5	   scorepointers =	$C5
    113  5000 ????
    114  5000 ????	       00 cb	   temp1      =	$CB	;used by kernel.  can be used in program too, but
    115  5000 ????	       00 cc	   temp2      =	$CC	;are obliterated when drawscreen is called.
    116  5000 ????	       00 cd	   temp3      =	$CD
    117  5000 ????	       00 ce	   temp4      =	$CE
    118  5000 ????	       00 cf	   temp5      =	$CF
    119  5000 ????	       00 d0	   temp6      =	$D0
    120  5000 ????	       00 d1	   temp7      =	$D1	; This is used to aid in bankswitching
    121  5000 ????
    122  5000 ????	       00 d2	   score      =	$D2
    123  5000 ????	       00 d5	   scorecolor =	$D5	;need to find other places for these, possibly...
    124  5000 ????	       00 d6	   rand       =	$D6
    125  5000 ????
    126  5000 ????
    127  5000 ????
    128  5000 ????	       00 d7	   A	      =	$d7
    129  5000 ????	       00 d7	   a	      =	$d7
    130  5000 ????	       00 d8	   B	      =	$d8
    131  5000 ????	       00 d8	   b	      =	$d8
    132  5000 ????	       00 d9	   C	      =	$d9
    133  5000 ????	       00 d9	   c	      =	$d9
    134  5000 ????	       00 da	   D	      =	$da
    135  5000 ????	       00 da	   d	      =	$da
    136  5000 ????	       00 db	   E	      =	$db
    137  5000 ????	       00 db	   e	      =	$db
    138  5000 ????	       00 dc	   F	      =	$dc
    139  5000 ????	       00 dc	   f	      =	$dc
    140  5000 ????	       00 dd	   G	      =	$dd
    141  5000 ????	       00 dd	   g	      =	$dd
    142  5000 ????	       00 de	   H	      =	$de
    143  5000 ????	       00 de	   h	      =	$de
    144  5000 ????	       00 df	   I	      =	$df
    145  5000 ????	       00 df	   i	      =	$df
    146  5000 ????	       00 e0	   J	      =	$e0
    147  5000 ????	       00 e0	   j	      =	$e0
    148  5000 ????	       00 e1	   K	      =	$e1
    149  5000 ????	       00 e1	   k	      =	$e1
    150  5000 ????	       00 e2	   L	      =	$e2
    151  5000 ????	       00 e2	   l	      =	$e2
    152  5000 ????	       00 e3	   M	      =	$e3
    153  5000 ????	       00 e3	   m	      =	$e3
    154  5000 ????	       00 e4	   N	      =	$e4
    155  5000 ????	       00 e4	   n	      =	$e4
    156  5000 ????	       00 e5	   O	      =	$e5
    157  5000 ????	       00 e5	   o	      =	$e5
    158  5000 ????	       00 e6	   P	      =	$e6
    159  5000 ????	       00 e6	   p	      =	$e6
    160  5000 ????	       00 e7	   Q	      =	$e7
    161  5000 ????	       00 e7	   q	      =	$e7
    162  5000 ????	       00 e8	   R	      =	$e8
    163  5000 ????	       00 e8	   r	      =	$e8
    164  5000 ????	       00 e9	   S	      =	$e9
    165  5000 ????	       00 e9	   s	      =	$e9
    166  5000 ????	       00 ea	   T	      =	$ea
    167  5000 ????	       00 ea	   t	      =	$ea
    168  5000 ????	       00 eb	   U	      =	$eb
    169  5000 ????	       00 eb	   u	      =	$eb
    170  5000 ????	       00 ec	   V	      =	$ec
    171  5000 ????	       00 ec	   v	      =	$ec
    172  5000 ????	       00 ed	   W	      =	$ed
    173  5000 ????	       00 ed	   w	      =	$ed
    174  5000 ????	       00 ee	   X	      =	$ee
    175  5000 ????	       00 ee	   x	      =	$ee
    176  5000 ????	       00 ef	   Y	      =	$ef
    177  5000 ????	       00 ef	   y	      =	$ef
    178  5000 ????	       00 f0	   Z	      =	$f0
    179  5000 ????	       00 f0	   z	      =	$f0
    180  5000 ????
    181  5000 ????	       00 f1	   spritesort =	$f1	; helps with flickersort
    182  5000 ????	       00 f2	   spritesort2 =	$f2	; helps with flickersort
    183  5000 ????	       00 f3	   spritesort3 =	$f3
    184  5000 ????	       00 f4	   spritesort4 =	$f4
    185  5000 ????	       00 f5	   spritesort5 =	$f5
    186  5000 ????
    187  5000 ????	       00 f6	   stack1     =	$f6
    188  5000 ????	       00 f7	   stack2     =	$f7
    189  5000 ????	       00 f8	   stack3     =	$f8
    190  5000 ????	       00 f9	   stack4     =	$f9
    191  5000 ????						; the stack bytes above may be used in the kernel
    192  5000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    193  5000 ????
    194  5000 ????				      MAC	return
    195  5000 ????				      ifnconst	bankswitch
    196  5000 ????				      rts
    197  5000 ????				      else
    198  5000 ????				      jmp	BS_return
    199  5000 ????				      endif
    200  5000 ????				      ENDM		; auto-return from either a regular or bankswitched module
------- FILE e:\Documents\bB\demos\ex_multisprite_9_objects.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  5000 ????				      include	"2600basic_variable_redefs.h"
      1  5000 ????						; This file contains variable mapping and other information for the current project.
      2  5000 ????
      3  5000 ????	       00 04	   _Data_MB_Width_length =	.skipL0238-_Data_MB_Width
      4  5000 ????
      5  5000 ????	       00 03	   _Data_Sprite_Size_length =	.skipL0237-_Data_Sprite_Size
      6  5000 ????
      7  5000 ????	       00 20	   bscode_length =	32
      8  5000 ????	       00 03	   _Data_1to5_Width_length =	.skipL0145-_Data_1to5_Width
      9  5000 ????
     10  5000 ????	       00 03	   _Data_Sprite0_Width_length =	.skipL0144-_Data_Sprite0_Width
     11  5000 ????
     12  5000 ????	       00 04	   _Data_M_B_x_Size_length =	.skipL0143-_Data_M_B_x_Size
     13  5000 ????
     14  5000 ????	       00 08	   _Ball      =	8
     15  5000 ????
     16  5000 ????	       00 07	   _Missile1  =	7
     17  5000 ????
     18  5000 ????	       00 06	   _Missile0  =	6
     19  5000 ????
     20  5000 ????	       00 05	   _Sprite5   =	5
     21  5000 ????
     22  5000 ????	       00 04	   _Sprite4   =	4
     23  5000 ????
     24  5000 ????	       00 03	   _Sprite3   =	3
     25  5000 ????
     26  5000 ????	       00 02	   _Sprite2   =	2
     27  5000 ????
     28  5000 ????	       00 01	   _Sprite1   =	1
     29  5000 ????
     30  5000 ????	       00 00	   _Sprite0   =	0
     31  5000 ????
     32  5000 ????	       00 d4	   _sc3       =	score + 2
     33  5000 ????
     34  5000 ????	       00 d3	   _sc2       =	score + 1
     35  5000 ????
     36  5000 ????	       00 d2	   _sc1       =	score
     37  5000 ????
     38  5000 ????	       00 f0	   rand16     =	z
     39  5000 ????
     40  5000 ????	       00 ef	   _Memy      =	y
     41  5000 ????
     42  5000 ????	       00 ee	   _Memx      =	x
     43  5000 ????
     44  5000 ????	       00 ea	   _Bit3_Flip_p0 =	t
     45  5000 ????
     46  5000 ????	       00 ea	   _Bit2_Activate_Jiggle =	t
     47  5000 ????
     48  5000 ????	       00 ea	   _Bit1_Joy0_Restrainer =	t
     49  5000 ????
     50  5000 ????	       00 ea	   _Bit0_Reset_Restrainer =	t
     51  5000 ????
     52  5000 ????	       00 e6	   _P0_NUSIZ  =	p
     53  5000 ????
     54  5000 ????	       00 e5	   _Jiggle_Counter =	o
     55  5000 ????
     56  5000 ????	       00 e4	   _Ball_Width =	n
     57  5000 ????
     58  5000 ????	       00 e3	   _Missile1_Width =	m
     59  5000 ????
     60  5000 ????	       00 e2	   _Missile0_Width =	l
     61  5000 ????
     62  5000 ????	       00 dd	   _Sprite_Size5 =	g
     63  5000 ????
     64  5000 ????	       00 dc	   _Sprite_Size4 =	f
     65  5000 ????
     66  5000 ????	       00 db	   _Sprite_Size3 =	e
     67  5000 ????
     68  5000 ????	       00 da	   _Sprite_Size2 =	d
     69  5000 ????
     70  5000 ????	       00 d9	   _Sprite_Size1 =	c
     71  5000 ????
     72  5000 ????	       00 d8	   _Sprite_Size0 =	b
     73  5000 ????
     74  5000 ????	       00 d7	   _Current_Object =	a
     75  5000 ????
     76  5000 ????	       00 03	   bs_mask    =	3
     77  5000 ????	       00 10	   bankswitch =	16
     78  5000 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     79  5000 ????	       00 01	   multisprite =	1
------- FILE e:\Documents\bB\demos\ex_multisprite_9_objects.bas.asm
      8  5000 ????				      ifconst	bankswitch
      9  5000 ????			  -	      if	bankswitch == 8
     10  5000 ????			  -	      ORG	$1000
     11  5000 ????			  -	      RORG	$D000
     12  5000 ????				      endif
     13  5000 ????				      if	bankswitch == 16
     14  1000					      ORG	$1000
     15  1000					      RORG	$9000
     16  1000					      endif
     17  1000				  -	      if	bankswitch == 32
     18  1000				  -	      ORG	$1000
     19  1000				  -	      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	234	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .
     57  1000							; 
     58  1000
     59  1000				   .
     60  1000							; 
     61  1000
     62  1000				   .
     63  1000							; 
     64  1000
     65  1000				   .
     66  1000							; 
     67  1000
     68  1000				   .
     69  1000							; 
     70  1000
     71  1000				   .
     72  1000							; 
     73  1000
     74  1000				   .
     75  1000							; 
     76  1000
     77  1000				   .
     78  1000							; 
     79  1000
     80  1000				   .
     81  1000							; 
     82  1000
     83  1000				   .
     84  1000							; 
     85  1000
     86  1000				   .
     87  1000							; 
     88  1000
     89  1000				   .
     90  1000							; 
     91  1000
     92  1000				   .
     93  1000							; 
     94  1000
     95  1000				   .
     96  1000							; 
     97  1000
     98  1000				   .
     99  1000							; 
    100  1000
    101  1000				   .
    102  1000							; 
    103  1000
    104  1000				   .
    105  1000							; 
    106  1000
    107  1000				   .
    108  1000							; 
    109  1000
    110  1000				   .
    111  1000							; 
    112  1000
    113  1000				   .
    114  1000							; 
    115  1000
    116  1000				   .
    117  1000							; 
    118  1000
    119  1000				   .
    120  1000							; 
    121  1000
    122  1000				   .
    123  1000							; 
    124  1000
    125  1000				   .
    126  1000							; 
    127  1000
    128  1000				   .
    129  1000							; 
    130  1000
    131  1000				   .
    132  1000							; 
    133  1000
    134  1000				   .
    135  1000							; 
    136  1000
    137  1000				   .
    138  1000							; 
    139  1000
    140  1000				   .
    141  1000							; 
    142  1000
    143  1000				   .
    144  1000							; 
    145  1000
    146  1000				   .
    147  1000							; 
    148  1000
    149  1000				   .
    150  1000							; 
    151  1000
    152  1000				   .
    153  1000							; 
    154  1000
    155  1000				   .L00 		;  includesfile multisprite_bankswitch.inc
    156  1000
    157  1000				   .L01 		;  set kernel multisprite
    158  1000
    159  1000				   .L02 		;  set romsize 16k
    160  1000
    161  1000				   .
    162  1000							; 
    163  1000
    164  1000				   .
    165  1000							; 
    166  1000
    167  1000				   .
    168  1000							; 
    169  1000
    170  1000				   .
    171  1000							; 
    172  1000
    173  1000				   .
    174  1000							; 
    175  1000
    176  1000				   .
    177  1000							; 
    178  1000
    179  1000				   .
    180  1000							; 
    181  1000
    182  1000				   .
    183  1000							; 
    184  1000
    185  1000				   .
    186  1000							; 
    187  1000
    188  1000				   .
    189  1000							; 
    190  1000
    191  1000				   .
    192  1000							; 
    193  1000
    194  1000				   .
    195  1000							; 
    196  1000
    197  1000				   .
    198  1000							; 
    199  1000
    200  1000				   .
    201  1000							; 
    202  1000
    203  1000				   .
    204  1000							; 
    205  1000
    206  1000				   .
    207  1000							; 
    208  1000
    209  1000				   .
    210  1000							; 
    211  1000
    212  1000				   .
    213  1000							; 
    214  1000
    215  1000				   .
    216  1000							; 
    217  1000
    218  1000				   .
    219  1000							; 
    220  1000
    221  1000				   .
    222  1000							; 
    223  1000
    224  1000				   .
    225  1000							; 
    226  1000
    227  1000				   .
    228  1000							; 
    229  1000
    230  1000				   .
    231  1000							; 
    232  1000
    233  1000				   .
    234  1000							; 
    235  1000
    236  1000				   .
    237  1000							; 
    238  1000
    239  1000				   .
    240  1000							; 
    241  1000
    242  1000				   .
    243  1000							; 
    244  1000
    245  1000				   .
    246  1000							; 
    247  1000
    248  1000				   .L03 		;  dim _Current_Object  =  a
    249  1000
    250  1000				   .
    251  1000							; 
    252  1000
    253  1000				   .
    254  1000							; 
    255  1000
    256  1000				   .
    257  1000							; 
    258  1000
    259  1000				   .
    260  1000							; 
    261  1000
    262  1000				   .L04 		;  dim _Sprite_Size0  =  b
    263  1000
    264  1000				   .L05 		;  dim _Sprite_Size1  =  c
    265  1000
    266  1000				   .L06 		;  dim _Sprite_Size2  =  d
    267  1000
    268  1000				   .L07 		;  dim _Sprite_Size3  =  e
    269  1000
    270  1000				   .L08 		;  dim _Sprite_Size4  =  f
    271  1000
    272  1000				   .L09 		;  dim _Sprite_Size5  =  g
    273  1000
    274  1000				   .
    275  1000							; 
    276  1000
    277  1000				   .
    278  1000							; 
    279  1000
    280  1000				   .
    281  1000							; 
    282  1000
    283  1000				   .
    284  1000							; 
    285  1000
    286  1000				   .L010		;  dim _Missile0_Width  =  l
    287  1000
    288  1000				   .L011		;  dim _Missile1_Width  =  m
    289  1000
    290  1000				   .
    291  1000							; 
    292  1000
    293  1000				   .
    294  1000							; 
    295  1000
    296  1000				   .
    297  1000							; 
    298  1000
    299  1000				   .
    300  1000							; 
    301  1000
    302  1000				   .L012		;  dim _Ball_Width  =	n
    303  1000
    304  1000				   .
    305  1000							; 
    306  1000
    307  1000				   .
    308  1000							; 
    309  1000
    310  1000				   .
    311  1000							; 
    312  1000
    313  1000				   .
    314  1000							; 
    315  1000
    316  1000				   .L013		;  dim _Jiggle_Counter  =  o
    317  1000
    318  1000				   .
    319  1000							; 
    320  1000
    321  1000				   .
    322  1000							; 
    323  1000
    324  1000				   .
    325  1000							; 
    326  1000
    327  1000				   .
    328  1000							; 
    329  1000
    330  1000				   .L014		;  dim _P0_NUSIZ  =  p
    331  1000
    332  1000				   .
    333  1000							; 
    334  1000
    335  1000				   .
    336  1000							; 
    337  1000
    338  1000				   .
    339  1000							; 
    340  1000
    341  1000				   .
    342  1000							; 
    343  1000
    344  1000				   .L015		;  dim _Bit0_Reset_Restrainer	=  t
    345  1000
    346  1000				   .L016		;  dim _Bit1_Joy0_Restrainer  =  t
    347  1000
    348  1000				   .L017		;  dim _Bit2_Activate_Jiggle  =  t
    349  1000
    350  1000				   .L018		;  dim _Bit3_Flip_p0  =  t
    351  1000
    352  1000				   .
    353  1000							; 
    354  1000
    355  1000				   .
    356  1000							; 
    357  1000
    358  1000				   .
    359  1000							; 
    360  1000
    361  1000				   .
    362  1000							; 
    363  1000
    364  1000				   .L019		;  dim _Memx  =  x
    365  1000
    366  1000				   .L020		;  dim _Memy  =  y
    367  1000
    368  1000				   .
    369  1000							; 
    370  1000
    371  1000				   .
    372  1000							; 
    373  1000
    374  1000				   .
    375  1000							; 
    376  1000
    377  1000				   .
    378  1000							; 
    379  1000
    380  1000				   .L021		;  dim rand16	=  z
    381  1000
    382  1000				   .
    383  1000							; 
    384  1000
    385  1000				   .
    386  1000							; 
    387  1000
    388  1000				   .
    389  1000							; 
    390  1000
    391  1000				   .
    392  1000							; 
    393  1000
    394  1000				   .L022		;  dim _sc1  =  score
    395  1000
    396  1000				   .L023		;  dim _sc2  =  score + 1
    397  1000
    398  1000				   .L024		;  dim _sc3  =  score + 2
    399  1000
    400  1000				   .
    401  1000							; 
    402  1000
    403  1000				   .
    404  1000							; 
    405  1000
    406  1000				   .
    407  1000							; 
    408  1000
    409  1000				   .
    410  1000							; 
    411  1000
    412  1000				   .
    413  1000							; 
    414  1000
    415  1000				   .
    416  1000							; 
    417  1000
    418  1000				   .
    419  1000							; 
    420  1000
    421  1000				   .L025		;  const _Sprite0  =  0
    422  1000
    423  1000				   .L026		;  const _Sprite1  =  1
    424  1000
    425  1000				   .L027		;  const _Sprite2  =  2
    426  1000
    427  1000				   .L028		;  const _Sprite3  =  3
    428  1000
    429  1000				   .L029		;  const _Sprite4  =  4
    430  1000
    431  1000				   .L030		;  const _Sprite5  =  5
    432  1000
    433  1000				   .L031		;  const _Missile0  =	6
    434  1000
    435  1000				   .L032		;  const _Missile1  =	7
    436  1000
    437  1000				   .L033		;  const _Ball  =  8
    438  1000
    439  1000				   .
    440  1000							; 
    441  1000
    442  1000				   .
    443  1000							; 
    444  1000
    445  1000				   .
    446  1000							; 
    447  1000
    448  1000				   .
    449  1000							; 
    450  1000
    451  1000				   .
    452  1000							; 
    453  1000
    454  1000				   .
    455  1000							; 
    456  1000
    457  1000				   .
    458  1000							; 
    459  1000
    460  1000				   .
    461  1000							; 
    462  1000
    463  1000				   .
    464  1000							; 
    465  1000
    466  1000				   .
    467  1000							; 
    468  1000
    469  1000				   .
    470  1000							; 
    471  1000
    472  1000				   .__Start_Restart
    473  1000							; __Start_Restart
    474  1000
    475  1000				   .
    476  1000							; 
    477  1000
    478  1000				   .
    479  1000							; 
    480  1000
    481  1000				   .
    482  1000							; 
    483  1000
    484  1000				   .
    485  1000							; 
    486  1000
    487  1000				   .
    488  1000							; 
    489  1000
    490  1000				   .
    491  1000							; 
    492  1000
    493  1000				   .L034		;  drawscreen
    494  1000
    495  1000		       85 d1		      sta	temp7
    496  1002		       a9 90		      lda	#>(ret_point1-1)
    497  1004		       48		      pha
    498  1005		       a9 17		      lda	#<(ret_point1-1)
    499  1007		       48		      pha
    500  1008		       a9 f0		      lda	#>(drawscreen-1)
    501  100a		       48		      pha
    502  100b		       a9 39		      lda	#<(drawscreen-1)
    503  100d		       48		      pha
    504  100e		       a5 d1		      lda	temp7
    505  1010		       48		      pha
    506  1011		       8a		      txa
    507  1012		       48		      pha
    508  1013		       a2 04		      ldx	#4
    509  1015		       4c eb ff 	      jmp	BS_jsr
    510  1018				   ret_point1
    511  1018				   .
    512  1018							; 
    513  1018
    514  1018				   .
    515  1018							; 
    516  1018
    517  1018				   .
    518  1018							; 
    519  1018
    520  1018				   .
    521  1018							; 
    522  1018
    523  1018				   .
    524  1018							; 
    525  1018
    526  1018				   .
    527  1018							; 
    528  1018
    529  1018				   .L035		;  player0:
    530  1018
    531  1018		       a2 5a		      LDX	#<playerL035_0
    532  101a		       86 a2		      STX	player0pointerlo
    533  101c		       a9 f4		      LDA	#>playerL035_0
    534  101e		       85 a3		      STA	player0pointerhi
    535  1020		       a9 09		      LDA	#9
    536  1022		       85 b0		      STA	player0height
    537  1024				   .
    538  1024							; 
    539  1024
    540  1024				   .
    541  1024							; 
    542  1024
    543  1024				   .L036		;    player1:
    544  1024
    545  1024		       a2 63		      LDX	#<playerL036_1
    546  1026		       86 a6		      STX	player1pointerlo
    547  1028		       a9 f4		      LDA	#>playerL036_1
    548  102a		       85 ab		      STA	player1pointerhi
    549  102c		       a9 08		      LDA	#8
    550  102e		       85 b1		      STA	player1height
    551  1030				   .
    552  1030							; 
    553  1030
    554  1030				   .
    555  1030							; 
    556  1030
    557  1030				   .L037		;  player2:
    558  1030
    559  1030		       a2 6a		      LDX	#<playerL037_2
    560  1032		       86 a7		      STX	player2pointerlo
    561  1034		       a9 f4		      LDA	#>playerL037_2
    562  1036		       85 ac		      STA	player2pointerhi
    563  1038		       a9 08		      LDA	#8
    564  103a		       85 b2		      STA	player2height
    565  103c				   .
    566  103c							; 
    567  103c
    568  103c				   .
    569  103c							; 
    570  103c
    571  103c				   .L038		;  player3:
    572  103c
    573  103c		       a2 71		      LDX	#<playerL038_3
    574  103e		       86 a8		      STX	player3pointerlo
    575  1040		       a9 f4		      LDA	#>playerL038_3
    576  1042		       85 ad		      STA	player3pointerhi
    577  1044		       a9 08		      LDA	#8
    578  1046		       85 b3		      STA	player3height
    579  1048				   .
    580  1048							; 
    581  1048
    582  1048				   .
    583  1048							; 
    584  1048
    585  1048				   .L039		;  player4:
    586  1048
    587  1048		       a2 78		      LDX	#<playerL039_4
    588  104a		       86 a9		      STX	player4pointerlo
    589  104c		       a9 f4		      LDA	#>playerL039_4
    590  104e		       85 ae		      STA	player4pointerhi
    591  1050		       a9 08		      LDA	#8
    592  1052		       85 b4		      STA	player4height
    593  1054				   .
    594  1054							; 
    595  1054
    596  1054				   .
    597  1054							; 
    598  1054
    599  1054				   .L040		;  player5:
    600  1054
    601  1054		       a2 7f		      LDX	#<playerL040_5
    602  1056		       86 aa		      STX	player5pointerlo
    603  1058		       a9 f4		      LDA	#>playerL040_5
    604  105a		       85 af		      STA	player5pointerhi
    605  105c		       a9 08		      LDA	#8
    606  105e		       85 b5		      STA	player5height
    607  1060				   .
    608  1060							; 
    609  1060
    610  1060				   .
    611  1060							; 
    612  1060
    613  1060				   .
    614  1060							; 
    615  1060
    616  1060				   .
    617  1060							; 
    618  1060
    619  1060				   .
    620  1060							; 
    621  1060
    622  1060				   .
    623  1060							; 
    624  1060
    625  1060				   .L041		;  player0x  =  77  :	player0y  =  88
    626  1060
    627  1060		       a9 4d		      LDA	#77
    628  1062		       85 84		      STA	player0x
    629  1064		       a9 58		      LDA	#88
    630  1066		       85 8d		      STA	player0y
    631  1068				   .L042		;  player1x  =  85  :	player1y  =  player0y  -  18
    632  1068
    633  1068		       a9 55		      LDA	#85
    634  106a		       85 85		      STA	player1x
    635  106c		       a5 8d		      LDA	player0y
    636  106e		       38		      SEC
    637  106f		       e9 12		      SBC	#18
    638  1071		       85 8e		      STA	player1y
    639  1073				   .L043		;  player2x  =  85  :	player2y  =  player1y  -  15
    640  1073
    641  1073		       a9 55		      LDA	#85
    642  1075		       85 86		      STA	player2x
    643  1077		       a5 8e		      LDA	player1y
    644  1079		       38		      SEC
    645  107a		       e9 0f		      SBC	#15
    646  107c		       85 8f		      STA	player2y
    647  107e				   .L044		;  player3x  =  85  :	player3y  =  player2y  -  15
    648  107e
    649  107e		       a9 55		      LDA	#85
    650  1080		       85 87		      STA	player3x
    651  1082		       a5 8f		      LDA	player2y
    652  1084		       38		      SEC
    653  1085		       e9 0f		      SBC	#15
    654  1087		       85 90		      STA	player3y
    655  1089				   .L045		;  player4x  =  85  :	player4y  =  player3y  -  15
    656  1089
    657  1089		       a9 55		      LDA	#85
    658  108b		       85 88		      STA	player4x
    659  108d		       a5 90		      LDA	player3y
    660  108f		       38		      SEC
    661  1090		       e9 0f		      SBC	#15
    662  1092		       85 91		      STA	player4y
    663  1094				   .L046		;  player5x  =  85  :	player5y  =  player4y  -  15
    664  1094
    665  1094		       a9 55		      LDA	#85
    666  1096		       85 89		      STA	player5x
    667  1098		       a5 91		      LDA	player4y
    668  109a		       38		      SEC
    669  109b		       e9 0f		      SBC	#15
    670  109d		       85 92		      STA	player5y
    671  109f				   .L047		;  missile0x  =  98  :  missile0y  =  78
    672  109f
    673  109f		       a9 62		      LDA	#98
    674  10a1		       85 80		      STA	missile0x
    675  10a3		       a9 4e		      LDA	#78
    676  10a5		       85 8a		      STA	missile0y
    677  10a7				   .L048		;  missile1x  =  98  :  missile1y  =  missile0y  -  15
    678  10a7
    679  10a7		       a9 62		      LDA	#98
    680  10a9		       85 81		      STA	missile1x
    681  10ab		       a5 8a		      LDA	missile0y
    682  10ad		       38		      SEC
    683  10ae		       e9 0f		      SBC	#15
    684  10b0		       85 8b		      STA	missile1y
    685  10b2				   .L049		;  ballx  =  98  :  bally  =  missile1y  -  15
    686  10b2
    687  10b2		       a9 62		      LDA	#98
    688  10b4		       85 82		      STA	ballx
    689  10b6		       a5 8b		      LDA	missile1y
    690  10b8		       38		      SEC
    691  10b9		       e9 0f		      SBC	#15
    692  10bb		       85 8c		      STA	bally
    693  10bd				   .
    694  10bd							; 
    695  10bd
    696  10bd				   .
    697  10bd							; 
    698  10bd
    699  10bd				   .
    700  10bd							; 
    701  10bd
    702  10bd				   .
    703  10bd							; 
    704  10bd
    705  10bd				   .
    706  10bd							; 
    707  10bd
    708  10bd				   .
    709  10bd							; 
    710  10bd
    711  10bd				   .L050		;  _NUSIZ1{3}	=  0  :  NUSIZ2{3}  =  0  :  NUSIZ3{3}	=  0
    712  10bd
    713  10bd		       a5 93		      LDA	_NUSIZ1
    714  10bf		       29 f7		      AND	#247
    715  10c1		       85 93		      STA	_NUSIZ1
    716  10c3		       a5 94		      LDA	NUSIZ2
    717  10c5		       29 f7		      AND	#247
    718  10c7		       85 94		      STA	NUSIZ2
    719  10c9		       a5 95		      LDA	NUSIZ3
    720  10cb		       29 f7		      AND	#247
    721  10cd		       85 95		      STA	NUSIZ3
    722  10cf				   .L051		;  NUSIZ4{3}  =  0  :	NUSIZ5{3}  =  0
    723  10cf
    724  10cf		       a5 96		      LDA	NUSIZ4
    725  10d1		       29 f7		      AND	#247
    726  10d3		       85 96		      STA	NUSIZ4
    727  10d5		       a5 97		      LDA	NUSIZ5
    728  10d7		       29 f7		      AND	#247
    729  10d9		       85 97		      STA	NUSIZ5
    730  10db				   .
    731  10db							; 
    732  10db
    733  10db				   .
    734  10db							; 
    735  10db
    736  10db				   .
    737  10db							; 
    738  10db
    739  10db				   .
    740  10db							; 
    741  10db
    742  10db				   .
    743  10db							; 
    744  10db
    745  10db				   .
    746  10db							; 
    747  10db
    748  10db				   .L052		;  AUDV0  =  0  :  AUDV1  =  0
    749  10db
    750  10db		       a9 00		      LDA	#0
    751  10dd		       85 19		      STA	AUDV0
    752  10df		       85 1a		      STA	AUDV1
    753  10e1				   .
    754  10e1							; 
    755  10e1
    756  10e1				   .
    757  10e1							; 
    758  10e1
    759  10e1				   .
    760  10e1							; 
    761  10e1
    762  10e1				   .
    763  10e1							; 
    764  10e1
    765  10e1				   .
    766  10e1							; 
    767  10e1
    768  10e1				   .
    769  10e1							; 
    770  10e1
    771  10e1				   .
    772  10e1							; 
    773  10e1
    774  10e1				   .
    775  10e1							; 
    776  10e1
    777  10e1				   .L053		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    778  10e1
    779  10e1		       a9 00		      LDA	#0
    780  10e3		       85 d7		      STA	a
    781  10e5		       85 d8		      STA	b
    782  10e7		       85 d9		      STA	c
    783  10e9		       85 da		      STA	d
    784  10eb		       85 db		      STA	e
    785  10ed		       85 dc		      STA	f
    786  10ef		       85 dd		      STA	g
    787  10f1		       85 de		      STA	h
    788  10f3		       85 df		      STA	i
    789  10f5				   .L054		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    790  10f5
    791  10f5		       a9 00		      LDA	#0
    792  10f7		       85 e0		      STA	j
    793  10f9		       85 e1		      STA	k
    794  10fb		       85 e2		      STA	l
    795  10fd		       85 e3		      STA	m
    796  10ff		       85 e4		      STA	n
    797  1101		       85 e5		      STA	o
    798  1103		       85 e6		      STA	p
    799  1105		       85 e7		      STA	q
    800  1107		       85 e8		      STA	r
    801  1109				   .L055		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0
    802  1109
    803  1109		       a9 00		      LDA	#0
    804  110b		       85 e9		      STA	s
    805  110d		       85 ea		      STA	t
    806  110f		       85 eb		      STA	u
    807  1111		       85 ec		      STA	v
    808  1113		       85 ed		      STA	w
    809  1115		       85 ee		      STA	x
    810  1117		       85 ef		      STA	y
    811  1119				   .
    812  1119							; 
    813  1119
    814  1119				   .
    815  1119							; 
    816  1119
    817  1119				   .
    818  1119							; 
    819  1119
    820  1119				   .
    821  1119							; 
    822  1119
    823  1119				   .
    824  1119							; 
    825  1119
    826  1119				   .
    827  1119							; 
    828  1119
    829  1119				   .
    830  1119							; 
    831  1119
    832  1119				   .L056		;  _Bit0_Reset_Restrainer{0}  =  1
    833  1119
    834  1119		       a5 ea		      LDA	_Bit0_Reset_Restrainer
    835  111b		       09 01		      ORA	#1
    836  111d		       85 ea		      STA	_Bit0_Reset_Restrainer
    837  111f				   .
    838  111f							; 
    839  111f
    840  111f				   .
    841  111f							; 
    842  111f
    843  111f				   .
    844  111f							; 
    845  111f
    846  111f				   .
    847  111f							; 
    848  111f
    849  111f				   .
    850  111f							; 
    851  111f
    852  111f				   .
    853  111f							; 
    854  111f
    855  111f				   .L057		;  _Missile0_Width  =	0  :  _Missile1_Width  =  0  :	_Ball_Width  =	0
    856  111f
    857  111f		       a9 00		      LDA	#0
    858  1121		       85 e2		      STA	_Missile0_Width
    859  1123		       85 e3		      STA	_Missile1_Width
    860  1125		       85 e4		      STA	_Ball_Width
    861  1127				   .
    862  1127							; 
    863  1127
    864  1127				   .
    865  1127							; 
    866  1127
    867  1127				   .
    868  1127							; 
    869  1127
    870  1127				   .
    871  1127							; 
    872  1127
    873  1127				   .
    874  1127							; 
    875  1127
    876  1127				   .
    877  1127							; 
    878  1127
    879  1127				   .
    880  1127							; 
    881  1127
    882  1127				   .
    883  1127							; 
    884  1127
    885  1127				   .
    886  1127							; 
    887  1127
    888  1127				   .
    889  1127							; 
    890  1127
    891  1127				   .
    892  1127							; 
    893  1127
    894  1127				   .__Main_Loop
    895  1127							; __Main_Loop
    896  1127
    897  1127				   .
    898  1127							; 
    899  1127
    900  1127				   .
    901  1127							; 
    902  1127
    903  1127				   .
    904  1127							; 
    905  1127
    906  1127				   .
    907  1127							; 
    908  1127
    909  1127				   .
    910  1127							; 
    911  1127
    912  1127				   .
    913  1127							; 
    914  1127
    915  1127				   .
    916  1127							; 
    917  1127
    918  1127				   .L058		;  COLUP0  =  $08  :  COLUP1  =  $BA  :  _COLUP1  =  $1A  :  COLUP2  =  $3A  :  COLUP3  =  $6A
    919  1127
    920  1127		       a9 08		      LDA	#$08
    921  1129		       85 06		      STA	COLUP0
    922  112b		       a9 ba		      LDA	#$BA
    923  112d		       85 07		      STA	COLUP1
    924  112f		       a9 1a		      LDA	#$1A
    925  1131		       85 98		      STA	_COLUP1
    926  1133		       a9 3a		      LDA	#$3A
    927  1135		       85 99		      STA	COLUP2
    928  1137		       a9 6a		      LDA	#$6A
    929  1139		       85 9a		      STA	COLUP3
    930  113b				   .
    931  113b							; 
    932  113b
    933  113b				   .L059		;  COLUP4  =  $8A  :  COLUP5  =  $CA  :  COLUBK =  0  :  COLUPF  =  $4A
    934  113b
    935  113b		       a9 8a		      LDA	#$8A
    936  113d		       85 9b		      STA	COLUP4
    937  113f		       a9 ca		      LDA	#$CA
    938  1141		       85 9c		      STA	COLUP5
    939  1143		       a9 00		      LDA	#0
    940  1145		       85 09		      STA	COLUBK
    941  1147		       a9 4a		      LDA	#$4A
    942  1149		       85 08		      STA	COLUPF
    943  114b				   .
    944  114b							; 
    945  114b
    946  114b				   .
    947  114b							; 
    948  114b
    949  114b				   .
    950  114b							; 
    951  114b
    952  114b				   .
    953  114b							; 
    954  114b
    955  114b				   .
    956  114b							; 
    957  114b
    958  114b				   .
    959  114b							; 
    960  114b
    961  114b				   .
    962  114b							; 
    963  114b
    964  114b				   .
    965  114b							; 
    966  114b
    967  114b				   .
    968  114b							; 
    969  114b
    970  114b				   .
    971  114b							; 
    972  114b
    973  114b				   .
    974  114b							; 
    975  114b
    976  114b				   .L060		;  if !joy0fire then _Bit1_Joy0_Restrainer{1}	=  0  :  goto __Skip_Fire_Button
    977  114b
    978  114b		       24 0c		      bit	INPT4
    979  114d		       10 09		      BPL	.skipL060
    980  114f				   .condpart0
    981  114f		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
    982  1151		       29 fd		      AND	#253
    983  1153		       85 ea		      STA	_Bit1_Joy0_Restrainer
    984  1155		       4c 2b 93 	      jmp	.__Skip_Fire_Button
    985  1158
    986  1158				   .skipL060
    987  1158				   .
    988  1158							; 
    989  1158
    990  1158				   .
    991  1158							; 
    992  1158
    993  1158				   .
    994  1158							; 
    995  1158
    996  1158				   .
    997  1158							; 
    998  1158
    999  1158				   .
   1000  1158							; 
   1001  1158
   1002  1158				   .L061		;  if !joy0up	&&  !joy0down  &&  !joy0left  &&  !joy0right then _Bit1_Joy0_Restrainer{1}  =  0
   1003  1158
   1004  1158		       a9 10		      lda	#$10
   1005  115a		       2c 80 02 	      bit	SWCHA
   1006  115d		       f0 17		      BEQ	.skipL061
   1007  115f				   .condpart1
   1008  115f		       a9 20		      lda	#$20
   1009  1161		       2c 80 02 	      bit	SWCHA
   1010  1164		       f0 10		      BEQ	.skip1then
   1011  1166				   .condpart2
   1012  1166		       2c 80 02 	      bit	SWCHA
   1013  1169		       50 0b		      BVC	.skip2then
   1014  116b				   .condpart3
   1015  116b		       2c 80 02 	      bit	SWCHA
   1016  116e		       10 06		      BPL	.skip3then
   1017  1170				   .condpart4
   1018  1170		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1019  1172		       29 fd		      AND	#253
   1020  1174		       85 ea		      STA	_Bit1_Joy0_Restrainer
   1021  1176				   .skip3then
   1022  1176				   .skip2then
   1023  1176				   .skip1then
   1024  1176				   .skipL061
   1025  1176				   .
   1026  1176							; 
   1027  1176
   1028  1176				   .
   1029  1176							; 
   1030  1176
   1031  1176				   .
   1032  1176							; 
   1033  1176
   1034  1176				   .
   1035  1176							; 
   1036  1176
   1037  1176				   .L062		;  if _Bit1_Joy0_Restrainer{1} then goto __Skip_Movement
   1038  1176
   1039  1176		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1040  1178		       29 02		      AND	#2
   1041  117a		       f0 03		      BEQ	.skipL062
   1042  117c				   .condpart5
   1043  117c		       4c 57 96 	      jmp	.__Skip_Movement
   1044  117f
   1045  117f				   .skipL062
   1046  117f				   .
   1047  117f							; 
   1048  117f
   1049  117f				   .
   1050  117f							; 
   1051  117f
   1052  117f				   .
   1053  117f							; 
   1054  117f
   1055  117f				   .
   1056  117f							; 
   1057  117f
   1058  117f				   .L063		;  if joy0up then _Bit1_Joy0_Restrainer{1}  =	1  :  _Bit2_Activate_Jiggle{2}	=  1  :  _Jiggle_Counter  =  0	:  _Current_Object  =  _Current_Object	-  1  :  if _Current_Object  >=  250 then _Current_Object  =  8
   1059  117f
   1060  117f		       a9 10		      lda	#$10
   1061  1181		       2c 80 02 	      bit	SWCHA
   1062  1184		       d0 1c		      BNE	.skipL063
   1063  1186				   .condpart6
   1064  1186		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1065  1188		       09 02		      ORA	#2
   1066  118a		       85 ea		      STA	_Bit1_Joy0_Restrainer
   1067  118c		       a5 ea		      LDA	_Bit2_Activate_Jiggle
   1068  118e		       09 04		      ORA	#4
   1069  1190		       85 ea		      STA	_Bit2_Activate_Jiggle
   1070  1192		       a9 00		      LDA	#0
   1071  1194		       85 e5		      STA	_Jiggle_Counter
   1072  1196		       c6 d7		      DEC	_Current_Object
   1073  1198		       a5 d7		      LDA	_Current_Object
   1074  119a		       c9 fa		      CMP	#250
   1075  119c		       90 04		      BCC	.skip6then
   1076  119e				   .condpart7
   1077  119e		       a9 08		      LDA	#8
   1078  11a0		       85 d7		      STA	_Current_Object
   1079  11a2				   .skip6then
   1080  11a2				   .skipL063
   1081  11a2				   .
   1082  11a2							; 
   1083  11a2
   1084  11a2				   .L064		;  if joy0down then _Bit1_Joy0_Restrainer{1}  =  1  :	_Bit2_Activate_Jiggle{2}  =  1	:  _Jiggle_Counter  =  0  :  _Current_Object  =  _Current_Object  +  1	:  if _Current_Object  >=  9 then _Current_Object  =  0
   1085  11a2
   1086  11a2		       a9 20		      lda	#$20
   1087  11a4		       2c 80 02 	      bit	SWCHA
   1088  11a7		       d0 1c		      BNE	.skipL064
   1089  11a9				   .condpart8
   1090  11a9		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1091  11ab		       09 02		      ORA	#2
   1092  11ad		       85 ea		      STA	_Bit1_Joy0_Restrainer
   1093  11af		       a5 ea		      LDA	_Bit2_Activate_Jiggle
   1094  11b1		       09 04		      ORA	#4
   1095  11b3		       85 ea		      STA	_Bit2_Activate_Jiggle
   1096  11b5		       a9 00		      LDA	#0
   1097  11b7		       85 e5		      STA	_Jiggle_Counter
   1098  11b9		       e6 d7		      INC	_Current_Object
   1099  11bb		       a5 d7		      LDA	_Current_Object
   1100  11bd		       c9 09		      CMP	#9
   1101  11bf		       90 04		      BCC	.skip8then
   1102  11c1				   .condpart9
   1103  11c1		       a9 00		      LDA	#0
   1104  11c3		       85 d7		      STA	_Current_Object
   1105  11c5				   .skip8then
   1106  11c5				   .skipL064
   1107  11c5				   .
   1108  11c5							; 
   1109  11c5
   1110  11c5				   .
   1111  11c5							; 
   1112  11c5
   1113  11c5				   .
   1114  11c5							; 
   1115  11c5
   1116  11c5				   .
   1117  11c5							; 
   1118  11c5
   1119  11c5				   .L065		;  if !joy0left then goto __Skip_Size_Decrease
   1120  11c5
   1121  11c5		       2c 80 02 	      bit	SWCHA
   1122  11c8		       50 03		      BVC	.skipL065
   1123  11ca				   .condpart10
   1124  11ca		       4c 78 92 	      jmp	.__Skip_Size_Decrease
   1125  11cd
   1126  11cd				   .skipL065
   1127  11cd				   .
   1128  11cd							; 
   1129  11cd
   1130  11cd				   .
   1131  11cd							; 
   1132  11cd
   1133  11cd				   .
   1134  11cd							; 
   1135  11cd
   1136  11cd				   .
   1137  11cd							; 
   1138  11cd
   1139  11cd				   .L066		;  _Bit1_Joy0_Restrainer{1}  =  1
   1140  11cd
   1141  11cd		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1142  11cf		       09 02		      ORA	#2
   1143  11d1		       85 ea		      STA	_Bit1_Joy0_Restrainer
   1144  11d3				   .
   1145  11d3							; 
   1146  11d3
   1147  11d3				   .
   1148  11d3							; 
   1149  11d3
   1150  11d3				   .
   1151  11d3							; 
   1152  11d3
   1153  11d3				   .
   1154  11d3							; 
   1155  11d3
   1156  11d3				   .L067		;  if _Current_Object	=  _Sprite0 then _Sprite_Size0	=  _Sprite_Size0  -  1	:  if _Sprite_Size0  >=  250 then _Sprite_Size0  =  2
   1157  11d3
   1158  11d3		       a5 d7		      LDA	_Current_Object
   1159  11d5		       c9 00		      CMP	#_Sprite0
   1160  11d7		       d0 0c		      BNE	.skipL067
   1161  11d9				   .condpart11
   1162  11d9		       c6 d8		      DEC	_Sprite_Size0
   1163  11db		       a5 d8		      LDA	_Sprite_Size0
   1164  11dd		       c9 fa		      CMP	#250
   1165  11df		       90 04		      BCC	.skip11then
   1166  11e1				   .condpart12
   1167  11e1		       a9 02		      LDA	#2
   1168  11e3		       85 d8		      STA	_Sprite_Size0
   1169  11e5				   .skip11then
   1170  11e5				   .skipL067
   1171  11e5				   .L068		;  if _Current_Object	=  _Sprite1 then _Sprite_Size1	=  _Sprite_Size1  -  1	:  if _Sprite_Size1  >=  250 then _Sprite_Size1  =  2
   1172  11e5
   1173  11e5		       a5 d7		      LDA	_Current_Object
   1174  11e7		       c9 01		      CMP	#_Sprite1
   1175  11e9		       d0 0c		      BNE	.skipL068
   1176  11eb				   .condpart13
   1177  11eb		       c6 d9		      DEC	_Sprite_Size1
   1178  11ed		       a5 d9		      LDA	_Sprite_Size1
   1179  11ef		       c9 fa		      CMP	#250
   1180  11f1		       90 04		      BCC	.skip13then
   1181  11f3				   .condpart14
   1182  11f3		       a9 02		      LDA	#2
   1183  11f5		       85 d9		      STA	_Sprite_Size1
   1184  11f7				   .skip13then
   1185  11f7				   .skipL068
   1186  11f7				   .L069		;  if _Current_Object	=  _Sprite2 then _Sprite_Size2	=  _Sprite_Size2  -  1	:  if _Sprite_Size2  >=  250 then _Sprite_Size2  =  2
   1187  11f7
   1188  11f7		       a5 d7		      LDA	_Current_Object
   1189  11f9		       c9 02		      CMP	#_Sprite2
   1190  11fb		       d0 0c		      BNE	.skipL069
   1191  11fd				   .condpart15
   1192  11fd		       c6 da		      DEC	_Sprite_Size2
   1193  11ff		       a5 da		      LDA	_Sprite_Size2
   1194  1201		       c9 fa		      CMP	#250
   1195  1203		       90 04		      BCC	.skip15then
   1196  1205				   .condpart16
   1197  1205		       a9 02		      LDA	#2
   1198  1207		       85 da		      STA	_Sprite_Size2
   1199  1209				   .skip15then
   1200  1209				   .skipL069
   1201  1209				   .L070		;  if _Current_Object	=  _Sprite3 then _Sprite_Size3	=  _Sprite_Size3  -  1	:  if _Sprite_Size3  >=  250 then _Sprite_Size3  =  2
   1202  1209
   1203  1209		       a5 d7		      LDA	_Current_Object
   1204  120b		       c9 03		      CMP	#_Sprite3
   1205  120d		       d0 0c		      BNE	.skipL070
   1206  120f				   .condpart17
   1207  120f		       c6 db		      DEC	_Sprite_Size3
   1208  1211		       a5 db		      LDA	_Sprite_Size3
   1209  1213		       c9 fa		      CMP	#250
   1210  1215		       90 04		      BCC	.skip17then
   1211  1217				   .condpart18
   1212  1217		       a9 02		      LDA	#2
   1213  1219		       85 db		      STA	_Sprite_Size3
   1214  121b				   .skip17then
   1215  121b				   .skipL070
   1216  121b				   .L071		;  if _Current_Object	=  _Sprite4 then _Sprite_Size4	=  _Sprite_Size4  -  1	:  if _Sprite_Size4  >=  250 then _Sprite_Size4  =  2
   1217  121b
   1218  121b		       a5 d7		      LDA	_Current_Object
   1219  121d		       c9 04		      CMP	#_Sprite4
   1220  121f		       d0 0c		      BNE	.skipL071
   1221  1221				   .condpart19
   1222  1221		       c6 dc		      DEC	_Sprite_Size4
   1223  1223		       a5 dc		      LDA	_Sprite_Size4
   1224  1225		       c9 fa		      CMP	#250
   1225  1227		       90 04		      BCC	.skip19then
   1226  1229				   .condpart20
   1227  1229		       a9 02		      LDA	#2
   1228  122b		       85 dc		      STA	_Sprite_Size4
   1229  122d				   .skip19then
   1230  122d				   .skipL071
   1231  122d				   .L072		;  if _Current_Object	=  _Sprite5 then _Sprite_Size5	=  _Sprite_Size5  -  1	:  if _Sprite_Size5  >=  250 then _Sprite_Size5  =  2
   1232  122d
   1233  122d		       a5 d7		      LDA	_Current_Object
   1234  122f		       c9 05		      CMP	#_Sprite5
   1235  1231		       d0 0c		      BNE	.skipL072
   1236  1233				   .condpart21
   1237  1233		       c6 dd		      DEC	_Sprite_Size5
   1238  1235		       a5 dd		      LDA	_Sprite_Size5
   1239  1237		       c9 fa		      CMP	#250
   1240  1239		       90 04		      BCC	.skip21then
   1241  123b				   .condpart22
   1242  123b		       a9 02		      LDA	#2
   1243  123d		       85 dd		      STA	_Sprite_Size5
   1244  123f				   .skip21then
   1245  123f				   .skipL072
   1246  123f				   .L073		;  if _Current_Object	=  _Missile0 then _Missile0_Width  =  _Missile0_Width  -  1  :	if _Missile0_Width  =  255 then _Missile0_Width  =  3
   1247  123f
   1248  123f		       a5 d7		      LDA	_Current_Object
   1249  1241		       c9 06		      CMP	#_Missile0
   1250  1243		       d0 0c		      BNE	.skipL073
   1251  1245				   .condpart23
   1252  1245		       c6 e2		      DEC	_Missile0_Width
   1253  1247		       a5 e2		      LDA	_Missile0_Width
   1254  1249		       c9 ff		      CMP	#255
   1255  124b		       d0 04		      BNE	.skip23then
   1256  124d				   .condpart24
   1257  124d		       a9 03		      LDA	#3
   1258  124f		       85 e2		      STA	_Missile0_Width
   1259  1251				   .skip23then
   1260  1251				   .skipL073
   1261  1251				   .L074		;  if _Current_Object	=  _Missile1 then _Missile1_Width  =  _Missile1_Width  -  1  :	if _Missile1_Width  =  255 then _Missile1_Width  =  3
   1262  1251
   1263  1251		       a5 d7		      LDA	_Current_Object
   1264  1253		       c9 07		      CMP	#_Missile1
   1265  1255		       d0 0c		      BNE	.skipL074
   1266  1257				   .condpart25
   1267  1257		       c6 e3		      DEC	_Missile1_Width
   1268  1259		       a5 e3		      LDA	_Missile1_Width
   1269  125b		       c9 ff		      CMP	#255
   1270  125d		       d0 04		      BNE	.skip25then
   1271  125f				   .condpart26
   1272  125f		       a9 03		      LDA	#3
   1273  1261		       85 e3		      STA	_Missile1_Width
   1274  1263				   .skip25then
   1275  1263				   .skipL074
   1276  1263				   .L075		;  if _Current_Object	=  _Ball then _Ball_Width  =  _Ball_Width  -  1  :  if _Ball_Width  =  255 then _Ball_Width  =	3
   1277  1263
   1278  1263		       a5 d7		      LDA	_Current_Object
   1279  1265		       c9 08		      CMP	#_Ball
   1280  1267		       d0 0c		      BNE	.skipL075
   1281  1269				   .condpart27
   1282  1269		       c6 e4		      DEC	_Ball_Width
   1283  126b		       a5 e4		      LDA	_Ball_Width
   1284  126d		       c9 ff		      CMP	#255
   1285  126f		       d0 04		      BNE	.skip27then
   1286  1271				   .condpart28
   1287  1271		       a9 03		      LDA	#3
   1288  1273		       85 e4		      STA	_Ball_Width
   1289  1275				   .skip27then
   1290  1275				   .skipL075
   1291  1275				   .
   1292  1275							; 
   1293  1275
   1294  1275				   .L076		;  goto __Skip_Size_Increase
   1295  1275
   1296  1275		       4c 28 93 	      jmp	.__Skip_Size_Increase
   1297  1278
   1298  1278				   .
   1299  1278							; 
   1300  1278
   1301  1278				   .__Skip_Size_Decrease
   1302  1278							; __Skip_Size_Decrease
   1303  1278
   1304  1278				   .
   1305  1278							; 
   1306  1278
   1307  1278				   .
   1308  1278							; 
   1309  1278
   1310  1278				   .
   1311  1278							; 
   1312  1278
   1313  1278				   .
   1314  1278							; 
   1315  1278
   1316  1278				   .L077		;  if !joy0right then goto __Skip_Size_Increase
   1317  1278
   1318  1278		       2c 80 02 	      bit	SWCHA
   1319  127b		       10 03		      BPL	.skipL077
   1320  127d				   .condpart29
   1321  127d		       4c 28 93 	      jmp	.__Skip_Size_Increase
   1322  1280
   1323  1280				   .skipL077
   1324  1280				   .
   1325  1280							; 
   1326  1280
   1327  1280				   .
   1328  1280							; 
   1329  1280
   1330  1280				   .
   1331  1280							; 
   1332  1280
   1333  1280				   .
   1334  1280							; 
   1335  1280
   1336  1280				   .L078		;  _Bit1_Joy0_Restrainer{1}  =  1
   1337  1280
   1338  1280		       a5 ea		      LDA	_Bit1_Joy0_Restrainer
   1339  1282		       09 02		      ORA	#2
   1340  1284		       85 ea		      STA	_Bit1_Joy0_Restrainer
   1341  1286				   .
   1342  1286							; 
   1343  1286
   1344  1286				   .
   1345  1286							; 
   1346  1286
   1347  1286				   .
   1348  1286							; 
   1349  1286
   1350  1286				   .
   1351  1286							; 
   1352  1286
   1353  1286				   .L079		;  if _Current_Object	=  _Sprite0 then _Sprite_Size0	=  _Sprite_Size0  +  1	:  if _Sprite_Size0  >=  3 then _Sprite_Size0  =  0
   1354  1286
   1355  1286		       a5 d7		      LDA	_Current_Object
   1356  1288		       c9 00		      CMP	#_Sprite0
   1357  128a		       d0 0c		      BNE	.skipL079
   1358  128c				   .condpart30
   1359  128c		       e6 d8		      INC	_Sprite_Size0
   1360  128e		       a5 d8		      LDA	_Sprite_Size0
   1361  1290		       c9 03		      CMP	#3
   1362  1292		       90 04		      BCC	.skip30then
   1363  1294				   .condpart31
   1364  1294		       a9 00		      LDA	#0
   1365  1296		       85 d8		      STA	_Sprite_Size0
   1366  1298				   .skip30then
   1367  1298				   .skipL079
   1368  1298				   .L080		;  if _Current_Object	=  _Sprite1 then _Sprite_Size1	=  _Sprite_Size1  +  1	:  if _Sprite_Size1  >=  3 then _Sprite_Size1  =  0
   1369  1298
   1370  1298		       a5 d7		      LDA	_Current_Object
   1371  129a		       c9 01		      CMP	#_Sprite1
   1372  129c		       d0 0c		      BNE	.skipL080
   1373  129e				   .condpart32
   1374  129e		       e6 d9		      INC	_Sprite_Size1
   1375  12a0		       a5 d9		      LDA	_Sprite_Size1
   1376  12a2		       c9 03		      CMP	#3
   1377  12a4		       90 04		      BCC	.skip32then
   1378  12a6				   .condpart33
   1379  12a6		       a9 00		      LDA	#0
   1380  12a8		       85 d9		      STA	_Sprite_Size1
   1381  12aa				   .skip32then
   1382  12aa				   .skipL080
   1383  12aa				   .L081		;  if _Current_Object	=  _Sprite2 then _Sprite_Size2	=  _Sprite_Size2  +  1	:  if _Sprite_Size2  >=  3 then _Sprite_Size2  =  0
   1384  12aa
   1385  12aa		       a5 d7		      LDA	_Current_Object
   1386  12ac		       c9 02		      CMP	#_Sprite2
   1387  12ae		       d0 0c		      BNE	.skipL081
   1388  12b0				   .condpart34
   1389  12b0		       e6 da		      INC	_Sprite_Size2
   1390  12b2		       a5 da		      LDA	_Sprite_Size2
   1391  12b4		       c9 03		      CMP	#3
   1392  12b6		       90 04		      BCC	.skip34then
   1393  12b8				   .condpart35
   1394  12b8		       a9 00		      LDA	#0
   1395  12ba		       85 da		      STA	_Sprite_Size2
   1396  12bc				   .skip34then
   1397  12bc				   .skipL081
   1398  12bc				   .L082		;  if _Current_Object	=  _Sprite3 then _Sprite_Size3	=  _Sprite_Size3  +  1	:  if _Sprite_Size3  >=  3 then _Sprite_Size3  =  0
   1399  12bc
   1400  12bc		       a5 d7		      LDA	_Current_Object
   1401  12be		       c9 03		      CMP	#_Sprite3
   1402  12c0		       d0 0c		      BNE	.skipL082
   1403  12c2				   .condpart36
   1404  12c2		       e6 db		      INC	_Sprite_Size3
   1405  12c4		       a5 db		      LDA	_Sprite_Size3
   1406  12c6		       c9 03		      CMP	#3
   1407  12c8		       90 04		      BCC	.skip36then
   1408  12ca				   .condpart37
   1409  12ca		       a9 00		      LDA	#0
   1410  12cc		       85 db		      STA	_Sprite_Size3
   1411  12ce				   .skip36then
   1412  12ce				   .skipL082
   1413  12ce				   .L083		;  if _Current_Object	=  _Sprite4 then _Sprite_Size4	=  _Sprite_Size4  +  1	:  if _Sprite_Size4  >=  3 then _Sprite_Size4  =  0
   1414  12ce
   1415  12ce		       a5 d7		      LDA	_Current_Object
   1416  12d0		       c9 04		      CMP	#_Sprite4
   1417  12d2		       d0 0c		      BNE	.skipL083
   1418  12d4				   .condpart38
   1419  12d4		       e6 dc		      INC	_Sprite_Size4
   1420  12d6		       a5 dc		      LDA	_Sprite_Size4
   1421  12d8		       c9 03		      CMP	#3
   1422  12da		       90 04		      BCC	.skip38then
   1423  12dc				   .condpart39
   1424  12dc		       a9 00		      LDA	#0
   1425  12de		       85 dc		      STA	_Sprite_Size4
   1426  12e0				   .skip38then
   1427  12e0				   .skipL083
   1428  12e0				   .L084		;  if _Current_Object	=  _Sprite5 then _Sprite_Size5	=  _Sprite_Size5  +  1	:  if _Sprite_Size5  >=  3 then _Sprite_Size5  =  0
   1429  12e0
   1430  12e0		       a5 d7		      LDA	_Current_Object
   1431  12e2		       c9 05		      CMP	#_Sprite5
   1432  12e4		       d0 0c		      BNE	.skipL084
   1433  12e6				   .condpart40
   1434  12e6		       e6 dd		      INC	_Sprite_Size5
   1435  12e8		       a5 dd		      LDA	_Sprite_Size5
   1436  12ea		       c9 03		      CMP	#3
   1437  12ec		       90 04		      BCC	.skip40then
   1438  12ee				   .condpart41
   1439  12ee		       a9 00		      LDA	#0
   1440  12f0		       85 dd		      STA	_Sprite_Size5
   1441  12f2				   .skip40then
   1442  12f2				   .skipL084
   1443  12f2				   .L085		;  if _Current_Object	=  _Missile0 then _Missile0_Width  =  _Missile0_Width  +  1  :	if _Missile0_Width  >=	4 then _Missile0_Width	=  0
   1444  12f2
   1445  12f2		       a5 d7		      LDA	_Current_Object
   1446  12f4		       c9 06		      CMP	#_Missile0
   1447  12f6		       d0 0c		      BNE	.skipL085
   1448  12f8				   .condpart42
   1449  12f8		       e6 e2		      INC	_Missile0_Width
   1450  12fa		       a5 e2		      LDA	_Missile0_Width
   1451  12fc		       c9 04		      CMP	#4
   1452  12fe		       90 04		      BCC	.skip42then
   1453  1300				   .condpart43
   1454  1300		       a9 00		      LDA	#0
   1455  1302		       85 e2		      STA	_Missile0_Width
   1456  1304				   .skip42then
   1457  1304				   .skipL085
   1458  1304				   .L086		;  if _Current_Object	=  _Missile1 then _Missile1_Width  =  _Missile1_Width  +  1  :	if _Missile1_Width  >=	4 then _Missile1_Width	=  0
   1459  1304
   1460  1304		       a5 d7		      LDA	_Current_Object
   1461  1306		       c9 07		      CMP	#_Missile1
   1462  1308		       d0 0c		      BNE	.skipL086
   1463  130a				   .condpart44
   1464  130a		       e6 e3		      INC	_Missile1_Width
   1465  130c		       a5 e3		      LDA	_Missile1_Width
   1466  130e		       c9 04		      CMP	#4
   1467  1310		       90 04		      BCC	.skip44then
   1468  1312				   .condpart45
   1469  1312		       a9 00		      LDA	#0
   1470  1314		       85 e3		      STA	_Missile1_Width
   1471  1316				   .skip44then
   1472  1316				   .skipL086
   1473  1316				   .L087		;  if _Current_Object	=  _Ball then _Ball_Width  =  _Ball_Width  +  1  :  if _Ball_Width  >=	4 then _Ball_Width  =  0
   1474  1316
   1475  1316		       a5 d7		      LDA	_Current_Object
   1476  1318		       c9 08		      CMP	#_Ball
   1477  131a		       d0 0c		      BNE	.skipL087
   1478  131c				   .condpart46
   1479  131c		       e6 e4		      INC	_Ball_Width
   1480  131e		       a5 e4		      LDA	_Ball_Width
   1481  1320		       c9 04		      CMP	#4
   1482  1322		       90 04		      BCC	.skip46then
   1483  1324				   .condpart47
   1484  1324		       a9 00		      LDA	#0
   1485  1326		       85 e4		      STA	_Ball_Width
   1486  1328				   .skip46then
   1487  1328				   .skipL087
   1488  1328				   .
   1489  1328							; 
   1490  1328
   1491  1328				   .__Skip_Size_Increase
   1492  1328							; __Skip_Size_Increase
   1493  1328
   1494  1328				   .
   1495  1328							; 
   1496  1328
   1497  1328				   .
   1498  1328							; 
   1499  1328
   1500  1328				   .
   1501  1328							; 
   1502  1328
   1503  1328				   .
   1504  1328							; 
   1505  1328
   1506  1328				   .L088		;  goto __Skip_Movement
   1507  1328
   1508  1328		       4c 57 96 	      jmp	.__Skip_Movement
   1509  132b
   1510  132b				   .
   1511  132b							; 
   1512  132b
   1513  132b				   .__Skip_Fire_Button
   1514  132b							; __Skip_Fire_Button
   1515  132b
   1516  132b				   .
   1517  132b							; 
   1518  132b
   1519  132b				   .
   1520  132b							; 
   1521  132b
   1522  132b				   .
   1523  132b							; 
   1524  132b
   1525  132b				   .
   1526  132b							; 
   1527  132b
   1528  132b				   .
   1529  132b							; 
   1530  132b
   1531  132b				   .
   1532  132b							; 
   1533  132b
   1534  132b				   .
   1535  132b							; 
   1536  132b
   1537  132b				   .
   1538  132b							; 
   1539  132b
   1540  132b				   .
   1541  132b							; 
   1542  132b
   1543  132b				   .
   1544  132b							; 
   1545  132b
   1546  132b				   .L089		;  if _Current_Object	>  _Sprite0 then goto __Skip_Sprite0_Movement
   1547  132b
   1548  132b		       a9 00		      LDA	#_Sprite0
   1549  132d		       c5 d7		      CMP	_Current_Object
   1550  132f		       b0 03		      BCS	.skipL089
   1551  1331				   .condpart48
   1552  1331		       4c 8a 93 	      jmp	.__Skip_Sprite0_Movement
   1553  1334
   1554  1334				   .skipL089
   1555  1334				   .
   1556  1334							; 
   1557  1334
   1558  1334				   .
   1559  1334							; 
   1560  1334
   1561  1334				   .
   1562  1334							; 
   1563  1334
   1564  1334				   .
   1565  1334							; 
   1566  1334
   1567  1334				   .L090		;  if joy0up then if player0y	<=  89 then player0y  =  player0y  +  1
   1568  1334
   1569  1334		       a9 10		      lda	#$10
   1570  1336		       2c 80 02 	      bit	SWCHA
   1571  1339		       d0 08		      BNE	.skipL090
   1572  133b				   .condpart49
   1573  133b		       a9 59		      LDA	#89
   1574  133d		       c5 8d		      CMP	player0y
   1575  133f		       90 02		      BCC	.skip49then
   1576  1341				   .condpart50
   1577  1341		       e6 8d		      INC	player0y
   1578  1343				   .skip49then
   1579  1343				   .skipL090
   1580  1343				   .
   1581  1343							; 
   1582  1343
   1583  1343				   .L091		;  if joy0down then if player0y  >=  2  +  player0height then player0y  =  player0y  -  1
   1584  1343
   1585  1343		       a9 20		      lda	#$20
   1586  1345		       2c 80 02 	      bit	SWCHA
   1587  1348		       d0 10		      BNE	.skipL091
   1588  134a				   .condpart51
   1589  134a							; complex condition detected
   1590  134a		       a9 02		      LDA	#2
   1591  134c		       18		      CLC
   1592  134d		       65 b0		      ADC	player0height
   1593  134f		       48		      PHA
   1594  1350		       ba		      TSX
   1595  1351		       68		      PLA
   1596  1352		       a5 8d		      LDA	player0y
   1597  1354		       d5 01		      CMP	1,x
   1598  1356		       90 02		      BCC	.skip51then
   1599  1358				   .condpart52
   1600  1358		       c6 8d		      DEC	player0y
   1601  135a				   .skip51then
   1602  135a				   .skipL091
   1603  135a				   .
   1604  135a							; 
   1605  135a
   1606  135a				   .L092		;  if joy0left then if player0x  >=  1 then player0x  =  player0x  -  1  :  _Bit3_Flip_p0{3}  =  0
   1607  135a
   1608  135a		       2c 80 02 	      bit	SWCHA
   1609  135d		       70 0e		      BVS	.skipL092
   1610  135f				   .condpart53
   1611  135f		       a5 84		      LDA	player0x
   1612  1361		       c9 01		      CMP	#1
   1613  1363		       90 08		      BCC	.skip53then
   1614  1365				   .condpart54
   1615  1365		       c6 84		      DEC	player0x
   1616  1367		       a5 ea		      LDA	_Bit3_Flip_p0
   1617  1369		       29 f7		      AND	#247
   1618  136b		       85 ea		      STA	_Bit3_Flip_p0
   1619  136d				   .skip53then
   1620  136d				   .skipL092
   1621  136d				   .
   1622  136d							; 
   1623  136d
   1624  136d				   .L093		;  if joy0right then temp5  =	_Data_Sprite0_Width[_Sprite_Size0]  :  if player0x  <=	temp5 then player0x  =	player0x  +  1	:  _Bit3_Flip_p0{3}  =	1
   1625  136d
   1626  136d		       2c 80 02 	      bit	SWCHA
   1627  1370		       30 15		      BMI	.skipL093
   1628  1372				   .condpart55
   1629  1372		       a6 d8		      LDX	_Sprite_Size0
   1630  1374		       bd 73 96 	      LDA	_Data_Sprite0_Width,x
   1631  1377		       85 cf		      STA	temp5
   1632  1379		       a5 cf		      LDA	temp5
   1633  137b		       c5 84		      CMP	player0x
   1634  137d		       90 08		      BCC	.skip55then
   1635  137f				   .condpart56
   1636  137f		       e6 84		      INC	player0x
   1637  1381		       a5 ea		      LDA	_Bit3_Flip_p0
   1638  1383		       09 08		      ORA	#8
   1639  1385		       85 ea		      STA	_Bit3_Flip_p0
   1640  1387				   .skip55then
   1641  1387				   .skipL093
   1642  1387				   .
   1643  1387							; 
   1644  1387
   1645  1387				   .L094		;  goto __Skip_Movement
   1646  1387
   1647  1387		       4c 57 96 	      jmp	.__Skip_Movement
   1648  138a
   1649  138a				   .
   1650  138a							; 
   1651  138a
   1652  138a				   .__Skip_Sprite0_Movement
   1653  138a							; __Skip_Sprite0_Movement
   1654  138a
   1655  138a				   .
   1656  138a							; 
   1657  138a
   1658  138a				   .
   1659  138a							; 
   1660  138a
   1661  138a				   .
   1662  138a							; 
   1663  138a
   1664  138a				   .
   1665  138a							; 
   1666  138a
   1667  138a				   .L095		;  if _Current_Object	>  _Sprite1 then goto __Skip_Sprite1_Movement
   1668  138a
   1669  138a		       a9 01		      LDA	#_Sprite1
   1670  138c		       c5 d7		      CMP	_Current_Object
   1671  138e		       b0 03		      BCS	.skipL095
   1672  1390				   .condpart57
   1673  1390		       4c ed 93 	      jmp	.__Skip_Sprite1_Movement
   1674  1393
   1675  1393				   .skipL095
   1676  1393				   .
   1677  1393							; 
   1678  1393
   1679  1393				   .
   1680  1393							; 
   1681  1393
   1682  1393				   .
   1683  1393							; 
   1684  1393
   1685  1393				   .
   1686  1393							; 
   1687  1393
   1688  1393				   .L096		;  if joy0up then if player1y	<=  83 then player1y  =  player1y  +  1
   1689  1393
   1690  1393		       a9 10		      lda	#$10
   1691  1395		       2c 80 02 	      bit	SWCHA
   1692  1398		       d0 08		      BNE	.skipL096
   1693  139a				   .condpart58
   1694  139a		       a9 53		      LDA	#83
   1695  139c		       c5 8e		      CMP	player1y
   1696  139e		       90 02		      BCC	.skip58then
   1697  13a0				   .condpart59
   1698  13a0		       e6 8e		      INC	player1y
   1699  13a2				   .skip58then
   1700  13a2				   .skipL096
   1701  13a2				   .
   1702  13a2							; 
   1703  13a2
   1704  13a2				   .L097		;  if joy0down then if player1y  >=  player1height then player1y  =  player1y	-  1
   1705  13a2
   1706  13a2		       a9 20		      lda	#$20
   1707  13a4		       2c 80 02 	      bit	SWCHA
   1708  13a7		       d0 08		      BNE	.skipL097
   1709  13a9				   .condpart60
   1710  13a9		       a5 8e		      LDA	player1y
   1711  13ab		       c5 b1		      CMP	player1height
   1712  13ad		       90 02		      BCC	.skip60then
   1713  13af				   .condpart61
   1714  13af		       c6 8e		      DEC	player1y
   1715  13b1				   .skip60then
   1716  13b1				   .skipL097
   1717  13b1				   .
   1718  13b1							; 
   1719  13b1
   1720  13b1				   .L098		;  if joy0left then if player1x  >=  9 then player1x  =  player1x  -  1  :  _NUSIZ1{3}  =  0  :  _NUSIZ1{6}  =  0
   1721  13b1
   1722  13b1		       2c 80 02 	      bit	SWCHA
   1723  13b4		       70 14		      BVS	.skipL098
   1724  13b6				   .condpart62
   1725  13b6		       a5 85		      LDA	player1x
   1726  13b8		       c9 09		      CMP	#9
   1727  13ba		       90 0e		      BCC	.skip62then
   1728  13bc				   .condpart63
   1729  13bc		       c6 85		      DEC	player1x
   1730  13be		       a5 93		      LDA	_NUSIZ1
   1731  13c0		       29 f7		      AND	#247
   1732  13c2		       85 93		      STA	_NUSIZ1
   1733  13c4		       a5 93		      LDA	_NUSIZ1
   1734  13c6		       29 bf		      AND	#191
   1735  13c8		       85 93		      STA	_NUSIZ1
   1736  13ca				   .skip62then
   1737  13ca				   .skipL098
   1738  13ca				   .
   1739  13ca							; 
   1740  13ca
   1741  13ca				   .L099		;  if joy0right then temp5  =	_Data_1to5_Width[_Sprite_Size1]  :  if player1x  <=  temp5 then player1x  =  player1x  +  1  :	_NUSIZ1{3}  =  1  :  _NUSIZ1{6}  =  1
   1742  13ca
   1743  13ca		       2c 80 02 	      bit	SWCHA
   1744  13cd		       30 1b		      BMI	.skipL099
   1745  13cf				   .condpart64
   1746  13cf		       a6 d9		      LDX	_Sprite_Size1
   1747  13d1		       bd 79 96 	      LDA	_Data_1to5_Width,x
   1748  13d4		       85 cf		      STA	temp5
   1749  13d6		       a5 cf		      LDA	temp5
   1750  13d8		       c5 85		      CMP	player1x
   1751  13da		       90 0e		      BCC	.skip64then
   1752  13dc				   .condpart65
   1753  13dc		       e6 85		      INC	player1x
   1754  13de		       a5 93		      LDA	_NUSIZ1
   1755  13e0		       09 08		      ORA	#8
   1756  13e2		       85 93		      STA	_NUSIZ1
   1757  13e4		       a5 93		      LDA	_NUSIZ1
   1758  13e6		       09 40		      ORA	#64
   1759  13e8		       85 93		      STA	_NUSIZ1
   1760  13ea				   .skip64then
   1761  13ea				   .skipL099
   1762  13ea				   .
   1763  13ea							; 
   1764  13ea
   1765  13ea				   .L0100		;  goto __Skip_Movement
   1766  13ea
   1767  13ea		       4c 57 96 	      jmp	.__Skip_Movement
   1768  13ed
   1769  13ed				   .
   1770  13ed							; 
   1771  13ed
   1772  13ed				   .__Skip_Sprite1_Movement
   1773  13ed							; __Skip_Sprite1_Movement
   1774  13ed
   1775  13ed				   .
   1776  13ed							; 
   1777  13ed
   1778  13ed				   .
   1779  13ed							; 
   1780  13ed
   1781  13ed				   .
   1782  13ed							; 
   1783  13ed
   1784  13ed				   .
   1785  13ed							; 
   1786  13ed
   1787  13ed				   .L0101		;  if _Current_Object	>  _Sprite2 then goto __Skip_Sprite2_Movement
   1788  13ed
   1789  13ed		       a9 02		      LDA	#_Sprite2
   1790  13ef		       c5 d7		      CMP	_Current_Object
   1791  13f1		       b0 03		      BCS	.skipL0101
   1792  13f3				   .condpart66
   1793  13f3		       4c 50 94 	      jmp	.__Skip_Sprite2_Movement
   1794  13f6
   1795  13f6				   .skipL0101
   1796  13f6				   .
   1797  13f6							; 
   1798  13f6
   1799  13f6				   .
   1800  13f6							; 
   1801  13f6
   1802  13f6				   .
   1803  13f6							; 
   1804  13f6
   1805  13f6				   .
   1806  13f6							; 
   1807  13f6
   1808  13f6				   .L0102		;  if joy0up then if player2y	<=  83 then player2y  =  player2y  +  1
   1809  13f6
   1810  13f6		       a9 10		      lda	#$10
   1811  13f8		       2c 80 02 	      bit	SWCHA
   1812  13fb		       d0 08		      BNE	.skipL0102
   1813  13fd				   .condpart67
   1814  13fd		       a9 53		      LDA	#83
   1815  13ff		       c5 8f		      CMP	player2y
   1816  1401		       90 02		      BCC	.skip67then
   1817  1403				   .condpart68
   1818  1403		       e6 8f		      INC	player2y
   1819  1405				   .skip67then
   1820  1405				   .skipL0102
   1821  1405				   .
   1822  1405							; 
   1823  1405
   1824  1405				   .L0103		;  if joy0down then if player2y  >=  player2height then player2y  =  player2y	-  1
   1825  1405
   1826  1405		       a9 20		      lda	#$20
   1827  1407		       2c 80 02 	      bit	SWCHA
   1828  140a		       d0 08		      BNE	.skipL0103
   1829  140c				   .condpart69
   1830  140c		       a5 8f		      LDA	player2y
   1831  140e		       c5 b2		      CMP	player2height
   1832  1410		       90 02		      BCC	.skip69then
   1833  1412				   .condpart70
   1834  1412		       c6 8f		      DEC	player2y
   1835  1414				   .skip69then
   1836  1414				   .skipL0103
   1837  1414				   .
   1838  1414							; 
   1839  1414
   1840  1414				   .L0104		;  if joy0left then if player2x  >=  9 then player2x  =  player2x  -  1  :  NUSIZ2{3}	=  0  :  NUSIZ2{6}  =  0
   1841  1414
   1842  1414		       2c 80 02 	      bit	SWCHA
   1843  1417		       70 14		      BVS	.skipL0104
   1844  1419				   .condpart71
   1845  1419		       a5 86		      LDA	player2x
   1846  141b		       c9 09		      CMP	#9
   1847  141d		       90 0e		      BCC	.skip71then
   1848  141f				   .condpart72
   1849  141f		       c6 86		      DEC	player2x
   1850  1421		       a5 94		      LDA	NUSIZ2
   1851  1423		       29 f7		      AND	#247
   1852  1425		       85 94		      STA	NUSIZ2
   1853  1427		       a5 94		      LDA	NUSIZ2
   1854  1429		       29 bf		      AND	#191
   1855  142b		       85 94		      STA	NUSIZ2
   1856  142d				   .skip71then
   1857  142d				   .skipL0104
   1858  142d				   .
   1859  142d							; 
   1860  142d
   1861  142d				   .L0105		;  if joy0right then temp5  =	_Data_1to5_Width[_Sprite_Size2]  :  if player2x  <=  temp5 then player2x  =  player2x  +  1  :	NUSIZ2{3}  =  1  :  NUSIZ2{6}  =  1
   1862  142d
   1863  142d		       2c 80 02 	      bit	SWCHA
   1864  1430		       30 1b		      BMI	.skipL0105
   1865  1432				   .condpart73
   1866  1432		       a6 da		      LDX	_Sprite_Size2
   1867  1434		       bd 79 96 	      LDA	_Data_1to5_Width,x
   1868  1437		       85 cf		      STA	temp5
   1869  1439		       a5 cf		      LDA	temp5
   1870  143b		       c5 86		      CMP	player2x
   1871  143d		       90 0e		      BCC	.skip73then
   1872  143f				   .condpart74
   1873  143f		       e6 86		      INC	player2x
   1874  1441		       a5 94		      LDA	NUSIZ2
   1875  1443		       09 08		      ORA	#8
   1876  1445		       85 94		      STA	NUSIZ2
   1877  1447		       a5 94		      LDA	NUSIZ2
   1878  1449		       09 40		      ORA	#64
   1879  144b		       85 94		      STA	NUSIZ2
   1880  144d				   .skip73then
   1881  144d				   .skipL0105
   1882  144d				   .
   1883  144d							; 
   1884  144d
   1885  144d				   .L0106		;  goto __Skip_Movement
   1886  144d
   1887  144d		       4c 57 96 	      jmp	.__Skip_Movement
   1888  1450
   1889  1450				   .
   1890  1450							; 
   1891  1450
   1892  1450				   .__Skip_Sprite2_Movement
   1893  1450							; __Skip_Sprite2_Movement
   1894  1450
   1895  1450				   .
   1896  1450							; 
   1897  1450
   1898  1450				   .
   1899  1450							; 
   1900  1450
   1901  1450				   .
   1902  1450							; 
   1903  1450
   1904  1450				   .
   1905  1450							; 
   1906  1450
   1907  1450				   .L0107		;  if _Current_Object	>  _Sprite3 then goto __Skip_Sprite3_Movement
   1908  1450
   1909  1450		       a9 03		      LDA	#_Sprite3
   1910  1452		       c5 d7		      CMP	_Current_Object
   1911  1454		       b0 03		      BCS	.skipL0107
   1912  1456				   .condpart75
   1913  1456		       4c b3 94 	      jmp	.__Skip_Sprite3_Movement
   1914  1459
   1915  1459				   .skipL0107
   1916  1459				   .
   1917  1459							; 
   1918  1459
   1919  1459				   .
   1920  1459							; 
   1921  1459
   1922  1459				   .
   1923  1459							; 
   1924  1459
   1925  1459				   .
   1926  1459							; 
   1927  1459
   1928  1459				   .L0108		;  if joy0up then if player3y	<=  83 then player3y  =  player3y  +  1
   1929  1459
   1930  1459		       a9 10		      lda	#$10
   1931  145b		       2c 80 02 	      bit	SWCHA
   1932  145e		       d0 08		      BNE	.skipL0108
   1933  1460				   .condpart76
   1934  1460		       a9 53		      LDA	#83
   1935  1462		       c5 90		      CMP	player3y
   1936  1464		       90 02		      BCC	.skip76then
   1937  1466				   .condpart77
   1938  1466		       e6 90		      INC	player3y
   1939  1468				   .skip76then
   1940  1468				   .skipL0108
   1941  1468				   .
   1942  1468							; 
   1943  1468
   1944  1468				   .L0109		;  if joy0down then if player3y  >=  player3height then player3y  =  player3y	-  1
   1945  1468
   1946  1468		       a9 20		      lda	#$20
   1947  146a		       2c 80 02 	      bit	SWCHA
   1948  146d		       d0 08		      BNE	.skipL0109
   1949  146f				   .condpart78
   1950  146f		       a5 90		      LDA	player3y
   1951  1471		       c5 b3		      CMP	player3height
   1952  1473		       90 02		      BCC	.skip78then
   1953  1475				   .condpart79
   1954  1475		       c6 90		      DEC	player3y
   1955  1477				   .skip78then
   1956  1477				   .skipL0109
   1957  1477				   .
   1958  1477							; 
   1959  1477
   1960  1477				   .L0110		;  if joy0left then if player3x  >=  9 then player3x  =  player3x  -  1  :  NUSIZ3{3}	=  0  :  NUSIZ3{6}  =  0
   1961  1477
   1962  1477		       2c 80 02 	      bit	SWCHA
   1963  147a		       70 14		      BVS	.skipL0110
   1964  147c				   .condpart80
   1965  147c		       a5 87		      LDA	player3x
   1966  147e		       c9 09		      CMP	#9
   1967  1480		       90 0e		      BCC	.skip80then
   1968  1482				   .condpart81
   1969  1482		       c6 87		      DEC	player3x
   1970  1484		       a5 95		      LDA	NUSIZ3
   1971  1486		       29 f7		      AND	#247
   1972  1488		       85 95		      STA	NUSIZ3
   1973  148a		       a5 95		      LDA	NUSIZ3
   1974  148c		       29 bf		      AND	#191
   1975  148e		       85 95		      STA	NUSIZ3
   1976  1490				   .skip80then
   1977  1490				   .skipL0110
   1978  1490				   .
   1979  1490							; 
   1980  1490
   1981  1490				   .L0111		;  if joy0right then temp5  =	_Data_1to5_Width[_Sprite_Size3]  :  if player3x  <=  temp5 then player3x  =  player3x  +  1  :	NUSIZ3{3}  =  1  :  NUSIZ3{6}  =  1
   1982  1490
   1983  1490		       2c 80 02 	      bit	SWCHA
   1984  1493		       30 1b		      BMI	.skipL0111
   1985  1495				   .condpart82
   1986  1495		       a6 db		      LDX	_Sprite_Size3
   1987  1497		       bd 79 96 	      LDA	_Data_1to5_Width,x
   1988  149a		       85 cf		      STA	temp5
   1989  149c		       a5 cf		      LDA	temp5
   1990  149e		       c5 87		      CMP	player3x
   1991  14a0		       90 0e		      BCC	.skip82then
   1992  14a2				   .condpart83
   1993  14a2		       e6 87		      INC	player3x
   1994  14a4		       a5 95		      LDA	NUSIZ3
   1995  14a6		       09 08		      ORA	#8
   1996  14a8		       85 95		      STA	NUSIZ3
   1997  14aa		       a5 95		      LDA	NUSIZ3
   1998  14ac		       09 40		      ORA	#64
   1999  14ae		       85 95		      STA	NUSIZ3
   2000  14b0				   .skip82then
   2001  14b0				   .skipL0111
   2002  14b0				   .
   2003  14b0							; 
   2004  14b0
   2005  14b0				   .L0112		;  goto __Skip_Movement
   2006  14b0
   2007  14b0		       4c 57 96 	      jmp	.__Skip_Movement
   2008  14b3
   2009  14b3				   .
   2010  14b3							; 
   2011  14b3
   2012  14b3				   .__Skip_Sprite3_Movement
   2013  14b3							; __Skip_Sprite3_Movement
   2014  14b3
   2015  14b3				   .
   2016  14b3							; 
   2017  14b3
   2018  14b3				   .
   2019  14b3							; 
   2020  14b3
   2021  14b3				   .
   2022  14b3							; 
   2023  14b3
   2024  14b3				   .
   2025  14b3							; 
   2026  14b3
   2027  14b3				   .L0113		;  if _Current_Object	>  _Sprite4 then goto __Skip_Sprite4_Movement
   2028  14b3
   2029  14b3		       a9 04		      LDA	#_Sprite4
   2030  14b5		       c5 d7		      CMP	_Current_Object
   2031  14b7		       b0 03		      BCS	.skipL0113
   2032  14b9				   .condpart84
   2033  14b9		       4c 16 95 	      jmp	.__Skip_Sprite4_Movement
   2034  14bc
   2035  14bc				   .skipL0113
   2036  14bc				   .
   2037  14bc							; 
   2038  14bc
   2039  14bc				   .
   2040  14bc							; 
   2041  14bc
   2042  14bc				   .
   2043  14bc							; 
   2044  14bc
   2045  14bc				   .
   2046  14bc							; 
   2047  14bc
   2048  14bc				   .L0114		;  if joy0up then if player4y	<=  83 then player4y  =  player4y  +  1
   2049  14bc
   2050  14bc		       a9 10		      lda	#$10
   2051  14be		       2c 80 02 	      bit	SWCHA
   2052  14c1		       d0 08		      BNE	.skipL0114
   2053  14c3				   .condpart85
   2054  14c3		       a9 53		      LDA	#83
   2055  14c5		       c5 91		      CMP	player4y
   2056  14c7		       90 02		      BCC	.skip85then
   2057  14c9				   .condpart86
   2058  14c9		       e6 91		      INC	player4y
   2059  14cb				   .skip85then
   2060  14cb				   .skipL0114
   2061  14cb				   .
   2062  14cb							; 
   2063  14cb
   2064  14cb				   .L0115		;  if joy0down then if player4y  >=  player4height then player4y  =  player4y	-  1
   2065  14cb
   2066  14cb		       a9 20		      lda	#$20
   2067  14cd		       2c 80 02 	      bit	SWCHA
   2068  14d0		       d0 08		      BNE	.skipL0115
   2069  14d2				   .condpart87
   2070  14d2		       a5 91		      LDA	player4y
   2071  14d4		       c5 b4		      CMP	player4height
   2072  14d6		       90 02		      BCC	.skip87then
   2073  14d8				   .condpart88
   2074  14d8		       c6 91		      DEC	player4y
   2075  14da				   .skip87then
   2076  14da				   .skipL0115
   2077  14da				   .
   2078  14da							; 
   2079  14da
   2080  14da				   .L0116		;  if joy0left then if player4x  >=  9 then player4x  =  player4x  -  1  :  NUSIZ4{3}	=  0  :  NUSIZ4{6}  =  0
   2081  14da
   2082  14da		       2c 80 02 	      bit	SWCHA
   2083  14dd		       70 14		      BVS	.skipL0116
   2084  14df				   .condpart89
   2085  14df		       a5 88		      LDA	player4x
   2086  14e1		       c9 09		      CMP	#9
   2087  14e3		       90 0e		      BCC	.skip89then
   2088  14e5				   .condpart90
   2089  14e5		       c6 88		      DEC	player4x
   2090  14e7		       a5 96		      LDA	NUSIZ4
   2091  14e9		       29 f7		      AND	#247
   2092  14eb		       85 96		      STA	NUSIZ4
   2093  14ed		       a5 96		      LDA	NUSIZ4
   2094  14ef		       29 bf		      AND	#191
   2095  14f1		       85 96		      STA	NUSIZ4
   2096  14f3				   .skip89then
   2097  14f3				   .skipL0116
   2098  14f3				   .
   2099  14f3							; 
   2100  14f3
   2101  14f3				   .L0117		;  if joy0right then temp5  =	_Data_1to5_Width[_Sprite_Size4]  :  if player4x  <=  temp5 then player4x  =  player4x  +  1  :	NUSIZ4{3}  =  1  :  NUSIZ4{6}  =  1
   2102  14f3
   2103  14f3		       2c 80 02 	      bit	SWCHA
   2104  14f6		       30 1b		      BMI	.skipL0117
   2105  14f8				   .condpart91
   2106  14f8		       a6 dc		      LDX	_Sprite_Size4
   2107  14fa		       bd 79 96 	      LDA	_Data_1to5_Width,x
   2108  14fd		       85 cf		      STA	temp5
   2109  14ff		       a5 cf		      LDA	temp5
   2110  1501		       c5 88		      CMP	player4x
   2111  1503		       90 0e		      BCC	.skip91then
   2112  1505				   .condpart92
   2113  1505		       e6 88		      INC	player4x
   2114  1507		       a5 96		      LDA	NUSIZ4
   2115  1509		       09 08		      ORA	#8
   2116  150b		       85 96		      STA	NUSIZ4
   2117  150d		       a5 96		      LDA	NUSIZ4
   2118  150f		       09 40		      ORA	#64
   2119  1511		       85 96		      STA	NUSIZ4
   2120  1513				   .skip91then
   2121  1513				   .skipL0117
   2122  1513				   .
   2123  1513							; 
   2124  1513
   2125  1513				   .L0118		;  goto __Skip_Movement
   2126  1513
   2127  1513		       4c 57 96 	      jmp	.__Skip_Movement
   2128  1516
   2129  1516				   .
   2130  1516							; 
   2131  1516
   2132  1516				   .__Skip_Sprite4_Movement
   2133  1516							; __Skip_Sprite4_Movement
   2134  1516
   2135  1516				   .
   2136  1516							; 
   2137  1516
   2138  1516				   .
   2139  1516							; 
   2140  1516
   2141  1516				   .
   2142  1516							; 
   2143  1516
   2144  1516				   .
   2145  1516							; 
   2146  1516
   2147  1516				   .L0119		;  if _Current_Object	>  _Sprite5 then goto __Skip_Sprite5_Movement
   2148  1516
   2149  1516		       a9 05		      LDA	#_Sprite5
   2150  1518		       c5 d7		      CMP	_Current_Object
   2151  151a		       b0 03		      BCS	.skipL0119
   2152  151c				   .condpart93
   2153  151c		       4c 79 95 	      jmp	.__Skip_Sprite5_Movement
   2154  151f
   2155  151f				   .skipL0119
   2156  151f				   .
   2157  151f							; 
   2158  151f
   2159  151f				   .
   2160  151f							; 
   2161  151f
   2162  151f				   .
   2163  151f							; 
   2164  151f
   2165  151f				   .
   2166  151f							; 
   2167  151f
   2168  151f				   .L0120		;  if joy0up then if player5y	<=  83 then player5y  =  player5y  +  1
   2169  151f
   2170  151f		       a9 10		      lda	#$10
   2171  1521		       2c 80 02 	      bit	SWCHA
   2172  1524		       d0 08		      BNE	.skipL0120
   2173  1526				   .condpart94
   2174  1526		       a9 53		      LDA	#83
   2175  1528		       c5 92		      CMP	player5y
   2176  152a		       90 02		      BCC	.skip94then
   2177  152c				   .condpart95
   2178  152c		       e6 92		      INC	player5y
   2179  152e				   .skip94then
   2180  152e				   .skipL0120
   2181  152e				   .
   2182  152e							; 
   2183  152e
   2184  152e				   .L0121		;  if joy0down then if player5y  >=  player5height then player5y  =  player5y	-  1
   2185  152e
   2186  152e		       a9 20		      lda	#$20
   2187  1530		       2c 80 02 	      bit	SWCHA
   2188  1533		       d0 08		      BNE	.skipL0121
   2189  1535				   .condpart96
   2190  1535		       a5 92		      LDA	player5y
   2191  1537		       c5 b5		      CMP	player5height
   2192  1539		       90 02		      BCC	.skip96then
   2193  153b				   .condpart97
   2194  153b		       c6 92		      DEC	player5y
   2195  153d				   .skip96then
   2196  153d				   .skipL0121
   2197  153d				   .
   2198  153d							; 
   2199  153d
   2200  153d				   .L0122		;  if joy0left then if player5x  >=  9 then player5x  =  player5x  -  1  :  NUSIZ5{3}	=  0  :  NUSIZ5{6}  =  0
   2201  153d
   2202  153d		       2c 80 02 	      bit	SWCHA
   2203  1540		       70 14		      BVS	.skipL0122
   2204  1542				   .condpart98
   2205  1542		       a5 89		      LDA	player5x
   2206  1544		       c9 09		      CMP	#9
   2207  1546		       90 0e		      BCC	.skip98then
   2208  1548				   .condpart99
   2209  1548		       c6 89		      DEC	player5x
   2210  154a		       a5 97		      LDA	NUSIZ5
   2211  154c		       29 f7		      AND	#247
   2212  154e		       85 97		      STA	NUSIZ5
   2213  1550		       a5 97		      LDA	NUSIZ5
   2214  1552		       29 bf		      AND	#191
   2215  1554		       85 97		      STA	NUSIZ5
   2216  1556				   .skip98then
   2217  1556				   .skipL0122
   2218  1556				   .
   2219  1556							; 
   2220  1556
   2221  1556				   .L0123		;  if joy0right then temp5  =	_Data_1to5_Width[_Sprite_Size5]  :  if player5x  <=  temp5 then player5x  =  player5x  +  1  :	NUSIZ5{3}  =  1  :  NUSIZ5{6}  =  1
   2222  1556
   2223  1556		       2c 80 02 	      bit	SWCHA
   2224  1559		       30 1b		      BMI	.skipL0123
   2225  155b				   .condpart100
   2226  155b		       a6 dd		      LDX	_Sprite_Size5
   2227  155d		       bd 79 96 	      LDA	_Data_1to5_Width,x
   2228  1560		       85 cf		      STA	temp5
   2229  1562		       a5 cf		      LDA	temp5
   2230  1564		       c5 89		      CMP	player5x
   2231  1566		       90 0e		      BCC	.skip100then
   2232  1568				   .condpart101
   2233  1568		       e6 89		      INC	player5x
   2234  156a		       a5 97		      LDA	NUSIZ5
   2235  156c		       09 08		      ORA	#8
   2236  156e		       85 97		      STA	NUSIZ5
   2237  1570		       a5 97		      LDA	NUSIZ5
   2238  1572		       09 40		      ORA	#64
   2239  1574		       85 97		      STA	NUSIZ5
   2240  1576				   .skip100then
   2241  1576				   .skipL0123
   2242  1576				   .
   2243  1576							; 
   2244  1576
   2245  1576				   .L0124		;  goto __Skip_Movement
   2246  1576
   2247  1576		       4c 57 96 	      jmp	.__Skip_Movement
   2248  1579
   2249  1579				   .
   2250  1579							; 
   2251  1579
   2252  1579				   .__Skip_Sprite5_Movement
   2253  1579							; __Skip_Sprite5_Movement
   2254  1579
   2255  1579				   .
   2256  1579							; 
   2257  1579
   2258  1579				   .
   2259  1579							; 
   2260  1579
   2261  1579				   .
   2262  1579							; 
   2263  1579
   2264  1579				   .
   2265  1579							; 
   2266  1579
   2267  1579				   .L0125		;  if _Current_Object	<>  _Missile0 then goto __Skip_Missile0_Movement
   2268  1579
   2269  1579		       a5 d7		      LDA	_Current_Object
   2270  157b		       c9 06		      CMP	#_Missile0
   2271  157d		       f0 03		      BEQ	.skipL0125
   2272  157f				   .condpart102
   2273  157f		       4c c4 95 	      jmp	.__Skip_Missile0_Movement
   2274  1582
   2275  1582				   .skipL0125
   2276  1582				   .
   2277  1582							; 
   2278  1582
   2279  1582				   .
   2280  1582							; 
   2281  1582
   2282  1582				   .
   2283  1582							; 
   2284  1582
   2285  1582				   .
   2286  1582							; 
   2287  1582
   2288  1582				   .L0126		;  if joy0up then if missile0y  <=  87 then missile0y	=  missile0y  +  1
   2289  1582
   2290  1582		       a9 10		      lda	#$10
   2291  1584		       2c 80 02 	      bit	SWCHA
   2292  1587		       d0 08		      BNE	.skipL0126
   2293  1589				   .condpart103
   2294  1589		       a9 57		      LDA	#87
   2295  158b		       c5 8a		      CMP	missile0y
   2296  158d		       90 02		      BCC	.skip103then
   2297  158f				   .condpart104
   2298  158f		       e6 8a		      INC	missile0y
   2299  1591				   .skip103then
   2300  1591				   .skipL0126
   2301  1591				   .
   2302  1591							; 
   2303  1591
   2304  1591				   .L0127		;  if joy0down then if missile0y  >=  3 then missile0y  =  missile0y  -  1
   2305  1591
   2306  1591		       a9 20		      lda	#$20
   2307  1593		       2c 80 02 	      bit	SWCHA
   2308  1596		       d0 08		      BNE	.skipL0127
   2309  1598				   .condpart105
   2310  1598		       a5 8a		      LDA	missile0y
   2311  159a		       c9 03		      CMP	#3
   2312  159c		       90 02		      BCC	.skip105then
   2313  159e				   .condpart106
   2314  159e		       c6 8a		      DEC	missile0y
   2315  15a0				   .skip105then
   2316  15a0				   .skipL0127
   2317  15a0				   .
   2318  15a0							; 
   2319  15a0
   2320  15a0				   .L0128		;  if joy0left then if missile0x  >=  2 then missile0x  =  missile0x  -  1
   2321  15a0
   2322  15a0		       2c 80 02 	      bit	SWCHA
   2323  15a3		       70 08		      BVS	.skipL0128
   2324  15a5				   .condpart107
   2325  15a5		       a5 80		      LDA	missile0x
   2326  15a7		       c9 02		      CMP	#2
   2327  15a9		       90 02		      BCC	.skip107then
   2328  15ab				   .condpart108
   2329  15ab		       c6 80		      DEC	missile0x
   2330  15ad				   .skip107then
   2331  15ad				   .skipL0128
   2332  15ad				   .
   2333  15ad							; 
   2334  15ad
   2335  15ad				   .L0129		;  if joy0right then temp5  =	_Data_M_B_x_Size[_Missile0_Width]  :  if missile0x  <=	temp5 then missile0x  =  missile0x  +  1
   2336  15ad
   2337  15ad		       2c 80 02 	      bit	SWCHA
   2338  15b0		       30 0f		      BMI	.skipL0129
   2339  15b2				   .condpart109
   2340  15b2		       a6 e2		      LDX	_Missile0_Width
   2341  15b4		       bd 6c 96 	      LDA	_Data_M_B_x_Size,x
   2342  15b7		       85 cf		      STA	temp5
   2343  15b9		       a5 cf		      LDA	temp5
   2344  15bb		       c5 80		      CMP	missile0x
   2345  15bd		       90 02		      BCC	.skip109then
   2346  15bf				   .condpart110
   2347  15bf		       e6 80		      INC	missile0x
   2348  15c1				   .skip109then
   2349  15c1				   .skipL0129
   2350  15c1				   .
   2351  15c1							; 
   2352  15c1
   2353  15c1				   .L0130		;  goto __Skip_Movement
   2354  15c1
   2355  15c1		       4c 57 96 	      jmp	.__Skip_Movement
   2356  15c4
   2357  15c4				   .
   2358  15c4							; 
   2359  15c4
   2360  15c4				   .__Skip_Missile0_Movement
   2361  15c4							; __Skip_Missile0_Movement
   2362  15c4
   2363  15c4				   .
   2364  15c4							; 
   2365  15c4
   2366  15c4				   .
   2367  15c4							; 
   2368  15c4
   2369  15c4				   .
   2370  15c4							; 
   2371  15c4
   2372  15c4				   .
   2373  15c4							; 
   2374  15c4
   2375  15c4				   .L0131		;  if _Current_Object	<>  _Missile1 then goto __Skip_Missile1_Movement
   2376  15c4
   2377  15c4		       a5 d7		      LDA	_Current_Object
   2378  15c6		       c9 07		      CMP	#_Missile1
   2379  15c8		       f0 03		      BEQ	.skipL0131
   2380  15ca				   .condpart111
   2381  15ca		       4c 0f 96 	      jmp	.__Skip_Missile1_Movement
   2382  15cd
   2383  15cd				   .skipL0131
   2384  15cd				   .
   2385  15cd							; 
   2386  15cd
   2387  15cd				   .
   2388  15cd							; 
   2389  15cd
   2390  15cd				   .
   2391  15cd							; 
   2392  15cd
   2393  15cd				   .
   2394  15cd							; 
   2395  15cd
   2396  15cd				   .L0132		;  if joy0up then if missile1y  <=  87 then missile1y	=  missile1y  +  1
   2397  15cd
   2398  15cd		       a9 10		      lda	#$10
   2399  15cf		       2c 80 02 	      bit	SWCHA
   2400  15d2		       d0 08		      BNE	.skipL0132
   2401  15d4				   .condpart112
   2402  15d4		       a9 57		      LDA	#87
   2403  15d6		       c5 8b		      CMP	missile1y
   2404  15d8		       90 02		      BCC	.skip112then
   2405  15da				   .condpart113
   2406  15da		       e6 8b		      INC	missile1y
   2407  15dc				   .skip112then
   2408  15dc				   .skipL0132
   2409  15dc				   .
   2410  15dc							; 
   2411  15dc
   2412  15dc				   .L0133		;  if joy0down then if missile1y  >=  3 then missile1y  =  missile1y  -  1
   2413  15dc
   2414  15dc		       a9 20		      lda	#$20
   2415  15de		       2c 80 02 	      bit	SWCHA
   2416  15e1		       d0 08		      BNE	.skipL0133
   2417  15e3				   .condpart114
   2418  15e3		       a5 8b		      LDA	missile1y
   2419  15e5		       c9 03		      CMP	#3
   2420  15e7		       90 02		      BCC	.skip114then
   2421  15e9				   .condpart115
   2422  15e9		       c6 8b		      DEC	missile1y
   2423  15eb				   .skip114then
   2424  15eb				   .skipL0133
   2425  15eb				   .
   2426  15eb							; 
   2427  15eb
   2428  15eb				   .L0134		;  if joy0left then if missile1x  >=  2 then missile1x  =  missile1x  -  1
   2429  15eb
   2430  15eb		       2c 80 02 	      bit	SWCHA
   2431  15ee		       70 08		      BVS	.skipL0134
   2432  15f0				   .condpart116
   2433  15f0		       a5 81		      LDA	missile1x
   2434  15f2		       c9 02		      CMP	#2
   2435  15f4		       90 02		      BCC	.skip116then
   2436  15f6				   .condpart117
   2437  15f6		       c6 81		      DEC	missile1x
   2438  15f8				   .skip116then
   2439  15f8				   .skipL0134
   2440  15f8				   .
   2441  15f8							; 
   2442  15f8
   2443  15f8				   .L0135		;  if joy0right then temp5  =	_Data_M_B_x_Size[_Missile1_Width]  :  if missile1x  <=	temp5 then missile1x  =  missile1x  +  1
   2444  15f8
   2445  15f8		       2c 80 02 	      bit	SWCHA
   2446  15fb		       30 0f		      BMI	.skipL0135
   2447  15fd				   .condpart118
   2448  15fd		       a6 e3		      LDX	_Missile1_Width
   2449  15ff		       bd 6c 96 	      LDA	_Data_M_B_x_Size,x
   2450  1602		       85 cf		      STA	temp5
   2451  1604		       a5 cf		      LDA	temp5
   2452  1606		       c5 81		      CMP	missile1x
   2453  1608		       90 02		      BCC	.skip118then
   2454  160a				   .condpart119
   2455  160a		       e6 81		      INC	missile1x
   2456  160c				   .skip118then
   2457  160c				   .skipL0135
   2458  160c				   .
   2459  160c							; 
   2460  160c
   2461  160c				   .L0136		;  goto __Skip_Movement
   2462  160c
   2463  160c		       4c 57 96 	      jmp	.__Skip_Movement
   2464  160f
   2465  160f				   .
   2466  160f							; 
   2467  160f
   2468  160f				   .__Skip_Missile1_Movement
   2469  160f							; __Skip_Missile1_Movement
   2470  160f
   2471  160f				   .
   2472  160f							; 
   2473  160f
   2474  160f				   .
   2475  160f							; 
   2476  160f
   2477  160f				   .
   2478  160f							; 
   2479  160f
   2480  160f				   .
   2481  160f							; 
   2482  160f
   2483  160f				   .L0137		;  if _Current_Object	<>  _Ball then goto __Skip_Movement
   2484  160f
   2485  160f		       a5 d7		      LDA	_Current_Object
   2486  1611		       c9 08		      CMP	#_Ball
   2487  1613		       f0 03		      BEQ	.skipL0137
   2488  1615				   .condpart120
   2489  1615		       4c 57 96 	      jmp	.__Skip_Movement
   2490  1618
   2491  1618				   .skipL0137
   2492  1618				   .
   2493  1618							; 
   2494  1618
   2495  1618				   .
   2496  1618							; 
   2497  1618
   2498  1618				   .
   2499  1618							; 
   2500  1618
   2501  1618				   .
   2502  1618							; 
   2503  1618
   2504  1618				   .L0138		;  if joy0up then if bally  <=  87 then bally	=  bally  +  1
   2505  1618
   2506  1618		       a9 10		      lda	#$10
   2507  161a		       2c 80 02 	      bit	SWCHA
   2508  161d		       d0 08		      BNE	.skipL0138
   2509  161f				   .condpart121
   2510  161f		       a9 57		      LDA	#87
   2511  1621		       c5 8c		      CMP	bally
   2512  1623		       90 02		      BCC	.skip121then
   2513  1625				   .condpart122
   2514  1625		       e6 8c		      INC	bally
   2515  1627				   .skip121then
   2516  1627				   .skipL0138
   2517  1627				   .
   2518  1627							; 
   2519  1627
   2520  1627				   .L0139		;  if joy0down then if bally  >=  3 then bally  =  bally  -  1
   2521  1627
   2522  1627		       a9 20		      lda	#$20
   2523  1629		       2c 80 02 	      bit	SWCHA
   2524  162c		       d0 08		      BNE	.skipL0139
   2525  162e				   .condpart123
   2526  162e		       a5 8c		      LDA	bally
   2527  1630		       c9 03		      CMP	#3
   2528  1632		       90 02		      BCC	.skip123then
   2529  1634				   .condpart124
   2530  1634		       c6 8c		      DEC	bally
   2531  1636				   .skip123then
   2532  1636				   .skipL0139
   2533  1636				   .
   2534  1636							; 
   2535  1636
   2536  1636				   .L0140		;  if joy0left then if ballx  >=  2 then ballx  =  ballx  -  1
   2537  1636
   2538  1636		       2c 80 02 	      bit	SWCHA
   2539  1639		       70 08		      BVS	.skipL0140
   2540  163b				   .condpart125
   2541  163b		       a5 82		      LDA	ballx
   2542  163d		       c9 02		      CMP	#2
   2543  163f		       90 02		      BCC	.skip125then
   2544  1641				   .condpart126
   2545  1641		       c6 82		      DEC	ballx
   2546  1643				   .skip125then
   2547  1643				   .skipL0140
   2548  1643				   .
   2549  1643							; 
   2550  1643
   2551  1643				   .L0141		;  if joy0right then temp5  =	_Data_M_B_x_Size[_Ball_Width] :  if ballx  <=  temp5 then ballx  =  ballx  +  1
   2552  1643
   2553  1643		       2c 80 02 	      bit	SWCHA
   2554  1646		       30 0f		      BMI	.skipL0141
   2555  1648				   .condpart127
   2556  1648		       a6 e4		      LDX	_Ball_Width
   2557  164a		       bd 6c 96 	      LDA	_Data_M_B_x_Size,x
   2558  164d		       85 cf		      STA	temp5
   2559  164f		       a5 cf		      LDA	temp5
   2560  1651		       c5 82		      CMP	ballx
   2561  1653		       90 02		      BCC	.skip127then
   2562  1655				   .condpart128
   2563  1655		       e6 82		      INC	ballx
   2564  1657				   .skip127then
   2565  1657				   .skipL0141
   2566  1657				   .
   2567  1657							; 
   2568  1657
   2569  1657				   .__Skip_Movement
   2570  1657							; __Skip_Movement
   2571  1657
   2572  1657				   .
   2573  1657							; 
   2574  1657
   2575  1657				   .
   2576  1657							; 
   2577  1657
   2578  1657				   .
   2579  1657							; 
   2580  1657
   2581  1657				   .L0142		;  goto __Bank_2 bank2
   2582  1657
   2583  1657		       85 d1		      sta	temp7
   2584  1659		       a9 af		      lda	#>(.__Bank_2-1)
   2585  165b		       48		      pha
   2586  165c		       a9 ff		      lda	#<(.__Bank_2-1)
   2587  165e		       48		      pha
   2588  165f		       a5 d1		      lda	temp7
   2589  1661		       48		      pha
   2590  1662		       8a		      txa
   2591  1663		       48		      pha
   2592  1664		       a2 02		      ldx	#2
   2593  1666		       4c eb ff 	      jmp	BS_jsr
   2594  1669				   .
   2595  1669							; 
   2596  1669
   2597  1669				   .
   2598  1669							; 
   2599  1669
   2600  1669				   .
   2601  1669							; 
   2602  1669
   2603  1669				   .
   2604  1669							; 
   2605  1669
   2606  1669				   .
   2607  1669							; 
   2608  1669
   2609  1669				   .
   2610  1669							; 
   2611  1669
   2612  1669				   .
   2613  1669							; 
   2614  1669
   2615  1669				   .
   2616  1669							; 
   2617  1669
   2618  1669				   .
   2619  1669							; 
   2620  1669
   2621  1669				   .L0143		;  data _Data_M_B_x_Size
   2622  1669
   2623  1669		       4c 70 96 	      JMP	.skipL0143
   2624  166c				   _Data_M_B_x_Size
   2625  166c		       9e 9d 9b 97	      .byte.b	158, 157, 155, 151
   2626  1670
   2627  1670				   .skipL0143
   2628  1670				   .
   2629  1670							; 
   2630  1670
   2631  1670				   .
   2632  1670							; 
   2633  1670
   2634  1670				   .
   2635  1670							; 
   2636  1670
   2637  1670				   .
   2638  1670							; 
   2639  1670
   2640  1670				   .
   2641  1670							; 
   2642  1670
   2643  1670				   .
   2644  1670							; 
   2645  1670
   2646  1670				   .
   2647  1670							; 
   2648  1670
   2649  1670				   .L0144		;  data _Data_Sprite0_Width
   2650  1670
   2651  1670		       4c 76 96 	      JMP	.skipL0144
   2652  1673				   _Data_Sprite0_Width
   2653  1673		       96 8d 7d 	      .byte.b	150, 141, 125
   2654  1676
   2655  1676				   .skipL0144
   2656  1676				   .
   2657  1676							; 
   2658  1676
   2659  1676				   .
   2660  1676							; 
   2661  1676
   2662  1676				   .
   2663  1676							; 
   2664  1676
   2665  1676				   .
   2666  1676							; 
   2667  1676
   2668  1676				   .
   2669  1676							; 
   2670  1676
   2671  1676				   .
   2672  1676							; 
   2673  1676
   2674  1676				   .L0145		;  data _Data_1to5_Width
   2675  1676
   2676  1676		       4c 7c 96 	      JMP	.skipL0145
   2677  1679				   _Data_1to5_Width
   2678  1679		       9e 96 86 	      .byte.b	158, 150, 134
   2679  167c
   2680  167c				   .skipL0145
   2681  167c				   .
   2682  167c							; 
   2683  167c
   2684  167c				   .
   2685  167c							; 
   2686  167c
   2687  167c				   .
   2688  167c							; 
   2689  167c
   2690  167c				   .L0146		;  bank 2
   2691  167c
   2692  167c					      if	ECHO1
      2392 bytes of ROM space left in bank 1
   2693  167c					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   2694  167c					      endif
   2695  167c		       00 01	   ECHO1      =	1
   2696  1fd4					      ORG	$1FF4-bscode_length
   2697  1fd4					      RORG	$9FF4-bscode_length
   2698  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   2699  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   2700  1fd6				  -	      stx	FASTFETCH
   2701  1fd6					      endif
   2702  1fd6		       9a		      txs
   2703  1fd7				  -	      if	bankswitch == 64
   2704  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   2705  1fd7					      else
   2706  1fd7		       a9 f3		      lda	#>(start-1)
   2707  1fd9					      endif
   2708  1fd9		       48		      pha
   2709  1fda		       a9 f4		      lda	#<(start-1)
   2710  1fdc		       48		      pha
   2711  1fdd		       48		      pha
   2712  1fde		       8a		      txa
   2713  1fdf		       48		      pha
   2714  1fe0		       ba		      tsx
   2715  1fe1					      if	bankswitch != 64
   2716  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   2717  1fe3		       2a		      rol
   2718  1fe4		       2a		      rol
   2719  1fe5		       2a		      rol
   2720  1fe6		       2a		      rol
   2721  1fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   2722  1fe9		       aa		      tax
   2723  1fea		       e8		      inx
   2724  1feb				  -	      else
   2725  1feb				  -	      lda	4,x	; get high byte of return address
   2726  1feb				  -	      tay
   2727  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   2728  1feb				  -	      sta	4,x
   2729  1feb				  -	      tya
   2730  1feb				  -	      lsr
   2731  1feb				  -	      lsr
   2732  1feb				  -	      lsr
   2733  1feb				  -	      lsr
   2734  1feb				  -	      tax
   2735  1feb				  -	      inx
   2736  1feb					      endif
   2737  1feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   2738  1fee		       68		      pla
   2739  1fef		       aa		      tax
   2740  1ff0		       68		      pla
   2741  1ff1		       60		      rts
   2742  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   2743  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   2744  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   2745  1ff2					      endif
   2746  1ffc					      ORG	$1FFC
   2747  1ffc					      RORG	$9FFC
   2748  1ffc		       d4 9f		      .word.w	(start_bank1 & $ffff)
   2749  1ffe		       d4 9f		      .word.w	(start_bank1 & $ffff)
   2750  2000					      ORG	$2000
   2751  2000					      RORG	$B000
   2752  2000				   .
   2753  2000							; 
   2754  2000
   2755  2000				   .
   2756  2000							; 
   2757  2000
   2758  2000				   .
   2759  2000							; 
   2760  2000
   2761  2000				   .__Bank_2
   2762  2000							; __Bank_2
   2763  2000
   2764  2000				   .
   2765  2000							; 
   2766  2000
   2767  2000				   .
   2768  2000							; 
   2769  2000
   2770  2000				   .
   2771  2000							; 
   2772  2000
   2773  2000				   .
   2774  2000							; 
   2775  2000
   2776  2000				   .
   2777  2000							; 
   2778  2000
   2779  2000				   .
   2780  2000							; 
   2781  2000
   2782  2000				   .L0147		;  if _Bit3_Flip_p0{3} then REFP0  =  8
   2783  2000
   2784  2000		       a5 ea		      LDA	_Bit3_Flip_p0
   2785  2002		       29 08		      AND	#8
   2786  2004		       f0 04		      BEQ	.skipL0147
   2787  2006				   .condpart129
   2788  2006		       a9 08		      LDA	#8
   2789  2008		       85 0b		      STA	REFP0
   2790  200a				   .skipL0147
   2791  200a				   .
   2792  200a							; 
   2793  200a
   2794  200a				   .
   2795  200a							; 
   2796  200a
   2797  200a				   .
   2798  200a							; 
   2799  200a
   2800  200a				   .
   2801  200a							; 
   2802  200a
   2803  200a				   .
   2804  200a							; 
   2805  200a
   2806  200a				   .
   2807  200a							; 
   2808  200a
   2809  200a				   .
   2810  200a							; 
   2811  200a
   2812  200a				   .
   2813  200a							; 
   2814  200a
   2815  200a				   .
   2816  200a							; 
   2817  200a
   2818  200a				   .
   2819  200a							; 
   2820  200a
   2821  200a				   .L0148		;  _P0_NUSIZ  =  _P0_NUSIZ  &	%11111000
   2822  200a
   2823  200a		       a5 e6		      LDA	_P0_NUSIZ
   2824  200c		       29 f8		      AND	#%11111000
   2825  200e		       85 e6		      STA	_P0_NUSIZ
   2826  2010				   .
   2827  2010							; 
   2828  2010
   2829  2010				   .
   2830  2010							; 
   2831  2010
   2832  2010				   .
   2833  2010							; 
   2834  2010
   2835  2010				   .
   2836  2010							; 
   2837  2010
   2838  2010				   .L0149		;  _P0_NUSIZ  =  _P0_NUSIZ  |	_Data_Sprite_Size[_Sprite_Size0]
   2839  2010
   2840  2010		       a5 e6		      LDA	_P0_NUSIZ
   2841  2012		       a6 d8		      LDX	_Sprite_Size0
   2842  2014		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2843  2017		       85 e6		      STA	_P0_NUSIZ
   2844  2019				   .
   2845  2019							; 
   2846  2019
   2847  2019				   .
   2848  2019							; 
   2849  2019
   2850  2019				   .
   2851  2019							; 
   2852  2019
   2853  2019				   .
   2854  2019							; 
   2855  2019
   2856  2019				   .L0150		;  NUSIZ0  =  _P0_NUSIZ
   2857  2019
   2858  2019		       a5 e6		      LDA	_P0_NUSIZ
   2859  201b		       85 04		      STA	NUSIZ0
   2860  201d				   .
   2861  201d							; 
   2862  201d
   2863  201d				   .
   2864  201d							; 
   2865  201d
   2866  201d				   .
   2867  201d							; 
   2868  201d
   2869  201d				   .
   2870  201d							; 
   2871  201d
   2872  201d				   .
   2873  201d							; 
   2874  201d
   2875  201d				   .L0151		;  _NUSIZ1  =	_NUSIZ1  &  %11111000  :  _NUSIZ1  =  _NUSIZ1  |  _Data_Sprite_Size[_Sprite_Size1]
   2876  201d
   2877  201d		       a5 93		      LDA	_NUSIZ1
   2878  201f		       29 f8		      AND	#%11111000
   2879  2021		       85 93		      STA	_NUSIZ1
   2880  2023		       a5 93		      LDA	_NUSIZ1
   2881  2025		       a6 d9		      LDX	_Sprite_Size1
   2882  2027		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2883  202a		       85 93		      STA	_NUSIZ1
   2884  202c				   .L0152		;  NUSIZ2  =  NUSIZ2  &  %11111000  :	NUSIZ2	=  NUSIZ2  |  _Data_Sprite_Size[_Sprite_Size2]
   2885  202c
   2886  202c		       a5 94		      LDA	NUSIZ2
   2887  202e		       29 f8		      AND	#%11111000
   2888  2030		       85 94		      STA	NUSIZ2
   2889  2032		       a5 94		      LDA	NUSIZ2
   2890  2034		       a6 da		      LDX	_Sprite_Size2
   2891  2036		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2892  2039		       85 94		      STA	NUSIZ2
   2893  203b				   .L0153		;  NUSIZ3  =  NUSIZ3  &  %11111000  :	NUSIZ3	=  NUSIZ3  |  _Data_Sprite_Size[_Sprite_Size3]
   2894  203b
   2895  203b		       a5 95		      LDA	NUSIZ3
   2896  203d		       29 f8		      AND	#%11111000
   2897  203f		       85 95		      STA	NUSIZ3
   2898  2041		       a5 95		      LDA	NUSIZ3
   2899  2043		       a6 db		      LDX	_Sprite_Size3
   2900  2045		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2901  2048		       85 95		      STA	NUSIZ3
   2902  204a				   .L0154		;  NUSIZ4  =  NUSIZ4  &  %11111000  :	NUSIZ4	=  NUSIZ4  |  _Data_Sprite_Size[_Sprite_Size4]
   2903  204a
   2904  204a		       a5 96		      LDA	NUSIZ4
   2905  204c		       29 f8		      AND	#%11111000
   2906  204e		       85 96		      STA	NUSIZ4
   2907  2050		       a5 96		      LDA	NUSIZ4
   2908  2052		       a6 dc		      LDX	_Sprite_Size4
   2909  2054		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2910  2057		       85 96		      STA	NUSIZ4
   2911  2059				   .L0155		;  NUSIZ5  =  NUSIZ5  &  %11111000  :	NUSIZ5	=  NUSIZ5  |  _Data_Sprite_Size[_Sprite_Size5]
   2912  2059
   2913  2059		       a5 97		      LDA	NUSIZ5
   2914  205b		       29 f8		      AND	#%11111000
   2915  205d		       85 97		      STA	NUSIZ5
   2916  205f		       a5 97		      LDA	NUSIZ5
   2917  2061		       a6 dd		      LDX	_Sprite_Size5
   2918  2063		       1d 85 b7 	      ORA	_Data_Sprite_Size,x
   2919  2066		       85 97		      STA	NUSIZ5
   2920  2068				   .
   2921  2068							; 
   2922  2068
   2923  2068				   .
   2924  2068							; 
   2925  2068
   2926  2068				   .
   2927  2068							; 
   2928  2068
   2929  2068				   .
   2930  2068							; 
   2931  2068
   2932  2068				   .
   2933  2068							; 
   2934  2068
   2935  2068				   .
   2936  2068							; 
   2937  2068
   2938  2068				   .
   2939  2068							; 
   2940  2068
   2941  2068				   .
   2942  2068							; 
   2943  2068
   2944  2068				   .
   2945  2068							; 
   2946  2068
   2947  2068				   .
   2948  2068							; 
   2949  2068
   2950  2068				   .L0156		;  _P0_NUSIZ  =  _P0_NUSIZ  &	%11001111
   2951  2068
   2952  2068		       a5 e6		      LDA	_P0_NUSIZ
   2953  206a		       29 cf		      AND	#%11001111
   2954  206c		       85 e6		      STA	_P0_NUSIZ
   2955  206e				   .
   2956  206e							; 
   2957  206e
   2958  206e				   .
   2959  206e							; 
   2960  206e
   2961  206e				   .
   2962  206e							; 
   2963  206e
   2964  206e				   .
   2965  206e							; 
   2966  206e
   2967  206e				   .L0157		;  _P0_NUSIZ  =  _P0_NUSIZ  |	_Data_MB_Width[_Missile0_Width]
   2968  206e
   2969  206e		       a5 e6		      LDA	_P0_NUSIZ
   2970  2070		       a6 e2		      LDX	_Missile0_Width
   2971  2072		       1d 8b b7 	      ORA	_Data_MB_Width,x
   2972  2075		       85 e6		      STA	_P0_NUSIZ
   2973  2077				   .
   2974  2077							; 
   2975  2077
   2976  2077				   .
   2977  2077							; 
   2978  2077
   2979  2077				   .
   2980  2077							; 
   2981  2077
   2982  2077				   .
   2983  2077							; 
   2984  2077
   2985  2077				   .L0158		;  NUSIZ0  =  _P0_NUSIZ
   2986  2077
   2987  2077		       a5 e6		      LDA	_P0_NUSIZ
   2988  2079		       85 04		      STA	NUSIZ0
   2989  207b				   .
   2990  207b							; 
   2991  207b
   2992  207b				   .
   2993  207b							; 
   2994  207b
   2995  207b				   .
   2996  207b							; 
   2997  207b
   2998  207b				   .
   2999  207b							; 
   3000  207b
   3001  207b				   .
   3002  207b							; 
   3003  207b
   3004  207b				   .
   3005  207b							; 
   3006  207b
   3007  207b				   .
   3008  207b							; 
   3009  207b
   3010  207b				   .
   3011  207b							; 
   3012  207b
   3013  207b				   .
   3014  207b							; 
   3015  207b
   3016  207b				   .
   3017  207b							; 
   3018  207b
   3019  207b				   .L0159		;  temp5  =  _Data_MB_Width[_Missile1_Width]
   3020  207b
   3021  207b		       a6 e3		      LDX	_Missile1_Width
   3022  207d		       bd 8b b7 	      LDA	_Data_MB_Width,x
   3023  2080		       85 cf		      STA	temp5
   3024  2082				   .
   3025  2082							; 
   3026  2082
   3027  2082				   .
   3028  2082							; 
   3029  2082
   3030  2082				   .
   3031  2082							; 
   3032  2082
   3033  2082				   .
   3034  2082							; 
   3035  2082
   3036  2082				   .
   3037  2082							; 
   3038  2082
   3039  2082				   .L0160		;  NUSIZ1  =  NUSIZ1  &  %11001111  :	NUSIZ1	=  NUSIZ1  |  temp5
   3040  2082
   3041  2082		       a5 05		      LDA	NUSIZ1
   3042  2084		       29 cf		      AND	#%11001111
   3043  2086		       85 05		      STA	NUSIZ1
   3044  2088		       a5 05		      LDA	NUSIZ1
   3045  208a		       05 cf		      ORA	temp5
   3046  208c		       85 05		      STA	NUSIZ1
   3047  208e				   .L0161		;  _NUSIZ1  =	_NUSIZ1  &  %11001111  :  _NUSIZ1  =  _NUSIZ1  |  temp5
   3048  208e
   3049  208e		       a5 93		      LDA	_NUSIZ1
   3050  2090		       29 cf		      AND	#%11001111
   3051  2092		       85 93		      STA	_NUSIZ1
   3052  2094		       a5 93		      LDA	_NUSIZ1
   3053  2096		       05 cf		      ORA	temp5
   3054  2098		       85 93		      STA	_NUSIZ1
   3055  209a				   .L0162		;  NUSIZ2  =  NUSIZ2  &  %11001111  :	NUSIZ2	=  NUSIZ2  |  temp5
   3056  209a
   3057  209a		       a5 94		      LDA	NUSIZ2
   3058  209c		       29 cf		      AND	#%11001111
   3059  209e		       85 94		      STA	NUSIZ2
   3060  20a0		       a5 94		      LDA	NUSIZ2
   3061  20a2		       05 cf		      ORA	temp5
   3062  20a4		       85 94		      STA	NUSIZ2
   3063  20a6				   .L0163		;  NUSIZ3  =  NUSIZ3  &  %11001111  :	NUSIZ3	=  NUSIZ3  |  temp5
   3064  20a6
   3065  20a6		       a5 95		      LDA	NUSIZ3
   3066  20a8		       29 cf		      AND	#%11001111
   3067  20aa		       85 95		      STA	NUSIZ3
   3068  20ac		       a5 95		      LDA	NUSIZ3
   3069  20ae		       05 cf		      ORA	temp5
   3070  20b0		       85 95		      STA	NUSIZ3
   3071  20b2				   .L0164		;  NUSIZ4  =  NUSIZ4  &  %11001111  :	NUSIZ4	=  NUSIZ4  |  temp5
   3072  20b2
   3073  20b2		       a5 96		      LDA	NUSIZ4
   3074  20b4		       29 cf		      AND	#%11001111
   3075  20b6		       85 96		      STA	NUSIZ4
   3076  20b8		       a5 96		      LDA	NUSIZ4
   3077  20ba		       05 cf		      ORA	temp5
   3078  20bc		       85 96		      STA	NUSIZ4
   3079  20be				   .L0165		;  NUSIZ5  =  NUSIZ5  &  %11001111  :	NUSIZ5	=  NUSIZ5  |  temp5
   3080  20be
   3081  20be		       a5 97		      LDA	NUSIZ5
   3082  20c0		       29 cf		      AND	#%11001111
   3083  20c2		       85 97		      STA	NUSIZ5
   3084  20c4		       a5 97		      LDA	NUSIZ5
   3085  20c6		       05 cf		      ORA	temp5
   3086  20c8		       85 97		      STA	NUSIZ5
   3087  20ca				   .
   3088  20ca							; 
   3089  20ca
   3090  20ca				   .
   3091  20ca							; 
   3092  20ca
   3093  20ca				   .
   3094  20ca							; 
   3095  20ca
   3096  20ca				   .
   3097  20ca							; 
   3098  20ca
   3099  20ca				   .
   3100  20ca							; 
   3101  20ca
   3102  20ca				   .
   3103  20ca							; 
   3104  20ca
   3105  20ca				   .
   3106  20ca							; 
   3107  20ca
   3108  20ca				   .
   3109  20ca							; 
   3110  20ca
   3111  20ca				   .
   3112  20ca							; 
   3113  20ca
   3114  20ca				   .
   3115  20ca							; 
   3116  20ca
   3117  20ca				   .L0166		;  CTRLPF  =  _Data_MB_Width[_Ball_Width]  +  1
   3118  20ca
   3119  20ca		       a6 e4		      LDX	_Ball_Width
   3120  20cc		       bd 8b b7 	      LDA	_Data_MB_Width,x
   3121  20cf		       18		      CLC
   3122  20d0		       69 01		      ADC	#1
   3123  20d2		       85 0a		      STA	CTRLPF
   3124  20d4				   .
   3125  20d4							; 
   3126  20d4
   3127  20d4				   .
   3128  20d4							; 
   3129  20d4
   3130  20d4				   .
   3131  20d4							; 
   3132  20d4
   3133  20d4				   .
   3134  20d4							; 
   3135  20d4
   3136  20d4				   .
   3137  20d4							; 
   3138  20d4
   3139  20d4				   .
   3140  20d4							; 
   3141  20d4
   3142  20d4				   .
   3143  20d4							; 
   3144  20d4
   3145  20d4				   .
   3146  20d4							; 
   3147  20d4
   3148  20d4				   .
   3149  20d4							; 
   3150  20d4
   3151  20d4				   .
   3152  20d4							; 
   3153  20d4
   3154  20d4				   .
   3155  20d4							; 
   3156  20d4
   3157  20d4				   .
   3158  20d4							; 
   3159  20d4
   3160  20d4				   .L0167		;  if !_Bit2_Activate_Jiggle{2} then goto __Skip_Object_Jiggle
   3161  20d4
   3162  20d4		       a5 ea		      LDA	_Bit2_Activate_Jiggle
   3163  20d6		       29 04		      AND	#4
   3164  20d8		       d0 03		      BNE	.skipL0167
   3165  20da				   .condpart130
   3166  20da		       4c 45 b5 	      jmp	.__Skip_Object_Jiggle
   3167  20dd
   3168  20dd				   .skipL0167
   3169  20dd				   .
   3170  20dd							; 
   3171  20dd
   3172  20dd				   .
   3173  20dd							; 
   3174  20dd
   3175  20dd				   .
   3176  20dd							; 
   3177  20dd
   3178  20dd				   .
   3179  20dd							; 
   3180  20dd
   3181  20dd				   .L0168		;  if _Jiggle_Counter	>=  1 then goto __Skip_Memory
   3182  20dd
   3183  20dd		       a5 e5		      LDA	_Jiggle_Counter
   3184  20df		       c9 01		      CMP	#1
   3185  20e1		       90 03		      BCC	.skipL0168
   3186  20e3				   .condpart131
   3187  20e3		       4c 64 b1 	      jmp	.__Skip_Memory
   3188  20e6
   3189  20e6				   .skipL0168
   3190  20e6				   .L0169		;  if _Current_Object	=  _Sprite0 then _Memx	=  player0x  :	_Memy  =  player0y
   3191  20e6
   3192  20e6		       a5 d7		      LDA	_Current_Object
   3193  20e8		       c9 00		      CMP	#_Sprite0
   3194  20ea		       d0 08		      BNE	.skipL0169
   3195  20ec				   .condpart132
   3196  20ec		       a5 84		      LDA	player0x
   3197  20ee		       85 ee		      STA	_Memx
   3198  20f0		       a5 8d		      LDA	player0y
   3199  20f2		       85 ef		      STA	_Memy
   3200  20f4				   .skipL0169
   3201  20f4				   .L0170		;  if _Current_Object	=  _Sprite1 then _Memx	=  player1x  :	_Memy  =  player1y
   3202  20f4
   3203  20f4		       a5 d7		      LDA	_Current_Object
   3204  20f6		       c9 01		      CMP	#_Sprite1
   3205  20f8		       d0 08		      BNE	.skipL0170
   3206  20fa				   .condpart133
   3207  20fa		       a5 85		      LDA	player1x
   3208  20fc		       85 ee		      STA	_Memx
   3209  20fe		       a5 8e		      LDA	player1y
   3210  2100		       85 ef		      STA	_Memy
   3211  2102				   .skipL0170
   3212  2102				   .L0171		;  if _Current_Object	=  _Sprite2 then _Memx	=  player2x  :	_Memy  =  player2y
   3213  2102
   3214  2102		       a5 d7		      LDA	_Current_Object
   3215  2104		       c9 02		      CMP	#_Sprite2
   3216  2106		       d0 08		      BNE	.skipL0171
   3217  2108				   .condpart134
   3218  2108		       a5 86		      LDA	player2x
   3219  210a		       85 ee		      STA	_Memx
   3220  210c		       a5 8f		      LDA	player2y
   3221  210e		       85 ef		      STA	_Memy
   3222  2110				   .skipL0171
   3223  2110				   .L0172		;  if _Current_Object	=  _Sprite3 then _Memx	=  player3x  :	_Memy  =  player3y
   3224  2110
   3225  2110		       a5 d7		      LDA	_Current_Object
   3226  2112		       c9 03		      CMP	#_Sprite3
   3227  2114		       d0 08		      BNE	.skipL0172
   3228  2116				   .condpart135
   3229  2116		       a5 87		      LDA	player3x
   3230  2118		       85 ee		      STA	_Memx
   3231  211a		       a5 90		      LDA	player3y
   3232  211c		       85 ef		      STA	_Memy
   3233  211e				   .skipL0172
   3234  211e				   .L0173		;  if _Current_Object	=  _Sprite4 then _Memx	=  player4x  :	_Memy  =  player4y
   3235  211e
   3236  211e		       a5 d7		      LDA	_Current_Object
   3237  2120		       c9 04		      CMP	#_Sprite4
   3238  2122		       d0 08		      BNE	.skipL0173
   3239  2124				   .condpart136
   3240  2124		       a5 88		      LDA	player4x
   3241  2126		       85 ee		      STA	_Memx
   3242  2128		       a5 91		      LDA	player4y
   3243  212a		       85 ef		      STA	_Memy
   3244  212c				   .skipL0173
   3245  212c				   .L0174		;  if _Current_Object	=  _Sprite5 then _Memx	=  player5x  :	_Memy  =  player5y
   3246  212c
   3247  212c		       a5 d7		      LDA	_Current_Object
   3248  212e		       c9 05		      CMP	#_Sprite5
   3249  2130		       d0 08		      BNE	.skipL0174
   3250  2132				   .condpart137
   3251  2132		       a5 89		      LDA	player5x
   3252  2134		       85 ee		      STA	_Memx
   3253  2136		       a5 92		      LDA	player5y
   3254  2138		       85 ef		      STA	_Memy
   3255  213a				   .skipL0174
   3256  213a				   .L0175		;  if _Current_Object	=  _Missile0 then _Memx  =  missile0x  :  _Memy  =  missile0y
   3257  213a
   3258  213a		       a5 d7		      LDA	_Current_Object
   3259  213c		       c9 06		      CMP	#_Missile0
   3260  213e		       d0 08		      BNE	.skipL0175
   3261  2140				   .condpart138
   3262  2140		       a5 80		      LDA	missile0x
   3263  2142		       85 ee		      STA	_Memx
   3264  2144		       a5 8a		      LDA	missile0y
   3265  2146		       85 ef		      STA	_Memy
   3266  2148				   .skipL0175
   3267  2148				   .L0176		;  if _Current_Object	=  _Missile1 then _Memx  =  missile1x  :  _Memy  =  missile1y
   3268  2148
   3269  2148		       a5 d7		      LDA	_Current_Object
   3270  214a		       c9 07		      CMP	#_Missile1
   3271  214c		       d0 08		      BNE	.skipL0176
   3272  214e				   .condpart139
   3273  214e		       a5 81		      LDA	missile1x
   3274  2150		       85 ee		      STA	_Memx
   3275  2152		       a5 8b		      LDA	missile1y
   3276  2154		       85 ef		      STA	_Memy
   3277  2156				   .skipL0176
   3278  2156				   .L0177		;  if _Current_Object	=  _Ball then _Memx  =	ballx  :  _Memy  =  bally
   3279  2156
   3280  2156		       a5 d7		      LDA	_Current_Object
   3281  2158		       c9 08		      CMP	#_Ball
   3282  215a		       d0 08		      BNE	.skipL0177
   3283  215c				   .condpart140
   3284  215c		       a5 82		      LDA	ballx
   3285  215e		       85 ee		      STA	_Memx
   3286  2160		       a5 8c		      LDA	bally
   3287  2162		       85 ef		      STA	_Memy
   3288  2164				   .skipL0177
   3289  2164				   .
   3290  2164							; 
   3291  2164
   3292  2164				   .__Skip_Memory
   3293  2164							; __Skip_Memory
   3294  2164
   3295  2164				   .
   3296  2164							; 
   3297  2164
   3298  2164				   .
   3299  2164							; 
   3300  2164
   3301  2164				   .
   3302  2164							; 
   3303  2164
   3304  2164				   .
   3305  2164							; 
   3306  2164
   3307  2164				   .L0178		;  _Jiggle_Counter  =	_Jiggle_Counter  +  1
   3308  2164
   3309  2164		       e6 e5		      INC	_Jiggle_Counter
   3310  2166				   .
   3311  2166							; 
   3312  2166
   3313  2166				   .
   3314  2166							; 
   3315  2166
   3316  2166				   .
   3317  2166							; 
   3318  2166
   3319  2166				   .
   3320  2166							; 
   3321  2166
   3322  2166				   .L0179		;  if _Current_Object	=  _Sprite0 then temp5	=  255	+   ( rand & 3 )   :  player0x	=  player0x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player0y	=  player0y  +	temp5
   3323  2166
   3324  2166		       a5 d7		      LDA	_Current_Object
   3325  2168		       c9 00		      CMP	#_Sprite0
   3326  216a		       d0 58		      BNE	.skipL0179
   3327  216c				   .condpart141
   3328  216c							; complex statement detected
   3329  216c		       a9 ff		      LDA	#255
   3330  216e		       48		      PHA
   3331  216f		       85 d1		      sta	temp7
   3332  2171		       a9 b1		      lda	#>(ret_point2-1)
   3333  2173		       48		      pha
   3334  2174		       a9 86		      lda	#<(ret_point2-1)
   3335  2176		       48		      pha
   3336  2177		       a9 f4		      lda	#>(randomize-1)
   3337  2179		       48		      pha
   3338  217a		       a9 31		      lda	#<(randomize-1)
   3339  217c		       48		      pha
   3340  217d		       a5 d1		      lda	temp7
   3341  217f		       48		      pha
   3342  2180		       8a		      txa
   3343  2181		       48		      pha
   3344  2182		       a2 04		      ldx	#4
   3345  2184		       4c eb ff 	      jmp	BS_jsr
   3346  2187				   ret_point2
   3347  2187		       29 03		      AND	#3
   3348  2189		       ba		      TSX
   3349  218a		       e8		      INX
   3350  218b		       9a		      TXS
   3351  218c		       18		      CLC
   3352  218d		       75 00		      ADC	$00,x
   3353  218f		       85 cf		      STA	temp5
   3354  2191		       a5 84		      LDA	player0x
   3355  2193		       18		      CLC
   3356  2194		       65 cf		      ADC	temp5
   3357  2196		       85 84		      STA	player0x
   3358  2198							; complex statement detected
   3359  2198		       a9 ff		      LDA	#255
   3360  219a		       48		      PHA
   3361  219b		       85 d1		      sta	temp7
   3362  219d		       a9 b1		      lda	#>(ret_point3-1)
   3363  219f		       48		      pha
   3364  21a0		       a9 b2		      lda	#<(ret_point3-1)
   3365  21a2		       48		      pha
   3366  21a3		       a9 f4		      lda	#>(randomize-1)
   3367  21a5		       48		      pha
   3368  21a6		       a9 31		      lda	#<(randomize-1)
   3369  21a8		       48		      pha
   3370  21a9		       a5 d1		      lda	temp7
   3371  21ab		       48		      pha
   3372  21ac		       8a		      txa
   3373  21ad		       48		      pha
   3374  21ae		       a2 04		      ldx	#4
   3375  21b0		       4c eb ff 	      jmp	BS_jsr
   3376  21b3				   ret_point3
   3377  21b3		       29 03		      AND	#3
   3378  21b5		       ba		      TSX
   3379  21b6		       e8		      INX
   3380  21b7		       9a		      TXS
   3381  21b8		       18		      CLC
   3382  21b9		       75 00		      ADC	$00,x
   3383  21bb		       85 cf		      STA	temp5
   3384  21bd		       a5 8d		      LDA	player0y
   3385  21bf		       18		      CLC
   3386  21c0		       65 cf		      ADC	temp5
   3387  21c2		       85 8d		      STA	player0y
   3388  21c4				   .skipL0179
   3389  21c4				   .L0180		;  if _Current_Object	=  _Sprite1 then temp5	=  255	+   ( rand & 3 )   :  player1x	=  player1x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player1y	=  player1y  +	temp5
   3390  21c4
   3391  21c4		       a5 d7		      LDA	_Current_Object
   3392  21c6		       c9 01		      CMP	#_Sprite1
   3393  21c8		       d0 58		      BNE	.skipL0180
   3394  21ca				   .condpart142
   3395  21ca							; complex statement detected
   3396  21ca		       a9 ff		      LDA	#255
   3397  21cc		       48		      PHA
   3398  21cd		       85 d1		      sta	temp7
   3399  21cf		       a9 b1		      lda	#>(ret_point4-1)
   3400  21d1		       48		      pha
   3401  21d2		       a9 e4		      lda	#<(ret_point4-1)
   3402  21d4		       48		      pha
   3403  21d5		       a9 f4		      lda	#>(randomize-1)
   3404  21d7		       48		      pha
   3405  21d8		       a9 31		      lda	#<(randomize-1)
   3406  21da		       48		      pha
   3407  21db		       a5 d1		      lda	temp7
   3408  21dd		       48		      pha
   3409  21de		       8a		      txa
   3410  21df		       48		      pha
   3411  21e0		       a2 04		      ldx	#4
   3412  21e2		       4c eb ff 	      jmp	BS_jsr
   3413  21e5				   ret_point4
   3414  21e5		       29 03		      AND	#3
   3415  21e7		       ba		      TSX
   3416  21e8		       e8		      INX
   3417  21e9		       9a		      TXS
   3418  21ea		       18		      CLC
   3419  21eb		       75 00		      ADC	$00,x
   3420  21ed		       85 cf		      STA	temp5
   3421  21ef		       a5 85		      LDA	player1x
   3422  21f1		       18		      CLC
   3423  21f2		       65 cf		      ADC	temp5
   3424  21f4		       85 85		      STA	player1x
   3425  21f6							; complex statement detected
   3426  21f6		       a9 ff		      LDA	#255
   3427  21f8		       48		      PHA
   3428  21f9		       85 d1		      sta	temp7
   3429  21fb		       a9 b2		      lda	#>(ret_point5-1)
   3430  21fd		       48		      pha
   3431  21fe		       a9 10		      lda	#<(ret_point5-1)
   3432  2200		       48		      pha
   3433  2201		       a9 f4		      lda	#>(randomize-1)
   3434  2203		       48		      pha
   3435  2204		       a9 31		      lda	#<(randomize-1)
   3436  2206		       48		      pha
   3437  2207		       a5 d1		      lda	temp7
   3438  2209		       48		      pha
   3439  220a		       8a		      txa
   3440  220b		       48		      pha
   3441  220c		       a2 04		      ldx	#4
   3442  220e		       4c eb ff 	      jmp	BS_jsr
   3443  2211				   ret_point5
   3444  2211		       29 03		      AND	#3
   3445  2213		       ba		      TSX
   3446  2214		       e8		      INX
   3447  2215		       9a		      TXS
   3448  2216		       18		      CLC
   3449  2217		       75 00		      ADC	$00,x
   3450  2219		       85 cf		      STA	temp5
   3451  221b		       a5 8e		      LDA	player1y
   3452  221d		       18		      CLC
   3453  221e		       65 cf		      ADC	temp5
   3454  2220		       85 8e		      STA	player1y
   3455  2222				   .skipL0180
   3456  2222				   .L0181		;  if _Current_Object	=  _Sprite2 then temp5	=  255	+   ( rand & 3 )   :  player2x	=  player2x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player2y	=  player2y  +	temp5
   3457  2222
   3458  2222		       a5 d7		      LDA	_Current_Object
   3459  2224		       c9 02		      CMP	#_Sprite2
   3460  2226		       d0 58		      BNE	.skipL0181
   3461  2228				   .condpart143
   3462  2228							; complex statement detected
   3463  2228		       a9 ff		      LDA	#255
   3464  222a		       48		      PHA
   3465  222b		       85 d1		      sta	temp7
   3466  222d		       a9 b2		      lda	#>(ret_point6-1)
   3467  222f		       48		      pha
   3468  2230		       a9 42		      lda	#<(ret_point6-1)
   3469  2232		       48		      pha
   3470  2233		       a9 f4		      lda	#>(randomize-1)
   3471  2235		       48		      pha
   3472  2236		       a9 31		      lda	#<(randomize-1)
   3473  2238		       48		      pha
   3474  2239		       a5 d1		      lda	temp7
   3475  223b		       48		      pha
   3476  223c		       8a		      txa
   3477  223d		       48		      pha
   3478  223e		       a2 04		      ldx	#4
   3479  2240		       4c eb ff 	      jmp	BS_jsr
   3480  2243				   ret_point6
   3481  2243		       29 03		      AND	#3
   3482  2245		       ba		      TSX
   3483  2246		       e8		      INX
   3484  2247		       9a		      TXS
   3485  2248		       18		      CLC
   3486  2249		       75 00		      ADC	$00,x
   3487  224b		       85 cf		      STA	temp5
   3488  224d		       a5 86		      LDA	player2x
   3489  224f		       18		      CLC
   3490  2250		       65 cf		      ADC	temp5
   3491  2252		       85 86		      STA	player2x
   3492  2254							; complex statement detected
   3493  2254		       a9 ff		      LDA	#255
   3494  2256		       48		      PHA
   3495  2257		       85 d1		      sta	temp7
   3496  2259		       a9 b2		      lda	#>(ret_point7-1)
   3497  225b		       48		      pha
   3498  225c		       a9 6e		      lda	#<(ret_point7-1)
   3499  225e		       48		      pha
   3500  225f		       a9 f4		      lda	#>(randomize-1)
   3501  2261		       48		      pha
   3502  2262		       a9 31		      lda	#<(randomize-1)
   3503  2264		       48		      pha
   3504  2265		       a5 d1		      lda	temp7
   3505  2267		       48		      pha
   3506  2268		       8a		      txa
   3507  2269		       48		      pha
   3508  226a		       a2 04		      ldx	#4
   3509  226c		       4c eb ff 	      jmp	BS_jsr
   3510  226f				   ret_point7
   3511  226f		       29 03		      AND	#3
   3512  2271		       ba		      TSX
   3513  2272		       e8		      INX
   3514  2273		       9a		      TXS
   3515  2274		       18		      CLC
   3516  2275		       75 00		      ADC	$00,x
   3517  2277		       85 cf		      STA	temp5
   3518  2279		       a5 8f		      LDA	player2y
   3519  227b		       18		      CLC
   3520  227c		       65 cf		      ADC	temp5
   3521  227e		       85 8f		      STA	player2y
   3522  2280				   .skipL0181
   3523  2280				   .L0182		;  if _Current_Object	=  _Sprite3 then temp5	=  255	+   ( rand & 3 )   :  player3x	=  player3x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player3y	=  player3y  +	temp5
   3524  2280
   3525  2280		       a5 d7		      LDA	_Current_Object
   3526  2282		       c9 03		      CMP	#_Sprite3
   3527  2284		       d0 58		      BNE	.skipL0182
   3528  2286				   .condpart144
   3529  2286							; complex statement detected
   3530  2286		       a9 ff		      LDA	#255
   3531  2288		       48		      PHA
   3532  2289		       85 d1		      sta	temp7
   3533  228b		       a9 b2		      lda	#>(ret_point8-1)
   3534  228d		       48		      pha
   3535  228e		       a9 a0		      lda	#<(ret_point8-1)
   3536  2290		       48		      pha
   3537  2291		       a9 f4		      lda	#>(randomize-1)
   3538  2293		       48		      pha
   3539  2294		       a9 31		      lda	#<(randomize-1)
   3540  2296		       48		      pha
   3541  2297		       a5 d1		      lda	temp7
   3542  2299		       48		      pha
   3543  229a		       8a		      txa
   3544  229b		       48		      pha
   3545  229c		       a2 04		      ldx	#4
   3546  229e		       4c eb ff 	      jmp	BS_jsr
   3547  22a1				   ret_point8
   3548  22a1		       29 03		      AND	#3
   3549  22a3		       ba		      TSX
   3550  22a4		       e8		      INX
   3551  22a5		       9a		      TXS
   3552  22a6		       18		      CLC
   3553  22a7		       75 00		      ADC	$00,x
   3554  22a9		       85 cf		      STA	temp5
   3555  22ab		       a5 87		      LDA	player3x
   3556  22ad		       18		      CLC
   3557  22ae		       65 cf		      ADC	temp5
   3558  22b0		       85 87		      STA	player3x
   3559  22b2							; complex statement detected
   3560  22b2		       a9 ff		      LDA	#255
   3561  22b4		       48		      PHA
   3562  22b5		       85 d1		      sta	temp7
   3563  22b7		       a9 b2		      lda	#>(ret_point9-1)
   3564  22b9		       48		      pha
   3565  22ba		       a9 cc		      lda	#<(ret_point9-1)
   3566  22bc		       48		      pha
   3567  22bd		       a9 f4		      lda	#>(randomize-1)
   3568  22bf		       48		      pha
   3569  22c0		       a9 31		      lda	#<(randomize-1)
   3570  22c2		       48		      pha
   3571  22c3		       a5 d1		      lda	temp7
   3572  22c5		       48		      pha
   3573  22c6		       8a		      txa
   3574  22c7		       48		      pha
   3575  22c8		       a2 04		      ldx	#4
   3576  22ca		       4c eb ff 	      jmp	BS_jsr
   3577  22cd				   ret_point9
   3578  22cd		       29 03		      AND	#3
   3579  22cf		       ba		      TSX
   3580  22d0		       e8		      INX
   3581  22d1		       9a		      TXS
   3582  22d2		       18		      CLC
   3583  22d3		       75 00		      ADC	$00,x
   3584  22d5		       85 cf		      STA	temp5
   3585  22d7		       a5 90		      LDA	player3y
   3586  22d9		       18		      CLC
   3587  22da		       65 cf		      ADC	temp5
   3588  22dc		       85 90		      STA	player3y
   3589  22de				   .skipL0182
   3590  22de				   .L0183		;  if _Current_Object	=  _Sprite4 then temp5	=  255	+   ( rand & 3 )   :  player4x	=  player4x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player4y	=  player4y  +	temp5
   3591  22de
   3592  22de		       a5 d7		      LDA	_Current_Object
   3593  22e0		       c9 04		      CMP	#_Sprite4
   3594  22e2		       d0 58		      BNE	.skipL0183
   3595  22e4				   .condpart145
   3596  22e4							; complex statement detected
   3597  22e4		       a9 ff		      LDA	#255
   3598  22e6		       48		      PHA
   3599  22e7		       85 d1		      sta	temp7
   3600  22e9		       a9 b2		      lda	#>(ret_point10-1)
   3601  22eb		       48		      pha
   3602  22ec		       a9 fe		      lda	#<(ret_point10-1)
   3603  22ee		       48		      pha
   3604  22ef		       a9 f4		      lda	#>(randomize-1)
   3605  22f1		       48		      pha
   3606  22f2		       a9 31		      lda	#<(randomize-1)
   3607  22f4		       48		      pha
   3608  22f5		       a5 d1		      lda	temp7
   3609  22f7		       48		      pha
   3610  22f8		       8a		      txa
   3611  22f9		       48		      pha
   3612  22fa		       a2 04		      ldx	#4
   3613  22fc		       4c eb ff 	      jmp	BS_jsr
   3614  22ff				   ret_point10
   3615  22ff		       29 03		      AND	#3
   3616  2301		       ba		      TSX
   3617  2302		       e8		      INX
   3618  2303		       9a		      TXS
   3619  2304		       18		      CLC
   3620  2305		       75 00		      ADC	$00,x
   3621  2307		       85 cf		      STA	temp5
   3622  2309		       a5 88		      LDA	player4x
   3623  230b		       18		      CLC
   3624  230c		       65 cf		      ADC	temp5
   3625  230e		       85 88		      STA	player4x
   3626  2310							; complex statement detected
   3627  2310		       a9 ff		      LDA	#255
   3628  2312		       48		      PHA
   3629  2313		       85 d1		      sta	temp7
   3630  2315		       a9 b3		      lda	#>(ret_point11-1)
   3631  2317		       48		      pha
   3632  2318		       a9 2a		      lda	#<(ret_point11-1)
   3633  231a		       48		      pha
   3634  231b		       a9 f4		      lda	#>(randomize-1)
   3635  231d		       48		      pha
   3636  231e		       a9 31		      lda	#<(randomize-1)
   3637  2320		       48		      pha
   3638  2321		       a5 d1		      lda	temp7
   3639  2323		       48		      pha
   3640  2324		       8a		      txa
   3641  2325		       48		      pha
   3642  2326		       a2 04		      ldx	#4
   3643  2328		       4c eb ff 	      jmp	BS_jsr
   3644  232b				   ret_point11
   3645  232b		       29 03		      AND	#3
   3646  232d		       ba		      TSX
   3647  232e		       e8		      INX
   3648  232f		       9a		      TXS
   3649  2330		       18		      CLC
   3650  2331		       75 00		      ADC	$00,x
   3651  2333		       85 cf		      STA	temp5
   3652  2335		       a5 91		      LDA	player4y
   3653  2337		       18		      CLC
   3654  2338		       65 cf		      ADC	temp5
   3655  233a		       85 91		      STA	player4y
   3656  233c				   .skipL0183
   3657  233c				   .L0184		;  if _Current_Object	=  _Sprite5 then temp5	=  255	+   ( rand & 3 )   :  player5x	=  player5x  +	temp5 :  temp5	=  255	+   ( rand & 3 )   :  player5y	=  player5y  +	temp5
   3658  233c
   3659  233c		       a5 d7		      LDA	_Current_Object
   3660  233e		       c9 05		      CMP	#_Sprite5
   3661  2340		       d0 58		      BNE	.skipL0184
   3662  2342				   .condpart146
   3663  2342							; complex statement detected
   3664  2342		       a9 ff		      LDA	#255
   3665  2344		       48		      PHA
   3666  2345		       85 d1		      sta	temp7
   3667  2347		       a9 b3		      lda	#>(ret_point12-1)
   3668  2349		       48		      pha
   3669  234a		       a9 5c		      lda	#<(ret_point12-1)
   3670  234c		       48		      pha
   3671  234d		       a9 f4		      lda	#>(randomize-1)
   3672  234f		       48		      pha
   3673  2350		       a9 31		      lda	#<(randomize-1)
   3674  2352		       48		      pha
   3675  2353		       a5 d1		      lda	temp7
   3676  2355		       48		      pha
   3677  2356		       8a		      txa
   3678  2357		       48		      pha
   3679  2358		       a2 04		      ldx	#4
   3680  235a		       4c eb ff 	      jmp	BS_jsr
   3681  235d				   ret_point12
   3682  235d		       29 03		      AND	#3
   3683  235f		       ba		      TSX
   3684  2360		       e8		      INX
   3685  2361		       9a		      TXS
   3686  2362		       18		      CLC
   3687  2363		       75 00		      ADC	$00,x
   3688  2365		       85 cf		      STA	temp5
   3689  2367		       a5 89		      LDA	player5x
   3690  2369		       18		      CLC
   3691  236a		       65 cf		      ADC	temp5
   3692  236c		       85 89		      STA	player5x
   3693  236e							; complex statement detected
   3694  236e		       a9 ff		      LDA	#255
   3695  2370		       48		      PHA
   3696  2371		       85 d1		      sta	temp7
   3697  2373		       a9 b3		      lda	#>(ret_point13-1)
   3698  2375		       48		      pha
   3699  2376		       a9 88		      lda	#<(ret_point13-1)
   3700  2378		       48		      pha
   3701  2379		       a9 f4		      lda	#>(randomize-1)
   3702  237b		       48		      pha
   3703  237c		       a9 31		      lda	#<(randomize-1)
   3704  237e		       48		      pha
   3705  237f		       a5 d1		      lda	temp7
   3706  2381		       48		      pha
   3707  2382		       8a		      txa
   3708  2383		       48		      pha
   3709  2384		       a2 04		      ldx	#4
   3710  2386		       4c eb ff 	      jmp	BS_jsr
   3711  2389				   ret_point13
   3712  2389		       29 03		      AND	#3
   3713  238b		       ba		      TSX
   3714  238c		       e8		      INX
   3715  238d		       9a		      TXS
   3716  238e		       18		      CLC
   3717  238f		       75 00		      ADC	$00,x
   3718  2391		       85 cf		      STA	temp5
   3719  2393		       a5 92		      LDA	player5y
   3720  2395		       18		      CLC
   3721  2396		       65 cf		      ADC	temp5
   3722  2398		       85 92		      STA	player5y
   3723  239a				   .skipL0184
   3724  239a				   .L0185		;  if _Current_Object	=  _Missile0 then temp5  =  255  +   ( rand & 3 )   :  missile0x  =  missile0x	+  temp5 :  temp5  =  255  +   ( rand & 3 )   :  missile0y  =  missile0y  +  temp5
   3725  239a
   3726  239a		       a5 d7		      LDA	_Current_Object
   3727  239c		       c9 06		      CMP	#_Missile0
   3728  239e		       d0 58		      BNE	.skipL0185
   3729  23a0				   .condpart147
   3730  23a0							; complex statement detected
   3731  23a0		       a9 ff		      LDA	#255
   3732  23a2		       48		      PHA
   3733  23a3		       85 d1		      sta	temp7
   3734  23a5		       a9 b3		      lda	#>(ret_point14-1)
   3735  23a7		       48		      pha
   3736  23a8		       a9 ba		      lda	#<(ret_point14-1)
   3737  23aa		       48		      pha
   3738  23ab		       a9 f4		      lda	#>(randomize-1)
   3739  23ad		       48		      pha
   3740  23ae		       a9 31		      lda	#<(randomize-1)
   3741  23b0		       48		      pha
   3742  23b1		       a5 d1		      lda	temp7
   3743  23b3		       48		      pha
   3744  23b4		       8a		      txa
   3745  23b5		       48		      pha
   3746  23b6		       a2 04		      ldx	#4
   3747  23b8		       4c eb ff 	      jmp	BS_jsr
   3748  23bb				   ret_point14
   3749  23bb		       29 03		      AND	#3
   3750  23bd		       ba		      TSX
   3751  23be		       e8		      INX
   3752  23bf		       9a		      TXS
   3753  23c0		       18		      CLC
   3754  23c1		       75 00		      ADC	$00,x
   3755  23c3		       85 cf		      STA	temp5
   3756  23c5		       a5 80		      LDA	missile0x
   3757  23c7		       18		      CLC
   3758  23c8		       65 cf		      ADC	temp5
   3759  23ca		       85 80		      STA	missile0x
   3760  23cc							; complex statement detected
   3761  23cc		       a9 ff		      LDA	#255
   3762  23ce		       48		      PHA
   3763  23cf		       85 d1		      sta	temp7
   3764  23d1		       a9 b3		      lda	#>(ret_point15-1)
   3765  23d3		       48		      pha
   3766  23d4		       a9 e6		      lda	#<(ret_point15-1)
   3767  23d6		       48		      pha
   3768  23d7		       a9 f4		      lda	#>(randomize-1)
   3769  23d9		       48		      pha
   3770  23da		       a9 31		      lda	#<(randomize-1)
   3771  23dc		       48		      pha
   3772  23dd		       a5 d1		      lda	temp7
   3773  23df		       48		      pha
   3774  23e0		       8a		      txa
   3775  23e1		       48		      pha
   3776  23e2		       a2 04		      ldx	#4
   3777  23e4		       4c eb ff 	      jmp	BS_jsr
   3778  23e7				   ret_point15
   3779  23e7		       29 03		      AND	#3
   3780  23e9		       ba		      TSX
   3781  23ea		       e8		      INX
   3782  23eb		       9a		      TXS
   3783  23ec		       18		      CLC
   3784  23ed		       75 00		      ADC	$00,x
   3785  23ef		       85 cf		      STA	temp5
   3786  23f1		       a5 8a		      LDA	missile0y
   3787  23f3		       18		      CLC
   3788  23f4		       65 cf		      ADC	temp5
   3789  23f6		       85 8a		      STA	missile0y
   3790  23f8				   .skipL0185
   3791  23f8				   .L0186		;  if _Current_Object	=  _Missile1 then temp5  =  255  +   ( rand & 3 )   :  missile1x  =  missile1x	+  temp5 :  temp5  =  255  +   ( rand & 3 )   :  missile1y  =  missile1y  +  temp5
   3792  23f8
   3793  23f8		       a5 d7		      LDA	_Current_Object
   3794  23fa		       c9 07		      CMP	#_Missile1
   3795  23fc		       d0 58		      BNE	.skipL0186
   3796  23fe				   .condpart148
   3797  23fe							; complex statement detected
   3798  23fe		       a9 ff		      LDA	#255
   3799  2400		       48		      PHA
   3800  2401		       85 d1		      sta	temp7
   3801  2403		       a9 b4		      lda	#>(ret_point16-1)
   3802  2405		       48		      pha
   3803  2406		       a9 18		      lda	#<(ret_point16-1)
   3804  2408		       48		      pha
   3805  2409		       a9 f4		      lda	#>(randomize-1)
   3806  240b		       48		      pha
   3807  240c		       a9 31		      lda	#<(randomize-1)
   3808  240e		       48		      pha
   3809  240f		       a5 d1		      lda	temp7
   3810  2411		       48		      pha
   3811  2412		       8a		      txa
   3812  2413		       48		      pha
   3813  2414		       a2 04		      ldx	#4
   3814  2416		       4c eb ff 	      jmp	BS_jsr
   3815  2419				   ret_point16
   3816  2419		       29 03		      AND	#3
   3817  241b		       ba		      TSX
   3818  241c		       e8		      INX
   3819  241d		       9a		      TXS
   3820  241e		       18		      CLC
   3821  241f		       75 00		      ADC	$00,x
   3822  2421		       85 cf		      STA	temp5
   3823  2423		       a5 81		      LDA	missile1x
   3824  2425		       18		      CLC
   3825  2426		       65 cf		      ADC	temp5
   3826  2428		       85 81		      STA	missile1x
   3827  242a							; complex statement detected
   3828  242a		       a9 ff		      LDA	#255
   3829  242c		       48		      PHA
   3830  242d		       85 d1		      sta	temp7
   3831  242f		       a9 b4		      lda	#>(ret_point17-1)
   3832  2431		       48		      pha
   3833  2432		       a9 44		      lda	#<(ret_point17-1)
   3834  2434		       48		      pha
   3835  2435		       a9 f4		      lda	#>(randomize-1)
   3836  2437		       48		      pha
   3837  2438		       a9 31		      lda	#<(randomize-1)
   3838  243a		       48		      pha
   3839  243b		       a5 d1		      lda	temp7
   3840  243d		       48		      pha
   3841  243e		       8a		      txa
   3842  243f		       48		      pha
   3843  2440		       a2 04		      ldx	#4
   3844  2442		       4c eb ff 	      jmp	BS_jsr
   3845  2445				   ret_point17
   3846  2445		       29 03		      AND	#3
   3847  2447		       ba		      TSX
   3848  2448		       e8		      INX
   3849  2449		       9a		      TXS
   3850  244a		       18		      CLC
   3851  244b		       75 00		      ADC	$00,x
   3852  244d		       85 cf		      STA	temp5
   3853  244f		       a5 8b		      LDA	missile1y
   3854  2451		       18		      CLC
   3855  2452		       65 cf		      ADC	temp5
   3856  2454		       85 8b		      STA	missile1y
   3857  2456				   .skipL0186
   3858  2456				   .L0187		;  if _Current_Object	=  _Ball then temp5  =	255  +	 ( rand & 3 )	:  ballx  =  ballx  +  temp5 :	temp5  =  255  +   ( rand & 3 )   :  bally  =  bally  +  temp5
   3859  2456
   3860  2456		       a5 d7		      LDA	_Current_Object
   3861  2458		       c9 08		      CMP	#_Ball
   3862  245a		       d0 58		      BNE	.skipL0187
   3863  245c				   .condpart149
   3864  245c							; complex statement detected
   3865  245c		       a9 ff		      LDA	#255
   3866  245e		       48		      PHA
   3867  245f		       85 d1		      sta	temp7
   3868  2461		       a9 b4		      lda	#>(ret_point18-1)
   3869  2463		       48		      pha
   3870  2464		       a9 76		      lda	#<(ret_point18-1)
   3871  2466		       48		      pha
   3872  2467		       a9 f4		      lda	#>(randomize-1)
   3873  2469		       48		      pha
   3874  246a		       a9 31		      lda	#<(randomize-1)
   3875  246c		       48		      pha
   3876  246d		       a5 d1		      lda	temp7
   3877  246f		       48		      pha
   3878  2470		       8a		      txa
   3879  2471		       48		      pha
   3880  2472		       a2 04		      ldx	#4
   3881  2474		       4c eb ff 	      jmp	BS_jsr
   3882  2477				   ret_point18
   3883  2477		       29 03		      AND	#3
   3884  2479		       ba		      TSX
   3885  247a		       e8		      INX
   3886  247b		       9a		      TXS
   3887  247c		       18		      CLC
   3888  247d		       75 00		      ADC	$00,x
   3889  247f		       85 cf		      STA	temp5
   3890  2481		       a5 82		      LDA	ballx
   3891  2483		       18		      CLC
   3892  2484		       65 cf		      ADC	temp5
   3893  2486		       85 82		      STA	ballx
   3894  2488							; complex statement detected
   3895  2488		       a9 ff		      LDA	#255
   3896  248a		       48		      PHA
   3897  248b		       85 d1		      sta	temp7
   3898  248d		       a9 b4		      lda	#>(ret_point19-1)
   3899  248f		       48		      pha
   3900  2490		       a9 a2		      lda	#<(ret_point19-1)
   3901  2492		       48		      pha
   3902  2493		       a9 f4		      lda	#>(randomize-1)
   3903  2495		       48		      pha
   3904  2496		       a9 31		      lda	#<(randomize-1)
   3905  2498		       48		      pha
   3906  2499		       a5 d1		      lda	temp7
   3907  249b		       48		      pha
   3908  249c		       8a		      txa
   3909  249d		       48		      pha
   3910  249e		       a2 04		      ldx	#4
   3911  24a0		       4c eb ff 	      jmp	BS_jsr
   3912  24a3				   ret_point19
   3913  24a3		       29 03		      AND	#3
   3914  24a5		       ba		      TSX
   3915  24a6		       e8		      INX
   3916  24a7		       9a		      TXS
   3917  24a8		       18		      CLC
   3918  24a9		       75 00		      ADC	$00,x
   3919  24ab		       85 cf		      STA	temp5
   3920  24ad		       a5 8c		      LDA	bally
   3921  24af		       18		      CLC
   3922  24b0		       65 cf		      ADC	temp5
   3923  24b2		       85 8c		      STA	bally
   3924  24b4				   .skipL0187
   3925  24b4				   .
   3926  24b4							; 
   3927  24b4
   3928  24b4				   .
   3929  24b4							; 
   3930  24b4
   3931  24b4				   .
   3932  24b4							; 
   3933  24b4
   3934  24b4				   .
   3935  24b4							; 
   3936  24b4
   3937  24b4				   .
   3938  24b4							; 
   3939  24b4
   3940  24b4				   .L0188		;  if _Jiggle_Counter	<=  4 then goto __Skip_Object_Jiggle
   3941  24b4
   3942  24b4		       a9 04		      LDA	#4
   3943  24b6		       c5 e5		      CMP	_Jiggle_Counter
   3944  24b8		       90 03		      BCC	.skipL0188
   3945  24ba				   .condpart150
   3946  24ba		       4c 45 b5 	      jmp	.__Skip_Object_Jiggle
   3947  24bd
   3948  24bd				   .skipL0188
   3949  24bd				   .
   3950  24bd							; 
   3951  24bd
   3952  24bd				   .L0189		;  _Bit2_Activate_Jiggle{2}  =  0  :  _Jiggle_Counter	=  0
   3953  24bd
   3954  24bd		       a5 ea		      LDA	_Bit2_Activate_Jiggle
   3955  24bf		       29 fb		      AND	#251
   3956  24c1		       85 ea		      STA	_Bit2_Activate_Jiggle
   3957  24c3		       a9 00		      LDA	#0
   3958  24c5		       85 e5		      STA	_Jiggle_Counter
   3959  24c7				   .
   3960  24c7							; 
   3961  24c7
   3962  24c7				   .L0190		;  if _Current_Object	=  _Sprite0 then player0x  =  _Memx  :	player0y  =  _Memy
   3963  24c7
   3964  24c7		       a5 d7		      LDA	_Current_Object
   3965  24c9		       c9 00		      CMP	#_Sprite0
   3966  24cb		       d0 08		      BNE	.skipL0190
   3967  24cd				   .condpart151
   3968  24cd		       a5 ee		      LDA	_Memx
   3969  24cf		       85 84		      STA	player0x
   3970  24d1		       a5 ef		      LDA	_Memy
   3971  24d3		       85 8d		      STA	player0y
   3972  24d5				   .skipL0190
   3973  24d5				   .L0191		;  if _Current_Object	=  _Sprite1 then player1x  =  _Memx  :	player1y  =  _Memy
   3974  24d5
   3975  24d5		       a5 d7		      LDA	_Current_Object
   3976  24d7		       c9 01		      CMP	#_Sprite1
   3977  24d9		       d0 08		      BNE	.skipL0191
   3978  24db				   .condpart152
   3979  24db		       a5 ee		      LDA	_Memx
   3980  24dd		       85 85		      STA	player1x
   3981  24df		       a5 ef		      LDA	_Memy
   3982  24e1		       85 8e		      STA	player1y
   3983  24e3				   .skipL0191
   3984  24e3				   .L0192		;  if _Current_Object	=  _Sprite2 then player2x  =  _Memx  :	player2y  =  _Memy
   3985  24e3
   3986  24e3		       a5 d7		      LDA	_Current_Object
   3987  24e5		       c9 02		      CMP	#_Sprite2
   3988  24e7		       d0 08		      BNE	.skipL0192
   3989  24e9				   .condpart153
   3990  24e9		       a5 ee		      LDA	_Memx
   3991  24eb		       85 86		      STA	player2x
   3992  24ed		       a5 ef		      LDA	_Memy
   3993  24ef		       85 8f		      STA	player2y
   3994  24f1				   .skipL0192
   3995  24f1				   .L0193		;  if _Current_Object	=  _Sprite3 then player3x  =  _Memx  :	player3y  =  _Memy
   3996  24f1
   3997  24f1		       a5 d7		      LDA	_Current_Object
   3998  24f3		       c9 03		      CMP	#_Sprite3
   3999  24f5		       d0 08		      BNE	.skipL0193
   4000  24f7				   .condpart154
   4001  24f7		       a5 ee		      LDA	_Memx
   4002  24f9		       85 87		      STA	player3x
   4003  24fb		       a5 ef		      LDA	_Memy
   4004  24fd		       85 90		      STA	player3y
   4005  24ff				   .skipL0193
   4006  24ff				   .L0194		;  if _Current_Object	=  _Sprite4 then player4x  =  _Memx  :	player4y  =  _Memy
   4007  24ff
   4008  24ff		       a5 d7		      LDA	_Current_Object
   4009  2501		       c9 04		      CMP	#_Sprite4
   4010  2503		       d0 08		      BNE	.skipL0194
   4011  2505				   .condpart155
   4012  2505		       a5 ee		      LDA	_Memx
   4013  2507		       85 88		      STA	player4x
   4014  2509		       a5 ef		      LDA	_Memy
   4015  250b		       85 91		      STA	player4y
   4016  250d				   .skipL0194
   4017  250d				   .L0195		;  if _Current_Object	=  _Sprite5 then player5x  =  _Memx  :	player5y  =  _Memy
   4018  250d
   4019  250d		       a5 d7		      LDA	_Current_Object
   4020  250f		       c9 05		      CMP	#_Sprite5
   4021  2511		       d0 08		      BNE	.skipL0195
   4022  2513				   .condpart156
   4023  2513		       a5 ee		      LDA	_Memx
   4024  2515		       85 89		      STA	player5x
   4025  2517		       a5 ef		      LDA	_Memy
   4026  2519		       85 92		      STA	player5y
   4027  251b				   .skipL0195
   4028  251b				   .L0196		;  if _Current_Object	=  _Missile0 then missile0x  =	_Memx  :  missile0y  =	_Memy
   4029  251b
   4030  251b		       a5 d7		      LDA	_Current_Object
   4031  251d		       c9 06		      CMP	#_Missile0
   4032  251f		       d0 08		      BNE	.skipL0196
   4033  2521				   .condpart157
   4034  2521		       a5 ee		      LDA	_Memx
   4035  2523		       85 80		      STA	missile0x
   4036  2525		       a5 ef		      LDA	_Memy
   4037  2527		       85 8a		      STA	missile0y
   4038  2529				   .skipL0196
   4039  2529				   .L0197		;  if _Current_Object	=  _Missile1 then missile1x  =	_Memx  :  missile1y  =	_Memy
   4040  2529
   4041  2529		       a5 d7		      LDA	_Current_Object
   4042  252b		       c9 07		      CMP	#_Missile1
   4043  252d		       d0 08		      BNE	.skipL0197
   4044  252f				   .condpart158
   4045  252f		       a5 ee		      LDA	_Memx
   4046  2531		       85 81		      STA	missile1x
   4047  2533		       a5 ef		      LDA	_Memy
   4048  2535		       85 8b		      STA	missile1y
   4049  2537				   .skipL0197
   4050  2537				   .L0198		;  if _Current_Object	=  _Ball then ballx  =	_Memx  :  bally  =  _Memy
   4051  2537
   4052  2537		       a5 d7		      LDA	_Current_Object
   4053  2539		       c9 08		      CMP	#_Ball
   4054  253b		       d0 08		      BNE	.skipL0198
   4055  253d				   .condpart159
   4056  253d		       a5 ee		      LDA	_Memx
   4057  253f		       85 82		      STA	ballx
   4058  2541		       a5 ef		      LDA	_Memy
   4059  2543		       85 8c		      STA	bally
   4060  2545				   .skipL0198
   4061  2545				   .
   4062  2545							; 
   4063  2545
   4064  2545				   .__Skip_Object_Jiggle
   4065  2545							; __Skip_Object_Jiggle
   4066  2545
   4067  2545				   .
   4068  2545							; 
   4069  2545
   4070  2545				   .
   4071  2545							; 
   4072  2545
   4073  2545				   .
   4074  2545							; 
   4075  2545
   4076  2545				   .
   4077  2545							; 
   4078  2545
   4079  2545				   .
   4080  2545							; 
   4081  2545
   4082  2545				   .
   4083  2545							; 
   4084  2545
   4085  2545				   .
   4086  2545							; 
   4087  2545
   4088  2545				   .L0199		;  if _Current_Object	=  _Sprite0 then scorecolor  =	$08  :	temp4  =  player0x
   4089  2545
   4090  2545		       a5 d7		      LDA	_Current_Object
   4091  2547		       c9 00		      CMP	#_Sprite0
   4092  2549		       d0 08		      BNE	.skipL0199
   4093  254b				   .condpart160
   4094  254b		       a9 08		      LDA	#$08
   4095  254d		       85 d5		      STA	scorecolor
   4096  254f		       a5 84		      LDA	player0x
   4097  2551		       85 ce		      STA	temp4
   4098  2553				   .skipL0199
   4099  2553				   .L0200		;  if _Current_Object	=  _Sprite1 then scorecolor  =	$1A  :	temp4  =  player1x
   4100  2553
   4101  2553		       a5 d7		      LDA	_Current_Object
   4102  2555		       c9 01		      CMP	#_Sprite1
   4103  2557		       d0 08		      BNE	.skipL0200
   4104  2559				   .condpart161
   4105  2559		       a9 1a		      LDA	#$1A
   4106  255b		       85 d5		      STA	scorecolor
   4107  255d		       a5 85		      LDA	player1x
   4108  255f		       85 ce		      STA	temp4
   4109  2561				   .skipL0200
   4110  2561				   .L0201		;  if _Current_Object	=  _Sprite2 then scorecolor  =	$3A  :	temp4  =  player2x
   4111  2561
   4112  2561		       a5 d7		      LDA	_Current_Object
   4113  2563		       c9 02		      CMP	#_Sprite2
   4114  2565		       d0 08		      BNE	.skipL0201
   4115  2567				   .condpart162
   4116  2567		       a9 3a		      LDA	#$3A
   4117  2569		       85 d5		      STA	scorecolor
   4118  256b		       a5 86		      LDA	player2x
   4119  256d		       85 ce		      STA	temp4
   4120  256f				   .skipL0201
   4121  256f				   .L0202		;  if _Current_Object	=  _Sprite3 then scorecolor  =	$6A  :	temp4  =  player3x
   4122  256f
   4123  256f		       a5 d7		      LDA	_Current_Object
   4124  2571		       c9 03		      CMP	#_Sprite3
   4125  2573		       d0 08		      BNE	.skipL0202
   4126  2575				   .condpart163
   4127  2575		       a9 6a		      LDA	#$6A
   4128  2577		       85 d5		      STA	scorecolor
   4129  2579		       a5 87		      LDA	player3x
   4130  257b		       85 ce		      STA	temp4
   4131  257d				   .skipL0202
   4132  257d				   .L0203		;  if _Current_Object	=  _Sprite4 then scorecolor  =	$8A  :	temp4  =  player4x
   4133  257d
   4134  257d		       a5 d7		      LDA	_Current_Object
   4135  257f		       c9 04		      CMP	#_Sprite4
   4136  2581		       d0 08		      BNE	.skipL0203
   4137  2583				   .condpart164
   4138  2583		       a9 8a		      LDA	#$8A
   4139  2585		       85 d5		      STA	scorecolor
   4140  2587		       a5 88		      LDA	player4x
   4141  2589		       85 ce		      STA	temp4
   4142  258b				   .skipL0203
   4143  258b				   .L0204		;  if _Current_Object	=  _Sprite5 then scorecolor  =	$CA  :	temp4  =  player5x
   4144  258b
   4145  258b		       a5 d7		      LDA	_Current_Object
   4146  258d		       c9 05		      CMP	#_Sprite5
   4147  258f		       d0 08		      BNE	.skipL0204
   4148  2591				   .condpart165
   4149  2591		       a9 ca		      LDA	#$CA
   4150  2593		       85 d5		      STA	scorecolor
   4151  2595		       a5 89		      LDA	player5x
   4152  2597		       85 ce		      STA	temp4
   4153  2599				   .skipL0204
   4154  2599				   .L0205		;  if _Current_Object	=  _Missile0 then scorecolor  =  $5A  :  temp4	=  missile0x
   4155  2599
   4156  2599		       a5 d7		      LDA	_Current_Object
   4157  259b		       c9 06		      CMP	#_Missile0
   4158  259d		       d0 08		      BNE	.skipL0205
   4159  259f				   .condpart166
   4160  259f		       a9 5a		      LDA	#$5A
   4161  25a1		       85 d5		      STA	scorecolor
   4162  25a3		       a5 80		      LDA	missile0x
   4163  25a5		       85 ce		      STA	temp4
   4164  25a7				   .skipL0205
   4165  25a7				   .L0206		;  if _Current_Object	=  _Missile1 then scorecolor  =  $BA  :  temp4	=  missile1x
   4166  25a7
   4167  25a7		       a5 d7		      LDA	_Current_Object
   4168  25a9		       c9 07		      CMP	#_Missile1
   4169  25ab		       d0 08		      BNE	.skipL0206
   4170  25ad				   .condpart167
   4171  25ad		       a9 ba		      LDA	#$BA
   4172  25af		       85 d5		      STA	scorecolor
   4173  25b1		       a5 81		      LDA	missile1x
   4174  25b3		       85 ce		      STA	temp4
   4175  25b5				   .skipL0206
   4176  25b5				   .L0207		;  if _Current_Object	=  _Ball then scorecolor  =  $4A  :  temp4  =  ballx
   4177  25b5
   4178  25b5		       a5 d7		      LDA	_Current_Object
   4179  25b7		       c9 08		      CMP	#_Ball
   4180  25b9		       d0 08		      BNE	.skipL0207
   4181  25bb				   .condpart168
   4182  25bb		       a9 4a		      LDA	#$4A
   4183  25bd		       85 d5		      STA	scorecolor
   4184  25bf		       a5 82		      LDA	ballx
   4185  25c1		       85 ce		      STA	temp4
   4186  25c3				   .skipL0207
   4187  25c3				   .
   4188  25c3							; 
   4189  25c3
   4190  25c3				   .L0208		;  _sc1  =  0	:  _sc2  =  _sc2  &  15
   4191  25c3
   4192  25c3		       a9 00		      LDA	#0
   4193  25c5		       85 d2		      STA	_sc1
   4194  25c7		       a5 d3		      LDA	_sc2
   4195  25c9		       29 0f		      AND	#15
   4196  25cb		       85 d3		      STA	_sc2
   4197  25cd				   .L0209		;  if temp4  >=  100 then _sc1  =  _sc1  +  16  :  temp4  =  temp4  -	100
   4198  25cd
   4199  25cd		       a5 ce		      LDA	temp4
   4200  25cf		       c9 64		      CMP	#100
   4201  25d1		       90 0e		      BCC	.skipL0209
   4202  25d3				   .condpart169
   4203  25d3		       a5 d2		      LDA	_sc1
   4204  25d5		       18		      CLC
   4205  25d6		       69 10		      ADC	#16
   4206  25d8		       85 d2		      STA	_sc1
   4207  25da		       a5 ce		      LDA	temp4
   4208  25dc		       38		      SEC
   4209  25dd		       e9 64		      SBC	#100
   4210  25df		       85 ce		      STA	temp4
   4211  25e1				   .skipL0209
   4212  25e1				   .L0210		;  if temp4  >=  100 then _sc1  =  _sc1  +  16  :  temp4  =  temp4  -	100
   4213  25e1
   4214  25e1		       a5 ce		      LDA	temp4
   4215  25e3		       c9 64		      CMP	#100
   4216  25e5		       90 0e		      BCC	.skipL0210
   4217  25e7				   .condpart170
   4218  25e7		       a5 d2		      LDA	_sc1
   4219  25e9		       18		      CLC
   4220  25ea		       69 10		      ADC	#16
   4221  25ec		       85 d2		      STA	_sc1
   4222  25ee		       a5 ce		      LDA	temp4
   4223  25f0		       38		      SEC
   4224  25f1		       e9 64		      SBC	#100
   4225  25f3		       85 ce		      STA	temp4
   4226  25f5				   .skipL0210
   4227  25f5				   .L0211		;  if temp4  >=  50 then _sc1	=  _sc1  +  5  :  temp4  =  temp4  -  50
   4228  25f5
   4229  25f5		       a5 ce		      LDA	temp4
   4230  25f7		       c9 32		      CMP	#50
   4231  25f9		       90 0e		      BCC	.skipL0211
   4232  25fb				   .condpart171
   4233  25fb		       a5 d2		      LDA	_sc1
   4234  25fd		       18		      CLC
   4235  25fe		       69 05		      ADC	#5
   4236  2600		       85 d2		      STA	_sc1
   4237  2602		       a5 ce		      LDA	temp4
   4238  2604		       38		      SEC
   4239  2605		       e9 32		      SBC	#50
   4240  2607		       85 ce		      STA	temp4
   4241  2609				   .skipL0211
   4242  2609				   .L0212		;  if temp4  >=  30 then _sc1	=  _sc1  +  3  :  temp4  =  temp4  -  30
   4243  2609
   4244  2609		       a5 ce		      LDA	temp4
   4245  260b		       c9 1e		      CMP	#30
   4246  260d		       90 0e		      BCC	.skipL0212
   4247  260f				   .condpart172
   4248  260f		       a5 d2		      LDA	_sc1
   4249  2611		       18		      CLC
   4250  2612		       69 03		      ADC	#3
   4251  2614		       85 d2		      STA	_sc1
   4252  2616		       a5 ce		      LDA	temp4
   4253  2618		       38		      SEC
   4254  2619		       e9 1e		      SBC	#30
   4255  261b		       85 ce		      STA	temp4
   4256  261d				   .skipL0212
   4257  261d				   .L0213		;  if temp4  >=  20 then _sc1	=  _sc1  +  2  :  temp4  =  temp4  -  20
   4258  261d
   4259  261d		       a5 ce		      LDA	temp4
   4260  261f		       c9 14		      CMP	#20
   4261  2621		       90 0e		      BCC	.skipL0213
   4262  2623				   .condpart173
   4263  2623		       a5 d2		      LDA	_sc1
   4264  2625		       18		      CLC
   4265  2626		       69 02		      ADC	#2
   4266  2628		       85 d2		      STA	_sc1
   4267  262a		       a5 ce		      LDA	temp4
   4268  262c		       38		      SEC
   4269  262d		       e9 14		      SBC	#20
   4270  262f		       85 ce		      STA	temp4
   4271  2631				   .skipL0213
   4272  2631				   .L0214		;  if temp4  >=  10 then _sc1	=  _sc1  +  1  :  temp4  =  temp4  -  10
   4273  2631
   4274  2631		       a5 ce		      LDA	temp4
   4275  2633		       c9 0a		      CMP	#10
   4276  2635		       90 09		      BCC	.skipL0214
   4277  2637				   .condpart174
   4278  2637		       e6 d2		      INC	_sc1
   4279  2639		       a5 ce		      LDA	temp4
   4280  263b		       38		      SEC
   4281  263c		       e9 0a		      SBC	#10
   4282  263e		       85 ce		      STA	temp4
   4283  2640				   .skipL0214
   4284  2640				   .L0215		;  _sc2  =   ( temp4  *  4  *	4 )   |  _sc2
   4285  2640
   4286  2640							; complex statement detected
   4287  2640		       a5 ce		      LDA	temp4
   4288  2642		       0a		      asl
   4289  2643		       0a		      asl
   4290  2644		       0a		      asl
   4291  2645		       0a		      asl
   4292  2646		       05 d3		      ORA	_sc2
   4293  2648		       85 d3		      STA	_sc2
   4294  264a				   .
   4295  264a							; 
   4296  264a
   4297  264a				   .
   4298  264a							; 
   4299  264a
   4300  264a				   .
   4301  264a							; 
   4302  264a
   4303  264a				   .
   4304  264a							; 
   4305  264a
   4306  264a				   .
   4307  264a							; 
   4308  264a
   4309  264a				   .
   4310  264a							; 
   4311  264a
   4312  264a				   .
   4313  264a							; 
   4314  264a
   4315  264a				   .L0216		;  if _Current_Object	=  _Sprite0 then temp4	=  player0y
   4316  264a
   4317  264a		       a5 d7		      LDA	_Current_Object
   4318  264c		       c9 00		      CMP	#_Sprite0
   4319  264e		       d0 04		      BNE	.skipL0216
   4320  2650				   .condpart175
   4321  2650		       a5 8d		      LDA	player0y
   4322  2652		       85 ce		      STA	temp4
   4323  2654				   .skipL0216
   4324  2654				   .L0217		;  if _Current_Object	=  _Sprite1 then temp4	=  player1y
   4325  2654
   4326  2654		       a5 d7		      LDA	_Current_Object
   4327  2656		       c9 01		      CMP	#_Sprite1
   4328  2658		       d0 04		      BNE	.skipL0217
   4329  265a				   .condpart176
   4330  265a		       a5 8e		      LDA	player1y
   4331  265c		       85 ce		      STA	temp4
   4332  265e				   .skipL0217
   4333  265e				   .L0218		;  if _Current_Object	=  _Sprite2 then temp4	=  player2y
   4334  265e
   4335  265e		       a5 d7		      LDA	_Current_Object
   4336  2660		       c9 02		      CMP	#_Sprite2
   4337  2662		       d0 04		      BNE	.skipL0218
   4338  2664				   .condpart177
   4339  2664		       a5 8f		      LDA	player2y
   4340  2666		       85 ce		      STA	temp4
   4341  2668				   .skipL0218
   4342  2668				   .L0219		;  if _Current_Object	=  _Sprite3 then temp4	=  player3y
   4343  2668
   4344  2668		       a5 d7		      LDA	_Current_Object
   4345  266a		       c9 03		      CMP	#_Sprite3
   4346  266c		       d0 04		      BNE	.skipL0219
   4347  266e				   .condpart178
   4348  266e		       a5 90		      LDA	player3y
   4349  2670		       85 ce		      STA	temp4
   4350  2672				   .skipL0219
   4351  2672				   .L0220		;  if _Current_Object	=  _Sprite4 then temp4	=  player4y
   4352  2672
   4353  2672		       a5 d7		      LDA	_Current_Object
   4354  2674		       c9 04		      CMP	#_Sprite4
   4355  2676		       d0 04		      BNE	.skipL0220
   4356  2678				   .condpart179
   4357  2678		       a5 91		      LDA	player4y
   4358  267a		       85 ce		      STA	temp4
   4359  267c				   .skipL0220
   4360  267c				   .L0221		;  if _Current_Object	=  _Sprite5 then temp4	=  player5y
   4361  267c
   4362  267c		       a5 d7		      LDA	_Current_Object
   4363  267e		       c9 05		      CMP	#_Sprite5
   4364  2680		       d0 04		      BNE	.skipL0221
   4365  2682				   .condpart180
   4366  2682		       a5 92		      LDA	player5y
   4367  2684		       85 ce		      STA	temp4
   4368  2686				   .skipL0221
   4369  2686				   .L0222		;  if _Current_Object	=  _Missile0 then temp4  =  missile0y
   4370  2686
   4371  2686		       a5 d7		      LDA	_Current_Object
   4372  2688		       c9 06		      CMP	#_Missile0
   4373  268a		       d0 04		      BNE	.skipL0222
   4374  268c				   .condpart181
   4375  268c		       a5 8a		      LDA	missile0y
   4376  268e		       85 ce		      STA	temp4
   4377  2690				   .skipL0222
   4378  2690				   .L0223		;  if _Current_Object	=  _Missile1 then temp4  =  missile1y
   4379  2690
   4380  2690		       a5 d7		      LDA	_Current_Object
   4381  2692		       c9 07		      CMP	#_Missile1
   4382  2694		       d0 04		      BNE	.skipL0223
   4383  2696				   .condpart182
   4384  2696		       a5 8b		      LDA	missile1y
   4385  2698		       85 ce		      STA	temp4
   4386  269a				   .skipL0223
   4387  269a				   .L0224		;  if _Current_Object	=  _Ball then temp4  =	bally
   4388  269a
   4389  269a		       a5 d7		      LDA	_Current_Object
   4390  269c		       c9 08		      CMP	#_Ball
   4391  269e		       d0 04		      BNE	.skipL0224
   4392  26a0				   .condpart183
   4393  26a0		       a5 8c		      LDA	bally
   4394  26a2		       85 ce		      STA	temp4
   4395  26a4				   .skipL0224
   4396  26a4				   .
   4397  26a4							; 
   4398  26a4
   4399  26a4				   .L0225		;  _sc2  =  _sc2  &  240  :  _sc3  =  0
   4400  26a4
   4401  26a4		       a5 d3		      LDA	_sc2
   4402  26a6		       29 f0		      AND	#240
   4403  26a8		       85 d3		      STA	_sc2
   4404  26aa		       a9 00		      LDA	#0
   4405  26ac		       85 d4		      STA	_sc3
   4406  26ae				   .L0226		;  if temp4  >=  100 then _sc2  =  _sc2  +  1	:  temp4  =  temp4  -  100
   4407  26ae
   4408  26ae		       a5 ce		      LDA	temp4
   4409  26b0		       c9 64		      CMP	#100
   4410  26b2		       90 09		      BCC	.skipL0226
   4411  26b4				   .condpart184
   4412  26b4		       e6 d3		      INC	_sc2
   4413  26b6		       a5 ce		      LDA	temp4
   4414  26b8		       38		      SEC
   4415  26b9		       e9 64		      SBC	#100
   4416  26bb		       85 ce		      STA	temp4
   4417  26bd				   .skipL0226
   4418  26bd				   .L0227		;  if temp4  >=  100 then _sc2  =  _sc2  +  1	:  temp4  =  temp4  -  100
   4419  26bd
   4420  26bd		       a5 ce		      LDA	temp4
   4421  26bf		       c9 64		      CMP	#100
   4422  26c1		       90 09		      BCC	.skipL0227
   4423  26c3				   .condpart185
   4424  26c3		       e6 d3		      INC	_sc2
   4425  26c5		       a5 ce		      LDA	temp4
   4426  26c7		       38		      SEC
   4427  26c8		       e9 64		      SBC	#100
   4428  26ca		       85 ce		      STA	temp4
   4429  26cc				   .skipL0227
   4430  26cc				   .L0228		;  if temp4  >=  50 then _sc3	=  _sc3  +  80	:  temp4  =  temp4  -  50
   4431  26cc
   4432  26cc		       a5 ce		      LDA	temp4
   4433  26ce		       c9 32		      CMP	#50
   4434  26d0		       90 0e		      BCC	.skipL0228
   4435  26d2				   .condpart186
   4436  26d2		       a5 d4		      LDA	_sc3
   4437  26d4		       18		      CLC
   4438  26d5		       69 50		      ADC	#80
   4439  26d7		       85 d4		      STA	_sc3
   4440  26d9		       a5 ce		      LDA	temp4
   4441  26db		       38		      SEC
   4442  26dc		       e9 32		      SBC	#50
   4443  26de		       85 ce		      STA	temp4
   4444  26e0				   .skipL0228
   4445  26e0				   .L0229		;  if temp4  >=  30 then _sc3	=  _sc3  +  48	:  temp4  =  temp4  -  30
   4446  26e0
   4447  26e0		       a5 ce		      LDA	temp4
   4448  26e2		       c9 1e		      CMP	#30
   4449  26e4		       90 0e		      BCC	.skipL0229
   4450  26e6				   .condpart187
   4451  26e6		       a5 d4		      LDA	_sc3
   4452  26e8		       18		      CLC
   4453  26e9		       69 30		      ADC	#48
   4454  26eb		       85 d4		      STA	_sc3
   4455  26ed		       a5 ce		      LDA	temp4
   4456  26ef		       38		      SEC
   4457  26f0		       e9 1e		      SBC	#30
   4458  26f2		       85 ce		      STA	temp4
   4459  26f4				   .skipL0229
   4460  26f4				   .L0230		;  if temp4  >=  20 then _sc3	=  _sc3  +  32	:  temp4  =  temp4  -  20
   4461  26f4
   4462  26f4		       a5 ce		      LDA	temp4
   4463  26f6		       c9 14		      CMP	#20
   4464  26f8		       90 0e		      BCC	.skipL0230
   4465  26fa				   .condpart188
   4466  26fa		       a5 d4		      LDA	_sc3
   4467  26fc		       18		      CLC
   4468  26fd		       69 20		      ADC	#32
   4469  26ff		       85 d4		      STA	_sc3
   4470  2701		       a5 ce		      LDA	temp4
   4471  2703		       38		      SEC
   4472  2704		       e9 14		      SBC	#20
   4473  2706		       85 ce		      STA	temp4
   4474  2708				   .skipL0230
   4475  2708				   .L0231		;  if temp4  >=  10 then _sc3	=  _sc3  +  16	:  temp4  =  temp4  -  10
   4476  2708
   4477  2708		       a5 ce		      LDA	temp4
   4478  270a		       c9 0a		      CMP	#10
   4479  270c		       90 0e		      BCC	.skipL0231
   4480  270e				   .condpart189
   4481  270e		       a5 d4		      LDA	_sc3
   4482  2710		       18		      CLC
   4483  2711		       69 10		      ADC	#16
   4484  2713		       85 d4		      STA	_sc3
   4485  2715		       a5 ce		      LDA	temp4
   4486  2717		       38		      SEC
   4487  2718		       e9 0a		      SBC	#10
   4488  271a		       85 ce		      STA	temp4
   4489  271c				   .skipL0231
   4490  271c				   .L0232		;  _sc3  =  _sc3  |  temp4
   4491  271c
   4492  271c		       a5 d4		      LDA	_sc3
   4493  271e		       05 ce		      ORA	temp4
   4494  2720		       85 d4		      STA	_sc3
   4495  2722				   .
   4496  2722							; 
   4497  2722
   4498  2722				   .
   4499  2722							; 
   4500  2722
   4501  2722				   .
   4502  2722							; 
   4503  2722
   4504  2722				   .
   4505  2722							; 
   4506  2722
   4507  2722				   .
   4508  2722							; 
   4509  2722
   4510  2722				   .
   4511  2722							; 
   4512  2722
   4513  2722				   .
   4514  2722							; 
   4515  2722
   4516  2722				   .L0233		;  drawscreen
   4517  2722
   4518  2722		       85 d1		      sta	temp7
   4519  2724		       a9 b7		      lda	#>(ret_point20-1)
   4520  2726		       48		      pha
   4521  2727		       a9 39		      lda	#<(ret_point20-1)
   4522  2729		       48		      pha
   4523  272a		       a9 f0		      lda	#>(drawscreen-1)
   4524  272c		       48		      pha
   4525  272d		       a9 39		      lda	#<(drawscreen-1)
   4526  272f		       48		      pha
   4527  2730		       a5 d1		      lda	temp7
   4528  2732		       48		      pha
   4529  2733		       8a		      txa
   4530  2734		       48		      pha
   4531  2735		       a2 04		      ldx	#4
   4532  2737		       4c eb ff 	      jmp	BS_jsr
   4533  273a				   ret_point20
   4534  273a				   .
   4535  273a							; 
   4536  273a
   4537  273a				   .
   4538  273a							; 
   4539  273a
   4540  273a				   .
   4541  273a							; 
   4542  273a
   4543  273a				   .
   4544  273a							; 
   4545  273a
   4546  273a				   .
   4547  273a							; 
   4548  273a
   4549  273a				   .
   4550  273a							; 
   4551  273a
   4552  273a				   .
   4553  273a							; 
   4554  273a
   4555  273a				   .
   4556  273a							; 
   4557  273a
   4558  273a				   .
   4559  273a							; 
   4560  273a
   4561  273a				   .
   4562  273a							; 
   4563  273a
   4564  273a				   .
   4565  273a							; 
   4566  273a
   4567  273a				   .
   4568  273a							; 
   4569  273a
   4570  273a				   .
   4571  273a							; 
   4572  273a
   4573  273a				   .
   4574  273a							; 
   4575  273a
   4576  273a				   .
   4577  273a							; 
   4578  273a
   4579  273a				   .L0234		;  if !switchreset then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Main_Loop bank1
   4580  273a
   4581  273a		       a9 01		      lda	#1
   4582  273c		       2c 82 02 	      bit	SWCHB
   4583  273f		       f0 18		      BEQ	.skipL0234
   4584  2741				   .condpart190
   4585  2741		       a5 ea		      LDA	_Bit0_Reset_Restrainer
   4586  2743		       29 fe		      AND	#254
   4587  2745		       85 ea		      STA	_Bit0_Reset_Restrainer
   4588  2747		       85 d1		      sta	temp7
   4589  2749		       a9 91		      lda	#>(.__Main_Loop-1)
   4590  274b		       48		      pha
   4591  274c		       a9 26		      lda	#<(.__Main_Loop-1)
   4592  274e		       48		      pha
   4593  274f		       a5 d1		      lda	temp7
   4594  2751		       48		      pha
   4595  2752		       8a		      txa
   4596  2753		       48		      pha
   4597  2754		       a2 01		      ldx	#1
   4598  2756		       4c eb ff 	      jmp	BS_jsr
   4599  2759				   .skipL0234
   4600  2759				   .
   4601  2759							; 
   4602  2759
   4603  2759				   .
   4604  2759							; 
   4605  2759
   4606  2759				   .
   4607  2759							; 
   4608  2759
   4609  2759				   .
   4610  2759							; 
   4611  2759
   4612  2759				   .
   4613  2759							; 
   4614  2759
   4615  2759				   .L0235		;  if _Bit0_Reset_Restrainer{0} then goto __Main_Loop bank1
   4616  2759
   4617  2759		       a5 ea		      LDA	_Bit0_Reset_Restrainer
   4618  275b		       4a		      LSR
   4619  275c		       90 12		      BCC	.skipL0235
   4620  275e				   .condpart191
   4621  275e		       85 d1		      sta	temp7
   4622  2760		       a9 91		      lda	#>(.__Main_Loop-1)
   4623  2762		       48		      pha
   4624  2763		       a9 26		      lda	#<(.__Main_Loop-1)
   4625  2765		       48		      pha
   4626  2766		       a5 d1		      lda	temp7
   4627  2768		       48		      pha
   4628  2769		       8a		      txa
   4629  276a		       48		      pha
   4630  276b		       a2 01		      ldx	#1
   4631  276d		       4c eb ff 	      jmp	BS_jsr
   4632  2770				   .skipL0235
   4633  2770				   .
   4634  2770							; 
   4635  2770
   4636  2770				   .
   4637  2770							; 
   4638  2770
   4639  2770				   .
   4640  2770							; 
   4641  2770
   4642  2770				   .
   4643  2770							; 
   4644  2770
   4645  2770				   .L0236		;  goto __Start_Restart bank1
   4646  2770
   4647  2770		       85 d1		      sta	temp7
   4648  2772		       a9 8f		      lda	#>(.__Start_Restart-1)
   4649  2774		       48		      pha
   4650  2775		       a9 ff		      lda	#<(.__Start_Restart-1)
   4651  2777		       48		      pha
   4652  2778		       a5 d1		      lda	temp7
   4653  277a		       48		      pha
   4654  277b		       8a		      txa
   4655  277c		       48		      pha
   4656  277d		       a2 01		      ldx	#1
   4657  277f		       4c eb ff 	      jmp	BS_jsr
   4658  2782				   .
   4659  2782							; 
   4660  2782
   4661  2782				   .
   4662  2782							; 
   4663  2782
   4664  2782				   .
   4665  2782							; 
   4666  2782
   4667  2782				   .
   4668  2782							; 
   4669  2782
   4670  2782				   .
   4671  2782							; 
   4672  2782
   4673  2782				   .
   4674  2782							; 
   4675  2782
   4676  2782				   .
   4677  2782							; 
   4678  2782
   4679  2782				   .
   4680  2782							; 
   4681  2782
   4682  2782				   .
   4683  2782							; 
   4684  2782
   4685  2782				   .L0237		;  data _Data_Sprite_Size
   4686  2782
   4687  2782		       4c 88 b7 	      JMP	.skipL0237
   4688  2785				   _Data_Sprite_Size
   4689  2785		       00 05 07 	      .byte.b	0, 5, 7
   4690  2788
   4691  2788				   .skipL0237
   4692  2788				   .
   4693  2788							; 
   4694  2788
   4695  2788				   .
   4696  2788							; 
   4697  2788
   4698  2788				   .
   4699  2788							; 
   4700  2788
   4701  2788				   .
   4702  2788							; 
   4703  2788
   4704  2788				   .
   4705  2788							; 
   4706  2788
   4707  2788				   .
   4708  2788							; 
   4709  2788
   4710  2788				   .
   4711  2788							; 
   4712  2788
   4713  2788				   .L0238		;  data _Data_MB_Width
   4714  2788
   4715  2788		       4c 8f b7 	      JMP	.skipL0238
   4716  278b				   _Data_MB_Width
   4717  278b		       00 10 20 30	      .byte.b	$00, $10, $20, $30
   4718  278f
   4719  278f				   .skipL0238
   4720  278f				   .
   4721  278f							; 
   4722  278f
   4723  278f				   .
   4724  278f							; 
   4725  278f
   4726  278f				   .
   4727  278f							; 
   4728  278f
   4729  278f				   .L0239		;  bank 3
   4730  278f
   4731  278f					      if	ECHO2
      2117 bytes of ROM space left in bank 2
   4732  278f					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   4733  278f					      endif
   4734  278f		       00 01	   ECHO2      =	1
   4735  2fd4					      ORG	$2FF4-bscode_length
   4736  2fd4					      RORG	$BFF4-bscode_length
   4737  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   4738  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   4739  2fd6				  -	      stx	FASTFETCH
   4740  2fd6					      endif
   4741  2fd6		       9a		      txs
   4742  2fd7				  -	      if	bankswitch == 64
   4743  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4744  2fd7					      else
   4745  2fd7		       a9 f3		      lda	#>(start-1)
   4746  2fd9					      endif
   4747  2fd9		       48		      pha
   4748  2fda		       a9 f4		      lda	#<(start-1)
   4749  2fdc		       48		      pha
   4750  2fdd		       48		      pha
   4751  2fde		       8a		      txa
   4752  2fdf		       48		      pha
   4753  2fe0		       ba		      tsx
   4754  2fe1					      if	bankswitch != 64
   4755  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   4756  2fe3		       2a		      rol
   4757  2fe4		       2a		      rol
   4758  2fe5		       2a		      rol
   4759  2fe6		       2a		      rol
   4760  2fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4761  2fe9		       aa		      tax
   4762  2fea		       e8		      inx
   4763  2feb				  -	      else
   4764  2feb				  -	      lda	4,x	; get high byte of return address
   4765  2feb				  -	      tay
   4766  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4767  2feb				  -	      sta	4,x
   4768  2feb				  -	      tya
   4769  2feb				  -	      lsr
   4770  2feb				  -	      lsr
   4771  2feb				  -	      lsr
   4772  2feb				  -	      lsr
   4773  2feb				  -	      tax
   4774  2feb				  -	      inx
   4775  2feb					      endif
   4776  2feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4777  2fee		       68		      pla
   4778  2fef		       aa		      tax
   4779  2ff0		       68		      pla
   4780  2ff1		       60		      rts
   4781  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4782  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4783  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4784  2ff2					      endif
   4785  2ffc					      ORG	$2FFC
   4786  2ffc					      RORG	$BFFC
   4787  2ffc		       d4 bf		      .word.w	(start_bank2 & $ffff)
   4788  2ffe		       d4 bf		      .word.w	(start_bank2 & $ffff)
   4789  3000					      ORG	$3000
   4790  3000					      RORG	$D000
   4791  3000				   .
   4792  3000							; 
   4793  3000
   4794  3000				   .
   4795  3000							; 
   4796  3000
   4797  3000				   .
   4798  3000							; 
   4799  3000
   4800  3000				   .L0240		;  bank 4
   4801  3000					      if	ECHO3
      4052 bytes of ROM space left in bank 3
   4802  3000					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   4803  3000					      endif
   4804  3000		       00 01	   ECHO3      =	1
   4805  3fd4					      ORG	$3FF4-bscode_length
   4806  3fd4					      RORG	$DFF4-bscode_length
   4807  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   4808  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   4809  3fd6				  -	      stx	FASTFETCH
   4810  3fd6					      endif
   4811  3fd6		       9a		      txs
   4812  3fd7				  -	      if	bankswitch == 64
   4813  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4814  3fd7					      else
   4815  3fd7		       a9 f3		      lda	#>(start-1)
   4816  3fd9					      endif
   4817  3fd9		       48		      pha
   4818  3fda		       a9 f4		      lda	#<(start-1)
   4819  3fdc		       48		      pha
   4820  3fdd		       48		      pha
   4821  3fde		       8a		      txa
   4822  3fdf		       48		      pha
   4823  3fe0		       ba		      tsx
   4824  3fe1					      if	bankswitch != 64
   4825  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   4826  3fe3		       2a		      rol
   4827  3fe4		       2a		      rol
   4828  3fe5		       2a		      rol
   4829  3fe6		       2a		      rol
   4830  3fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4831  3fe9		       aa		      tax
   4832  3fea		       e8		      inx
   4833  3feb				  -	      else
   4834  3feb				  -	      lda	4,x	; get high byte of return address
   4835  3feb				  -	      tay
   4836  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4837  3feb				  -	      sta	4,x
   4838  3feb				  -	      tya
   4839  3feb				  -	      lsr
   4840  3feb				  -	      lsr
   4841  3feb				  -	      lsr
   4842  3feb				  -	      lsr
   4843  3feb				  -	      tax
   4844  3feb				  -	      inx
   4845  3feb					      endif
   4846  3feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4847  3fee		       68		      pla
   4848  3fef		       aa		      tax
   4849  3ff0		       68		      pla
   4850  3ff1		       60		      rts
   4851  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4852  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4853  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4854  3ff2					      endif
   4855  3ffc					      ORG	$3FFC
   4856  3ffc					      RORG	$DFFC
   4857  3ffc		       d4 df		      .word.w	(start_bank3 & $ffff)
   4858  3ffe		       d4 df		      .word.w	(start_bank3 & $ffff)
   4859  4000					      ORG	$4000
   4860  4000					      RORG	$F000
   4861  4000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4862  4000
   4863  4000				   FineAdjustTableBegin
   4864  4000		       60		      .byte.b	%01100000	;left 6
   4865  4001		       50		      .byte.b	%01010000
   4866  4002		       40		      .byte.b	%01000000
   4867  4003		       30		      .byte.b	%00110000
   4868  4004		       20		      .byte.b	%00100000
   4869  4005		       10		      .byte.b	%00010000
   4870  4006		       00		      .byte.b	%00000000	;left 0
   4871  4007		       f0		      .byte.b	%11110000
   4872  4008		       e0		      .byte.b	%11100000
   4873  4009		       d0		      .byte.b	%11010000
   4874  400a		       c0		      .byte.b	%11000000
   4875  400b		       b0		      .byte.b	%10110000
   4876  400c		       a0		      .byte.b	%10100000
   4877  400d		       90		      .byte.b	%10010000
   4878  400e		       80		      .byte.b	%10000000	;right 8
   4879  400e		       ef 0f	   FineAdjustTableEnd =	FineAdjustTableBegin - 241
   4880  400f
   4881  400f				   PFStart
   4882  400f		       57 2b 00 15*	      .byte.b	87,43,0,21,0,0,0,10
   4883  4017				   blank_pf
   4884  4017		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,5
   4885  401f							; .byte 43,21,0,10,0,0,0,5
   4886  401f				  -	      ifconst	screenheight
   4887  401f				  -pfsub
   4888  401f				  -	      .byte	8,4,2,2,1,0,0,1,0
   4889  401f					      endif
   4890  401f							;--set initial P1 positions
   4891  401f				   multisprite_setup
   4892  401f		       a9 0f		      lda	#15
   4893  4021		       85 c4		      sta	pfheight
   4894  4023
   4895  4023		       a2 04		      ldx	#4
   4896  4025							; stx temp3
   4897  4025				   SetCopyHeight
   4898  4025							;	lda #76
   4899  4025							;	sta NewSpriteX,X
   4900  4025							;	lda CopyColorData,X
   4901  4025							;	sta NewCOLUP1,X
   4902  4025							;lda SpriteHeightTable,X
   4903  4025							; sta spriteheight,x
   4904  4025		       8a		      txa
   4905  4026		       95 9d		      sta	SpriteGfxIndex,X
   4906  4028		       95 f1		      sta	spritesort,X
   4907  402a		       ca		      dex
   4908  402b		       10 f8		      bpl	SetCopyHeight
   4909  402d
   4910  402d
   4911  402d
   4912  402d							; since we can't turn off pf, point PF to zeros here
   4913  402d		       a9 f0		      lda	#>blank_pf
   4914  402f		       85 be		      sta	PF2pointer+1
   4915  4031		       85 bc		      sta	PF1pointer+1
   4916  4033		       a9 17		      lda	#<blank_pf
   4917  4035		       85 bd		      sta	PF2pointer
   4918  4037		       85 bb		      sta	PF1pointer
   4919  4039		       60		      rts
   4920  403a
   4921  403a				   drawscreen
   4922  403a				  -	      ifconst	debugscore
   4923  403a				  -	      jsr	debugcycles
   4924  403a					      endif
   4925  403a
   4926  403a				   WaitForOverscanEnd
   4927  403a		       ad 84 02 	      lda	INTIM
   4928  403d		       30 fb		      bmi	WaitForOverscanEnd
   4929  403f
   4930  403f		       a9 02		      lda	#2
   4931  4041		       85 02		      sta	WSYNC
   4932  4043		       85 00		      sta	VSYNC
   4933  4045		       85 02		      sta	WSYNC
   4934  4047		       85 02		      sta	WSYNC
   4935  4049		       4a		      lsr
   4936  404a		       85 27		      sta	VDELBL
   4937  404c		       85 25		      sta	VDELP0
   4938  404e		       85 02		      sta	WSYNC
   4939  4050		       85 00		      sta	VSYNC	;turn off VSYNC
   4940  4052				  -	      ifconst	overscan_time
   4941  4052				  -	      lda	#overscan_time+5+128
   4942  4052					      else
   4943  4052		       a9 aa		      lda	#42+128
   4944  4054					      endif
   4945  4054		       8d 96 02 	      sta	TIM64T
   4946  4057
   4947  4057							; run possible vblank bB code
   4948  4057				  -	      ifconst	vblank_bB_code
   4949  4057				  -	      jsr	vblank_bB_code
   4950  4057					      endif
   4951  4057
   4952  4057		       20 dc f1 	      jsr	setscorepointers
   4953  405a		       20 7b f3 	      jsr	SetupP1Subroutine
   4954  405d
   4955  405d							;-------------
   4956  405d
   4957  405d
   4958  405d
   4959  405d
   4960  405d
   4961  405d							;--position P0, M0, M1, BL
   4962  405d
   4963  405d		       20 b5 f0 	      jsr	PrePositionAllObjects
   4964  4060
   4965  4060							;--set up player 0 pointer
   4966  4060
   4967  4060		       c6 8d		      dec	player0y
   4968  4062		       a5 a2		      lda	player0pointer	; player0: must be run every frame!
   4969  4064		       38		      sec
   4970  4065		       e5 8d		      sbc	player0y
   4971  4067		       18		      clc
   4972  4068		       65 b0		      adc	player0height
   4973  406a		       85 a2		      sta	player0pointer
   4974  406c
   4975  406c		       a5 8d		      lda	player0y
   4976  406e		       85 cf		      sta	P0Top
   4977  4070		       38		      sec
   4978  4071		       e5 b0		      sbc	player0height
   4979  4073		       18		      clc
   4980  4074		       69 80		      adc	#$80
   4981  4076		       85 a4		      sta	P0Bottom
   4982  4078
   4983  4078
   4984  4078							;--some final setup
   4985  4078
   4986  4078		       a2 04		      ldx	#4
   4987  407a		       a9 80		      lda	#$80
   4988  407c				   cycle74_HMCLR
   4989  407c		       95 20		      sta	HMP0,X
   4990  407e		       ca		      dex
   4991  407f		       10 fb		      bpl	cycle74_HMCLR
   4992  4081							;	sta HMCLR
   4993  4081
   4994  4081
   4995  4081		       a9 00		      lda	#0
   4996  4083		       85 0e		      sta	PF1
   4997  4085		       85 0f		      sta	PF2
   4998  4087		       85 1b		      sta	GRP0
   4999  4089		       85 1c		      sta	GRP1
   5000  408b
   5001  408b
   5002  408b		       20 d0 f0 	      jsr	KernelSetupSubroutine
   5003  408e
   5004  408e				   WaitForVblankEnd
   5005  408e		       ad 84 02 	      lda	INTIM
   5006  4091		       30 fb		      bmi	WaitForVblankEnd
   5007  4093		       a9 00		      lda	#0
   5008  4095		       85 02		      sta	WSYNC
   5009  4097		       85 01		      sta	VBLANK	;turn off VBLANK - it was turned on by overscan
   5010  4099		       85 2c		      sta	CXCLR
   5011  409b
   5012  409b
   5013  409b		       4c 5d f1 	      jmp	KernelRoutine
   5014  409e
   5015  409e
   5016  409e				   PositionASpriteSubroutine		;call this function with A == horizontal position (0-159)
   5017  409e							;and X == the object to be positioned (0=P0, 1=P1, 2=M0, etc.)
   5018  409e							;if you do not wish to write to P1 during this function, make
   5019  409e							;sure Y==0 before you call it.  This function will change Y, and A
   5020  409e							;will be the value put into HMxx when returned.
   5021  409e							;Call this function with at least 11 cycles left in the scanline 
   5022  409e							;(jsr + sec + sta WSYNC = 11); it will return 9 cycles
   5023  409e							;into the second scanline
   5024  409e		       38		      sec
   5025  409f		       85 02		      sta	WSYNC	;begin line 1
   5026  40a1		       8d 2b 00 	      sta.w	HMCLR	;+4	 4
   5027  40a4				   DivideBy15Loop
   5028  40a4		       e9 0f		      sbc	#15
   5029  40a6		       b0 fc		      bcs	DivideBy15Loop	;+4/5	8/13.../58
   5030  40a8
   5031  40a8		       a8		      tay		;+2	10/15/...60
   5032  40a9		       b9 0f ef 	      lda	FineAdjustTableEnd,Y	;+5	15/20/...65
   5033  40ac
   5034  40ac							;	15
   5035  40ac		       95 20		      sta	HMP0,X	;+4	19/24/...69
   5036  40ae		       95 10		      sta	RESP0,X	;+4	23/28/33/38/43/48/53/58/63/68/73
   5037  40b0		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   5038  40b2		       85 2a		      sta	HMOVE	;+3
   5039  40b4		       60		      rts		;+6	 9
   5040  40b5
   5041  40b5							;-------------------------------------------------------------------------
   5042  40b5
   5043  40b5				   PrePositionAllObjects
   5044  40b5
   5045  40b5		       a2 04		      ldx	#4
   5046  40b7		       a5 82		      lda	ballx
   5047  40b9		       20 9e f0 	      jsr	PositionASpriteSubroutine
   5048  40bc
   5049  40bc		       ca		      dex
   5050  40bd		       a5 81		      lda	missile1x
   5051  40bf		       20 9e f0 	      jsr	PositionASpriteSubroutine
   5052  40c2
   5053  40c2		       ca		      dex
   5054  40c3		       a5 80		      lda	missile0x
   5055  40c5		       20 9e f0 	      jsr	PositionASpriteSubroutine
   5056  40c8
   5057  40c8		       ca		      dex
   5058  40c9		       ca		      dex
   5059  40ca		       a5 84		      lda	player0x
   5060  40cc		       20 9e f0 	      jsr	PositionASpriteSubroutine
   5061  40cf
   5062  40cf		       60		      rts
   5063  40d0
   5064  40d0
   5065  40d0							;-------------------------------------------------------------------------
   5066  40d0
   5067  40d0
   5068  40d0
   5069  40d0
   5070  40d0
   5071  40d0
   5072  40d0
   5073  40d0
   5074  40d0							;-------------------------------------------------------------------------
   5075  40d0
   5076  40d0
   5077  40d0				   KernelSetupSubroutine
   5078  40d0
   5079  40d0		       a2 04		      ldx	#4
   5080  40d2				   AdjustYValuesUpLoop
   5081  40d2		       b5 8e		      lda	NewSpriteY,X
   5082  40d4		       18		      clc
   5083  40d5		       69 02		      adc	#2
   5084  40d7		       95 8e		      sta	NewSpriteY,X
   5085  40d9		       ca		      dex
   5086  40da		       10 f6		      bpl	AdjustYValuesUpLoop
   5087  40dc
   5088  40dc
   5089  40dc		       a6 cd		      ldx	temp3	; first sprite displayed
   5090  40de
   5091  40de		       b5 9d		      lda	SpriteGfxIndex,x
   5092  40e0		       a8		      tay
   5093  40e1		       b9 8e 00 	      lda	NewSpriteY,y
   5094  40e4		       85 ce		      sta	RepoLine
   5095  40e6
   5096  40e6		       b5 9c		      lda	SpriteGfxIndex-1,x
   5097  40e8		       a8		      tay
   5098  40e9		       b9 8e 00 	      lda	NewSpriteY,y
   5099  40ec		       85 d0		      sta	temp6
   5100  40ee
   5101  40ee		       86 83		      stx	SpriteIndex
   5102  40f0
   5103  40f0
   5104  40f0
   5105  40f0		       a9 ff		      lda	#255
   5106  40f2		       85 a5		      sta	P1Bottom
   5107  40f4
   5108  40f4		       a5 8d		      lda	player0y
   5109  40f6				  -	      ifconst	screenheight
   5110  40f6				  -	      cmp	#screenheight+1
   5111  40f6					      else
   5112  40f6		       c9 59		      cmp	#$59
   5113  40f8					      endif
   5114  40f8		       90 04		      bcc	nottoohigh
   5115  40fa		       a5 a4		      lda	P0Bottom
   5116  40fc		       85 cf		      sta	P0Top
   5117  40fe
   5118  40fe
   5119  40fe
   5120  40fe				   nottoohigh
   5121  40fe		       60		      rts
   5122  40ff
   5123  40ff							;-------------------------------------------------------------------------
   5124  40ff
   5125  40ff
   5126  40ff
   5127  40ff
   5128  40ff
   5129  40ff							;*************************************************************************
   5130  40ff
   5131  40ff							;-------------------------------------------------------------------------
   5132  40ff							;-------------------------Data Below--------------------------------------
   5133  40ff							;-------------------------------------------------------------------------
   5134  40ff
   5135  40ff				   MaskTable
   5136  40ff		       01 03 07 0f*	      .byte.b	1,3,7,15,31
   5137  4104
   5138  4104							; shove 6-digit score routine here
   5139  4104
   5140  4104				   sixdigscore
   5141  4104		       a9 00		      lda	#0
   5142  4106							;	sta COLUBK
   5143  4106		       85 0d		      sta	PF0
   5144  4108		       85 0e		      sta	PF1
   5145  410a		       85 0f		      sta	PF2
   5146  410c		       85 1f		      sta	ENABL
   5147  410e		       85 1d		      sta	ENAM0
   5148  4110		       85 1e		      sta	ENAM1
   5149  4112							;end of kernel here
   5150  4112
   5151  4112
   5152  4112							; 6 digit score routine
   5153  4112							; lda #0
   5154  4112							; sta PF1
   5155  4112							; sta PF2
   5156  4112							; tax
   5157  4112
   5158  4112		       85 02		      sta	WSYNC	;,x
   5159  4114
   5160  4114							;		  STA WSYNC ;first one, need one more
   5161  4114		       85 0b		      sta	REFP0
   5162  4116		       85 0c		      sta	REFP1
   5163  4118		       85 1b		      STA	GRP0
   5164  411a		       85 1c		      STA	GRP1
   5165  411c		       85 2b		      sta	HMCLR
   5166  411e
   5167  411e							; restore P0pointer
   5168  411e
   5169  411e		       a5 a2		      lda	player0pointer
   5170  4120		       18		      clc
   5171  4121		       65 8d		      adc	player0y
   5172  4123		       38		      sec
   5173  4124		       e5 b0		      sbc	player0height
   5174  4126		       85 a2		      sta	player0pointer
   5175  4128		       e6 8d		      inc	player0y
   5176  412a
   5177  412a				  -	      ifconst	vblank_time
   5178  412a				  -	      ifconst	screenheight
   5179  412a				  -	      if	screenheight == 84
   5180  412a				  -	      lda	#vblank_time+9+128+10
   5181  412a				  -	      else
   5182  412a				  -	      lda	#vblank_time+9+128+19
   5183  412a				  -	      endif
   5184  412a				  -	      else
   5185  412a				  -	      lda	#vblank_time+9+128
   5186  412a				  -	      endif
   5187  412a					      else
   5188  412a				  -	      ifconst	screenheight
   5189  412a				  -	      if	screenheight == 84
   5190  412a				  -	      lda	#52+128+10
   5191  412a				  -	      else
   5192  412a				  -	      lda	#52+128+19
   5193  412a				  -	      endif
   5194  412a					      else
   5195  412a		       a9 b4		      lda	#52+128
   5196  412c					      endif
   5197  412c					      endif
   5198  412c
   5199  412c		       8d 96 02 	      sta	TIM64T
   5200  412f				  -	      ifconst	minikernel
   5201  412f				  -	      jsr	minikernel
   5202  412f					      endif
   5203  412f				  -	      ifconst	noscore
   5204  412f				  -	      pla
   5205  412f				  -	      pla
   5206  412f				  -	      jmp	skipscore
   5207  412f					      endif
   5208  412f
   5209  412f							; score pointers contain:
   5210  412f							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   5211  412f							; swap lo2->temp1
   5212  412f							; swap lo4->temp3
   5213  412f							; swap lo6->temp5
   5214  412f
   5215  412f		       a5 ca		      lda	scorepointers+5
   5216  4131		       85 cf		      sta	temp5
   5217  4133		       a5 c6		      lda	scorepointers+1
   5218  4135		       85 cb		      sta	temp1
   5219  4137		       a5 c8		      lda	scorepointers+3
   5220  4139		       85 cd		      sta	temp3
   5221  413b
   5222  413b		       a9 ff		      lda	#>scoretable
   5223  413d		       85 c6		      sta	scorepointers+1
   5224  413f		       85 c8		      sta	scorepointers+3
   5225  4141		       85 ca		      sta	scorepointers+5
   5226  4143		       85 cc		      sta	temp2
   5227  4145		       85 ce		      sta	temp4
   5228  4147		       85 d0		      sta	temp6
   5229  4149
   5230  4149		       60		      rts
   5231  414a
   5232  414a
   5233  414a
   5234  414a							;-------------------------------------------------------------------------
   5235  414a							;----------------------Kernel Routine-------------------------------------
   5236  414a							;-------------------------------------------------------------------------
   5237  414a
   5238  414a
   5239  414a							;-------------------------------------------------------------------------
   5240  414a							; repeat $f147-*
   5241  414a							; brk
   5242  414a							; repend
   5243  414a							;	org $F240
   5244  414a
   5245  414a				   SwitchDrawP0K1		;	72
   5246  414a		       a5 a4		      lda	P0Bottom
   5247  414c		       85 cf		      sta	P0Top	;+6	 2
   5248  414e		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   5249  4151
   5250  4151				   WaitDrawP0K1 		;	74
      0  4151					      SLEEP	4	;+4	 2
      1  4151				   .CYCLES    SET	4
      2  4151
      3  4151				  -	      IF	.CYCLES < 2
      4  4151				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4151				  -	      ERR
      6  4151					      ENDIF
      7  4151
      8  4151				  -	      IF	.CYCLES & 1
      9  4151				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4151				  -	      nop	0
     11  4151				  -	      ELSE
     12  4151				  -	      bit	VSYNC
     13  4151				  -	      ENDIF
     14  4151				  -.CYCLES    SET	.CYCLES - 3
     15  4151					      ENDIF
     16  4151
     17  4151					      REPEAT	.CYCLES / 2
     18  4151		       ea		      nop
     17  4151					      REPEND
     18  4152		       ea		      nop
     19  4153					      REPEND
   5252  4153		       4c 88 f1 	      jmp	BackFromSwitchDrawP0K1	;+3	 5
   5253  4156
   5254  4156				   SkipDrawP1K1 		;	11
   5255  4156		       a9 00		      lda	#0
   5256  4158		       85 1c		      sta	GRP1	;+5	16	so Ball gets drawn
   5257  415a		       4c 91 f1 	      jmp	BackFromSkipDrawP1	;+3	19
   5258  415d
   5259  415d							;-------------------------------------------------------------------------
   5260  415d
   5261  415d				   KernelRoutine
   5262  415d					      ifnconst	screenheight
      0  415d					      sleep	12
      1  415d				   .CYCLES    SET	12
      2  415d
      3  415d				  -	      IF	.CYCLES < 2
      4  415d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  415d				  -	      ERR
      6  415d					      ENDIF
      7  415d
      8  415d				  -	      IF	.CYCLES & 1
      9  415d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  415d				  -	      nop	0
     11  415d				  -	      ELSE
     12  415d				  -	      bit	VSYNC
     13  415d				  -	      ENDIF
     14  415d				  -.CYCLES    SET	.CYCLES - 3
     15  415d					      ENDIF
     16  415d
     17  415d					      REPEAT	.CYCLES / 2
     18  415d		       ea		      nop
     17  415d					      REPEND
     18  415e		       ea		      nop
     17  415e					      REPEND
     18  415f		       ea		      nop
     17  415f					      REPEND
     18  4160		       ea		      nop
     17  4160					      REPEND
     18  4161		       ea		      nop
     17  4161					      REPEND
     18  4162		       ea		      nop
     19  4163					      REPEND
   5264  4163							; jsr wastetime ; waste 12 cycles
   5265  4163				  -	      else
   5266  4163				  -	      sleep	6
   5267  4163					      endif
   5268  4163		       ba		      tsx
   5269  4164		       86 f6		      stx	stack1
   5270  4166		       a2 1f		      ldx	#ENABL
   5271  4168		       9a		      txs		;+9	 9
   5272  4169
   5273  4169		       a2 00		      ldx	#0
   5274  416b		       a5 c4		      lda	pfheight
   5275  416d		       10 01		      bpl	asdhj
   5276  416f		       24		      .byte.b	$24
   5277  4170				   asdhj
   5278  4170		       aa		      tax
   5279  4171
   5280  4171							; ldx pfheight
   5281  4171		       bd 0f f0 	      lda	PFStart,x	; get pf pixel resolution for heights 15,7,3,1,0
   5282  4174
   5283  4174				  -	      ifconst	screenheight
   5284  4174				  -	      sec
   5285  4174				  -	      if	screenheight == 84
   5286  4174				  -	      sbc	pfsub+1,x
   5287  4174				  -	      else
   5288  4174				  -	      sbc	pfsub,x
   5289  4174				  -	      endif
   5290  4174					      endif
   5291  4174
   5292  4174		       85 ba		      sta	pfpixelheight
   5293  4176
   5294  4176				  -	      ifconst	screenheight
   5295  4176				  -	      ldy	#screenheight
   5296  4176					      else
   5297  4176		       a0 58		      ldy	#88
   5298  4178					      endif
   5299  4178
   5300  4178							;	lda #$02
   5301  4178							;	sta COLUBK		;+5	18
   5302  4178
   5303  4178							; sleep 25
      0  4178					      sleep	2
      1  4178				   .CYCLES    SET	2
      2  4178
      3  4178				  -	      IF	.CYCLES < 2
      4  4178				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4178				  -	      ERR
      6  4178					      ENDIF
      7  4178
      8  4178				  -	      IF	.CYCLES & 1
      9  4178				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4178				  -	      nop	0
     11  4178				  -	      ELSE
     12  4178				  -	      bit	VSYNC
     13  4178				  -	      ENDIF
     14  4178				  -.CYCLES    SET	.CYCLES - 3
     15  4178					      ENDIF
     16  4178
     17  4178					      REPEAT	.CYCLES / 2
     18  4178		       ea		      nop
     19  4179					      REPEND
   5305  4179				   KernelLoopa		;	50
      0  4179					      SLEEP	7	;+4	54
      1  4179				   .CYCLES    SET	7
      2  4179
      3  4179				  -	      IF	.CYCLES < 2
      4  4179				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4179				  -	      ERR
      6  4179					      ENDIF
      7  4179
      8  4179					      IF	.CYCLES & 1
      9  4179					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4179		       04 00		      nop	0
     11  417b				  -	      ELSE
     12  417b				  -	      bit	VSYNC
     13  417b					      ENDIF
     14  417b				   .CYCLES    SET	.CYCLES - 3
     15  417b					      ENDIF
     16  417b
     17  417b					      REPEAT	.CYCLES / 2
     18  417b		       ea		      nop
     17  417b					      REPEND
     18  417c		       ea		      nop
     19  417d					      REPEND
   5307  417d				   KernelLoopb		;	54
      0  417d					      SLEEP	2	;+12	66
      1  417d				   .CYCLES    SET	2
      2  417d
      3  417d				  -	      IF	.CYCLES < 2
      4  417d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  417d				  -	      ERR
      6  417d					      ENDIF
      7  417d
      8  417d				  -	      IF	.CYCLES & 1
      9  417d				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  417d				  -	      nop	0
     11  417d				  -	      ELSE
     12  417d				  -	      bit	VSYNC
     13  417d				  -	      ENDIF
     14  417d				  -.CYCLES    SET	.CYCLES - 3
     15  417d					      ENDIF
     16  417d
     17  417d					      REPEAT	.CYCLES / 2
     18  417d		       ea		      nop
     19  417e					      REPEND
   5309  417e		       c4 cf		      cpy	P0Top	;+3	69
   5310  4180		       f0 c8		      beq	SwitchDrawP0K1	;+2	71
   5311  4182		       10 cd		      bpl	WaitDrawP0K1	;+2	73
   5312  4184		       b1 a2		      lda	(player0pointer),Y	;+5	 2
   5313  4186		       85 1b		      sta	GRP0	;+3	 5	VDEL because of repokernel
   5314  4188				   BackFromSwitchDrawP0K1
   5315  4188
   5316  4188		       c4 a5		      cpy	P1Bottom	;+3	 8	unless we mean to draw immediately, this should be set
   5317  418a							;		to a value greater than maximum Y value initially
   5318  418a		       90 ca		      bcc	SkipDrawP1K1	;+2	10
   5319  418c		       b1 cc		      lda	(P1display),Y	;+5	15
   5320  418e		       8d 1c 00 	      sta.w	GRP1	;+4	19
   5321  4191				   BackFromSkipDrawP1
   5322  4191
   5323  4191							;fuck	
   5324  4191		       84 cb		      sty	temp1
   5325  4193		       a4 ba		      ldy	pfpixelheight
   5326  4195		       b3 bb		      lax	(PF1pointer),y
   5327  4197		       86 0e		      stx	PF1	;+7	26
   5328  4199		       b1 bd		      lda	(PF2pointer),y
   5329  419b		       85 0f		      sta	PF2	;+7	33
   5330  419d							;sleep 6
   5331  419d		       86 b7		      stx	PF1temp2
   5332  419f		       85 b9		      sta	PF2temp2
   5333  41a1		       88		      dey
   5334  41a2		       30 35		      bmi	pagewraphandler
   5335  41a4		       b1 bb		      lda	(PF1pointer),y
   5336  41a6				   cyclebalance
   5337  41a6		       85 b6		      sta	PF1temp1
   5338  41a8		       b1 bd		      lda	(PF2pointer),y
   5339  41aa		       85 b8		      sta	PF2temp1
   5340  41ac		       a4 cb		      ldy	temp1
   5341  41ae
   5342  41ae		       a2 1f		      ldx	#ENABL
   5343  41b0		       9a		      txs
   5344  41b1		       c4 8c		      cpy	bally
   5345  41b3		       08		      php		;+6	39	VDEL ball
   5346  41b4
   5347  41b4
   5348  41b4		       c4 8b		      cpy	missile1y
   5349  41b6		       08		      php		;+6	71
   5350  41b7
   5351  41b7		       c4 8a		      cpy	missile0y
   5352  41b9		       08		      php		;+6	 1
   5353  41ba
   5354  41ba
   5355  41ba		       88		      dey		;+2	15
   5356  41bb
   5357  41bb		       c4 ce		      cpy	RepoLine	;+3	18
   5358  41bd		       f0 62		      beq	RepoKernel	;+2	20
   5359  41bf							;	SLEEP 20		;+23	43
      0  41bf					      sleep	6
      1  41bf				   .CYCLES    SET	6
      2  41bf
      3  41bf				  -	      IF	.CYCLES < 2
      4  41bf				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41bf				  -	      ERR
      6  41bf					      ENDIF
      7  41bf
      8  41bf				  -	      IF	.CYCLES & 1
      9  41bf				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41bf				  -	      nop	0
     11  41bf				  -	      ELSE
     12  41bf				  -	      bit	VSYNC
     13  41bf				  -	      ENDIF
     14  41bf				  -.CYCLES    SET	.CYCLES - 3
     15  41bf					      ENDIF
     16  41bf
     17  41bf					      REPEAT	.CYCLES / 2
     18  41bf		       ea		      nop
     17  41bf					      REPEND
     18  41c0		       ea		      nop
     17  41c0					      REPEND
     18  41c1		       ea		      nop
     19  41c2					      REPEND
   5361  41c2
   5362  41c2				   newrepo		; since we have time here, store next repoline
   5363  41c2		       a6 83		      ldx	SpriteIndex
   5364  41c4		       b5 9c		      lda	SpriteGfxIndex-1,x
   5365  41c6		       aa		      tax
   5366  41c7		       b5 8e		      lda	NewSpriteY,x
   5367  41c9		       85 d0		      sta	temp6
      0  41cb					      sleep	4
      1  41cb				   .CYCLES    SET	4
      2  41cb
      3  41cb				  -	      IF	.CYCLES < 2
      4  41cb				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  41cb				  -	      ERR
      6  41cb					      ENDIF
      7  41cb
      8  41cb				  -	      IF	.CYCLES & 1
      9  41cb				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  41cb				  -	      nop	0
     11  41cb				  -	      ELSE
     12  41cb				  -	      bit	VSYNC
     13  41cb				  -	      ENDIF
     14  41cb				  -.CYCLES    SET	.CYCLES - 3
     15  41cb					      ENDIF
     16  41cb
     17  41cb					      REPEAT	.CYCLES / 2
     18  41cb		       ea		      nop
     17  41cb					      REPEND
     18  41cc		       ea		      nop
     19  41cd					      REPEND
   5369  41cd
   5370  41cd				   BackFromRepoKernel
   5371  41cd		       98		      tya		;+2	45
   5372  41ce		       25 c4		      and	pfheight	;+2	47
   5373  41d0		       d0 a7		      bne	KernelLoopa	;+2	49
   5374  41d2		       c6 ba		      dec	pfpixelheight
   5375  41d4		       10 a7		      bpl	KernelLoopb	;+3	54
   5376  41d6							;	bmi donewkernel		;+3	54
   5377  41d6							;	bne KernelLoopb+1		;+3	54
   5378  41d6
   5379  41d6				   donewkernel
   5380  41d6		       4c e0 f2 	      jmp	DoneWithKernel	;+3	56
   5381  41d9
   5382  41d9				   pagewraphandler
   5383  41d9		       4c a6 f1 	      jmp	cyclebalance
   5384  41dc
   5385  41dc							;-------------------------------------------------------------------------
   5386  41dc
   5387  41dc							; room here for score?
   5388  41dc
   5389  41dc				   setscorepointers
   5390  41dc		       a7 d4		      lax	score+2
   5391  41de		       20 f8 f1 	      jsr	scorepointerset
   5392  41e1		       84 ca		      sty	scorepointers+5
   5393  41e3		       86 c7		      stx	scorepointers+2
   5394  41e5		       a7 d3		      lax	score+1
   5395  41e7		       20 f8 f1 	      jsr	scorepointerset
   5396  41ea		       84 c9		      sty	scorepointers+4
   5397  41ec		       86 c6		      stx	scorepointers+1
   5398  41ee		       a7 d2		      lax	score
   5399  41f0		       20 f8 f1 	      jsr	scorepointerset
   5400  41f3		       84 c8		      sty	scorepointers+3
   5401  41f5		       86 c5		      stx	scorepointers
   5402  41f7				   wastetime
   5403  41f7		       60		      rts
   5404  41f8
   5405  41f8				   scorepointerset
   5406  41f8		       29 0f		      and	#$0F
   5407  41fa		       0a		      asl
   5408  41fb		       0a		      asl
   5409  41fc		       0a		      asl
   5410  41fd		       69 74		      adc	#<scoretable
   5411  41ff		       a8		      tay
   5412  4200		       8a		      txa
   5413  4201		       29 f0		      and	#$F0
   5414  4203		       4a		      lsr
   5415  4204		       69 74		      adc	#<scoretable
   5416  4206		       aa		      tax
   5417  4207		       60		      rts
   5418  4208							;	align 256
   5419  4208
   5420  4208				   SwitchDrawP0KR		;	45
   5421  4208		       a5 a4		      lda	P0Bottom
   5422  420a		       85 cf		      sta	P0Top	;+6	51
   5423  420c		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   5424  420f
   5425  420f				   WaitDrawP0KR 		;	47
      0  420f					      SLEEP	4	;+4	51
      1  420f				   .CYCLES    SET	4
      2  420f
      3  420f				  -	      IF	.CYCLES < 2
      4  420f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  420f				  -	      ERR
      6  420f					      ENDIF
      7  420f
      8  420f				  -	      IF	.CYCLES & 1
      9  420f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  420f				  -	      nop	0
     11  420f				  -	      ELSE
     12  420f				  -	      bit	VSYNC
     13  420f				  -	      ENDIF
     14  420f				  -.CYCLES    SET	.CYCLES - 3
     15  420f					      ENDIF
     16  420f
     17  420f					      REPEAT	.CYCLES / 2
     18  420f		       ea		      nop
     17  420f					      REPEND
     18  4210		       ea		      nop
     19  4211					      REPEND
   5427  4211		       4c 33 f2 	      jmp	BackFromSwitchDrawP0KR	;+3	54
   5428  4214
   5429  4214							;-----------------------------------------------------------
   5430  4214
   5431  4214				   noUpdateXKR
   5432  4214		       a2 01		      ldx	#1
   5433  4216		       cc cf 00 	      cpy.w	P0Top
   5434  4219		       4c 2b f2 	      JMP	retXKR
   5435  421c
   5436  421c				   skipthis
   5437  421c		       a2 01		      ldx	#1
   5438  421e		       4c 6d f2 	      jmp	goback
   5439  4221
   5440  4221				   RepoKernel		;	22	crosses page boundary
   5441  4221		       98		      tya
   5442  4222		       25 c4		      and	pfheight	;+2	26
   5443  4224		       d0 ee		      bne	noUpdateXKR	;+2	28
   5444  4226		       aa		      tax
   5445  4227							;	dex			;+2	30
   5446  4227		       c6 ba		      dec	pfpixelheight
   5447  4229							;	stx Temp		;+3	35
   5448  4229							;	SLEEP 3
   5449  4229
   5450  4229		       c4 cf		      cpy	P0Top	;+3	42
   5451  422b				   retXKR
   5452  422b		       f0 db		      beq	SwitchDrawP0KR	;+2	44
   5453  422d		       10 e0		      bpl	WaitDrawP0KR	;+2	46
   5454  422f		       b1 a2		      lda	(player0pointer),Y	;+5	51
   5455  4231		       85 1b		      sta	GRP0	;+3	54	VDEL
   5456  4233				   BackFromSwitchDrawP0KR
   5457  4233		       38		      sec		;+2	56
   5458  4234
   5459  4234
   5460  4234
   5461  4234		       b5 b8		      lda	PF2temp1,X
   5462  4236		       b4 b6		      ldy	PF1temp1,X
   5463  4238
   5464  4238		       a6 83		      ldx	SpriteIndex	;+3	 2
   5465  423a
   5466  423a		       85 0f		      sta	PF2	;+7	63
   5467  423c
   5468  423c		       b5 9d		      lda	SpriteGfxIndex,x
   5469  423e		       84 0e		      sty	PF1	;+7	70	too early?
   5470  4240		       aa		      tax
   5471  4241		       a9 00		      lda	#0
   5472  4243		       85 1c		      sta	GRP1	;+5	75	to display player 0
   5473  4245		       b5 85		      lda	NewSpriteX,X	;+4	 6
   5474  4247
   5475  4247				   DivideBy15LoopK		;	 6	(carry set above)
   5476  4247		       e9 0f		      sbc	#15
   5477  4249		       b0 fc		      bcs	DivideBy15LoopK	;+4/5	10/15.../60
   5478  424b
   5479  424b		       aa		      tax		;+2	12/17/...62
   5480  424c		       bd 0f ef 	      lda	FineAdjustTableEnd,X	;+5	17/22/...67
   5481  424f
   5482  424f		       85 21		      sta	HMP1	;+3	20/25/...70
   5483  4251		       85 11		      sta	RESP1	;+3	23/28/33/38/43/48/53/58/63/68/73
   5484  4253		       85 02		      sta	WSYNC	;+3	 0	begin line 2
   5485  4255							;sta HMOVE			;+3	 3
   5486  4255
   5487  4255		       a2 1f		      ldx	#ENABL
   5488  4257		       9a		      txs		;+4	25
   5489  4258		       a4 ce		      ldy	RepoLine	; restore y
   5490  425a		       c4 8c		      cpy	bally
   5491  425c		       08		      php		;+6	 9	VDEL ball
   5492  425d
   5493  425d		       c4 8b		      cpy	missile1y
   5494  425f		       08		      php		;+6	15
   5495  4260
   5496  4260		       c4 8a		      cpy	missile0y
   5497  4262		       08		      php		;+6	21
   5498  4263
   5499  4263
   5500  4263
   5501  4263
   5502  4263
   5503  4263							;15 cycles
   5504  4263		       98		      tya
   5505  4264		       25 c4		      and	pfheight
   5506  4266							;eor #1
   5507  4266		       29 fe		      and	#$FE
   5508  4268		       d0 b2		      bne	skipthis
   5509  426a		       aa		      tax
      0  426b					      sleep	4
      1  426b				   .CYCLES    SET	4
      2  426b
      3  426b				  -	      IF	.CYCLES < 2
      4  426b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  426b				  -	      ERR
      6  426b					      ENDIF
      7  426b
      8  426b				  -	      IF	.CYCLES & 1
      9  426b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  426b				  -	      nop	0
     11  426b				  -	      ELSE
     12  426b				  -	      bit	VSYNC
     13  426b				  -	      ENDIF
     14  426b				  -.CYCLES    SET	.CYCLES - 3
     15  426b					      ENDIF
     16  426b
     17  426b					      REPEAT	.CYCLES / 2
     18  426b		       ea		      nop
     17  426b					      REPEND
     18  426c		       ea		      nop
     19  426d					      REPEND
   5511  426d							;	sleep 2
   5512  426d				   goback
   5513  426d
   5514  426d		       88		      dey
   5515  426e		       c4 cf		      cpy	P0Top	;+3	52
   5516  4270		       f0 62		      beq	SwitchDrawP0KV	;+2	54
   5517  4272		       10 67		      bpl	WaitDrawP0KV	;+2	56
   5518  4274		       b1 a2		      lda	(player0pointer),Y	;+5	61
   5519  4276		       85 1b		      sta	GRP0	;+3	64	VDEL
   5520  4278				   BackFromSwitchDrawP0KV
   5521  4278
   5522  4278							; sleep 3
   5523  4278
   5524  4278		       b5 b8		      lda	PF2temp1,X
   5525  427a		       85 0f		      sta	PF2	;+7	 5
   5526  427c		       b5 b6		      lda	PF1temp1,X
   5527  427e		       85 0e		      sta	PF1	;+7	74 
   5528  4280		       85 2a		      sta	HMOVE
   5529  4282
   5530  4282		       a9 00		      lda	#0
   5531  4284		       85 1c		      sta	GRP1	;+5	10	to display GRP0
   5532  4286
   5533  4286		       a2 1f		      ldx	#ENABL
   5534  4288		       9a		      txs		;+4	 8
   5535  4289
   5536  4289		       a6 83		      ldx	SpriteIndex	;+3	13	restore index into new sprite vars
   5537  428b							;--now, set all new variables and return to main kernel loop
   5538  428b
   5539  428b
   5540  428b							;
   5541  428b		       b5 9d		      lda	SpriteGfxIndex,X	;+4	31
   5542  428d		       aa		      tax		;+2	33
   5543  428e							;
   5544  428e
   5545  428e
   5546  428e
   5547  428e		       b5 93		      lda	NewNUSIZ,X
   5548  4290		       85 05		      sta	NUSIZ1	;+7	20
   5549  4292		       85 0c		      sta	REFP1
   5550  4294		       b5 98		      lda	NewCOLUP1,X
   5551  4296		       85 07		      sta	COLUP1	;+7	27
   5552  4298
   5553  4298							;	lda SpriteGfxIndex,X	;+4	31
   5554  4298							;	tax				;+2	33
   5555  4298							;fuck2
   5556  4298		       b5 8e		      lda	NewSpriteY,X	;+4	46
   5557  429a		       38		      sec		;+2	38
   5558  429b		       f5 b1		      sbc	spriteheight,X	;+4	42
   5559  429d		       85 a5		      sta	P1Bottom	;+3	45
   5560  429f
      0  429f					      sleep	6
      1  429f				   .CYCLES    SET	6
      2  429f
      3  429f				  -	      IF	.CYCLES < 2
      4  429f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  429f				  -	      ERR
      6  429f					      ENDIF
      7  429f
      8  429f				  -	      IF	.CYCLES & 1
      9  429f				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  429f				  -	      nop	0
     11  429f				  -	      ELSE
     12  429f				  -	      bit	VSYNC
     13  429f				  -	      ENDIF
     14  429f				  -.CYCLES    SET	.CYCLES - 3
     15  429f					      ENDIF
     16  429f
     17  429f					      REPEAT	.CYCLES / 2
     18  429f		       ea		      nop
     17  429f					      REPEND
     18  42a0		       ea		      nop
     17  42a0					      REPEND
     18  42a1		       ea		      nop
     19  42a2					      REPEND
   5562  42a2		       b5 a6		      lda	player1pointerlo,X	;+4	49
   5563  42a4		       e5 a5		      sbc	P1Bottom	;+3	52	carry should still be set
   5564  42a6		       85 cc		      sta	P1display	;+3	55
   5565  42a8		       b5 ab		      lda	player1pointerhi,X
   5566  42aa		       85 cd		      sta	P1display+1	;+7	62
   5567  42ac
   5568  42ac
   5569  42ac		       c4 8c		      cpy	bally
   5570  42ae		       08		      php		;+6	68	VDELed
   5571  42af
   5572  42af		       c4 8b		      cpy	missile1y
   5573  42b1		       08		      php		;+6	74
   5574  42b2
   5575  42b2		       c4 8a		      cpy	missile0y
   5576  42b4		       08		      php		;+6	 4
   5577  42b5
   5578  42b5
   5579  42b5
   5580  42b5							; lda SpriteGfxIndex-1,x
   5581  42b5							; sleep 3
   5582  42b5		       c6 83		      dec	SpriteIndex	;+5	13
   5583  42b7							; tax
   5584  42b7							; lda NewSpriteY,x
   5585  42b7							; sta RepoLine
   5586  42b7
   5587  42b7							; 10 cycles below...
   5588  42b7		       10 05		      bpl	SetNextLine
   5589  42b9		       a9 ff		      lda	#255
   5590  42bb		       4c c1 f2 	      jmp	SetLastLine
   5591  42be				   SetNextLine
   5592  42be							;	lda NewSpriteY-1,x
   5593  42be		       ad d0 00 	      lda.w	temp6
   5594  42c1				   SetLastLine
   5595  42c1		       85 ce		      sta	RepoLine
   5596  42c3
   5597  42c3		       98		      tya
   5598  42c4		       25 c4		      and	pfheight
   5599  42c6		       d0 06		      bne	nodec
   5600  42c8		       c6 ba		      dec	pfpixelheight
   5601  42ca		       88		      dey		;+2	30
   5602  42cb
   5603  42cb							; 10 cycles 
   5604  42cb
   5605  42cb
   5606  42cb		       4c cd f1 	      jmp	BackFromRepoKernel	;+3	43
   5607  42ce
   5608  42ce				   nodec
      0  42ce					      sleep	4
      1  42ce				   .CYCLES    SET	4
      2  42ce
      3  42ce				  -	      IF	.CYCLES < 2
      4  42ce				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  42ce				  -	      ERR
      6  42ce					      ENDIF
      7  42ce
      8  42ce				  -	      IF	.CYCLES & 1
      9  42ce				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  42ce				  -	      nop	0
     11  42ce				  -	      ELSE
     12  42ce				  -	      bit	VSYNC
     13  42ce				  -	      ENDIF
     14  42ce				  -.CYCLES    SET	.CYCLES - 3
     15  42ce					      ENDIF
     16  42ce
     17  42ce					      REPEAT	.CYCLES / 2
     18  42ce		       ea		      nop
     17  42ce					      REPEND
     18  42cf		       ea		      nop
     19  42d0					      REPEND
   5610  42d0		       88		      dey
   5611  42d1		       4c cd f1 	      jmp	BackFromRepoKernel
   5612  42d4
   5613  42d4							;-------------------------------------------------------------------------
   5614  42d4
   5615  42d4
   5616  42d4				   SwitchDrawP0KV		;	69
   5617  42d4		       a5 a4		      lda	P0Bottom
   5618  42d6		       85 cf		      sta	P0Top	;+6	75
   5619  42d8		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   5620  42db
   5621  42db				   WaitDrawP0KV 		;	71
      0  42db					      SLEEP	4	;+4	75
      1  42db				   .CYCLES    SET	4
      2  42db
      3  42db				  -	      IF	.CYCLES < 2
      4  42db				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  42db				  -	      ERR
      6  42db					      ENDIF
      7  42db
      8  42db				  -	      IF	.CYCLES & 1
      9  42db				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  42db				  -	      nop	0
     11  42db				  -	      ELSE
     12  42db				  -	      bit	VSYNC
     13  42db				  -	      ENDIF
     14  42db				  -.CYCLES    SET	.CYCLES - 3
     15  42db					      ENDIF
     16  42db
     17  42db					      REPEAT	.CYCLES / 2
     18  42db		       ea		      nop
     17  42db					      REPEND
     18  42dc		       ea		      nop
     19  42dd					      REPEND
   5623  42dd		       4c 78 f2 	      jmp	BackFromSwitchDrawP0KV	;+3	 2
   5624  42e0
   5625  42e0							;-------------------------------------------------------------------------
   5626  42e0
   5627  42e0				   DoneWithKernel
   5628  42e0
   5629  42e0				   BottomOfKernelLoop
   5630  42e0
   5631  42e0		       85 02		      sta	WSYNC
   5632  42e2		       a6 f6		      ldx	stack1
   5633  42e4		       9a		      txs
   5634  42e5		       20 04 f1 	      jsr	sixdigscore	; set up score
   5635  42e8
   5636  42e8
   5637  42e8		       85 02		      sta	WSYNC
   5638  42ea		       a2 00		      ldx	#0
   5639  42ec		       85 2b		      sta	HMCLR
   5640  42ee		       86 1b		      STx	GRP0
   5641  42f0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   5642  42f2
   5643  42f2		       a0 07		      LDY	#7
   5644  42f4		       84 25		      STy	VDELP0
   5645  42f6		       84 26		      STy	VDELP1
   5646  42f8		       a9 10		      LDA	#$10
   5647  42fa		       85 21		      STA	HMP1
   5648  42fc		       a5 d5		      LDA	scorecolor
   5649  42fe		       85 06		      STA	COLUP0
   5650  4300		       85 07		      STA	COLUP1
   5651  4302
   5652  4302		       a9 03		      LDA	#$03
   5653  4304		       85 04		      STA	NUSIZ0
   5654  4306		       85 05		      STA	NUSIZ1
   5655  4308
   5656  4308		       85 10		      STA	RESP0
   5657  430a		       85 11		      STA	RESP1
   5658  430c
      0  430c					      sleep	9
      1  430c				   .CYCLES    SET	9
      2  430c
      3  430c				  -	      IF	.CYCLES < 2
      4  430c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  430c				  -	      ERR
      6  430c					      ENDIF
      7  430c
      8  430c					      IF	.CYCLES & 1
      9  430c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  430c		       04 00		      nop	0
     11  430e				  -	      ELSE
     12  430e				  -	      bit	VSYNC
     13  430e					      ENDIF
     14  430e				   .CYCLES    SET	.CYCLES - 3
     15  430e					      ENDIF
     16  430e
     17  430e					      REPEAT	.CYCLES / 2
     18  430e		       ea		      nop
     17  430e					      REPEND
     18  430f		       ea		      nop
     17  430f					      REPEND
     18  4310		       ea		      nop
     19  4311					      REPEND
   5660  4311		       b1 c5		      lda	(scorepointers),y
   5661  4313		       85 1b		      sta	GRP0
   5662  4315				  -	      ifconst	pfscore
   5663  4315				  -	      lda	pfscorecolor
   5664  4315				  -	      sta	COLUPF
   5665  4315					      else
      0  4315					      sleep	6
      1  4315				   .CYCLES    SET	6
      2  4315
      3  4315				  -	      IF	.CYCLES < 2
      4  4315				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4315				  -	      ERR
      6  4315					      ENDIF
      7  4315
      8  4315				  -	      IF	.CYCLES & 1
      9  4315				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4315				  -	      nop	0
     11  4315				  -	      ELSE
     12  4315				  -	      bit	VSYNC
     13  4315				  -	      ENDIF
     14  4315				  -.CYCLES    SET	.CYCLES - 3
     15  4315					      ENDIF
     16  4315
     17  4315					      REPEAT	.CYCLES / 2
     18  4315		       ea		      nop
     17  4315					      REPEND
     18  4316		       ea		      nop
     17  4316					      REPEND
     18  4317		       ea		      nop
     19  4318					      REPEND
   5667  4318					      endif
   5668  4318
   5669  4318		       85 2a		      STA	HMOVE
   5670  431a		       b1 cd		      lda	(scorepointers+8),y
   5671  431c							; sta WSYNC
   5672  431c							;sleep 2
   5673  431c		       4c 29 f3 	      jmp	beginscore
   5674  431f
   5675  431f
   5676  431f				   loop2
   5677  431f		       b1 c5		      lda	(scorepointers),y	;+5  68  204
   5678  4321		       85 1b		      sta	GRP0	;+3  71  213	   D1	  --	  --	 --
   5679  4323				  -	      ifconst	pfscore
   5680  4323				  -	      lda.w	pfscore1
   5681  4323				  -	      sta	PF1
   5682  4323					      else
      0  4323					      sleep	7
      1  4323				   .CYCLES    SET	7
      2  4323
      3  4323				  -	      IF	.CYCLES < 2
      4  4323				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4323				  -	      ERR
      6  4323					      ENDIF
      7  4323
      8  4323					      IF	.CYCLES & 1
      9  4323					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4323		       04 00		      nop	0
     11  4325				  -	      ELSE
     12  4325				  -	      bit	VSYNC
     13  4325					      ENDIF
     14  4325				   .CYCLES    SET	.CYCLES - 3
     15  4325					      ENDIF
     16  4325
     17  4325					      REPEAT	.CYCLES / 2
     18  4325		       ea		      nop
     17  4325					      REPEND
     18  4326		       ea		      nop
     19  4327					      REPEND
   5684  4327					      endif
   5685  4327							; cycle 0
   5686  4327		       b1 cd		      lda	(scorepointers+$8),y	;+5   5   15
   5687  4329				   beginscore
   5688  4329		       85 1c		      sta	GRP1	;+3   8   24	   D1	  D1	  D2	 --
   5689  432b		       b1 cb		      lda	(scorepointers+$6),y	;+5  13   39
   5690  432d		       85 1b		      sta	GRP0	;+3  16   48	   D3	  D1	  D2	 D2
   5691  432f		       b3 c7		      lax	(scorepointers+$2),y	;+5  29   87
   5692  4331		       9a		      txs
   5693  4332		       b3 c9		      lax	(scorepointers+$4),y	;+5  36  108
      0  4334					      sleep	3
      1  4334				   .CYCLES    SET	3
      2  4334
      3  4334				  -	      IF	.CYCLES < 2
      4  4334				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4334				  -	      ERR
      6  4334					      ENDIF
      7  4334
      8  4334					      IF	.CYCLES & 1
      9  4334					      IFNCONST	NO_ILLEGAL_OPCODES
     10  4334		       04 00		      nop	0
     11  4336				  -	      ELSE
     12  4336				  -	      bit	VSYNC
     13  4336					      ENDIF
     14  4336				   .CYCLES    SET	.CYCLES - 3
     15  4336					      ENDIF
     16  4336
     17  4336				  -	      REPEAT	.CYCLES / 2
     18  4336				  -	      nop
     19  4336					      REPEND
   5695  4336				  -	      ifconst	pfscore
   5696  4336				  -	      lda	pfscore2
   5697  4336				  -	      sta	PF1
   5698  4336					      else
      0  4336					      sleep	6
      1  4336				   .CYCLES    SET	6
      2  4336
      3  4336				  -	      IF	.CYCLES < 2
      4  4336				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  4336				  -	      ERR
      6  4336					      ENDIF
      7  4336
      8  4336				  -	      IF	.CYCLES & 1
      9  4336				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  4336				  -	      nop	0
     11  4336				  -	      ELSE
     12  4336				  -	      bit	VSYNC
     13  4336				  -	      ENDIF
     14  4336				  -.CYCLES    SET	.CYCLES - 3
     15  4336					      ENDIF
     16  4336
     17  4336					      REPEAT	.CYCLES / 2
     18  4336		       ea		      nop
     17  4336					      REPEND
     18  4337		       ea		      nop
     17  4337					      REPEND
     18  4338		       ea		      nop
     19  4339					      REPEND
   5700  4339					      endif
   5701  4339		       b1 cf		      lda	(scorepointers+$A),y	;+5  21   63
   5702  433b		       86 1c		      stx	GRP1	;+3  44  132	   D3	  D3	  D4	 D2!
   5703  433d		       ba		      tsx
   5704  433e		       86 1b		      stx	GRP0	;+3  47  141	   D5	  D3!	  D4	 D4
   5705  4340		       85 1c		      sta	GRP1	;+3  50  150	   D5	  D5	  D6	 D4!
   5706  4342		       84 1b		      sty	GRP0	;+3  53  159	   D4*	  D5!	  D6	 D6
   5707  4344		       88		      dey
   5708  4345		       10 d8		      bpl	loop2	;+2  60  180
   5709  4347		       a6 f6		      ldx	stack1
   5710  4349		       9a		      txs
   5711  434a
   5712  434a
   5713  434a							; lda scorepointers+1
   5714  434a		       a4 cb		      ldy	temp1
   5715  434c							; sta temp1
   5716  434c		       84 c6		      sty	scorepointers+1
   5717  434e
   5718  434e		       a9 00		      LDA	#0
   5719  4350		       85 1b		      STA	GRP0
   5720  4352		       85 1c		      STA	GRP1
   5721  4354		       85 0e		      sta	PF1
   5722  4356		       85 25		      STA	VDELP0
   5723  4358		       85 26		      STA	VDELP1	;do we need these
   5724  435a		       85 04		      STA	NUSIZ0
   5725  435c		       85 05		      STA	NUSIZ1
   5726  435e
   5727  435e							; lda scorepointers+3
   5728  435e		       a4 cd		      ldy	temp3
   5729  4360							; sta temp3
   5730  4360		       84 c8		      sty	scorepointers+3
   5731  4362
   5732  4362							; lda scorepointers+5
   5733  4362		       a4 cf		      ldy	temp5
   5734  4364							; sta temp5
   5735  4364		       84 ca		      sty	scorepointers+5
   5736  4366
   5737  4366
   5738  4366							;-------------------------------------------------------------------------
   5739  4366							;------------------------Overscan Routine---------------------------------
   5740  4366							;-------------------------------------------------------------------------
   5741  4366
   5742  4366				   OverscanRoutine
   5743  4366
   5744  4366
   5745  4366
   5746  4366				   skipscore
   5747  4366				  -	      ifconst	qtcontroller
   5748  4366				  -	      lda	qtcontroller
   5749  4366				  -	      lsr		; bit 0 in carry
   5750  4366				  -	      lda	#4
   5751  4366				  -	      ror		; carry into top of A
   5752  4366					      else
   5753  4366		       a9 02		      lda	#2
   5754  4368					      endif		; qtcontroller
   5755  4368		       85 02		      sta	WSYNC
   5756  436a		       85 01		      sta	VBLANK	;turn on VBLANK
   5757  436c
   5758  436c
   5759  436c
   5760  436c
   5761  436c
   5762  436c							;-------------------------------------------------------------------------
   5763  436c							;----------------------------End Main Routines----------------------------
   5764  436c							;-------------------------------------------------------------------------
   5765  436c
   5766  436c
   5767  436c							;*************************************************************************
   5768  436c
   5769  436c							;-------------------------------------------------------------------------
   5770  436c							;----------------------Begin Subroutines----------------------------------
   5771  436c							;-------------------------------------------------------------------------
   5772  436c
   5773  436c
   5774  436c
   5775  436c
   5776  436c				   KernelCleanupSubroutine
   5777  436c
   5778  436c		       a2 04		      ldx	#4
   5779  436e				   AdjustYValuesDownLoop
   5780  436e		       b5 8e		      lda	NewSpriteY,X
   5781  4370		       38		      sec
   5782  4371		       e9 02		      sbc	#2
   5783  4373		       95 8e		      sta	NewSpriteY,X
   5784  4375		       ca		      dex
   5785  4376		       10 f6		      bpl	AdjustYValuesDownLoop
   5786  4378
   5787  4378
      0  4378					      RETURN
      1  4378				  -	      ifnconst	bankswitch
      2  4378				  -	      rts
      3  4378					      else
      4  4378		       4c dd ff 	      jmp	BS_return
      5  437b					      endif
   5789  437b							;rts
   5790  437b
   5791  437b				   SetupP1Subroutine
   5792  437b							; flickersort algorithm
   5793  437b							; count 4-0
   5794  437b							; table2=table1 (?)
   5795  437b							; detect overlap of sprites in table 2
   5796  437b							; if overlap, do regular sort in table2, then place one sprite at top of table 1, decrement # displayed
   5797  437b							; if no overlap, do regular sort in table 2 and table 1
   5798  437b				   fsstart
   5799  437b		       a2 ff		      ldx	#255
   5800  437d				   copytable
   5801  437d		       e8		      inx
   5802  437e		       b5 f1		      lda	spritesort,x
   5803  4380		       95 9d		      sta	SpriteGfxIndex,x
   5804  4382		       e0 04		      cpx	#4
   5805  4384		       d0 f7		      bne	copytable
   5806  4386
   5807  4386		       86 cd		      stx	temp3	; highest displayed sprite
   5808  4388		       ca		      dex
   5809  4389		       86 cc		      stx	temp2
   5810  438b				   sortloop
   5811  438b		       a6 cc		      ldx	temp2
   5812  438d		       b5 f1		      lda	spritesort,x
   5813  438f		       aa		      tax
   5814  4390		       b5 8e		      lda	NewSpriteY,x
   5815  4392		       85 cb		      sta	temp1
   5816  4394
   5817  4394		       a6 cc		      ldx	temp2
   5818  4396		       b5 f2		      lda	spritesort+1,x
   5819  4398		       aa		      tax
   5820  4399		       b5 8e		      lda	NewSpriteY,x
   5821  439b		       38		      sec
   5822  439c		       18		      clc
   5823  439d		       e5 cb		      sbc	temp1
   5824  439f		       90 0e		      bcc	largerXislower
   5825  43a1
   5826  43a1							; larger x is higher (A>=temp1)
   5827  43a1		       d5 b1		      cmp	spriteheight,x
   5828  43a3		       b0 2f		      bcs	countdown
   5829  43a5							; overlap with x+1>x
   5830  43a5							; 
   5831  43a5							; stick x at end of gfxtable, dec counter
   5832  43a5				   overlapping
   5833  43a5		       c6 cd		      dec	temp3
   5834  43a7		       a6 cc		      ldx	temp2
   5835  43a9							; inx
   5836  43a9		       20 e8 f3 	      jsr	shiftnumbers
   5837  43ac		       4c ca f3 	      jmp	skipswapGfxtable
   5838  43af
   5839  43af				   largerXislower		; (temp1>A)
   5840  43af		       a8		      tay
   5841  43b0		       a6 cc		      ldx	temp2
   5842  43b2		       b5 f1		      lda	spritesort,x
   5843  43b4		       aa		      tax
   5844  43b5		       98		      tya
   5845  43b6		       49 ff		      eor	#$FF
   5846  43b8		       e9 01		      sbc	#1
   5847  43ba		       90 e9		      bcc	overlapping
   5848  43bc		       d5 b1		      cmp	spriteheight,x
   5849  43be		       b0 0a		      bcs	notoverlapping
   5850  43c0
   5851  43c0		       c6 cd		      dec	temp3
   5852  43c2		       a6 cc		      ldx	temp2
   5853  43c4							; inx
   5854  43c4		       20 e8 f3 	      jsr	shiftnumbers
   5855  43c7		       4c ca f3 	      jmp	skipswapGfxtable
   5856  43ca				   notoverlapping
   5857  43ca							; ldx temp2 ; swap display table
   5858  43ca							; ldy SpriteGfxIndex+1,x
   5859  43ca							; lda SpriteGfxIndex,x
   5860  43ca							; sty SpriteGfxIndex,x
   5861  43ca							; sta SpriteGfxIndex+1,x 
   5862  43ca
   5863  43ca				   skipswapGfxtable
   5864  43ca		       a6 cc		      ldx	temp2	; swap sort table
   5865  43cc		       b4 f2		      ldy	spritesort+1,x
   5866  43ce		       b5 f1		      lda	spritesort,x
   5867  43d0		       94 f1		      sty	spritesort,x
   5868  43d2		       95 f2		      sta	spritesort+1,x
   5869  43d4
   5870  43d4				   countdown
   5871  43d4		       c6 cc		      dec	temp2
   5872  43d6		       10 b3		      bpl	sortloop
   5873  43d8
   5874  43d8				   checktoohigh
   5875  43d8		       a6 cd		      ldx	temp3
   5876  43da		       b5 9d		      lda	SpriteGfxIndex,x
   5877  43dc		       aa		      tax
   5878  43dd		       b5 8e		      lda	NewSpriteY,x
   5879  43df				  -	      ifconst	screenheight
   5880  43df				  -	      cmp	#screenheight-3
   5881  43df					      else
   5882  43df		       c9 55		      cmp	#$55
   5883  43e1					      endif
   5884  43e1		       90 04		      bcc	nonetoohigh
   5885  43e3		       c6 cd		      dec	temp3
   5886  43e5		       d0 f1		      bne	checktoohigh
   5887  43e7
   5888  43e7				   nonetoohigh
   5889  43e7		       60		      rts
   5890  43e8
   5891  43e8
   5892  43e8				   shiftnumbers
   5893  43e8							; stick current x at end, shift others down
   5894  43e8							; if x=4: don't do anything
   5895  43e8							; if x=3: swap 3 and 4
   5896  43e8							; if x=2: 2=3, 3=4, 4=2
   5897  43e8							; if x=1: 1=2, 2=3, 3=4, 4=1
   5898  43e8							; if x=0: 0=1, 1=2, 2=3, 3=4, 4=0
   5899  43e8							; ldy SpriteGfxIndex,x
   5900  43e8				   swaploop
   5901  43e8		       e0 04		      cpx	#4
   5902  43ea		       f0 08		      beq	shiftdone
   5903  43ec		       b5 9e		      lda	SpriteGfxIndex+1,x
   5904  43ee		       95 9d		      sta	SpriteGfxIndex,x
   5905  43f0		       e8		      inx
   5906  43f1		       4c e8 f3 	      jmp	swaploop
   5907  43f4				   shiftdone
   5908  43f4							; sty SpriteGfxIndex,x
   5909  43f4		       60		      rts
   5910  43f5
   5911  43f5				  -	      ifconst	debugscore
   5912  43f5				  -debugcycles
   5913  43f5				  -	      ldx	#14
   5914  43f5				  -	      lda	INTIM	; display # cycles left in the score
   5915  43f5				  -
   5916  43f5				  -	      ifconst	mincycles
   5917  43f5				  -	      lda	mincycles
   5918  43f5				  -	      cmp	INTIM
   5919  43f5				  -	      lda	mincycles
   5920  43f5				  -	      bcc	nochange
   5921  43f5				  -	      lda	INTIM
   5922  43f5				  -	      sta	mincycles
   5923  43f5				  -nochange
   5924  43f5				  -	      endif
   5925  43f5				  -
   5926  43f5				  -			;   cmp #$2B
   5927  43f5				  -			;   bcs no_cycles_left
   5928  43f5				  -	      bmi	cycles_left
   5929  43f5				  -	      ldx	#64
   5930  43f5				  -	      eor	#$ff	;make negative
   5931  43f5				  -cycles_left
   5932  43f5				  -	      stx	scorecolor
   5933  43f5				  -	      and	#$7f	; clear sign bit
   5934  43f5				  -	      tax
   5935  43f5				  -	      lda	scorebcd,x
   5936  43f5				  -	      sta	score+2
   5937  43f5				  -	      lda	scorebcd1,x
   5938  43f5				  -	      sta	score+1
   5939  43f5				  -	      rts
   5940  43f5				  -scorebcd
   5941  43f5				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   5942  43f5				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   5943  43f5				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   5944  43f5				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   5945  43f5				  -scorebcd1
   5946  43f5				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   5947  43f5				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   5948  43f5				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   5949  43f5				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   5950  43f5					      endif
   5951  43f5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5952  43f5
   5953  43f5				   start
   5954  43f5		       78		      sei
   5955  43f6		       d8		      cld
   5956  43f7		       a0 00		      ldy	#0
   5957  43f9		       a5 d0		      lda	$D0
   5958  43fb		       c9 2c		      cmp	#$2C	;check RAM location #1
   5959  43fd		       d0 07		      bne	MachineIs2600
   5960  43ff		       a5 d1		      lda	$D1
   5961  4401		       c9 a9		      cmp	#$A9	;check RAM location #2
   5962  4403		       d0 01		      bne	MachineIs2600
   5963  4405		       88		      dey
   5964  4406				   MachineIs2600
   5965  4406		       a2 00		      ldx	#0
   5966  4408		       8a		      txa
   5967  4409				   clearmem
   5968  4409		       e8		      inx
   5969  440a		       9a		      txs
   5970  440b		       48		      pha
   5971  440c		       d0 fb		      bne	clearmem
   5972  440e		       84 cb		      sty	temp1
   5973  4410				  -	      ifnconst	multisprite
   5974  4410				  -	      ifconst	pfrowheight
   5975  4410				  -	      lda	#pfrowheight
   5976  4410				  -	      else
   5977  4410				  -	      ifconst	pfres
   5978  4410				  -	      lda	#(96/pfres)
   5979  4410				  -	      else
   5980  4410				  -	      lda	#8
   5981  4410				  -	      endif
   5982  4410				  -	      endif
   5983  4410				  -	      sta	playfieldpos
   5984  4410					      endif
   5985  4410		       a2 05		      ldx	#5
   5986  4412				   initscore
   5987  4412		       a9 74		      lda	#<scoretable
   5988  4414		       95 c5		      sta	scorepointers,x
   5989  4416		       ca		      dex
   5990  4417		       10 f9		      bpl	initscore
   5991  4419		       a9 01		      lda	#1
   5992  441b		       85 0a		      sta	CTRLPF
   5993  441d		       0d 84 02 	      ora	INTIM
   5994  4420		       85 d6		      sta	rand
   5995  4422
   5996  4422					      ifconst	multisprite
   5997  4422		       20 1f f0 	      jsr	multisprite_setup
   5998  4425					      endif
   5999  4425
   6000  4425				  -	      ifnconst	bankswitch
   6001  4425				  -	      jmp	game
   6002  4425					      else
   6003  4425		       a9 8f		      lda	#>(game-1)
   6004  4427		       48		      pha
   6005  4428		       a9 ff		      lda	#<(game-1)
   6006  442a		       48		      pha
   6007  442b		       48		      pha
   6008  442c		       48		      pha
   6009  442d		       a2 01		      ldx	#1
   6010  442f		       4c eb ff 	      jmp	BS_jsr
   6011  4432					      endif
   6012  4432							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6013  4432
   6014  4432							;standard routines needed for pretty much all games
   6015  4432							; just the random number generator is left - maybe we should remove this asm file altogether?
   6016  4432							; repositioning code and score pointer setup moved to overscan
   6017  4432							; read switches, joysticks now compiler generated (more efficient)
   6018  4432
   6019  4432				   randomize
   6020  4432		       a5 d6		      lda	rand
   6021  4434		       4a		      lsr
   6022  4435					      ifconst	rand16
   6023  4435		       26 f0		      rol	rand16
   6024  4437					      endif
   6025  4437		       90 02		      bcc	noeor
   6026  4439		       49 b4		      eor	#$B4
   6027  443b				   noeor
   6028  443b		       85 d6		      sta	rand
   6029  443d					      ifconst	rand16
   6030  443d		       45 f0		      eor	rand16
   6031  443f					      endif
      0  443f					      RETURN
      1  443f				  -	      ifnconst	bankswitch
      2  443f				  -	      rts
      3  443f					      else
      4  443f		       4c dd ff 	      jmp	BS_return
      5  4442					      endif
   6033  4442							;bB.asm
   6034  4442							; bB.asm file is split here
   6035  4442				  -	      if	(<*) > (<(*+8))
   6036  4442				  -	      repeat	($100-<*)
   6037  4442				  -	      .byte	0
   6038  4442				  -	      repend
   6039  4442					      endif
   6040  4442					      if	(<*) < 90
   6041  4442					      repeat	(90-<*)
   6042  4442		       00		      .byte.b	0
   6041  4442					      repend
   6042  4443		       00		      .byte.b	0
   6041  4443					      repend
   6042  4444		       00		      .byte.b	0
   6041  4444					      repend
   6042  4445		       00		      .byte.b	0
   6041  4445					      repend
   6042  4446		       00		      .byte.b	0
   6041  4446					      repend
   6042  4447		       00		      .byte.b	0
   6041  4447					      repend
   6042  4448		       00		      .byte.b	0
   6041  4448					      repend
   6042  4449		       00		      .byte.b	0
   6041  4449					      repend
   6042  444a		       00		      .byte.b	0
   6041  444a					      repend
   6042  444b		       00		      .byte.b	0
   6041  444b					      repend
   6042  444c		       00		      .byte.b	0
   6041  444c					      repend
   6042  444d		       00		      .byte.b	0
   6041  444d					      repend
   6042  444e		       00		      .byte.b	0
   6041  444e					      repend
   6042  444f		       00		      .byte.b	0
   6041  444f					      repend
   6042  4450		       00		      .byte.b	0
   6041  4450					      repend
   6042  4451		       00		      .byte.b	0
   6041  4451					      repend
   6042  4452		       00		      .byte.b	0
   6041  4452					      repend
   6042  4453		       00		      .byte.b	0
   6041  4453					      repend
   6042  4454		       00		      .byte.b	0
   6041  4454					      repend
   6042  4455		       00		      .byte.b	0
   6041  4455					      repend
   6042  4456		       00		      .byte.b	0
   6041  4456					      repend
   6042  4457		       00		      .byte.b	0
   6041  4457					      repend
   6042  4458		       00		      .byte.b	0
   6041  4458					      repend
   6042  4459		       00		      .byte.b	0
   6043  445a					      repend
   6044  445a					      endif
   6045  445a				   playerL035_0
   6046  445a		       00		      .byte.b	0
   6047  445b		       0f		      .byte.b	%00001111
   6048  445c		       06		      .byte.b	%00000110
   6049  445d		       ff		      .byte.b	%11111111
   6050  445e		       3e		      .byte.b	%00111110
   6051  445f		       ff		      .byte.b	%11111111
   6052  4460		       06		      .byte.b	%00000110
   6053  4461		       0f		      .byte.b	%00001111
   6054  4462		       00		      .byte.b
   6055  4463				  -	      if	(<*) > (<(*+6))
   6056  4463				  -	      repeat	($100-<*)
   6057  4463				  -	      .byte	0
   6058  4463				  -	      repend
   6059  4463					      endif
   6060  4463				  -	      if	(<*) < 90
   6061  4463				  -	      repeat	(90-<*)
   6062  4463				  -	      .byte	0
   6063  4463				  -	      repend
   6064  4463					      endif
   6065  4463				   playerL036_1
   6066  4463		       03		      .byte.b	%00000011
   6067  4464		       06		      .byte.b	%00000110
   6068  4465		       1f		      .byte.b	%00011111
   6069  4466		       fe		      .byte.b	%11111110
   6070  4467		       1f		      .byte.b	%00011111
   6071  4468		       06		      .byte.b	%00000110
   6072  4469		       03		      .byte.b	%00000011
   6073  446a				  -	      if	(<*) > (<(*+6))
   6074  446a				  -	      repeat	($100-<*)
   6075  446a				  -	      .byte	0
   6076  446a				  -	      repend
   6077  446a					      endif
   6078  446a				  -	      if	(<*) < 90
   6079  446a				  -	      repeat	(90-<*)
   6080  446a				  -	      .byte	0
   6081  446a				  -	      repend
   6082  446a					      endif
   6083  446a				   playerL037_2
   6084  446a		       0f		      .byte.b	%00001111
   6085  446b		       06		      .byte.b	%00000110
   6086  446c		       fe		      .byte.b	%11111110
   6087  446d		       0f		      .byte.b	%00001111
   6088  446e		       fe		      .byte.b	%11111110
   6089  446f		       06		      .byte.b	%00000110
   6090  4470		       0f		      .byte.b	%00001111
   6091  4471				  -	      if	(<*) > (<(*+6))
   6092  4471				  -	      repeat	($100-<*)
   6093  4471				  -	      .byte	0
   6094  4471				  -	      repend
   6095  4471					      endif
   6096  4471				  -	      if	(<*) < 90
   6097  4471				  -	      repeat	(90-<*)
   6098  4471				  -	      .byte	0
   6099  4471				  -	      repend
   6100  4471					      endif
   6101  4471				   playerL038_3
   6102  4471		       3e		      .byte.b	%00111110
   6103  4472		       07		      .byte.b	%00000111
   6104  4473		       1e		      .byte.b	%00011110
   6105  4474		       fe		      .byte.b	%11111110
   6106  4475		       1e		      .byte.b	%00011110
   6107  4476		       07		      .byte.b	%00000111
   6108  4477		       3e		      .byte.b	%00111110
   6109  4478				  -	      if	(<*) > (<(*+6))
   6110  4478				  -	      repeat	($100-<*)
   6111  4478				  -	      .byte	0
   6112  4478				  -	      repend
   6113  4478					      endif
   6114  4478				  -	      if	(<*) < 90
   6115  4478				  -	      repeat	(90-<*)
   6116  4478				  -	      .byte	0
   6117  4478				  -	      repend
   6118  4478					      endif
   6119  4478				   playerL039_4
   6120  4478		       0f		      .byte.b	%00001111
   6121  4479		       06		      .byte.b	%00000110
   6122  447a		       1e		      .byte.b	%00011110
   6123  447b		       ff		      .byte.b	%11111111
   6124  447c		       1e		      .byte.b	%00011110
   6125  447d		       06		      .byte.b	%00000110
   6126  447e		       0f		      .byte.b	%00001111
   6127  447f				  -	      if	(<*) > (<(*+6))
   6128  447f				  -	      repeat	($100-<*)
   6129  447f				  -	      .byte	0
   6130  447f				  -	      repend
   6131  447f					      endif
   6132  447f				  -	      if	(<*) < 90
   6133  447f				  -	      repeat	(90-<*)
   6134  447f				  -	      .byte	0
   6135  447f				  -	      repend
   6136  447f					      endif
   6137  447f				   playerL040_5
   6138  447f		       1f		      .byte.b	%00011111
   6139  4480		       04		      .byte.b	%00000100
   6140  4481		       fe		      .byte.b	%11111110
   6141  4482		       3e		      .byte.b	%00111110
   6142  4483		       fe		      .byte.b	%11111110
   6143  4484		       04		      .byte.b	%00000100
   6144  4485		       1f		      .byte.b	%00011111
   6145  4486					      if	ECHOFIRST
      2798 bytes of ROM space left in bank 4
   6146  4486					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 4")
   6147  4486					      endif
   6148  4486		       00 01	   ECHOFIRST  =	1
   6149  4486
   6150  4486
   6151  4486							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6152  4486
   6153  4486							; feel free to modify the score graphics - just keep each digit 8 high
   6154  4486							; and keep the conditional compilation stuff intact
   6155  4486				  -	      ifconst	ROM2k
   6156  4486				  -	      ORG	$F7AC-8
   6157  4486					      else
   6158  4486					      ifconst	bankswitch
   6159  4486				  -	      if	bankswitch == 8
   6160  4486				  -	      ORG	$2F94-bscode_length
   6161  4486				  -	      RORG	$FF94-bscode_length
   6162  4486					      endif
   6163  4486					      if	bankswitch == 16
   6164  4f74					      ORG	$4F94-bscode_length
   6165  4f74					      RORG	$FF94-bscode_length
   6166  4f74					      endif
   6167  4f74				  -	      if	bankswitch == 32
   6168  4f74				  -	      ORG	$8F94-bscode_length
   6169  4f74				  -	      RORG	$FF94-bscode_length
   6170  4f74					      endif
   6171  4f74				  -	      if	bankswitch == 64
   6172  4f74				  -	      ORG	$10F80-bscode_length
   6173  4f74				  -	      RORG	$1FF80-bscode_length
   6174  4f74					      endif
   6175  4f74				  -	      else
   6176  4f74				  -	      ORG	$FF9C
   6177  4f74					      endif
   6178  4f74					      endif
   6179  4f74
   6180  4f74							; font equates
   6181  4f74		       00 01	   .21stcentury =	1
   6182  4f74		       00 02	   alarmclock =	2
   6183  4f74		       00 03	   handwritten =	3
   6184  4f74		       00 04	   interrupted =	4
   6185  4f74		       00 05	   retroputer =	5
   6186  4f74		       00 06	   whimsey    =	6
   6187  4f74		       00 07	   tiny       =	7
   6188  4f74		       00 08	   hex	      =	8
   6189  4f74
   6190  4f74				  -	      ifconst	font
   6191  4f74				  -	      if	font == hex
   6192  4f74				  -	      ORG	. - 48
   6193  4f74				  -	      endif
   6194  4f74					      endif
   6195  4f74
   6196  4f74				   scoretable
   6197  4f74
   6198  4f74				  -	      ifconst	font
   6199  4f74				  -	      if	font == .21stcentury
   6200  4f74				  -	      include	"score_graphics.asm.21stcentury"
   6201  4f74				  -	      endif
   6202  4f74				  -	      if	font == alarmclock
   6203  4f74				  -	      include	"score_graphics.asm.alarmclock"
   6204  4f74				  -	      endif
   6205  4f74				  -	      if	font == handwritten
   6206  4f74				  -	      include	"score_graphics.asm.handwritten"
   6207  4f74				  -	      endif
   6208  4f74				  -	      if	font == interrupted
   6209  4f74				  -	      include	"score_graphics.asm.interrupted"
   6210  4f74				  -	      endif
   6211  4f74				  -	      if	font == retroputer
   6212  4f74				  -	      include	"score_graphics.asm.retroputer"
   6213  4f74				  -	      endif
   6214  4f74				  -	      if	font == whimsey
   6215  4f74				  -	      include	"score_graphics.asm.whimsey"
   6216  4f74				  -	      endif
   6217  4f74				  -	      if	font == tiny
   6218  4f74				  -	      include	"score_graphics.asm.tiny"
   6219  4f74				  -	      endif
   6220  4f74				  -	      if	font == hex
   6221  4f74				  -	      include	"score_graphics.asm.hex"
   6222  4f74				  -	      endif
   6223  4f74					      else		; default font
   6224  4f74
   6225  4f74		       3c		      .byte.b	%00111100
   6226  4f75		       66		      .byte.b	%01100110
   6227  4f76		       66		      .byte.b	%01100110
   6228  4f77		       66		      .byte.b	%01100110
   6229  4f78		       66		      .byte.b	%01100110
   6230  4f79		       66		      .byte.b	%01100110
   6231  4f7a		       66		      .byte.b	%01100110
   6232  4f7b		       3c		      .byte.b	%00111100
   6233  4f7c
   6234  4f7c		       7e		      .byte.b	%01111110
   6235  4f7d		       18		      .byte.b	%00011000
   6236  4f7e		       18		      .byte.b	%00011000
   6237  4f7f		       18		      .byte.b	%00011000
   6238  4f80		       18		      .byte.b	%00011000
   6239  4f81		       38		      .byte.b	%00111000
   6240  4f82		       18		      .byte.b	%00011000
   6241  4f83		       08		      .byte.b	%00001000
   6242  4f84
   6243  4f84		       7e		      .byte.b	%01111110
   6244  4f85		       60		      .byte.b	%01100000
   6245  4f86		       60		      .byte.b	%01100000
   6246  4f87		       3c		      .byte.b	%00111100
   6247  4f88		       06		      .byte.b	%00000110
   6248  4f89		       06		      .byte.b	%00000110
   6249  4f8a		       46		      .byte.b	%01000110
   6250  4f8b		       3c		      .byte.b	%00111100
   6251  4f8c
   6252  4f8c		       3c		      .byte.b	%00111100
   6253  4f8d		       46		      .byte.b	%01000110
   6254  4f8e		       06		      .byte.b	%00000110
   6255  4f8f		       06		      .byte.b	%00000110
   6256  4f90		       1c		      .byte.b	%00011100
   6257  4f91		       06		      .byte.b	%00000110
   6258  4f92		       46		      .byte.b	%01000110
   6259  4f93		       3c		      .byte.b	%00111100
   6260  4f94
   6261  4f94		       0c		      .byte.b	%00001100
   6262  4f95		       0c		      .byte.b	%00001100
   6263  4f96		       7e		      .byte.b	%01111110
   6264  4f97		       4c		      .byte.b	%01001100
   6265  4f98		       4c		      .byte.b	%01001100
   6266  4f99		       2c		      .byte.b	%00101100
   6267  4f9a		       1c		      .byte.b	%00011100
   6268  4f9b		       0c		      .byte.b	%00001100
   6269  4f9c
   6270  4f9c		       3c		      .byte.b	%00111100
   6271  4f9d		       46		      .byte.b	%01000110
   6272  4f9e		       06		      .byte.b	%00000110
   6273  4f9f		       06		      .byte.b	%00000110
   6274  4fa0		       3c		      .byte.b	%00111100
   6275  4fa1		       60		      .byte.b	%01100000
   6276  4fa2		       60		      .byte.b	%01100000
   6277  4fa3		       7e		      .byte.b	%01111110
   6278  4fa4
   6279  4fa4		       3c		      .byte.b	%00111100
   6280  4fa5		       66		      .byte.b	%01100110
   6281  4fa6		       66		      .byte.b	%01100110
   6282  4fa7		       66		      .byte.b	%01100110
   6283  4fa8		       7c		      .byte.b	%01111100
   6284  4fa9		       60		      .byte.b	%01100000
   6285  4faa		       62		      .byte.b	%01100010
   6286  4fab		       3c		      .byte.b	%00111100
   6287  4fac
   6288  4fac		       30		      .byte.b	%00110000
   6289  4fad		       30		      .byte.b	%00110000
   6290  4fae		       30		      .byte.b	%00110000
   6291  4faf		       18		      .byte.b	%00011000
   6292  4fb0		       0c		      .byte.b	%00001100
   6293  4fb1		       06		      .byte.b	%00000110
   6294  4fb2		       42		      .byte.b	%01000010
   6295  4fb3		       3e		      .byte.b	%00111110
   6296  4fb4
   6297  4fb4		       3c		      .byte.b	%00111100
   6298  4fb5		       66		      .byte.b	%01100110
   6299  4fb6		       66		      .byte.b	%01100110
   6300  4fb7		       66		      .byte.b	%01100110
   6301  4fb8		       3c		      .byte.b	%00111100
   6302  4fb9		       66		      .byte.b	%01100110
   6303  4fba		       66		      .byte.b	%01100110
   6304  4fbb		       3c		      .byte.b	%00111100
   6305  4fbc
   6306  4fbc		       3c		      .byte.b	%00111100
   6307  4fbd		       46		      .byte.b	%01000110
   6308  4fbe		       06		      .byte.b	%00000110
   6309  4fbf		       3e		      .byte.b	%00111110
   6310  4fc0		       66		      .byte.b	%01100110
   6311  4fc1		       66		      .byte.b	%01100110
   6312  4fc2		       66		      .byte.b	%01100110
   6313  4fc3		       3c		      .byte.b	%00111100
   6314  4fc4
   6315  4fc4					      ifnconst	DPC_kernel_options
   6316  4fc4
   6317  4fc4		       00		      .byte.b	%00000000
   6318  4fc5		       00		      .byte.b	%00000000
   6319  4fc6		       00		      .byte.b	%00000000
   6320  4fc7		       00		      .byte.b	%00000000
   6321  4fc8		       00		      .byte.b	%00000000
   6322  4fc9		       00		      .byte.b	%00000000
   6323  4fca		       00		      .byte.b	%00000000
   6324  4fcb		       00		      .byte.b	%00000000
   6325  4fcc
   6326  4fcc					      endif
   6327  4fcc
   6328  4fcc					      endif
   6329  4fcc
   6330  4fcc				  -	      ifconst	ROM2k
   6331  4fcc				  -	      ORG	$F7FC
   6332  4fcc					      else
   6333  4fcc					      ifconst	bankswitch
   6334  4fcc				  -	      if	bankswitch == 8
   6335  4fcc				  -	      ORG	$2FF4-bscode_length
   6336  4fcc				  -	      RORG	$FFF4-bscode_length
   6337  4fcc					      endif
   6338  4fcc					      if	bankswitch == 16
   6339  4fd4					      ORG	$4FF4-bscode_length
   6340  4fd4					      RORG	$FFF4-bscode_length
   6341  4fd4					      endif
   6342  4fd4				  -	      if	bankswitch == 32
   6343  4fd4				  -	      ORG	$8FF4-bscode_length
   6344  4fd4				  -	      RORG	$FFF4-bscode_length
   6345  4fd4					      endif
   6346  4fd4				  -	      if	bankswitch == 64
   6347  4fd4				  -	      ORG	$10FE0-bscode_length
   6348  4fd4				  -	      RORG	$1FFE0-bscode_length
   6349  4fd4					      endif
   6350  4fd4				  -	      else
   6351  4fd4				  -	      ORG	$FFFC
   6352  4fd4					      endif
   6353  4fd4					      endif
   6354  4fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6355  4fd4
   6356  4fd4							; every bank has this stuff at the same place
   6357  4fd4							; this code can switch to/from any bank at any entry point
   6358  4fd4							; and can preserve register values
   6359  4fd4							; note: lines not starting with a space are not placed in all banks
   6360  4fd4							;
   6361  4fd4							; line below tells the compiler how long this is - do not remove
   6362  4fd4							;size=32
   6363  4fd4
   6364  4fd4				   begin_bscode
   6365  4fd4		       a2 ff		      ldx	#$ff
   6366  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   6367  4fd6				  -	      stx	FASTFETCH
   6368  4fd6					      endif
   6369  4fd6		       9a		      txs
   6370  4fd7				  -	      if	bankswitch == 64
   6371  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   6372  4fd7					      else
   6373  4fd7		       a9 f3		      lda	#>(start-1)
   6374  4fd9					      endif
   6375  4fd9		       48		      pha
   6376  4fda		       a9 f4		      lda	#<(start-1)
   6377  4fdc		       48		      pha
   6378  4fdd
   6379  4fdd				   BS_return
   6380  4fdd		       48		      pha
   6381  4fde		       8a		      txa
   6382  4fdf		       48		      pha
   6383  4fe0		       ba		      tsx
   6384  4fe1
   6385  4fe1					      if	bankswitch != 64
   6386  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   6387  4fe3
   6388  4fe3		       2a		      rol
   6389  4fe4		       2a		      rol
   6390  4fe5		       2a		      rol
   6391  4fe6		       2a		      rol
   6392  4fe7		       29 03		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   6393  4fe9		       aa		      tax
   6394  4fea		       e8		      inx
   6395  4feb				  -	      else
   6396  4feb				  -	      lda	4,x	; get high byte of return address
   6397  4feb				  -	      tay
   6398  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   6399  4feb				  -	      sta	4,x
   6400  4feb				  -	      tya
   6401  4feb				  -	      lsr
   6402  4feb				  -	      lsr
   6403  4feb				  -	      lsr
   6404  4feb				  -	      lsr
   6405  4feb				  -	      tax
   6406  4feb				  -	      inx
   6407  4feb					      endif
   6408  4feb
   6409  4feb				   BS_jsr
   6410  4feb		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   6411  4fee		       68		      pla
   6412  4fef		       aa		      tax
   6413  4ff0		       68		      pla
   6414  4ff1		       60		      rts
   6415  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   6416  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   6417  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   6418  4ff2					      endif
   6419  4ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6420  4ff2
   6421  4ff2					      ifconst	bankswitch
   6422  4ff2				  -	      if	bankswitch == 8
   6423  4ff2				  -	      ORG	$2FFC
   6424  4ff2				  -	      RORG	$FFFC
   6425  4ff2					      endif
   6426  4ff2					      if	bankswitch == 16
   6427  4ffc					      ORG	$4FFC
   6428  4ffc					      RORG	$FFFC
   6429  4ffc					      endif
   6430  4ffc				  -	      if	bankswitch == 32
   6431  4ffc				  -	      ORG	$8FFC
   6432  4ffc				  -	      RORG	$FFFC
   6433  4ffc					      endif
   6434  4ffc				  -	      if	bankswitch == 64
   6435  4ffc				  -	      ORG	$10FF0
   6436  4ffc				  -	      RORG	$1FFF0
   6437  4ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   6438  4ffc				  -	      ORG	$10FF8
   6439  4ffc				  -	      RORG	$1FFF8
   6440  4ffc				  -	      ifconst	superchip
   6441  4ffc				  -	      .byte	"E","F","S","C"
   6442  4ffc				  -	      else
   6443  4ffc				  -	      .byte	"E","F","E","F"
   6444  4ffc				  -	      endif
   6445  4ffc				  -	      ORG	$10FFC
   6446  4ffc				  -	      RORG	$1FFFC
   6447  4ffc					      endif
   6448  4ffc				  -	      else
   6449  4ffc				  -	      ifconst	ROM2k
   6450  4ffc				  -	      ORG	$F7FC
   6451  4ffc				  -	      else
   6452  4ffc				  -	      ORG	$FFFC
   6453  4ffc				  -	      endif
   6454  4ffc					      endif
   6455  4ffc		       f5 f3		      .word.w	(start & $ffff)
   6456  4ffe		       f5 f3		      .word.w	(start & $ffff)
