------- FILE e:\Documents\bB\demos\ex_title_screen_and_game_over.bas.asm LEVEL 1 PASS 2
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_title_screen_and_game_over.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE e:\Documents\bB\demos\ex_title_screen_and_game_over.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 9f	   _M_Edge_Right =	159
      5  9000 ????
      6  9000 ????	       00 02	   _M_Edge_Left =	2
      7  9000 ????
      8  9000 ????	       00 58	   _M_Edge_Bottom =	88
      9  9000 ????
     10  9000 ????	       00 02	   _M_Edge_Top =	2
     11  9000 ????
     12  9000 ????	       00 98	   _P_Edge_Right =	152
     13  9000 ????
     14  9000 ????	       00 01	   _P_Edge_Left =	1
     15  9000 ????
     16  9000 ????	       00 58	   _P_Edge_Bottom =	88
     17  9000 ????
     18  9000 ????	       00 09	   _P_Edge_Top =	9
     19  9000 ????
     20  9000 ????	       00 95	   _sc3       =	score + 2
     21  9000 ????
     22  9000 ????	       00 94	   _sc2       =	score + 1
     23  9000 ????
     24  9000 ????	       00 93	   _sc1       =	score
     25  9000 ????
     26  9000 ????	       00 ed	   rand16     =	z
     27  9000 ????
     28  9000 ????	       00 ec	   _Bit7_M1_Moving =	y
     29  9000 ????
     30  9000 ????	       00 ec	   _Bit6_Swap_Scores =	y
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit3_Auto_Play =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit2_Game_Control =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit1_FireB_Restrainer =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     39  9000 ????
     40  9000 ????	       00 ec	   _BitOp_01  =	y
     41  9000 ????
     42  9000 ????	       00 eb	   _High_Score3 =	x
     43  9000 ????
     44  9000 ????	       00 ea	   _High_Score2 =	w
     45  9000 ????
     46  9000 ????	       00 e9	   _High_Score1 =	v
     47  9000 ????
     48  9000 ????	       00 e8	   _Score3_Mem =	u
     49  9000 ????
     50  9000 ????	       00 e7	   _Score2_Mem =	t
     51  9000 ????
     52  9000 ????	       00 e6	   _Score1_Mem =	s
     53  9000 ????
     54  9000 ????	       00 e5	   _Bit2_Pause_Clr_Scheme =	r
     55  9000 ????
     56  9000 ????	       00 e5	   _Bit1_BW_Check =	r
     57  9000 ????
     58  9000 ????	       00 e5	   _Bit0_BW_Mem =	r
     59  9000 ????
     60  9000 ????	       00 e5	   _BitOp_02  =	r
     61  9000 ????
     62  9000 ????	       00 df	   _Pause_Color_Tmp =	l
     63  9000 ????
     64  9000 ????	       00 df	   _AP_Dir_Counter =	l
     65  9000 ????
     66  9000 ????	       00 de	   _Pause_Mem_Color_Tmp =	k
     67  9000 ????
     68  9000 ????	       00 de	   _AP_2_Sec_Score_Flip =	k
     69  9000 ????
     70  9000 ????	       00 dd	   _AP_Mem_P0y =	j
     71  9000 ????
     72  9000 ????	       00 dc	   _AP_Mem_P0x =	i
     73  9000 ????
     74  9000 ????	       00 db	   _Pause_Counter_Tmp =	h
     75  9000 ????
     76  9000 ????	       00 db	   _AP_Mem_Dir =	h
     77  9000 ????
     78  9000 ????	       00 a0	   _T5_AP_Dir =	temp5
     79  9000 ????
     80  9000 ????	       00 da	   _Bit7_M1_Dir_Right =	g
     81  9000 ????
     82  9000 ????	       00 da	   _Bit6_M1_Dir_Left =	g
     83  9000 ????
     84  9000 ????	       00 da	   _Bit5_M1_Dir_Down =	g
     85  9000 ????
     86  9000 ????	       00 da	   _Bit4_M1_Dir_Up =	g
     87  9000 ????
     88  9000 ????	       00 da	   _Bit3_P0_Dir_Right =	g
     89  9000 ????
     90  9000 ????	       00 da	   _Bit2_P0_Dir_Left =	g
     91  9000 ????
     92  9000 ????	       00 da	   _Bit1_P0_Dir_Down =	g
     93  9000 ????
     94  9000 ????	       00 da	   _Bit0_P0_Dir_Up =	g
     95  9000 ????
     96  9000 ????	       00 da	   _BitOp_P0_M1_Dir =	g
     97  9000 ????
     98  9000 ????	       00 d9	   _Frame_Counter =	f
     99  9000 ????
    100  9000 ????	       00 d8	   _Master_Counter =	e
    101  9000 ????
    102  9000 ????	       00 07	   bs_mask    =	7
    103  9000 ????	       00 20	   bankswitch =	32
    104  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
    105  9000 ????	       00 01	   PFcolors   =	1
    106  9000 ????	       00 01	   no_blank_lines =	1
------- FILE 2600basic.h
      7  9000 ????
      8  9000 ????	       00 80	   player0x   =	$80
      9  9000 ????	       00 81	   player1x   =	$81
     10  9000 ????	       00 82	   missile0x  =	$82
     11  9000 ????	       00 83	   missile1x  =	$83
     12  9000 ????	       00 84	   ballx      =	$84
     13  9000 ????
     14  9000 ????	       00 85	   objecty    =	$85
     15  9000 ????	       00 85	   player0y   =	$85
     16  9000 ????	       00 86	   player1y   =	$86
     17  9000 ????	       00 87	   missile1height =	$87
     18  9000 ????	       00 88	   missile1y  =	$88
     19  9000 ????	       00 89	   bally      =	$89
     20  9000 ????
     21  9000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  9000 ????
     23  9000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  9000 ????	       00 8a	   player0pointerlo =	$8A
     25  9000 ????	       00 8b	   player0pointerhi =	$8B
     26  9000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  9000 ????	       00 8c	   player1pointerlo =	$8C
     28  9000 ????	       00 8d	   player1pointerhi =	$8D
     29  9000 ????
     30  9000 ????	       00 8e	   player0height =	$8E
     31  9000 ????	       00 8f	   player1height =	$8F
     32  9000 ????	       00 90	   missile0height =	$90
     33  9000 ????	       00 91	   missile0y  =	$91
     34  9000 ????	       00 92	   ballheight =	$92
     35  9000 ????
     36  9000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  9000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  9000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  9000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  9000 ????
     41  9000 ????	       00 93	   score      =	$93	; $93-$95
     42  9000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  9000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  9000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  9000 ????	       00 9e	   temp3      =	$9E
     46  9000 ????	       00 9f	   temp4      =	$9F
     47  9000 ????	       00 a0	   temp5      =	$A0
     48  9000 ????	       00 a1	   temp6      =	$A1
     49  9000 ????
     50  9000 ????	       00 a2	   rand       =	$A2
     51  9000 ????	       00 a3	   scorecolor =	$A3
     52  9000 ????
     53  9000 ????	       00 a4	   var0       =	$A4
     54  9000 ????	       00 a5	   var1       =	$A5
     55  9000 ????	       00 a6	   var2       =	$A6
     56  9000 ????	       00 a7	   var3       =	$A7
     57  9000 ????	       00 a8	   var4       =	$A8
     58  9000 ????	       00 a9	   var5       =	$A9
     59  9000 ????	       00 aa	   var6       =	$AA
     60  9000 ????	       00 ab	   var7       =	$AB
     61  9000 ????	       00 ac	   var8       =	$AC
     62  9000 ????	       00 ad	   var9       =	$AD
     63  9000 ????	       00 ae	   var10      =	$AE
     64  9000 ????	       00 af	   var11      =	$AF
     65  9000 ????	       00 b0	   var12      =	$B0
     66  9000 ????	       00 b1	   var13      =	$B1
     67  9000 ????	       00 b2	   var14      =	$B2
     68  9000 ????	       00 b3	   var15      =	$B3
     69  9000 ????	       00 b4	   var16      =	$B4
     70  9000 ????	       00 b5	   var17      =	$B5
     71  9000 ????	       00 b6	   var18      =	$B6
     72  9000 ????	       00 b7	   var19      =	$B7
     73  9000 ????	       00 b8	   var20      =	$B8
     74  9000 ????	       00 b9	   var21      =	$B9
     75  9000 ????	       00 ba	   var22      =	$BA
     76  9000 ????	       00 bb	   var23      =	$BB
     77  9000 ????	       00 bc	   var24      =	$BC
     78  9000 ????	       00 bd	   var25      =	$BD
     79  9000 ????	       00 be	   var26      =	$BE
     80  9000 ????	       00 bf	   var27      =	$BF
     81  9000 ????	       00 c0	   var28      =	$C0
     82  9000 ????	       00 c1	   var29      =	$C1
     83  9000 ????	       00 c2	   var30      =	$C2
     84  9000 ????	       00 c3	   var31      =	$C3
     85  9000 ????	       00 c4	   var32      =	$C4
     86  9000 ????	       00 c5	   var33      =	$C5
     87  9000 ????	       00 c6	   var34      =	$C6
     88  9000 ????	       00 c7	   var35      =	$C7
     89  9000 ????	       00 c8	   var36      =	$C8
     90  9000 ????	       00 c9	   var37      =	$C9
     91  9000 ????	       00 ca	   var38      =	$CA
     92  9000 ????	       00 cb	   var39      =	$CB
     93  9000 ????	       00 cc	   var40      =	$CC
     94  9000 ????	       00 cd	   var41      =	$CD
     95  9000 ????	       00 ce	   var42      =	$CE
     96  9000 ????	       00 cf	   var43      =	$CF
     97  9000 ????	       00 d0	   var44      =	$D0
     98  9000 ????	       00 d1	   var45      =	$D1
     99  9000 ????	       00 d2	   var46      =	$D2
    100  9000 ????	       00 d3	   var47      =	$D3
    101  9000 ????
    102  9000 ????	       00 d4	   A	      =	$d4
    103  9000 ????	       00 d4	   a	      =	$d4
    104  9000 ????	       00 d5	   B	      =	$d5
    105  9000 ????	       00 d5	   b	      =	$d5
    106  9000 ????	       00 d6	   C	      =	$d6
    107  9000 ????	       00 d6	   c	      =	$d6
    108  9000 ????	       00 d7	   D	      =	$d7
    109  9000 ????	       00 d7	   d	      =	$d7
    110  9000 ????	       00 d8	   E	      =	$d8
    111  9000 ????	       00 d8	   e	      =	$d8
    112  9000 ????	       00 d9	   F	      =	$d9
    113  9000 ????	       00 d9	   f	      =	$d9
    114  9000 ????	       00 da	   G	      =	$da
    115  9000 ????	       00 da	   g	      =	$da
    116  9000 ????	       00 db	   H	      =	$db
    117  9000 ????	       00 db	   h	      =	$db
    118  9000 ????	       00 dc	   I	      =	$dc
    119  9000 ????	       00 dc	   i	      =	$dc
    120  9000 ????	       00 dd	   J	      =	$dd
    121  9000 ????	       00 dd	   j	      =	$dd
    122  9000 ????	       00 de	   K	      =	$de
    123  9000 ????	       00 de	   k	      =	$de
    124  9000 ????	       00 df	   L	      =	$df
    125  9000 ????	       00 df	   l	      =	$df
    126  9000 ????	       00 e0	   M	      =	$e0
    127  9000 ????	       00 e0	   m	      =	$e0
    128  9000 ????	       00 e1	   N	      =	$e1
    129  9000 ????	       00 e1	   n	      =	$e1
    130  9000 ????	       00 e2	   O	      =	$e2
    131  9000 ????	       00 e2	   o	      =	$e2
    132  9000 ????	       00 e3	   P	      =	$e3
    133  9000 ????	       00 e3	   p	      =	$e3
    134  9000 ????	       00 e4	   Q	      =	$e4
    135  9000 ????	       00 e4	   q	      =	$e4
    136  9000 ????	       00 e5	   R	      =	$e5
    137  9000 ????	       00 e5	   r	      =	$e5
    138  9000 ????	       00 e6	   S	      =	$e6
    139  9000 ????	       00 e6	   s	      =	$e6
    140  9000 ????	       00 e7	   T	      =	$e7
    141  9000 ????	       00 e7	   t	      =	$e7
    142  9000 ????	       00 e8	   U	      =	$e8
    143  9000 ????	       00 e8	   u	      =	$e8
    144  9000 ????	       00 e9	   V	      =	$e9
    145  9000 ????	       00 e9	   v	      =	$e9
    146  9000 ????	       00 ea	   W	      =	$ea
    147  9000 ????	       00 ea	   w	      =	$ea
    148  9000 ????	       00 eb	   X	      =	$eb
    149  9000 ????	       00 eb	   x	      =	$eb
    150  9000 ????	       00 ec	   Y	      =	$ec
    151  9000 ????	       00 ec	   y	      =	$ec
    152  9000 ????	       00 ed	   Z	      =	$ed
    153  9000 ????	       00 ed	   z	      =	$ed
    154  9000 ????
    155  9000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  9000 ????	       00 ef	   playfieldpos =	$ef
    157  9000 ????
    158  9000 ????						; available for other uses, or if unused, provide more stack space
    159  9000 ????
    160  9000 ????	       00 f0	   aux1       =	$f0
    161  9000 ????	       00 f1	   aux2       =	$f1
    162  9000 ????	       00 f2	   aux3       =	$f2
    163  9000 ????	       00 f3	   aux4       =	$f3
    164  9000 ????	       00 f4	   aux5       =	$f4
    165  9000 ????	       00 f5	   aux6       =	$f5
    166  9000 ????
    167  9000 ????						; playfield color/height pointers
    168  9000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  9000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  9000 ????						; the above pointers are the same because if color and height are both used together,
    171  9000 ????						; they must used absolute indexed and cannot use pointers
    172  9000 ????
    173  9000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  9000 ????						; upper 3 bits of $f2 contain the number of lives
    175  9000 ????	       00 f4	   lifecolor  =	$f4
    176  9000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  9000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  9000 ????
    179  9000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  9000 ????	       00 f3	   pfscore2   =	$f3
    181  9000 ????	       00 f4	   pfscorecolor =	$f4
    182  9000 ????
    183  9000 ????	       00 f6	   stack1     =	$f6
    184  9000 ????	       00 f7	   stack2     =	$f7
    185  9000 ????	       00 f8	   stack3     =	$f8
    186  9000 ????	       00 f9	   stack4     =	$f9
    187  9000 ????						; the stack bytes above may be used in the kernel
    188  9000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  9000 ????
    190  9000 ????				      MAC	return
    191  9000 ????				      ifnconst	bankswitch
    192  9000 ????				      rts
    193  9000 ????				      else
    194  9000 ????				      jmp	BS_return
    195  9000 ????				      endif
    196  9000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  9000 ????
    198  9000 ????			  -	      ifconst	superchip
    199  9000 ????			  -playfieldbase =	$10D0
    200  9000 ????			  -	      include	superchip.h
    201  9000 ????				      else
    202  9000 ????	       00 a4	   playfieldbase =	$A4
    203  9000 ????				      endif
    204  9000 ????
    205  9000 ????				      ifnconst	pfhalfwidth
    206  9000 ????	       00 04	   pfwidth    =	4
    207  9000 ????	       00 0e	   PF1L       =	PF1
    208  9000 ????	       00 0f	   PF2L       =	PF2
    209  9000 ????	       00 0e	   PF1R       =	PF1
    210  9000 ????	       00 0f	   PF2R       =	PF2
    211  9000 ????	       00 00	   pfadjust   =	0
    212  9000 ????			  -	      else
    213  9000 ????			  -pfwidth    =	2
    214  9000 ????			  -	      ifconst	pfcenter
    215  9000 ????			  -PF1L       =	$3F	; no effect
    216  9000 ????			  -PF2L       =	PF2
    217  9000 ????			  -PF1R       =	$3F
    218  9000 ????			  -PF2R       =	PF2	; no effect
    219  9000 ????			  -pfadjust   =	1
    220  9000 ????			  -	      else
    221  9000 ????			  -PF1L       =	PF1
    222  9000 ????			  -PF2L       =	PF2
    223  9000 ????			  -PF1R       =	$3F	; no effect
    224  9000 ????			  -PF2R       =	$3F	; no effect
    225  9000 ????			  -pfadjust   =	0
    226  9000 ????			  -	      endif
    227  9000 ????				      endif
    228  9000 ????
    229  9000 ????						; define playfield start based on height
    230  9000 ????				      ifnconst	pfres
    231  9000 ????	       00 a4	   playfield  =	playfieldbase
    232  9000 ????			  -	      else
    233  9000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  9000 ????				      endif
------- FILE e:\Documents\bB\demos\ex_title_screen_and_game_over.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 9f	   _M_Edge_Right =	159
      5  9000 ????
      6  9000 ????	       00 02	   _M_Edge_Left =	2
      7  9000 ????
      8  9000 ????	       00 58	   _M_Edge_Bottom =	88
      9  9000 ????
     10  9000 ????	       00 02	   _M_Edge_Top =	2
     11  9000 ????
     12  9000 ????	       00 98	   _P_Edge_Right =	152
     13  9000 ????
     14  9000 ????	       00 01	   _P_Edge_Left =	1
     15  9000 ????
     16  9000 ????	       00 58	   _P_Edge_Bottom =	88
     17  9000 ????
     18  9000 ????	       00 09	   _P_Edge_Top =	9
     19  9000 ????
     20  9000 ????	       00 95	   _sc3       =	score + 2
     21  9000 ????
     22  9000 ????	       00 94	   _sc2       =	score + 1
     23  9000 ????
     24  9000 ????	       00 93	   _sc1       =	score
     25  9000 ????
     26  9000 ????	       00 ed	   rand16     =	z
     27  9000 ????
     28  9000 ????	       00 ec	   _Bit7_M1_Moving =	y
     29  9000 ????
     30  9000 ????	       00 ec	   _Bit6_Swap_Scores =	y
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit3_Auto_Play =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit2_Game_Control =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit1_FireB_Restrainer =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _Bit0_Reset_Restrainer =	y
     39  9000 ????
     40  9000 ????	       00 ec	   _BitOp_01  =	y
     41  9000 ????
     42  9000 ????	       00 eb	   _High_Score3 =	x
     43  9000 ????
     44  9000 ????	       00 ea	   _High_Score2 =	w
     45  9000 ????
     46  9000 ????	       00 e9	   _High_Score1 =	v
     47  9000 ????
     48  9000 ????	       00 e8	   _Score3_Mem =	u
     49  9000 ????
     50  9000 ????	       00 e7	   _Score2_Mem =	t
     51  9000 ????
     52  9000 ????	       00 e6	   _Score1_Mem =	s
     53  9000 ????
     54  9000 ????	       00 e5	   _Bit2_Pause_Clr_Scheme =	r
     55  9000 ????
     56  9000 ????	       00 e5	   _Bit1_BW_Check =	r
     57  9000 ????
     58  9000 ????	       00 e5	   _Bit0_BW_Mem =	r
     59  9000 ????
     60  9000 ????	       00 e5	   _BitOp_02  =	r
     61  9000 ????
     62  9000 ????	       00 df	   _Pause_Color_Tmp =	l
     63  9000 ????
     64  9000 ????	       00 df	   _AP_Dir_Counter =	l
     65  9000 ????
     66  9000 ????	       00 de	   _Pause_Mem_Color_Tmp =	k
     67  9000 ????
     68  9000 ????	       00 de	   _AP_2_Sec_Score_Flip =	k
     69  9000 ????
     70  9000 ????	       00 dd	   _AP_Mem_P0y =	j
     71  9000 ????
     72  9000 ????	       00 dc	   _AP_Mem_P0x =	i
     73  9000 ????
     74  9000 ????	       00 db	   _Pause_Counter_Tmp =	h
     75  9000 ????
     76  9000 ????	       00 db	   _AP_Mem_Dir =	h
     77  9000 ????
     78  9000 ????	       00 a0	   _T5_AP_Dir =	temp5
     79  9000 ????
     80  9000 ????	       00 da	   _Bit7_M1_Dir_Right =	g
     81  9000 ????
     82  9000 ????	       00 da	   _Bit6_M1_Dir_Left =	g
     83  9000 ????
     84  9000 ????	       00 da	   _Bit5_M1_Dir_Down =	g
     85  9000 ????
     86  9000 ????	       00 da	   _Bit4_M1_Dir_Up =	g
     87  9000 ????
     88  9000 ????	       00 da	   _Bit3_P0_Dir_Right =	g
     89  9000 ????
     90  9000 ????	       00 da	   _Bit2_P0_Dir_Left =	g
     91  9000 ????
     92  9000 ????	       00 da	   _Bit1_P0_Dir_Down =	g
     93  9000 ????
     94  9000 ????	       00 da	   _Bit0_P0_Dir_Up =	g
     95  9000 ????
     96  9000 ????	       00 da	   _BitOp_P0_M1_Dir =	g
     97  9000 ????
     98  9000 ????	       00 d9	   _Frame_Counter =	f
     99  9000 ????
    100  9000 ????	       00 d8	   _Master_Counter =	e
    101  9000 ????
    102  9000 ????	       00 07	   bs_mask    =	7
    103  9000 ????	       00 20	   bankswitch =	32
    104  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
    105  9000 ????	       00 01	   PFcolors   =	1
    106  9000 ????	       00 01	   no_blank_lines =	1
------- FILE e:\Documents\bB\demos\ex_title_screen_and_game_over.bas.asm
      8  9000 ????				      ifconst	bankswitch
      9  9000 ????			  -	      if	bankswitch == 8
     10  9000 ????			  -	      ORG	$1000
     11  9000 ????			  -	      RORG	$D000
     12  9000 ????				      endif
     13  9000 ????			  -	      if	bankswitch == 16
     14  9000 ????			  -	      ORG	$1000
     15  9000 ????			  -	      RORG	$9000
     16  9000 ????				      endif
     17  9000 ????				      if	bankswitch == 32
     18  1000					      ORG	$1000
     19  1000					      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .
     57  1000							; 
     58  1000
     59  1000				   .
     60  1000							; 
     61  1000
     62  1000				   .
     63  1000							; 
     64  1000
     65  1000				   .
     66  1000							; 
     67  1000
     68  1000				   .
     69  1000							; 
     70  1000
     71  1000				   .
     72  1000							; 
     73  1000
     74  1000				   .
     75  1000							; 
     76  1000
     77  1000				   .
     78  1000							; 
     79  1000
     80  1000				   .
     81  1000							; 
     82  1000
     83  1000				   .
     84  1000							; 
     85  1000
     86  1000				   .
     87  1000							; 
     88  1000
     89  1000				   .
     90  1000							; 
     91  1000
     92  1000				   .
     93  1000							; 
     94  1000
     95  1000				   .
     96  1000							; 
     97  1000
     98  1000				   .
     99  1000							; 
    100  1000
    101  1000				   .
    102  1000							; 
    103  1000
    104  1000				   .
    105  1000							; 
    106  1000
    107  1000				   .
    108  1000							; 
    109  1000
    110  1000				   .
    111  1000							; 
    112  1000
    113  1000				   .
    114  1000							; 
    115  1000
    116  1000				   .
    117  1000							; 
    118  1000
    119  1000				   .
    120  1000							; 
    121  1000
    122  1000				   .
    123  1000							; 
    124  1000
    125  1000				   .
    126  1000							; 
    127  1000
    128  1000				   .
    129  1000							; 
    130  1000
    131  1000				   .
    132  1000							; 
    133  1000
    134  1000				   .
    135  1000							; 
    136  1000
    137  1000				   .
    138  1000							; 
    139  1000
    140  1000				   .
    141  1000							; 
    142  1000
    143  1000				   .
    144  1000							; 
    145  1000
    146  1000				   .
    147  1000							; 
    148  1000
    149  1000				   .
    150  1000							; 
    151  1000
    152  1000				   .
    153  1000							; 
    154  1000
    155  1000				   .
    156  1000							; 
    157  1000
    158  1000				   .
    159  1000							; 
    160  1000
    161  1000				   .
    162  1000							; 
    163  1000
    164  1000				   .
    165  1000							; 
    166  1000
    167  1000				   .
    168  1000							; 
    169  1000
    170  1000				   .
    171  1000							; 
    172  1000
    173  1000				   .
    174  1000							; 
    175  1000
    176  1000				   .
    177  1000							; 
    178  1000
    179  1000				   .
    180  1000							; 
    181  1000
    182  1000				   .
    183  1000							; 
    184  1000
    185  1000				   .
    186  1000							; 
    187  1000
    188  1000				   .
    189  1000							; 
    190  1000
    191  1000				   .
    192  1000							; 
    193  1000
    194  1000				   .
    195  1000							; 
    196  1000
    197  1000				   .
    198  1000							; 
    199  1000
    200  1000				   .
    201  1000							; 
    202  1000
    203  1000				   .
    204  1000							; 
    205  1000
    206  1000				   .
    207  1000							; 
    208  1000
    209  1000				   .
    210  1000							; 
    211  1000
    212  1000				   .
    213  1000							; 
    214  1000
    215  1000				   .
    216  1000							; 
    217  1000
    218  1000				   .
    219  1000							; 
    220  1000
    221  1000				   .
    222  1000							; 
    223  1000
    224  1000				   .
    225  1000							; 
    226  1000
    227  1000				   .L00 		;  set kernel_options pfcolors no_blank_lines
    228  1000
    229  1000				   .
    230  1000							; 
    231  1000
    232  1000				   .
    233  1000							; 
    234  1000
    235  1000				   .
    236  1000							; 
    237  1000
    238  1000				   .
    239  1000							; 
    240  1000
    241  1000				   .
    242  1000							; 
    243  1000
    244  1000				   .
    245  1000							; 
    246  1000
    247  1000				   .
    248  1000							; 
    249  1000
    250  1000				   .L01 		;  set romsize 32k
    251  1000
    252  1000				   .
    253  1000							; 
    254  1000
    255  1000				   .
    256  1000							; 
    257  1000
    258  1000				   .
    259  1000							; 
    260  1000
    261  1000				   .
    262  1000							; 
    263  1000
    264  1000				   .
    265  1000							; 
    266  1000
    267  1000				   .
    268  1000							; 
    269  1000
    270  1000				   .
    271  1000							; 
    272  1000
    273  1000				   .
    274  1000							; 
    275  1000
    276  1000				   .L02 		;  set optimization inlinerand
    277  1000
    278  1000				   .
    279  1000							; 
    280  1000
    281  1000				   .
    282  1000							; 
    283  1000
    284  1000				   .
    285  1000							; 
    286  1000
    287  1000				   .
    288  1000							; 
    289  1000
    290  1000				   .
    291  1000							; 
    292  1000
    293  1000				   .
    294  1000							; 
    295  1000
    296  1000				   .
    297  1000							; 
    298  1000
    299  1000				   .
    300  1000							; 
    301  1000
    302  1000				   .
    303  1000							; 
    304  1000
    305  1000				   .
    306  1000							; 
    307  1000
    308  1000				   .
    309  1000							; 
    310  1000
    311  1000				   .
    312  1000							; 
    313  1000
    314  1000				   .
    315  1000							; 
    316  1000
    317  1000				   .
    318  1000							; 
    319  1000
    320  1000				   .
    321  1000							; 
    322  1000
    323  1000				   .
    324  1000							; 
    325  1000
    326  1000				   .
    327  1000							; 
    328  1000
    329  1000				   .
    330  1000							; 
    331  1000
    332  1000				   .
    333  1000							; 
    334  1000
    335  1000				   .
    336  1000							; 
    337  1000
    338  1000				   .
    339  1000							; 
    340  1000
    341  1000				   .
    342  1000							; 
    343  1000
    344  1000				   .
    345  1000							; 
    346  1000
    347  1000				   .
    348  1000							; 
    349  1000
    350  1000				   .
    351  1000							; 
    352  1000
    353  1000				   .
    354  1000							; 
    355  1000
    356  1000				   .
    357  1000							; 
    358  1000
    359  1000				   .
    360  1000							; 
    361  1000
    362  1000				   .
    363  1000							; 
    364  1000
    365  1000				   .
    366  1000							; 
    367  1000
    368  1000				   .
    369  1000							; 
    370  1000
    371  1000				   .L03 		;  dim _Master_Counter  =  e
    372  1000
    373  1000				   .L04 		;  dim _Frame_Counter	=  f
    374  1000
    375  1000				   .
    376  1000							; 
    377  1000
    378  1000				   .
    379  1000							; 
    380  1000
    381  1000				   .
    382  1000							; 
    383  1000
    384  1000				   .
    385  1000							; 
    386  1000
    387  1000				   .L05 		;  dim _BitOp_P0_M1_Dir  =  g
    388  1000
    389  1000				   .L06 		;  dim _Bit0_P0_Dir_Up  =  g
    390  1000
    391  1000				   .L07 		;  dim _Bit1_P0_Dir_Down  =  g
    392  1000
    393  1000				   .L08 		;  dim _Bit2_P0_Dir_Left  =  g
    394  1000
    395  1000				   .L09 		;  dim _Bit3_P0_Dir_Right  =  g
    396  1000
    397  1000				   .L010		;  dim _Bit4_M1_Dir_Up  =  g
    398  1000
    399  1000				   .L011		;  dim _Bit5_M1_Dir_Down  =  g
    400  1000
    401  1000				   .L012		;  dim _Bit6_M1_Dir_Left  =  g
    402  1000
    403  1000				   .L013		;  dim _Bit7_M1_Dir_Right  =  g
    404  1000
    405  1000				   .
    406  1000							; 
    407  1000
    408  1000				   .
    409  1000							; 
    410  1000
    411  1000				   .
    412  1000							; 
    413  1000
    414  1000				   .
    415  1000							; 
    416  1000
    417  1000				   .
    418  1000							; 
    419  1000
    420  1000				   .
    421  1000							; 
    422  1000
    423  1000				   .L014		;  dim _T5_AP_Dir  =  temp5
    424  1000
    425  1000				   .
    426  1000							; 
    427  1000
    428  1000				   .
    429  1000							; 
    430  1000
    431  1000				   .
    432  1000							; 
    433  1000
    434  1000				   .
    435  1000							; 
    436  1000
    437  1000				   .
    438  1000							; 
    439  1000
    440  1000				   .
    441  1000							; 
    442  1000
    443  1000				   .
    444  1000							; 
    445  1000
    446  1000				   .
    447  1000							; 
    448  1000
    449  1000				   .L015		;  dim _AP_Mem_Dir  =	h
    450  1000
    451  1000				   .
    452  1000							; 
    453  1000
    454  1000				   .
    455  1000							; 
    456  1000
    457  1000				   .
    458  1000							; 
    459  1000
    460  1000				   .
    461  1000							; 
    462  1000
    463  1000				   .
    464  1000							; 
    465  1000
    466  1000				   .
    467  1000							; 
    468  1000
    469  1000				   .L016		;  dim _Pause_Counter_Tmp  =  h
    470  1000
    471  1000				   .
    472  1000							; 
    473  1000
    474  1000				   .
    475  1000							; 
    476  1000
    477  1000				   .
    478  1000							; 
    479  1000
    480  1000				   .
    481  1000							; 
    482  1000
    483  1000				   .
    484  1000							; 
    485  1000
    486  1000				   .
    487  1000							; 
    488  1000
    489  1000				   .
    490  1000							; 
    491  1000
    492  1000				   .L017		;  dim _AP_Mem_P0x  =	i
    493  1000
    494  1000				   .L018		;  dim _AP_Mem_P0y  =	j
    495  1000
    496  1000				   .
    497  1000							; 
    498  1000
    499  1000				   .
    500  1000							; 
    501  1000
    502  1000				   .
    503  1000							; 
    504  1000
    505  1000				   .
    506  1000							; 
    507  1000
    508  1000				   .
    509  1000							; 
    510  1000
    511  1000				   .
    512  1000							; 
    513  1000
    514  1000				   .L019		;  dim _AP_2_Sec_Score_Flip  =  k
    515  1000
    516  1000				   .
    517  1000							; 
    518  1000
    519  1000				   .
    520  1000							; 
    521  1000
    522  1000				   .
    523  1000							; 
    524  1000
    525  1000				   .
    526  1000							; 
    527  1000
    528  1000				   .
    529  1000							; 
    530  1000
    531  1000				   .
    532  1000							; 
    533  1000
    534  1000				   .L020		;  dim _Pause_Mem_Color_Tmp  =  k
    535  1000
    536  1000				   .
    537  1000							; 
    538  1000
    539  1000				   .
    540  1000							; 
    541  1000
    542  1000				   .
    543  1000							; 
    544  1000
    545  1000				   .
    546  1000							; 
    547  1000
    548  1000				   .
    549  1000							; 
    550  1000
    551  1000				   .
    552  1000							; 
    553  1000
    554  1000				   .L021		;  dim _AP_Dir_Counter  =  l
    555  1000
    556  1000				   .
    557  1000							; 
    558  1000
    559  1000				   .
    560  1000							; 
    561  1000
    562  1000				   .
    563  1000							; 
    564  1000
    565  1000				   .
    566  1000							; 
    567  1000
    568  1000				   .
    569  1000							; 
    570  1000
    571  1000				   .
    572  1000							; 
    573  1000
    574  1000				   .L022		;  dim _Pause_Color_Tmp  =  l
    575  1000
    576  1000				   .
    577  1000							; 
    578  1000
    579  1000				   .
    580  1000							; 
    581  1000
    582  1000				   .
    583  1000							; 
    584  1000
    585  1000				   .
    586  1000							; 
    587  1000
    588  1000				   .
    589  1000							; 
    590  1000
    591  1000				   .L023		;  dim _BitOp_02  =  r
    592  1000
    593  1000				   .
    594  1000							; 
    595  1000
    596  1000				   .
    597  1000							; 
    598  1000
    599  1000				   .
    600  1000							; 
    601  1000
    602  1000				   .
    603  1000							; 
    604  1000
    605  1000				   .L024		;  dim _Bit0_BW_Mem  =  r
    606  1000
    607  1000				   .
    608  1000							; 
    609  1000
    610  1000				   .
    611  1000							; 
    612  1000
    613  1000				   .
    614  1000							; 
    615  1000
    616  1000				   .
    617  1000							; 
    618  1000
    619  1000				   .L025		;  dim _Bit1_BW_Check	=  r
    620  1000
    621  1000				   .
    622  1000							; 
    623  1000
    624  1000				   .
    625  1000							; 
    626  1000
    627  1000				   .
    628  1000							; 
    629  1000
    630  1000				   .
    631  1000							; 
    632  1000
    633  1000				   .L026		;  dim _Bit2_Pause_Clr_Scheme	=  r
    634  1000
    635  1000				   .
    636  1000							; 
    637  1000
    638  1000				   .
    639  1000							; 
    640  1000
    641  1000				   .
    642  1000							; 
    643  1000
    644  1000				   .
    645  1000							; 
    646  1000
    647  1000				   .
    648  1000							; 
    649  1000
    650  1000				   .
    651  1000							; 
    652  1000
    653  1000				   .
    654  1000							; 
    655  1000
    656  1000				   .
    657  1000							; 
    658  1000
    659  1000				   .L027		;  dim _Score1_Mem  =	s
    660  1000
    661  1000				   .L028		;  dim _Score2_Mem  =	t
    662  1000
    663  1000				   .L029		;  dim _Score3_Mem  =	u
    664  1000
    665  1000				   .
    666  1000							; 
    667  1000
    668  1000				   .
    669  1000							; 
    670  1000
    671  1000				   .
    672  1000							; 
    673  1000
    674  1000				   .
    675  1000							; 
    676  1000
    677  1000				   .L030		;  dim _High_Score1  =  v
    678  1000
    679  1000				   .L031		;  dim _High_Score2  =  w
    680  1000
    681  1000				   .L032		;  dim _High_Score3  =  x
    682  1000
    683  1000				   .
    684  1000							; 
    685  1000
    686  1000				   .
    687  1000							; 
    688  1000
    689  1000				   .
    690  1000							; 
    691  1000
    692  1000				   .
    693  1000							; 
    694  1000
    695  1000				   .
    696  1000							; 
    697  1000
    698  1000				   .L033		;  dim _BitOp_01  =  y
    699  1000
    700  1000				   .L034		;  dim _Bit0_Reset_Restrainer	=  y
    701  1000
    702  1000				   .L035		;  dim _Bit1_FireB_Restrainer	=  y
    703  1000
    704  1000				   .L036		;  dim _Bit2_Game_Control  =  y
    705  1000
    706  1000				   .L037		;  dim _Bit3_Auto_Play  =  y
    707  1000
    708  1000				   .L038		;  dim _Bit6_Swap_Scores  =  y
    709  1000
    710  1000				   .L039		;  dim _Bit7_M1_Moving  =  y
    711  1000
    712  1000				   .
    713  1000							; 
    714  1000
    715  1000				   .
    716  1000							; 
    717  1000
    718  1000				   .
    719  1000							; 
    720  1000
    721  1000				   .
    722  1000							; 
    723  1000
    724  1000				   .L040		;  dim rand16	=  z
    725  1000
    726  1000				   .
    727  1000							; 
    728  1000
    729  1000				   .
    730  1000							; 
    731  1000
    732  1000				   .
    733  1000							; 
    734  1000
    735  1000				   .
    736  1000							; 
    737  1000
    738  1000				   .
    739  1000							; 
    740  1000
    741  1000				   .
    742  1000							; 
    743  1000
    744  1000				   .
    745  1000							; 
    746  1000
    747  1000				   .
    748  1000							; 
    749  1000
    750  1000				   .L041		;  dim _sc1  =  score
    751  1000
    752  1000				   .L042		;  dim _sc2  =  score + 1
    753  1000
    754  1000				   .L043		;  dim _sc3  =  score + 2
    755  1000
    756  1000				   .
    757  1000							; 
    758  1000
    759  1000				   .
    760  1000							; 
    761  1000
    762  1000				   .
    763  1000							; 
    764  1000
    765  1000				   .
    766  1000							; 
    767  1000
    768  1000				   .
    769  1000							; 
    770  1000
    771  1000				   .
    772  1000							; 
    773  1000
    774  1000				   .
    775  1000							; 
    776  1000
    777  1000				   .
    778  1000							; 
    779  1000
    780  1000				   .
    781  1000							; 
    782  1000
    783  1000				   .L044		;  const _P_Edge_Top  =  9
    784  1000
    785  1000				   .L045		;  const _P_Edge_Bottom  =  88
    786  1000
    787  1000				   .L046		;  const _P_Edge_Left	=  1
    788  1000
    789  1000				   .L047		;  const _P_Edge_Right  =  152
    790  1000
    791  1000				   .
    792  1000							; 
    793  1000
    794  1000				   .
    795  1000							; 
    796  1000
    797  1000				   .
    798  1000							; 
    799  1000
    800  1000				   .
    801  1000							; 
    802  1000
    803  1000				   .
    804  1000							; 
    805  1000
    806  1000				   .
    807  1000							; 
    808  1000
    809  1000				   .
    810  1000							; 
    811  1000
    812  1000				   .
    813  1000							; 
    814  1000
    815  1000				   .
    816  1000							; 
    817  1000
    818  1000				   .L048		;  const _M_Edge_Top  =  2
    819  1000
    820  1000				   .L049		;  const _M_Edge_Bottom  =  88
    821  1000
    822  1000				   .L050		;  const _M_Edge_Left	=  2
    823  1000
    824  1000				   .L051		;  const _M_Edge_Right  =  159
    825  1000
    826  1000				   .
    827  1000							; 
    828  1000
    829  1000				   .
    830  1000							; 
    831  1000
    832  1000				   .
    833  1000							; 
    834  1000
    835  1000				   .
    836  1000							; 
    837  1000
    838  1000				   .
    839  1000							; 
    840  1000
    841  1000				   .
    842  1000							; 
    843  1000
    844  1000				   .
    845  1000							; 
    846  1000
    847  1000				   .
    848  1000							; 
    849  1000
    850  1000				   .
    851  1000							; 
    852  1000
    853  1000				   .
    854  1000							; 
    855  1000
    856  1000				   .
    857  1000							; 
    858  1000
    859  1000				   .__Start_Restart
    860  1000							; __Start_Restart
    861  1000
    862  1000				   .
    863  1000							; 
    864  1000
    865  1000				   .
    866  1000							; 
    867  1000
    868  1000				   .
    869  1000							; 
    870  1000
    871  1000				   .
    872  1000							; 
    873  1000
    874  1000				   .
    875  1000							; 
    876  1000
    877  1000				   .
    878  1000							; 
    879  1000
    880  1000				   .L052		;  AUDV0  =  0  :  AUDV1  =  0
    881  1000
    882  1000		       a9 00		      LDA	#0
    883  1002		       85 19		      STA	AUDV0
    884  1004		       85 1a		      STA	AUDV1
    885  1006				   .
    886  1006							; 
    887  1006
    888  1006				   .
    889  1006							; 
    890  1006
    891  1006				   .
    892  1006							; 
    893  1006
    894  1006				   .
    895  1006							; 
    896  1006
    897  1006				   .
    898  1006							; 
    899  1006
    900  1006				   .
    901  1006							; 
    902  1006
    903  1006				   .
    904  1006							; 
    905  1006
    906  1006				   .
    907  1006							; 
    908  1006
    909  1006				   .
    910  1006							; 
    911  1006
    912  1006				   .
    913  1006							; 
    914  1006
    915  1006				   .
    916  1006							; 
    917  1006
    918  1006				   .L053		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    919  1006
    920  1006		       a9 00		      LDA	#0
    921  1008		       85 d4		      STA	a
    922  100a		       85 d5		      STA	b
    923  100c		       85 d6		      STA	c
    924  100e		       85 d7		      STA	d
    925  1010		       85 d8		      STA	e
    926  1012		       85 d9		      STA	f
    927  1014		       85 da		      STA	g
    928  1016		       85 db		      STA	h
    929  1018		       85 dc		      STA	i
    930  101a				   .L054		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    931  101a
    932  101a		       a9 00		      LDA	#0
    933  101c		       85 dd		      STA	j
    934  101e		       85 de		      STA	k
    935  1020		       85 df		      STA	l
    936  1022		       85 e0		      STA	m
    937  1024		       85 e1		      STA	n
    938  1026		       85 e2		      STA	o
    939  1028		       85 e3		      STA	p
    940  102a		       85 e4		      STA	q
    941  102c		       85 e5		      STA	r
    942  102e				   .L055		;  s  =  0  :	t  =  0  :  u  =  0
    943  102e
    944  102e		       a9 00		      LDA	#0
    945  1030		       85 e6		      STA	s
    946  1032		       85 e7		      STA	t
    947  1034		       85 e8		      STA	u
    948  1036				   .
    949  1036							; 
    950  1036
    951  1036				   .
    952  1036							; 
    953  1036
    954  1036				   .
    955  1036							; 
    956  1036
    957  1036				   .
    958  1036							; 
    959  1036
    960  1036				   .
    961  1036							; 
    962  1036
    963  1036				   .
    964  1036							; 
    965  1036
    966  1036				   .
    967  1036							; 
    968  1036
    969  1036				   .
    970  1036							; 
    971  1036
    972  1036				   .
    973  1036							; 
    974  1036
    975  1036				   .L056		;  _BitOp_01  =  _BitOp_01  &	%00000100
    976  1036
    977  1036		       a5 ec		      LDA	_BitOp_01
    978  1038		       29 04		      AND	#%00000100
    979  103a		       85 ec		      STA	_BitOp_01
    980  103c				   .
    981  103c							; 
    982  103c
    983  103c				   .
    984  103c							; 
    985  103c
    986  103c				   .
    987  103c							; 
    988  103c
    989  103c				   .
    990  103c							; 
    991  103c
    992  103c				   .
    993  103c							; 
    994  103c
    995  103c				   .
    996  103c							; 
    997  103c
    998  103c				   .L057		;  player0y  =  200  :  player1y  =  200  :  missile1y  =  200
    999  103c
   1000  103c		       a9 c8		      LDA	#200
   1001  103e		       85 85		      STA	player0y
   1002  1040		       85 86		      STA	player1y
   1003  1042		       85 88		      STA	missile1y
   1004  1044				   .
   1005  1044							; 
   1006  1044
   1007  1044				   .
   1008  1044							; 
   1009  1044
   1010  1044				   .
   1011  1044							; 
   1012  1044
   1013  1044				   .
   1014  1044							; 
   1015  1044
   1016  1044				   .
   1017  1044							; 
   1018  1044
   1019  1044				   .
   1020  1044							; 
   1021  1044
   1022  1044				   .
   1023  1044							; 
   1024  1044
   1025  1044				   .
   1026  1044							; 
   1027  1044
   1028  1044				   .
   1029  1044							; 
   1030  1044
   1031  1044				   .
   1032  1044							; 
   1033  1044
   1034  1044				   .L058		;  if _Bit2_Game_Control{2} then goto __Main_Loop_Setup bank2
   1035  1044
   1036  1044		       a5 ec		      LDA	_Bit2_Game_Control
   1037  1046		       29 04		      AND	#4
   1038  1048		       f0 12		      BEQ	.skipL058
   1039  104a				   .condpart0
   1040  104a		       85 ee		      sta	temp7
   1041  104c		       a9 2f		      lda	#>(.__Main_Loop_Setup-1)
   1042  104e		       48		      pha
   1043  104f		       a9 ff		      lda	#<(.__Main_Loop_Setup-1)
   1044  1051		       48		      pha
   1045  1052		       a5 ee		      lda	temp7
   1046  1054		       48		      pha
   1047  1055		       8a		      txa
   1048  1056		       48		      pha
   1049  1057		       a2 02		      ldx	#2
   1050  1059		       4c eb ff 	      jmp	BS_jsr
   1051  105c				   .skipL058
   1052  105c				   .
   1053  105c							; 
   1054  105c
   1055  105c				   .
   1056  105c							; 
   1057  105c
   1058  105c				   .
   1059  105c							; 
   1060  105c
   1061  105c				   .
   1062  105c							; 
   1063  105c
   1064  105c				   .
   1065  105c							; 
   1066  105c
   1067  105c				   .
   1068  105c							; 
   1069  105c
   1070  105c				   .
   1071  105c							; 
   1072  105c
   1073  105c				   .
   1074  105c							; 
   1075  105c
   1076  105c				   .
   1077  105c							; 
   1078  105c
   1079  105c				   .
   1080  105c							; 
   1081  105c
   1082  105c				   .
   1083  105c							; 
   1084  105c
   1085  105c				   .__Title_Screen_Setup
   1086  105c							; __Title_Screen_Setup
   1087  105c
   1088  105c				   .
   1089  105c							; 
   1090  105c
   1091  105c				   .
   1092  105c							; 
   1093  105c
   1094  105c				   .
   1095  105c							; 
   1096  105c
   1097  105c				   .
   1098  105c							; 
   1099  105c
   1100  105c				   .
   1101  105c							; 
   1102  105c
   1103  105c				   .
   1104  105c							; 
   1105  105c
   1106  105c				   .L059		;  scorecolor	=  0
   1107  105c
   1108  105c		       a9 00		      LDA	#0
   1109  105e		       85 a3		      STA	scorecolor
   1110  1060				   .
   1111  1060							; 
   1112  1060
   1113  1060				   .
   1114  1060							; 
   1115  1060
   1116  1060				   .
   1117  1060							; 
   1118  1060
   1119  1060				   .
   1120  1060							; 
   1121  1060
   1122  1060				   .
   1123  1060							; 
   1124  1060
   1125  1060				   .
   1126  1060							; 
   1127  1060
   1128  1060				   .L060		;  COLUBK  =  0
   1129  1060
   1130  1060		       a9 00		      LDA	#0
   1131  1062		       85 09		      STA	COLUBK
   1132  1064				   .
   1133  1064							; 
   1134  1064
   1135  1064				   .
   1136  1064							; 
   1137  1064
   1138  1064				   .
   1139  1064							; 
   1140  1064
   1141  1064				   .
   1142  1064							; 
   1143  1064
   1144  1064				   .
   1145  1064							; 
   1146  1064
   1147  1064				   .
   1148  1064							; 
   1149  1064
   1150  1064				   .
   1151  1064							; 
   1152  1064
   1153  1064				   .
   1154  1064							; 
   1155  1064
   1156  1064				   .
   1157  1064							; 
   1158  1064
   1159  1064				   .
   1160  1064							; 
   1161  1064
   1162  1064				   .
   1163  1064							; 
   1164  1064
   1165  1064				   .L061		;  _Bit0_Reset_Restrainer{0}  =  1
   1166  1064
   1167  1064		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1168  1066		       09 01		      ORA	#1
   1169  1068		       85 ec		      STA	_Bit0_Reset_Restrainer
   1170  106a				   .
   1171  106a							; 
   1172  106a
   1173  106a				   .
   1174  106a							; 
   1175  106a
   1176  106a				   .
   1177  106a							; 
   1178  106a
   1179  106a				   .
   1180  106a							; 
   1181  106a
   1182  106a				   .
   1183  106a							; 
   1184  106a
   1185  106a				   .
   1186  106a							; 
   1187  106a
   1188  106a				   .L062		;  playfield:
   1189  106a
   1190  106a				  -	      ifconst	pfres
   1191  106a				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   1192  106a					      else
   1193  106a		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   1194  106c					      endif
   1195  106c		       4c 9b 10 	      jmp	pflabel0
   1196  106f				   PF_data0
   1197  106f		       7e bf		      .byte.b	%01111110, %10111111
   1198  1071					      if	(pfwidth>2)
   1199  1071		       ff 7d		      .byte.b	%11111111, %01111101
   1200  1073					      endif
   1201  1073		       60 b3		      .byte.b	%01100000, %10110011
   1202  1075					      if	(pfwidth>2)
   1203  1075		       99 0d		      .byte.b	%10011001, %00001101
   1204  1077					      endif
   1205  1077		       6e bf		      .byte.b	%01101110, %10111111
   1206  1079					      if	(pfwidth>2)
   1207  1079		       99 3d		      .byte.b	%10011001, %00111101
   1208  107b					      endif
   1209  107b		       66 b3		      .byte.b	%01100110, %10110011
   1210  107d					      if	(pfwidth>2)
   1211  107d		       99 0d		      .byte.b	%10011001, %00001101
   1212  107f					      endif
   1213  107f		       7e b3		      .byte.b	%01111110, %10110011
   1214  1081					      if	(pfwidth>2)
   1215  1081		       99 7d		      .byte.b	%10011001, %01111101
   1216  1083					      endif
   1217  1083		       00 00		      .byte.b	%00000000, %00000000
   1218  1085					      if	(pfwidth>2)
   1219  1085		       00 00		      .byte.b	%00000000, %00000000
   1220  1087					      endif
   1221  1087		       3f f6		      .byte.b	%00111111, %11110110
   1222  1089					      if	(pfwidth>2)
   1223  1089		       d8 3e		      .byte.b	%11011000, %00111110
   1224  108b					      endif
   1225  108b		       0c c6		      .byte.b	%00001100, %11000110
   1226  108d					      if	(pfwidth>2)
   1227  108d		       18 06		      .byte.b	%00011000, %00000110
   1228  108f					      endif
   1229  108f		       0c c6		      .byte.b	%00001100, %11000110
   1230  1091					      if	(pfwidth>2)
   1231  1091		       18 1e		      .byte.b	%00011000, %00011110
   1232  1093					      endif
   1233  1093		       0c c6		      .byte.b	%00001100, %11000110
   1234  1095					      if	(pfwidth>2)
   1235  1095		       18 06		      .byte.b	%00011000, %00000110
   1236  1097					      endif
   1237  1097		       0c c6		      .byte.b	%00001100, %11000110
   1238  1099					      if	(pfwidth>2)
   1239  1099		       1f 3e		      .byte.b	%00011111, %00111110
   1240  109b					      endif
   1241  109b				   pflabel0
   1242  109b		       bd 6f 10 	      lda	PF_data0,x
   1243  109e		       95 a4		      sta	playfield,x
   1244  10a0		       ca		      dex
   1245  10a1		       10 f8		      bpl	pflabel0
   1246  10a3				   .
   1247  10a3							; 
   1248  10a3
   1249  10a3				   .
   1250  10a3							; 
   1251  10a3
   1252  10a3				   .
   1253  10a3							; 
   1254  10a3
   1255  10a3				   .
   1256  10a3							; 
   1257  10a3
   1258  10a3				   .
   1259  10a3							; 
   1260  10a3
   1261  10a3				   .
   1262  10a3							; 
   1263  10a3
   1264  10a3				   .
   1265  10a3							; 
   1266  10a3
   1267  10a3				   .
   1268  10a3							; 
   1269  10a3
   1270  10a3				   .
   1271  10a3							; 
   1272  10a3
   1273  10a3				   .
   1274  10a3							; 
   1275  10a3
   1276  10a3				   .
   1277  10a3							; 
   1278  10a3
   1279  10a3				   .__Title_Screen_Loop
   1280  10a3							; __Title_Screen_Loop
   1281  10a3
   1282  10a3				   .
   1283  10a3							; 
   1284  10a3
   1285  10a3				   .
   1286  10a3							; 
   1287  10a3
   1288  10a3				   .
   1289  10a3							; 
   1290  10a3
   1291  10a3				   .
   1292  10a3							; 
   1293  10a3
   1294  10a3				   .
   1295  10a3							; 
   1296  10a3
   1297  10a3				   .
   1298  10a3							; 
   1299  10a3
   1300  10a3				   .
   1301  10a3							; 
   1302  10a3
   1303  10a3				   .L063		;  pfcolors:
   1304  10a3
   1305  10a3		       a9 6e		      lda	# $6E
   1306  10a5		       85 08		      sta	COLUPF
   1307  10a7				  -	      ifconst	pfres
   1308  10a7				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
   1309  10a7					      else
   1310  10a7		       a9 f5		      lda	#>(pfcolorlabel13-84)
   1311  10a9					      endif
   1312  10a9		       85 f1		      sta	pfcolortable+1
   1313  10ab				  -	      ifconst	pfres
   1314  10ab				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
   1315  10ab					      else
   1316  10ab		       a9 04		      lda	#<(pfcolorlabel13-84)
   1317  10ad					      endif
   1318  10ad		       85 f0		      sta	pfcolortable
   1319  10af				   .
   1320  10af							; 
   1321  10af
   1322  10af				   .
   1323  10af							; 
   1324  10af
   1325  10af				   .
   1326  10af							; 
   1327  10af
   1328  10af				   .
   1329  10af							; 
   1330  10af
   1331  10af				   .
   1332  10af							; 
   1333  10af
   1334  10af				   .
   1335  10af							; 
   1336  10af
   1337  10af				   .
   1338  10af							; 
   1339  10af
   1340  10af				   .
   1341  10af							; 
   1342  10af
   1343  10af				   .
   1344  10af							; 
   1345  10af
   1346  10af				   .
   1347  10af							; 
   1348  10af
   1349  10af				   .
   1350  10af							; 
   1351  10af
   1352  10af				   .
   1353  10af							; 
   1354  10af
   1355  10af				   .
   1356  10af							; 
   1357  10af
   1358  10af				   .L064		;  _Master_Counter  =	_Master_Counter  +  1
   1359  10af
   1360  10af		       e6 d8		      INC	_Master_Counter
   1361  10b1				   .
   1362  10b1							; 
   1363  10b1
   1364  10b1				   .
   1365  10b1							; 
   1366  10b1
   1367  10b1				   .
   1368  10b1							; 
   1369  10b1
   1370  10b1				   .
   1371  10b1							; 
   1372  10b1
   1373  10b1				   .L065		;  if _Master_Counter	<  60 then goto __TS_AP_Skip
   1374  10b1
   1375  10b1		       a5 d8		      LDA	_Master_Counter
   1376  10b3		       c9 3c		      CMP	#60
   1377  10b5		       b0 03		      BCS	.skipL065
   1378  10b7				   .condpart1
   1379  10b7		       4c de 10 	      jmp	.__TS_AP_Skip
   1380  10ba
   1381  10ba				   .skipL065
   1382  10ba				   .
   1383  10ba							; 
   1384  10ba
   1385  10ba				   .
   1386  10ba							; 
   1387  10ba
   1388  10ba				   .
   1389  10ba							; 
   1390  10ba
   1391  10ba				   .
   1392  10ba							; 
   1393  10ba
   1394  10ba				   .L066		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
   1395  10ba
   1396  10ba		       e6 d9		      INC	_Frame_Counter
   1397  10bc		       a9 00		      LDA	#0
   1398  10be		       85 d8		      STA	_Master_Counter
   1399  10c0				   .
   1400  10c0							; 
   1401  10c0
   1402  10c0				   .
   1403  10c0							; 
   1404  10c0
   1405  10c0				   .
   1406  10c0							; 
   1407  10c0
   1408  10c0				   .
   1409  10c0							; 
   1410  10c0
   1411  10c0				   .
   1412  10c0							; 
   1413  10c0
   1414  10c0				   .
   1415  10c0							; 
   1416  10c0
   1417  10c0				   .
   1418  10c0							; 
   1419  10c0
   1420  10c0				   .L067		;  if _Frame_Counter  >  9 then _Bit3_Auto_Play{3}  =	1  :  goto __Main_Loop_Setup bank2
   1421  10c0
   1422  10c0		       a9 09		      LDA	#9
   1423  10c2		       c5 d9		      CMP	_Frame_Counter
   1424  10c4		       b0 18		      BCS	.skipL067
   1425  10c6				   .condpart2
   1426  10c6		       a5 ec		      LDA	_Bit3_Auto_Play
   1427  10c8		       09 08		      ORA	#8
   1428  10ca		       85 ec		      STA	_Bit3_Auto_Play
   1429  10cc		       85 ee		      sta	temp7
   1430  10ce		       a9 2f		      lda	#>(.__Main_Loop_Setup-1)
   1431  10d0		       48		      pha
   1432  10d1		       a9 ff		      lda	#<(.__Main_Loop_Setup-1)
   1433  10d3		       48		      pha
   1434  10d4		       a5 ee		      lda	temp7
   1435  10d6		       48		      pha
   1436  10d7		       8a		      txa
   1437  10d8		       48		      pha
   1438  10d9		       a2 02		      ldx	#2
   1439  10db		       4c eb ff 	      jmp	BS_jsr
   1440  10de				   .skipL067
   1441  10de				   .
   1442  10de							; 
   1443  10de
   1444  10de				   .__TS_AP_Skip
   1445  10de							; __TS_AP_Skip
   1446  10de
   1447  10de				   .
   1448  10de							; 
   1449  10de
   1450  10de				   .
   1451  10de							; 
   1452  10de
   1453  10de				   .
   1454  10de							; 
   1455  10de
   1456  10de				   .
   1457  10de							; 
   1458  10de
   1459  10de				   .
   1460  10de							; 
   1461  10de
   1462  10de				   .
   1463  10de							; 
   1464  10de
   1465  10de				   .
   1466  10de							; 
   1467  10de
   1468  10de				   .L068		;  drawscreen
   1469  10de
   1470  10de		       85 ee		      sta	temp7
   1471  10e0		       a9 10		      lda	#>(ret_point1-1)
   1472  10e2		       48		      pha
   1473  10e3		       a9 f5		      lda	#<(ret_point1-1)
   1474  10e5		       48		      pha
   1475  10e6		       a9 f4		      lda	#>(drawscreen-1)
   1476  10e8		       48		      pha
   1477  10e9		       a9 39		      lda	#<(drawscreen-1)
   1478  10eb		       48		      pha
   1479  10ec		       a5 ee		      lda	temp7
   1480  10ee		       48		      pha
   1481  10ef		       8a		      txa
   1482  10f0		       48		      pha
   1483  10f1		       a2 08		      ldx	#8
   1484  10f3		       4c eb ff 	      jmp	BS_jsr
   1485  10f6				   ret_point1
   1486  10f6				   .
   1487  10f6							; 
   1488  10f6
   1489  10f6				   .
   1490  10f6							; 
   1491  10f6
   1492  10f6				   .
   1493  10f6							; 
   1494  10f6
   1495  10f6				   .
   1496  10f6							; 
   1497  10f6
   1498  10f6				   .
   1499  10f6							; 
   1500  10f6
   1501  10f6				   .
   1502  10f6							; 
   1503  10f6
   1504  10f6				   .
   1505  10f6							; 
   1506  10f6
   1507  10f6				   .
   1508  10f6							; 
   1509  10f6
   1510  10f6				   .
   1511  10f6							; 
   1512  10f6
   1513  10f6				   .
   1514  10f6							; 
   1515  10f6
   1516  10f6				   .
   1517  10f6							; 
   1518  10f6
   1519  10f6				   .
   1520  10f6							; 
   1521  10f6
   1522  10f6				   .
   1523  10f6							; 
   1524  10f6
   1525  10f6				   .
   1526  10f6							; 
   1527  10f6
   1528  10f6				   .L069		;  if !switchreset  &&  !joy0fire then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Title_Screen_Loop
   1529  10f6
   1530  10f6		       a9 01		      lda	#1
   1531  10f8		       2c 82 02 	      bit	SWCHB
   1532  10fb		       f0 0d		      BEQ	.skipL069
   1533  10fd				   .condpart3
   1534  10fd		       24 0c		      bit	INPT4
   1535  10ff		       10 09		      BPL	.skip3then
   1536  1101				   .condpart4
   1537  1101		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1538  1103		       29 fe		      AND	#254
   1539  1105		       85 ec		      STA	_Bit0_Reset_Restrainer
   1540  1107		       4c a3 10 	      jmp	.__Title_Screen_Loop
   1541  110a
   1542  110a				   .skip3then
   1543  110a				   .skipL069
   1544  110a				   .
   1545  110a							; 
   1546  110a
   1547  110a				   .
   1548  110a							; 
   1549  110a
   1550  110a				   .
   1551  110a							; 
   1552  110a
   1553  110a				   .
   1554  110a							; 
   1555  110a
   1556  110a				   .
   1557  110a							; 
   1558  110a
   1559  110a				   .L070		;  if _Bit0_Reset_Restrainer{0} then goto __Title_Screen_Loop
   1560  110a
   1561  110a		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1562  110c		       4a		      LSR
   1563  110d		       90 03		      BCC	.skipL070
   1564  110f				   .condpart5
   1565  110f		       4c a3 10 	      jmp	.__Title_Screen_Loop
   1566  1112
   1567  1112				   .skipL070
   1568  1112				   .
   1569  1112							; 
   1570  1112
   1571  1112				   .
   1572  1112							; 
   1573  1112
   1574  1112				   .
   1575  1112							; 
   1576  1112
   1577  1112				   .
   1578  1112							; 
   1579  1112
   1580  1112				   .L071		;  _Bit2_Game_Control{2}  =  1
   1581  1112
   1582  1112		       a5 ec		      LDA	_Bit2_Game_Control
   1583  1114		       09 04		      ORA	#4
   1584  1116		       85 ec		      STA	_Bit2_Game_Control
   1585  1118				   .
   1586  1118							; 
   1587  1118
   1588  1118				   .
   1589  1118							; 
   1590  1118
   1591  1118				   .
   1592  1118							; 
   1593  1118
   1594  1118				   .
   1595  1118							; 
   1596  1118
   1597  1118				   .L072		;  goto __Start_Restart
   1598  1118
   1599  1118		       4c 00 10 	      jmp	.__Start_Restart
   1600  111b
   1601  111b				   .
   1602  111b							; 
   1603  111b
   1604  111b				   .
   1605  111b							; 
   1606  111b
   1607  111b				   .
   1608  111b							; 
   1609  111b
   1610  111b				   .
   1611  111b							; 
   1612  111b
   1613  111b				   .
   1614  111b							; 
   1615  111b
   1616  111b				   .L073		;  bank 2
   1617  111b
   1618  111b					      if	ECHO1
      3769 bytes of ROM space left in bank 1
   1619  111b					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1620  111b					      endif
   1621  111b		       00 01	   ECHO1      =	1
   1622  1fd4					      ORG	$1FF4-bscode_length
   1623  1fd4					      RORG	$1FF4-bscode_length
   1624  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1625  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1626  1fd6				  -	      stx	FASTFETCH
   1627  1fd6					      endif
   1628  1fd6		       9a		      txs
   1629  1fd7				  -	      if	bankswitch == 64
   1630  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1631  1fd7					      else
   1632  1fd7		       a9 f2		      lda	#>(start-1)
   1633  1fd9					      endif
   1634  1fd9		       48		      pha
   1635  1fda		       a9 4f		      lda	#<(start-1)
   1636  1fdc		       48		      pha
   1637  1fdd		       48		      pha
   1638  1fde		       8a		      txa
   1639  1fdf		       48		      pha
   1640  1fe0		       ba		      tsx
   1641  1fe1					      if	bankswitch != 64
   1642  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1643  1fe3		       2a		      rol
   1644  1fe4		       2a		      rol
   1645  1fe5		       2a		      rol
   1646  1fe6		       2a		      rol
   1647  1fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1648  1fe9		       aa		      tax
   1649  1fea		       e8		      inx
   1650  1feb				  -	      else
   1651  1feb				  -	      lda	4,x	; get high byte of return address
   1652  1feb				  -	      tay
   1653  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1654  1feb				  -	      sta	4,x
   1655  1feb				  -	      tya
   1656  1feb				  -	      lsr
   1657  1feb				  -	      lsr
   1658  1feb				  -	      lsr
   1659  1feb				  -	      lsr
   1660  1feb				  -	      tax
   1661  1feb				  -	      inx
   1662  1feb					      endif
   1663  1feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1664  1fee		       68		      pla
   1665  1fef		       aa		      tax
   1666  1ff0		       68		      pla
   1667  1ff1		       60		      rts
   1668  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1669  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1670  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1671  1ff2					      endif
   1672  1ffc					      ORG	$1FFC
   1673  1ffc					      RORG	$1FFC
   1674  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1675  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1676  2000					      ORG	$2000
   1677  2000					      RORG	$3000
   1678  2000				   .
   1679  2000							; 
   1680  2000
   1681  2000				   .
   1682  2000							; 
   1683  2000
   1684  2000				   .
   1685  2000							; 
   1686  2000
   1687  2000				   .
   1688  2000							; 
   1689  2000
   1690  2000				   .
   1691  2000							; 
   1692  2000
   1693  2000				   .
   1694  2000							; 
   1695  2000
   1696  2000				   .
   1697  2000							; 
   1698  2000
   1699  2000				   .
   1700  2000							; 
   1701  2000
   1702  2000				   .
   1703  2000							; 
   1704  2000
   1705  2000				   .
   1706  2000							; 
   1707  2000
   1708  2000				   .
   1709  2000							; 
   1710  2000
   1711  2000				   .__Main_Loop_Setup
   1712  2000							; __Main_Loop_Setup
   1713  2000
   1714  2000				   .
   1715  2000							; 
   1716  2000
   1717  2000				   .
   1718  2000							; 
   1719  2000
   1720  2000				   .
   1721  2000							; 
   1722  2000
   1723  2000				   .
   1724  2000							; 
   1725  2000
   1726  2000				   .
   1727  2000							; 
   1728  2000
   1729  2000				   .
   1730  2000							; 
   1731  2000
   1732  2000				   .
   1733  2000							; 
   1734  2000
   1735  2000				   .
   1736  2000							; 
   1737  2000
   1738  2000				   .
   1739  2000							; 
   1740  2000
   1741  2000				   .
   1742  2000							; 
   1743  2000
   1744  2000				   .L074		;  _Bit2_Game_Control{2}  =  0
   1745  2000
   1746  2000		       a5 ec		      LDA	_Bit2_Game_Control
   1747  2002		       29 fb		      AND	#251
   1748  2004		       85 ec		      STA	_Bit2_Game_Control
   1749  2006				   .
   1750  2006							; 
   1751  2006
   1752  2006				   .
   1753  2006							; 
   1754  2006
   1755  2006				   .
   1756  2006							; 
   1757  2006
   1758  2006				   .
   1759  2006							; 
   1760  2006
   1761  2006				   .
   1762  2006							; 
   1763  2006
   1764  2006				   .
   1765  2006							; 
   1766  2006
   1767  2006				   .
   1768  2006							; 
   1769  2006
   1770  2006				   .
   1771  2006							; 
   1772  2006
   1773  2006				   .
   1774  2006							; 
   1775  2006
   1776  2006				   .
   1777  2006							; 
   1778  2006
   1779  2006				   .
   1780  2006							; 
   1781  2006
   1782  2006				   .
   1783  2006							; 
   1784  2006
   1785  2006				   .
   1786  2006							; 
   1787  2006
   1788  2006				   .L075		;  _Bit0_Reset_Restrainer{0}  =  1
   1789  2006
   1790  2006		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   1791  2008		       09 01		      ORA	#1
   1792  200a		       85 ec		      STA	_Bit0_Reset_Restrainer
   1793  200c				   .
   1794  200c							; 
   1795  200c
   1796  200c				   .
   1797  200c							; 
   1798  200c
   1799  200c				   .
   1800  200c							; 
   1801  200c
   1802  200c				   .
   1803  200c							; 
   1804  200c
   1805  200c				   .
   1806  200c							; 
   1807  200c
   1808  200c				   .
   1809  200c							; 
   1810  200c
   1811  200c				   .
   1812  200c							; 
   1813  200c
   1814  200c				   .
   1815  200c							; 
   1816  200c
   1817  200c				   .
   1818  200c							; 
   1819  200c
   1820  200c				   .
   1821  200c							; 
   1822  200c
   1823  200c				   .
   1824  200c							; 
   1825  200c
   1826  200c				   .
   1827  200c							; 
   1828  200c
   1829  200c				   .L076		;  _Bit1_FireB_Restrainer{1}  =  1
   1830  200c
   1831  200c		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   1832  200e		       09 02		      ORA	#2
   1833  2010		       85 ec		      STA	_Bit1_FireB_Restrainer
   1834  2012				   .
   1835  2012							; 
   1836  2012
   1837  2012				   .
   1838  2012							; 
   1839  2012
   1840  2012				   .
   1841  2012							; 
   1842  2012
   1843  2012				   .
   1844  2012							; 
   1845  2012
   1846  2012				   .
   1847  2012							; 
   1848  2012
   1849  2012				   .
   1850  2012							; 
   1851  2012
   1852  2012				   .L077		;  player0x  =  77  :	player0y  =  53
   1853  2012
   1854  2012		       a9 4d		      LDA	#77
   1855  2014		       85 80		      STA	player0x
   1856  2016		       a9 35		      LDA	#53
   1857  2018		       85 85		      STA	player0y
   1858  201a				   .
   1859  201a							; 
   1860  201a
   1861  201a				   .
   1862  201a							; 
   1863  201a
   1864  201a				   .
   1865  201a							; 
   1866  201a
   1867  201a				   .
   1868  201a							; 
   1869  201a
   1870  201a				   .
   1871  201a							; 
   1872  201a
   1873  201a				   .
   1874  201a							; 
   1875  201a
   1876  201a				   .L078		;  scorecolor	=  $1C
   1877  201a
   1878  201a		       a9 1c		      LDA	#$1C
   1879  201c		       85 a3		      STA	scorecolor
   1880  201e				   .
   1881  201e							; 
   1882  201e
   1883  201e				   .
   1884  201e							; 
   1885  201e
   1886  201e				   .
   1887  201e							; 
   1888  201e
   1889  201e				   .
   1890  201e							; 
   1891  201e
   1892  201e				   .
   1893  201e							; 
   1894  201e
   1895  201e				   .
   1896  201e							; 
   1897  201e
   1898  201e				   .L079		;  missile1height  =  1
   1899  201e
   1900  201e		       a9 01		      LDA	#1
   1901  2020		       85 87		      STA	missile1height
   1902  2022				   .
   1903  2022							; 
   1904  2022
   1905  2022				   .
   1906  2022							; 
   1907  2022
   1908  2022				   .
   1909  2022							; 
   1910  2022
   1911  2022				   .
   1912  2022							; 
   1913  2022
   1914  2022				   .
   1915  2022							; 
   1916  2022
   1917  2022				   .
   1918  2022							; 
   1919  2022
   1920  2022				   .
   1921  2022							; 
   1922  2022
   1923  2022				   .L080		;  _Bit3_P0_Dir_Right{3}  =  1
   1924  2022
   1925  2022		       a5 da		      LDA	_Bit3_P0_Dir_Right
   1926  2024		       09 08		      ORA	#8
   1927  2026		       85 da		      STA	_Bit3_P0_Dir_Right
   1928  2028				   .
   1929  2028							; 
   1930  2028
   1931  2028				   .
   1932  2028							; 
   1933  2028
   1934  2028				   .
   1935  2028							; 
   1936  2028
   1937  2028				   .
   1938  2028							; 
   1939  2028
   1940  2028				   .
   1941  2028							; 
   1942  2028
   1943  2028				   .
   1944  2028							; 
   1945  2028
   1946  2028				   .L081		;  player0:
   1947  2028
   1948  2028		       a2 84		      LDX	#<playerL081_0
   1949  202a		       86 8a		      STX	player0pointerlo
   1950  202c		       a9 f5		      LDA	#>playerL081_0
   1951  202e		       85 8b		      STA	player0pointerhi
   1952  2030		       a9 07		      LDA	#7
   1953  2032		       85 8e		      STA	player0height
   1954  2034				   .
   1955  2034							; 
   1956  2034
   1957  2034				   .
   1958  2034							; 
   1959  2034
   1960  2034				   .
   1961  2034							; 
   1962  2034
   1963  2034				   .
   1964  2034							; 
   1965  2034
   1966  2034				   .
   1967  2034							; 
   1968  2034
   1969  2034				   .
   1970  2034							; 
   1971  2034
   1972  2034				   .L082		;  player1:
   1973  2034
   1974  2034		       a2 8c		      LDX	#<playerL082_1
   1975  2036		       86 8c		      STX	player1pointerlo
   1976  2038		       a9 f5		      LDA	#>playerL082_1
   1977  203a		       85 8d		      STA	player1pointerhi
   1978  203c		       a9 07		      LDA	#7
   1979  203e		       85 8f		      STA	player1height
   1980  2040				   .
   1981  2040							; 
   1982  2040
   1983  2040				   .
   1984  2040							; 
   1985  2040
   1986  2040				   .
   1987  2040							; 
   1988  2040
   1989  2040				   .
   1990  2040							; 
   1991  2040
   1992  2040				   .
   1993  2040							; 
   1994  2040
   1995  2040				   .
   1996  2040							; 
   1997  2040
   1998  2040				   .L083		;  player1y  =   ( rand & 63 )   +  15  :  temp5  =  rand
   1999  2040
   2000  2040							; complex statement detected
   2001  2040		       a5 a2		      lda	rand
   2002  2042		       4a		      lsr
   2003  2043					      ifconst	rand16
   2004  2043		       26 ed		      rol	rand16
   2005  2045					      endif
   2006  2045		       90 02		      bcc	*+4
   2007  2047		       49 b4		      eor	#$B4
   2008  2049		       85 a2		      sta	rand
   2009  204b					      ifconst	rand16
   2010  204b		       45 ed		      eor	rand16
   2011  204d					      endif
   2012  204d		       29 3f		      AND	#63
   2013  204f		       18		      CLC
   2014  2050		       69 0f		      ADC	#15
   2015  2052		       85 86		      STA	player1y
   2016  2054		       a5 a2		      lda	rand
   2017  2056		       4a		      lsr
   2018  2057					      ifconst	rand16
   2019  2057		       26 ed		      rol	rand16
   2020  2059					      endif
   2021  2059		       90 02		      bcc	*+4
   2022  205b		       49 b4		      eor	#$B4
   2023  205d		       85 a2		      sta	rand
   2024  205f					      ifconst	rand16
   2025  205f		       45 ed		      eor	rand16
   2026  2061					      endif
   2027  2061		       85 a0		      STA	temp5
   2028  2063				   .
   2029  2063							; 
   2030  2063
   2031  2063				   .L084		;  if temp5  >  128 then player1x  =	( rand & 7 )   +  5  :	goto __Skip_Enemy_Setup
   2032  2063
   2033  2063		       a9 80		      LDA	#128
   2034  2065		       c5 a0		      CMP	temp5
   2035  2067		       b0 17		      BCS	.skipL084
   2036  2069				   .condpart6
   2037  2069							; complex statement detected
   2038  2069		       a5 a2		      lda	rand
   2039  206b		       4a		      lsr
   2040  206c					      ifconst	rand16
   2041  206c		       26 ed		      rol	rand16
   2042  206e					      endif
   2043  206e		       90 02		      bcc	*+4
   2044  2070		       49 b4		      eor	#$B4
   2045  2072		       85 a2		      sta	rand
   2046  2074					      ifconst	rand16
   2047  2074		       45 ed		      eor	rand16
   2048  2076					      endif
   2049  2076		       29 07		      AND	#7
   2050  2078		       18		      CLC
   2051  2079		       69 05		      ADC	#5
   2052  207b		       85 81		      STA	player1x
   2053  207d		       4c 94 30 	      jmp	.__Skip_Enemy_Setup
   2054  2080
   2055  2080				   .skipL084
   2056  2080				   .
   2057  2080							; 
   2058  2080
   2059  2080				   .L085		;  player1x  =   ( rand & 7 )	 +  140
   2060  2080
   2061  2080							; complex statement detected
   2062  2080		       a5 a2		      lda	rand
   2063  2082		       4a		      lsr
   2064  2083					      ifconst	rand16
   2065  2083		       26 ed		      rol	rand16
   2066  2085					      endif
   2067  2085		       90 02		      bcc	*+4
   2068  2087		       49 b4		      eor	#$B4
   2069  2089		       85 a2		      sta	rand
   2070  208b					      ifconst	rand16
   2071  208b		       45 ed		      eor	rand16
   2072  208d					      endif
   2073  208d		       29 07		      AND	#7
   2074  208f		       18		      CLC
   2075  2090		       69 8c		      ADC	#140
   2076  2092		       85 81		      STA	player1x
   2077  2094				   .
   2078  2094							; 
   2079  2094
   2080  2094				   .__Skip_Enemy_Setup
   2081  2094							; __Skip_Enemy_Setup
   2082  2094
   2083  2094				   .
   2084  2094							; 
   2085  2094
   2086  2094				   .
   2087  2094							; 
   2088  2094
   2089  2094				   .
   2090  2094							; 
   2091  2094
   2092  2094				   .
   2093  2094							; 
   2094  2094
   2095  2094				   .
   2096  2094							; 
   2097  2094
   2098  2094				   .
   2099  2094							; 
   2100  2094
   2101  2094				   .L086		;  playfield:
   2102  2094
   2103  2094				  -	      ifconst	pfres
   2104  2094				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   2105  2094					      else
   2106  2094		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   2107  2096					      endif
   2108  2096		       4c c5 30 	      jmp	pflabel1
   2109  2099				   PF_data1
   2110  2099		       00 00		      .byte.b	%00000000, %00000000
   2111  209b					      if	(pfwidth>2)
   2112  209b		       00 00		      .byte.b	%00000000, %00000000
   2113  209d					      endif
   2114  209d		       00 00		      .byte.b	%00000000, %00000000
   2115  209f					      if	(pfwidth>2)
   2116  209f		       00 00		      .byte.b	%00000000, %00000000
   2117  20a1					      endif
   2118  20a1		       0f 3f		      .byte.b	%00001111, %00111111
   2119  20a3					      if	(pfwidth>2)
   2120  20a3		       3f 0f		      .byte.b	%00111111, %00001111
   2121  20a5					      endif
   2122  20a5		       08 00		      .byte.b	%00001000, %00000000
   2123  20a7					      if	(pfwidth>2)
   2124  20a7		       00 08		      .byte.b	%00000000, %00001000
   2125  20a9					      endif
   2126  20a9		       08 00		      .byte.b	%00001000, %00000000
   2127  20ab					      if	(pfwidth>2)
   2128  20ab		       00 08		      .byte.b	%00000000, %00001000
   2129  20ad					      endif
   2130  20ad		       08 00		      .byte.b	%00001000, %00000000
   2131  20af					      if	(pfwidth>2)
   2132  20af		       00 08		      .byte.b	%00000000, %00001000
   2133  20b1					      endif
   2134  20b1		       00 00		      .byte.b	%00000000, %00000000
   2135  20b3					      if	(pfwidth>2)
   2136  20b3		       00 00		      .byte.b	%00000000, %00000000
   2137  20b5					      endif
   2138  20b5		       00 00		      .byte.b	%00000000, %00000000
   2139  20b7					      if	(pfwidth>2)
   2140  20b7		       00 00		      .byte.b	%00000000, %00000000
   2141  20b9					      endif
   2142  20b9		       0f 70		      .byte.b	%00001111, %01110000
   2143  20bb					      if	(pfwidth>2)
   2144  20bb		       70 0f		      .byte.b	%01110000, %00001111
   2145  20bd					      endif
   2146  20bd		       00 00		      .byte.b	%00000000, %00000000
   2147  20bf					      if	(pfwidth>2)
   2148  20bf		       00 00		      .byte.b	%00000000, %00000000
   2149  20c1					      endif
   2150  20c1		       00 00		      .byte.b	%00000000, %00000000
   2151  20c3					      if	(pfwidth>2)
   2152  20c3		       00 00		      .byte.b	%00000000, %00000000
   2153  20c5					      endif
   2154  20c5				   pflabel1
   2155  20c5		       bd 99 30 	      lda	PF_data1,x
   2156  20c8		       95 a4		      sta	playfield,x
   2157  20ca		       ca		      dex
   2158  20cb		       10 f8		      bpl	pflabel1
   2159  20cd				   .
   2160  20cd							; 
   2161  20cd
   2162  20cd				   .
   2163  20cd							; 
   2164  20cd
   2165  20cd				   .
   2166  20cd							; 
   2167  20cd
   2168  20cd				   .
   2169  20cd							; 
   2170  20cd
   2171  20cd				   .
   2172  20cd							; 
   2173  20cd
   2174  20cd				   .
   2175  20cd							; 
   2176  20cd
   2177  20cd				   .L087		;  _Bit0_BW_Mem{0}  =	0  :  if switchbw then _Bit0_BW_Mem{0}	=  1
   2178  20cd
   2179  20cd		       a5 e5		      LDA	_Bit0_BW_Mem
   2180  20cf		       29 fe		      AND	#254
   2181  20d1		       85 e5		      STA	_Bit0_BW_Mem
   2182  20d3		       a9 08		      lda	#8
   2183  20d5		       2c 82 02 	      bit	SWCHB
   2184  20d8		       d0 06		      BNE	.skipL087
   2185  20da				   .condpart7
   2186  20da		       a5 e5		      LDA	_Bit0_BW_Mem
   2187  20dc		       09 01		      ORA	#1
   2188  20de		       85 e5		      STA	_Bit0_BW_Mem
   2189  20e0				   .skipL087
   2190  20e0				   .
   2191  20e0							; 
   2192  20e0
   2193  20e0				   .
   2194  20e0							; 
   2195  20e0
   2196  20e0				   .
   2197  20e0							; 
   2198  20e0
   2199  20e0				   .
   2200  20e0							; 
   2201  20e0
   2202  20e0				   .
   2203  20e0							; 
   2204  20e0
   2205  20e0				   .
   2206  20e0							; 
   2207  20e0
   2208  20e0				   .
   2209  20e0							; 
   2210  20e0
   2211  20e0				   .
   2212  20e0							; 
   2213  20e0
   2214  20e0				   .
   2215  20e0							; 
   2216  20e0
   2217  20e0				   .L088		;  if !_Bit3_Auto_Play{3} then score  =  0  :	goto __AP_Skip_AP_Setup
   2218  20e0
   2219  20e0		       a5 ec		      LDA	_Bit3_Auto_Play
   2220  20e2		       29 08		      AND	#8
   2221  20e4		       d0 0f		      BNE	.skipL088
   2222  20e6				   .condpart8
   2223  20e6		       a9 00		      LDA	#$00
   2224  20e8		       85 95		      STA	score+2
   2225  20ea		       a9 00		      LDA	#$00
   2226  20ec		       85 94		      STA	score+1
   2227  20ee		       a9 00		      LDA	#$00
   2228  20f0		       85 93		      STA	score
   2229  20f2		       4c 07 31 	      jmp	.__AP_Skip_AP_Setup
   2230  20f5
   2231  20f5				   .skipL088
   2232  20f5				   .
   2233  20f5							; 
   2234  20f5
   2235  20f5				   .
   2236  20f5							; 
   2237  20f5
   2238  20f5				   .
   2239  20f5							; 
   2240  20f5
   2241  20f5				   .
   2242  20f5							; 
   2243  20f5
   2244  20f5				   .L089		;  _Score1_Mem  =  _sc1  :  _Score2_Mem  =  _sc2  :  _Score3_Mem  =  _sc3
   2245  20f5
   2246  20f5		       a5 93		      LDA	_sc1
   2247  20f7		       85 e6		      STA	_Score1_Mem
   2248  20f9		       a5 94		      LDA	_sc2
   2249  20fb		       85 e7		      STA	_Score2_Mem
   2250  20fd		       a5 95		      LDA	_sc3
   2251  20ff		       85 e8		      STA	_Score3_Mem
   2252  2101				   .
   2253  2101							; 
   2254  2101
   2255  2101				   .L090		;  _Bit6_Swap_Scores{6}  =  0
   2256  2101
   2257  2101		       a5 ec		      LDA	_Bit6_Swap_Scores
   2258  2103		       29 bf		      AND	#191
   2259  2105		       85 ec		      STA	_Bit6_Swap_Scores
   2260  2107				   .
   2261  2107							; 
   2262  2107
   2263  2107				   .__AP_Skip_AP_Setup
   2264  2107							; __AP_Skip_AP_Setup
   2265  2107
   2266  2107				   .
   2267  2107							; 
   2268  2107
   2269  2107				   .
   2270  2107							; 
   2271  2107
   2272  2107				   .
   2273  2107							; 
   2274  2107
   2275  2107				   .
   2276  2107							; 
   2277  2107
   2278  2107				   .
   2279  2107							; 
   2280  2107
   2281  2107				   .
   2282  2107							; 
   2283  2107
   2284  2107				   .
   2285  2107							; 
   2286  2107
   2287  2107				   .
   2288  2107							; 
   2289  2107
   2290  2107				   .
   2291  2107							; 
   2292  2107
   2293  2107				   .
   2294  2107							; 
   2295  2107
   2296  2107				   .
   2297  2107							; 
   2298  2107
   2299  2107				   .__Main_Loop
   2300  2107							; __Main_Loop
   2301  2107
   2302  2107				   .
   2303  2107							; 
   2304  2107
   2305  2107				   .
   2306  2107							; 
   2307  2107
   2308  2107				   .
   2309  2107							; 
   2310  2107
   2311  2107				   .
   2312  2107							; 
   2313  2107
   2314  2107				   .
   2315  2107							; 
   2316  2107
   2317  2107				   .
   2318  2107							; 
   2319  2107
   2320  2107				   .
   2321  2107							; 
   2322  2107
   2323  2107				   .L091		;  COLUBK  =  0
   2324  2107
   2325  2107		       a9 00		      LDA	#0
   2326  2109		       85 09		      STA	COLUBK
   2327  210b				   .
   2328  210b							; 
   2329  210b
   2330  210b				   .
   2331  210b							; 
   2332  210b
   2333  210b				   .
   2334  210b							; 
   2335  210b
   2336  210b				   .
   2337  210b							; 
   2338  210b
   2339  210b				   .
   2340  210b							; 
   2341  210b
   2342  210b				   .
   2343  210b							; 
   2344  210b
   2345  210b				   .
   2346  210b							; 
   2347  210b
   2348  210b				   .L092		;  pfcolors:
   2349  210b
   2350  210b		       a9 2c		      lda	# $2C
   2351  210d		       85 08		      sta	COLUPF
   2352  210f				  -	      ifconst	pfres
   2353  210f				  -	      lda	#>(pfcolorlabel13-131+pfres*pfwidth)
   2354  210f					      else
   2355  210f		       a9 f5		      lda	#>(pfcolorlabel13-83)
   2356  2111					      endif
   2357  2111		       85 f1		      sta	pfcolortable+1
   2358  2113				  -	      ifconst	pfres
   2359  2113				  -	      lda	#<(pfcolorlabel13-131+pfres*pfwidth)
   2360  2113					      else
   2361  2113		       a9 05		      lda	#<(pfcolorlabel13-83)
   2362  2115					      endif
   2363  2115		       85 f0		      sta	pfcolortable
   2364  2117				   .
   2365  2117							; 
   2366  2117
   2367  2117				   .
   2368  2117							; 
   2369  2117
   2370  2117				   .
   2371  2117							; 
   2372  2117
   2373  2117				   .
   2374  2117							; 
   2375  2117
   2376  2117				   .
   2377  2117							; 
   2378  2117
   2379  2117				   .
   2380  2117							; 
   2381  2117
   2382  2117				   .
   2383  2117							; 
   2384  2117
   2385  2117				   .L093		;  COLUP0  =  $9C  :  COLUP1  =  $44
   2386  2117
   2387  2117		       a9 9c		      LDA	#$9C
   2388  2119		       85 06		      STA	COLUP0
   2389  211b		       a9 44		      LDA	#$44
   2390  211d		       85 07		      STA	COLUP1
   2391  211f				   .
   2392  211f							; 
   2393  211f
   2394  211f				   .
   2395  211f							; 
   2396  211f
   2397  211f				   .
   2398  211f							; 
   2399  211f
   2400  211f				   .
   2401  211f							; 
   2402  211f
   2403  211f				   .
   2404  211f							; 
   2405  211f
   2406  211f				   .
   2407  211f							; 
   2408  211f
   2409  211f				   .
   2410  211f							; 
   2411  211f
   2412  211f				   .L094		;  NUSIZ1  =  $10
   2413  211f
   2414  211f		       a9 10		      LDA	#$10
   2415  2121		       85 05		      STA	NUSIZ1
   2416  2123				   .
   2417  2123							; 
   2418  2123
   2419  2123				   .
   2420  2123							; 
   2421  2123
   2422  2123				   .
   2423  2123							; 
   2424  2123
   2425  2123				   .
   2426  2123							; 
   2427  2123
   2428  2123				   .
   2429  2123							; 
   2430  2123
   2431  2123				   .
   2432  2123							; 
   2433  2123
   2434  2123				   .
   2435  2123							; 
   2436  2123
   2437  2123				   .
   2438  2123							; 
   2439  2123
   2440  2123				   .
   2441  2123							; 
   2442  2123
   2443  2123				   .
   2444  2123							; 
   2445  2123
   2446  2123				   .L095		;  if _Bit3_Auto_Play{3} then goto __Skip_Joystick_Precheck
   2447  2123
   2448  2123		       a5 ec		      LDA	_Bit3_Auto_Play
   2449  2125		       29 08		      AND	#8
   2450  2127		       f0 03		      BEQ	.skipL095
   2451  2129				   .condpart9
   2452  2129		       4c 4d 31 	      jmp	.__Skip_Joystick_Precheck
   2453  212c
   2454  212c				   .skipL095
   2455  212c				   .
   2456  212c							; 
   2457  212c
   2458  212c				   .
   2459  212c							; 
   2460  212c
   2461  212c				   .
   2462  212c							; 
   2463  212c
   2464  212c				   .
   2465  212c							; 
   2466  212c
   2467  212c				   .L096		;  if !joy0up	&&  !joy0down  &&  !joy0left  &&  !joy0right then goto __Skip_Joystick_Precheck
   2468  212c
   2469  212c		       a9 10		      lda	#$10
   2470  212e		       2c 80 02 	      bit	SWCHA
   2471  2131		       f0 14		      BEQ	.skipL096
   2472  2133				   .condpart10
   2473  2133		       a9 20		      lda	#$20
   2474  2135		       2c 80 02 	      bit	SWCHA
   2475  2138		       f0 0d		      BEQ	.skip10then
   2476  213a				   .condpart11
   2477  213a		       2c 80 02 	      bit	SWCHA
   2478  213d		       50 08		      BVC	.skip11then
   2479  213f				   .condpart12
   2480  213f		       2c 80 02 	      bit	SWCHA
   2481  2142		       10 03		      BPL	.skip12then
   2482  2144				   .condpart13
   2483  2144		       4c 4d 31 	      jmp	.__Skip_Joystick_Precheck
   2484  2147
   2485  2147				   .skip12then
   2486  2147				   .skip11then
   2487  2147				   .skip10then
   2488  2147				   .skipL096
   2489  2147				   .
   2490  2147							; 
   2491  2147
   2492  2147				   .
   2493  2147							; 
   2494  2147
   2495  2147				   .
   2496  2147							; 
   2497  2147
   2498  2147				   .
   2499  2147							; 
   2500  2147
   2501  2147				   .L097		;  _BitOp_P0_M1_Dir  =  _BitOp_P0_M1_Dir  &  %11110000
   2502  2147
   2503  2147		       a5 da		      LDA	_BitOp_P0_M1_Dir
   2504  2149		       29 f0		      AND	#%11110000
   2505  214b		       85 da		      STA	_BitOp_P0_M1_Dir
   2506  214d				   .
   2507  214d							; 
   2508  214d
   2509  214d				   .__Skip_Joystick_Precheck
   2510  214d							; __Skip_Joystick_Precheck
   2511  214d
   2512  214d				   .
   2513  214d							; 
   2514  214d
   2515  214d				   .
   2516  214d							; 
   2517  214d
   2518  214d				   .
   2519  214d							; 
   2520  214d
   2521  214d				   .
   2522  214d							; 
   2523  214d
   2524  214d				   .
   2525  214d							; 
   2526  214d
   2527  214d				   .
   2528  214d							; 
   2529  214d
   2530  214d				   .
   2531  214d							; 
   2532  214d
   2533  214d				   .
   2534  214d							; 
   2535  214d
   2536  214d				   .
   2537  214d							; 
   2538  214d
   2539  214d				   .
   2540  214d							; 
   2541  214d
   2542  214d				   .
   2543  214d							; 
   2544  214d
   2545  214d				   .L098		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_New_Dir
   2546  214d
   2547  214d		       a5 ec		      LDA	_Bit3_Auto_Play
   2548  214f		       29 08		      AND	#8
   2549  2151		       d0 03		      BNE	.skipL098
   2550  2153				   .condpart14
   2551  2153		       4c 0f 33 	      jmp	.__AP_Skip_New_Dir
   2552  2156
   2553  2156				   .skipL098
   2554  2156				   .
   2555  2156							; 
   2556  2156
   2557  2156				   .
   2558  2156							; 
   2559  2156
   2560  2156				   .
   2561  2156							; 
   2562  2156
   2563  2156				   .
   2564  2156							; 
   2565  2156
   2566  2156				   .L099		;  _AP_Dir_Counter  =	_AP_Dir_Counter  +  1
   2567  2156
   2568  2156		       e6 df		      INC	_AP_Dir_Counter
   2569  2158				   .
   2570  2158							; 
   2571  2158
   2572  2158				   .
   2573  2158							; 
   2574  2158
   2575  2158				   .
   2576  2158							; 
   2577  2158
   2578  2158				   .
   2579  2158							; 
   2580  2158
   2581  2158				   .
   2582  2158							; 
   2583  2158
   2584  2158				   .L0100		;  if _AP_Dir_Counter	>  254 then goto __Get_New_AP_Direction
   2585  2158
   2586  2158		       a9 fe		      LDA	#254
   2587  215a		       c5 df		      CMP	_AP_Dir_Counter
   2588  215c		       b0 03		      BCS	.skipL0100
   2589  215e				   .condpart15
   2590  215e		       4c 96 31 	      jmp	.__Get_New_AP_Direction
   2591  2161
   2592  2161				   .skipL0100
   2593  2161				   .
   2594  2161							; 
   2595  2161
   2596  2161				   .
   2597  2161							; 
   2598  2161
   2599  2161				   .
   2600  2161							; 
   2601  2161
   2602  2161				   .
   2603  2161							; 
   2604  2161
   2605  2161				   .
   2606  2161							; 
   2607  2161
   2608  2161				   .
   2609  2161							; 
   2610  2161
   2611  2161				   .L0101		;  temp6  =   ( rand & 63 )   +  50
   2612  2161
   2613  2161							; complex statement detected
   2614  2161		       a5 a2		      lda	rand
   2615  2163		       4a		      lsr
   2616  2164					      ifconst	rand16
   2617  2164		       26 ed		      rol	rand16
   2618  2166					      endif
   2619  2166		       90 02		      bcc	*+4
   2620  2168		       49 b4		      eor	#$B4
   2621  216a		       85 a2		      sta	rand
   2622  216c					      ifconst	rand16
   2623  216c		       45 ed		      eor	rand16
   2624  216e					      endif
   2625  216e		       29 3f		      AND	#63
   2626  2170		       18		      CLC
   2627  2171		       69 32		      ADC	#50
   2628  2173		       85 a1		      STA	temp6
   2629  2175				   .
   2630  2175							; 
   2631  2175
   2632  2175				   .
   2633  2175							; 
   2634  2175
   2635  2175				   .
   2636  2175							; 
   2637  2175
   2638  2175				   .
   2639  2175							; 
   2640  2175
   2641  2175				   .L0102		;  if _AP_Dir_Counter	<  temp6 then goto __AP_Skip_New_Dir
   2642  2175
   2643  2175		       a5 df		      LDA	_AP_Dir_Counter
   2644  2177		       c5 a1		      CMP	temp6
   2645  2179		       b0 03		      BCS	.skipL0102
   2646  217b				   .condpart16
   2647  217b		       4c 0f 33 	      jmp	.__AP_Skip_New_Dir
   2648  217e
   2649  217e				   .skipL0102
   2650  217e				   .
   2651  217e							; 
   2652  217e
   2653  217e				   .
   2654  217e							; 
   2655  217e
   2656  217e				   .
   2657  217e							; 
   2658  217e
   2659  217e				   .
   2660  217e							; 
   2661  217e
   2662  217e				   .L0103		;  temp5  =  rand
   2663  217e
   2664  217e		       a5 a2		      lda	rand
   2665  2180		       4a		      lsr
   2666  2181					      ifconst	rand16
   2667  2181		       26 ed		      rol	rand16
   2668  2183					      endif
   2669  2183		       90 02		      bcc	*+4
   2670  2185		       49 b4		      eor	#$B4
   2671  2187		       85 a2		      sta	rand
   2672  2189					      ifconst	rand16
   2673  2189		       45 ed		      eor	rand16
   2674  218b					      endif
   2675  218b		       85 a0		      STA	temp5
   2676  218d				   .
   2677  218d							; 
   2678  218d
   2679  218d				   .
   2680  218d							; 
   2681  218d
   2682  218d				   .
   2683  218d							; 
   2684  218d
   2685  218d				   .
   2686  218d							; 
   2687  218d
   2688  218d				   .L0104		;  if temp5  <  230 then goto __AP_Skip_New_Dir
   2689  218d
   2690  218d		       a5 a0		      LDA	temp5
   2691  218f		       c9 e6		      CMP	#230
   2692  2191		       b0 03		      BCS	.skipL0104
   2693  2193				   .condpart17
   2694  2193		       4c 0f 33 	      jmp	.__AP_Skip_New_Dir
   2695  2196
   2696  2196				   .skipL0104
   2697  2196				   .
   2698  2196							; 
   2699  2196
   2700  2196				   .__Get_New_AP_Direction
   2701  2196							; __Get_New_AP_Direction
   2702  2196
   2703  2196				   .
   2704  2196							; 
   2705  2196
   2706  2196				   .
   2707  2196							; 
   2708  2196
   2709  2196				   .
   2710  2196							; 
   2711  2196
   2712  2196				   .
   2713  2196							; 
   2714  2196
   2715  2196				   .
   2716  2196							; 
   2717  2196
   2718  2196				   .
   2719  2196							; 
   2720  2196
   2721  2196				   .
   2722  2196							; 
   2723  2196
   2724  2196				   .
   2725  2196							; 
   2726  2196
   2727  2196				   .
   2728  2196							; 
   2729  2196
   2730  2196				   .
   2731  2196							; 
   2732  2196
   2733  2196				   .
   2734  2196							; 
   2735  2196
   2736  2196				   .
   2737  2196							; 
   2738  2196
   2739  2196				   .
   2740  2196							; 
   2741  2196
   2742  2196				   .L0105		;  _T5_AP_Dir	=   ( rand & 7 ) 
   2743  2196
   2744  2196							; complex statement detected
   2745  2196		       a5 a2		      lda	rand
   2746  2198		       4a		      lsr
   2747  2199					      ifconst	rand16
   2748  2199		       26 ed		      rol	rand16
   2749  219b					      endif
   2750  219b		       90 02		      bcc	*+4
   2751  219d		       49 b4		      eor	#$B4
   2752  219f		       85 a2		      sta	rand
   2753  21a1					      ifconst	rand16
   2754  21a1		       45 ed		      eor	rand16
   2755  21a3					      endif
   2756  21a3		       29 07		      AND	#7
   2757  21a5		       85 a0		      STA	_T5_AP_Dir
   2758  21a7				   .
   2759  21a7							; 
   2760  21a7
   2761  21a7				   .
   2762  21a7							; 
   2763  21a7
   2764  21a7				   .
   2765  21a7							; 
   2766  21a7
   2767  21a7				   .
   2768  21a7							; 
   2769  21a7
   2770  21a7				   .
   2771  21a7							; 
   2772  21a7
   2773  21a7				   .
   2774  21a7							; 
   2775  21a7
   2776  21a7				   .
   2777  21a7							; 
   2778  21a7
   2779  21a7				   .L0106		;  if _T5_AP_Dir  =  _AP_Mem_Dir then _T5_AP_Dir  =  _T5_AP_Dir  +   ( rand & 1 )   +	 ( rand & 3 )	+  2  :  if _T5_AP_Dir	>  7 then _T5_AP_Dir  =  _T5_AP_Dir  -	8
   2780  21a7
   2781  21a7		       a5 a0		      LDA	_T5_AP_Dir
   2782  21a9		       c5 db		      CMP	_AP_Mem_Dir
   2783  21ab		       d0 40		      BNE	.skipL0106
   2784  21ad				   .condpart18
   2785  21ad							; complex statement detected
   2786  21ad		       a5 a0		      LDA	_T5_AP_Dir
   2787  21af		       48		      PHA
   2788  21b0		       a5 a2		      lda	rand
   2789  21b2		       4a		      lsr
   2790  21b3					      ifconst	rand16
   2791  21b3		       26 ed		      rol	rand16
   2792  21b5					      endif
   2793  21b5		       90 02		      bcc	*+4
   2794  21b7		       49 b4		      eor	#$B4
   2795  21b9		       85 a2		      sta	rand
   2796  21bb					      ifconst	rand16
   2797  21bb		       45 ed		      eor	rand16
   2798  21bd					      endif
   2799  21bd		       29 01		      AND	#1
   2800  21bf		       ba		      TSX
   2801  21c0		       e8		      INX
   2802  21c1		       9a		      TXS
   2803  21c2		       18		      CLC
   2804  21c3		       75 00		      ADC	$00,x
   2805  21c5		       48		      PHA
   2806  21c6		       a5 a2		      lda	rand
   2807  21c8		       4a		      lsr
   2808  21c9					      ifconst	rand16
   2809  21c9		       26 ed		      rol	rand16
   2810  21cb					      endif
   2811  21cb		       90 02		      bcc	*+4
   2812  21cd		       49 b4		      eor	#$B4
   2813  21cf		       85 a2		      sta	rand
   2814  21d1					      ifconst	rand16
   2815  21d1		       45 ed		      eor	rand16
   2816  21d3					      endif
   2817  21d3		       29 03		      AND	#3
   2818  21d5		       ba		      TSX
   2819  21d6		       e8		      INX
   2820  21d7		       9a		      TXS
   2821  21d8		       18		      CLC
   2822  21d9		       75 00		      ADC	$00,x
   2823  21db		       18		      CLC
   2824  21dc		       69 02		      ADC	#2
   2825  21de		       85 a0		      STA	_T5_AP_Dir
   2826  21e0		       a9 07		      LDA	#7
   2827  21e2		       c5 a0		      CMP	_T5_AP_Dir
   2828  21e4		       b0 07		      BCS	.skip18then
   2829  21e6				   .condpart19
   2830  21e6		       a5 a0		      LDA	_T5_AP_Dir
   2831  21e8		       38		      SEC
   2832  21e9		       e9 08		      SBC	#8
   2833  21eb		       85 a0		      STA	_T5_AP_Dir
   2834  21ed				   .skip18then
   2835  21ed				   .skipL0106
   2836  21ed				   .
   2837  21ed							; 
   2838  21ed
   2839  21ed				   .
   2840  21ed							; 
   2841  21ed
   2842  21ed				   .
   2843  21ed							; 
   2844  21ed
   2845  21ed				   .
   2846  21ed							; 
   2847  21ed
   2848  21ed				   .L0107		;  if player0y  >  85 then _T5_AP_Dir	=  1  :  temp6	=  rand  :  if temp6  >  128 then _T5_AP_Dir  =  7
   2849  21ed
   2850  21ed		       a9 55		      LDA	#85
   2851  21ef		       c5 85		      CMP	player0y
   2852  21f1		       b0 1d		      BCS	.skipL0107
   2853  21f3				   .condpart20
   2854  21f3		       a9 01		      LDA	#1
   2855  21f5		       85 a0		      STA	_T5_AP_Dir
   2856  21f7		       a5 a2		      lda	rand
   2857  21f9		       4a		      lsr
   2858  21fa					      ifconst	rand16
   2859  21fa		       26 ed		      rol	rand16
   2860  21fc					      endif
   2861  21fc		       90 02		      bcc	*+4
   2862  21fe		       49 b4		      eor	#$B4
   2863  2200		       85 a2		      sta	rand
   2864  2202					      ifconst	rand16
   2865  2202		       45 ed		      eor	rand16
   2866  2204					      endif
   2867  2204		       85 a1		      STA	temp6
   2868  2206		       a9 80		      LDA	#128
   2869  2208		       c5 a1		      CMP	temp6
   2870  220a		       b0 04		      BCS	.skip20then
   2871  220c				   .condpart21
   2872  220c		       a9 07		      LDA	#7
   2873  220e		       85 a0		      STA	_T5_AP_Dir
   2874  2210				   .skip20then
   2875  2210				   .skipL0107
   2876  2210				   .
   2877  2210							; 
   2878  2210
   2879  2210				   .
   2880  2210							; 
   2881  2210
   2882  2210				   .
   2883  2210							; 
   2884  2210
   2885  2210				   .
   2886  2210							; 
   2887  2210
   2888  2210				   .L0108		;  if player0y  <  12 then _T5_AP_Dir	=  3  :  temp6	=  rand  :  if temp6  >  128 then _T5_AP_Dir  =  5
   2889  2210
   2890  2210		       a5 85		      LDA	player0y
   2891  2212		       c9 0c		      CMP	#12
   2892  2214		       b0 1d		      BCS	.skipL0108
   2893  2216				   .condpart22
   2894  2216		       a9 03		      LDA	#3
   2895  2218		       85 a0		      STA	_T5_AP_Dir
   2896  221a		       a5 a2		      lda	rand
   2897  221c		       4a		      lsr
   2898  221d					      ifconst	rand16
   2899  221d		       26 ed		      rol	rand16
   2900  221f					      endif
   2901  221f		       90 02		      bcc	*+4
   2902  2221		       49 b4		      eor	#$B4
   2903  2223		       85 a2		      sta	rand
   2904  2225					      ifconst	rand16
   2905  2225		       45 ed		      eor	rand16
   2906  2227					      endif
   2907  2227		       85 a1		      STA	temp6
   2908  2229		       a9 80		      LDA	#128
   2909  222b		       c5 a1		      CMP	temp6
   2910  222d		       b0 04		      BCS	.skip22then
   2911  222f				   .condpart23
   2912  222f		       a9 05		      LDA	#5
   2913  2231		       85 a0		      STA	_T5_AP_Dir
   2914  2233				   .skip22then
   2915  2233				   .skipL0108
   2916  2233				   .
   2917  2233							; 
   2918  2233
   2919  2233				   .
   2920  2233							; 
   2921  2233
   2922  2233				   .
   2923  2233							; 
   2924  2233
   2925  2233				   .
   2926  2233							; 
   2927  2233
   2928  2233				   .L0109		;  if player0x  >  148 then _T5_AP_Dir  =  7  :  temp6  =  rand  :  if temp6  >  128 then _T5_AP_Dir  =  5
   2929  2233
   2930  2233		       a9 94		      LDA	#148
   2931  2235		       c5 80		      CMP	player0x
   2932  2237		       b0 1d		      BCS	.skipL0109
   2933  2239				   .condpart24
   2934  2239		       a9 07		      LDA	#7
   2935  223b		       85 a0		      STA	_T5_AP_Dir
   2936  223d		       a5 a2		      lda	rand
   2937  223f		       4a		      lsr
   2938  2240					      ifconst	rand16
   2939  2240		       26 ed		      rol	rand16
   2940  2242					      endif
   2941  2242		       90 02		      bcc	*+4
   2942  2244		       49 b4		      eor	#$B4
   2943  2246		       85 a2		      sta	rand
   2944  2248					      ifconst	rand16
   2945  2248		       45 ed		      eor	rand16
   2946  224a					      endif
   2947  224a		       85 a1		      STA	temp6
   2948  224c		       a9 80		      LDA	#128
   2949  224e		       c5 a1		      CMP	temp6
   2950  2250		       b0 04		      BCS	.skip24then
   2951  2252				   .condpart25
   2952  2252		       a9 05		      LDA	#5
   2953  2254		       85 a0		      STA	_T5_AP_Dir
   2954  2256				   .skip24then
   2955  2256				   .skipL0109
   2956  2256				   .
   2957  2256							; 
   2958  2256
   2959  2256				   .
   2960  2256							; 
   2961  2256
   2962  2256				   .
   2963  2256							; 
   2964  2256
   2965  2256				   .
   2966  2256							; 
   2967  2256
   2968  2256				   .L0110		;  if player0x  <  4 then _T5_AP_Dir  =  1  :	temp6  =  rand	:  if temp6  >	128 then _T5_AP_Dir  =	3
   2969  2256
   2970  2256		       a5 80		      LDA	player0x
   2971  2258		       c9 04		      CMP	#4
   2972  225a		       b0 1d		      BCS	.skipL0110
   2973  225c				   .condpart26
   2974  225c		       a9 01		      LDA	#1
   2975  225e		       85 a0		      STA	_T5_AP_Dir
   2976  2260		       a5 a2		      lda	rand
   2977  2262		       4a		      lsr
   2978  2263					      ifconst	rand16
   2979  2263		       26 ed		      rol	rand16
   2980  2265					      endif
   2981  2265		       90 02		      bcc	*+4
   2982  2267		       49 b4		      eor	#$B4
   2983  2269		       85 a2		      sta	rand
   2984  226b					      ifconst	rand16
   2985  226b		       45 ed		      eor	rand16
   2986  226d					      endif
   2987  226d		       85 a1		      STA	temp6
   2988  226f		       a9 80		      LDA	#128
   2989  2271		       c5 a1		      CMP	temp6
   2990  2273		       b0 04		      BCS	.skip26then
   2991  2275				   .condpart27
   2992  2275		       a9 03		      LDA	#3
   2993  2277		       85 a0		      STA	_T5_AP_Dir
   2994  2279				   .skip26then
   2995  2279				   .skipL0110
   2996  2279				   .
   2997  2279							; 
   2998  2279
   2999  2279				   .
   3000  2279							; 
   3001  2279
   3002  2279				   .
   3003  2279							; 
   3004  2279
   3005  2279				   .
   3006  2279							; 
   3007  2279
   3008  2279				   .
   3009  2279							; 
   3010  2279
   3011  2279				   .
   3012  2279							; 
   3013  2279
   3014  2279				   .L0111		;  _AP_Mem_Dir  =  _T5_AP_Dir	+  4  :  if _AP_Mem_Dir  >  7 then _AP_Mem_Dir	=  _AP_Mem_Dir	-  8
   3015  2279
   3016  2279		       a5 a0		      LDA	_T5_AP_Dir
   3017  227b		       18		      CLC
   3018  227c		       69 04		      ADC	#4
   3019  227e		       85 db		      STA	_AP_Mem_Dir
   3020  2280		       a9 07		      LDA	#7
   3021  2282		       c5 db		      CMP	_AP_Mem_Dir
   3022  2284		       b0 07		      BCS	.skipL0111
   3023  2286				   .condpart28
   3024  2286		       a5 db		      LDA	_AP_Mem_Dir
   3025  2288		       38		      SEC
   3026  2289		       e9 08		      SBC	#8
   3027  228b		       85 db		      STA	_AP_Mem_Dir
   3028  228d				   .skipL0111
   3029  228d				   .
   3030  228d							; 
   3031  228d
   3032  228d				   .
   3033  228d							; 
   3034  228d
   3035  228d				   .
   3036  228d							; 
   3037  228d
   3038  228d				   .
   3039  228d							; 
   3040  228d
   3041  228d				   .L0112		;  _AP_Dir_Counter  =	0  :  _BitOp_P0_M1_Dir	=  _BitOp_P0_M1_Dir  &	%11110000
   3042  228d
   3043  228d		       a9 00		      LDA	#0
   3044  228f		       85 df		      STA	_AP_Dir_Counter
   3045  2291		       a5 da		      LDA	_BitOp_P0_M1_Dir
   3046  2293		       29 f0		      AND	#%11110000
   3047  2295		       85 da		      STA	_BitOp_P0_M1_Dir
   3048  2297				   .
   3049  2297							; 
   3050  2297
   3051  2297				   .
   3052  2297							; 
   3053  2297
   3054  2297				   .
   3055  2297							; 
   3056  2297
   3057  2297				   .
   3058  2297							; 
   3059  2297
   3060  2297				   .L0113		;  if _T5_AP_Dir  =  0 then _Bit0_P0_Dir_Up{0}  =  1
   3061  2297
   3062  2297		       a5 a0		      LDA	_T5_AP_Dir
   3063  2299		       c9 00		      CMP	#0
   3064  229b		       d0 06		      BNE	.skipL0113
   3065  229d				   .condpart29
   3066  229d		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3067  229f		       09 01		      ORA	#1
   3068  22a1		       85 da		      STA	_Bit0_P0_Dir_Up
   3069  22a3				   .skipL0113
   3070  22a3				   .L0114		;  if _T5_AP_Dir  =  1 then _Bit0_P0_Dir_Up{0}  =  1  :  _Bit3_P0_Dir_Right{3}  =  1
   3071  22a3
   3072  22a3		       a5 a0		      LDA	_T5_AP_Dir
   3073  22a5		       c9 01		      CMP	#1
   3074  22a7		       d0 0c		      BNE	.skipL0114
   3075  22a9				   .condpart30
   3076  22a9		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3077  22ab		       09 01		      ORA	#1
   3078  22ad		       85 da		      STA	_Bit0_P0_Dir_Up
   3079  22af		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3080  22b1		       09 08		      ORA	#8
   3081  22b3		       85 da		      STA	_Bit3_P0_Dir_Right
   3082  22b5				   .skipL0114
   3083  22b5				   .L0115		;  if _T5_AP_Dir  =  2 then _Bit3_P0_Dir_Right{3}  =  1
   3084  22b5
   3085  22b5		       a5 a0		      LDA	_T5_AP_Dir
   3086  22b7		       c9 02		      CMP	#2
   3087  22b9		       d0 06		      BNE	.skipL0115
   3088  22bb				   .condpart31
   3089  22bb		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3090  22bd		       09 08		      ORA	#8
   3091  22bf		       85 da		      STA	_Bit3_P0_Dir_Right
   3092  22c1				   .skipL0115
   3093  22c1				   .L0116		;  if _T5_AP_Dir  =  3 then _Bit1_P0_Dir_Down{1}  =  1  :  _Bit3_P0_Dir_Right{3}  =  1
   3094  22c1
   3095  22c1		       a5 a0		      LDA	_T5_AP_Dir
   3096  22c3		       c9 03		      CMP	#3
   3097  22c5		       d0 0c		      BNE	.skipL0116
   3098  22c7				   .condpart32
   3099  22c7		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3100  22c9		       09 02		      ORA	#2
   3101  22cb		       85 da		      STA	_Bit1_P0_Dir_Down
   3102  22cd		       a5 da		      LDA	_Bit3_P0_Dir_Right
   3103  22cf		       09 08		      ORA	#8
   3104  22d1		       85 da		      STA	_Bit3_P0_Dir_Right
   3105  22d3				   .skipL0116
   3106  22d3				   .L0117		;  if _T5_AP_Dir  =  4 then _Bit1_P0_Dir_Down{1}  =  1
   3107  22d3
   3108  22d3		       a5 a0		      LDA	_T5_AP_Dir
   3109  22d5		       c9 04		      CMP	#4
   3110  22d7		       d0 06		      BNE	.skipL0117
   3111  22d9				   .condpart33
   3112  22d9		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3113  22db		       09 02		      ORA	#2
   3114  22dd		       85 da		      STA	_Bit1_P0_Dir_Down
   3115  22df				   .skipL0117
   3116  22df				   .L0118		;  if _T5_AP_Dir  =  5 then _Bit1_P0_Dir_Down{1}  =  1  :  _Bit2_P0_Dir_Left{2}  =  1
   3117  22df
   3118  22df		       a5 a0		      LDA	_T5_AP_Dir
   3119  22e1		       c9 05		      CMP	#5
   3120  22e3		       d0 0c		      BNE	.skipL0118
   3121  22e5				   .condpart34
   3122  22e5		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3123  22e7		       09 02		      ORA	#2
   3124  22e9		       85 da		      STA	_Bit1_P0_Dir_Down
   3125  22eb		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3126  22ed		       09 04		      ORA	#4
   3127  22ef		       85 da		      STA	_Bit2_P0_Dir_Left
   3128  22f1				   .skipL0118
   3129  22f1				   .L0119		;  if _T5_AP_Dir  =  6 then _Bit2_P0_Dir_Left{2}  =  1
   3130  22f1
   3131  22f1		       a5 a0		      LDA	_T5_AP_Dir
   3132  22f3		       c9 06		      CMP	#6
   3133  22f5		       d0 06		      BNE	.skipL0119
   3134  22f7				   .condpart35
   3135  22f7		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3136  22f9		       09 04		      ORA	#4
   3137  22fb		       85 da		      STA	_Bit2_P0_Dir_Left
   3138  22fd				   .skipL0119
   3139  22fd				   .L0120		;  if _T5_AP_Dir  =  7 then _Bit0_P0_Dir_Up{0}  =  1  :  _Bit2_P0_Dir_Left{2}	=  1
   3140  22fd
   3141  22fd		       a5 a0		      LDA	_T5_AP_Dir
   3142  22ff		       c9 07		      CMP	#7
   3143  2301		       d0 0c		      BNE	.skipL0120
   3144  2303				   .condpart36
   3145  2303		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3146  2305		       09 01		      ORA	#1
   3147  2307		       85 da		      STA	_Bit0_P0_Dir_Up
   3148  2309		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3149  230b		       09 04		      ORA	#4
   3150  230d		       85 da		      STA	_Bit2_P0_Dir_Left
   3151  230f				   .skipL0120
   3152  230f				   .
   3153  230f							; 
   3154  230f
   3155  230f				   .__AP_Skip_New_Dir
   3156  230f							; __AP_Skip_New_Dir
   3157  230f
   3158  230f				   .
   3159  230f							; 
   3160  230f
   3161  230f				   .
   3162  230f							; 
   3163  230f
   3164  230f				   .
   3165  230f							; 
   3166  230f
   3167  230f				   .
   3168  230f							; 
   3169  230f
   3170  230f				   .
   3171  230f							; 
   3172  230f
   3173  230f				   .
   3174  230f							; 
   3175  230f
   3176  230f				   .
   3177  230f							; 
   3178  230f
   3179  230f				   .
   3180  230f							; 
   3181  230f
   3182  230f				   .
   3183  230f							; 
   3184  230f
   3185  230f				   .
   3186  230f							; 
   3187  230f
   3188  230f				   .
   3189  230f							; 
   3190  230f
   3191  230f				   .L0121		;  if _Bit3_Auto_Play{3}  &&  _Bit0_P0_Dir_Up{0} then goto __AP_Move_Up
   3192  230f
   3193  230f		       a5 ec		      LDA	_Bit3_Auto_Play
   3194  2311		       29 08		      AND	#8
   3195  2313		       f0 08		      BEQ	.skipL0121
   3196  2315				   .condpart37
   3197  2315		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3198  2317		       4a		      LSR
   3199  2318		       90 03		      BCC	.skip37then
   3200  231a				   .condpart38
   3201  231a		       4c 2d 33 	      jmp	.__AP_Move_Up
   3202  231d
   3203  231d				   .skip37then
   3204  231d				   .skipL0121
   3205  231d				   .
   3206  231d							; 
   3207  231d
   3208  231d				   .
   3209  231d							; 
   3210  231d
   3211  231d				   .
   3212  231d							; 
   3213  231d
   3214  231d				   .
   3215  231d							; 
   3216  231d
   3217  231d				   .L0122		;  if !joy0up then goto __Skip_Joy0_Up
   3218  231d
   3219  231d		       a9 10		      lda	#$10
   3220  231f		       2c 80 02 	      bit	SWCHA
   3221  2322		       f0 03		      BEQ	.skipL0122
   3222  2324				   .condpart39
   3223  2324		       4c d0 33 	      jmp	.__Skip_Joy0_Up
   3224  2327
   3225  2327				   .skipL0122
   3226  2327				   .
   3227  2327							; 
   3228  2327
   3229  2327				   .
   3230  2327							; 
   3231  2327
   3232  2327				   .
   3233  2327							; 
   3234  2327
   3235  2327				   .
   3236  2327							; 
   3237  2327
   3238  2327				   .L0123		;  _Bit0_P0_Dir_Up{0}	=  1
   3239  2327
   3240  2327		       a5 da		      LDA	_Bit0_P0_Dir_Up
   3241  2329		       09 01		      ORA	#1
   3242  232b		       85 da		      STA	_Bit0_P0_Dir_Up
   3243  232d				   .
   3244  232d							; 
   3245  232d
   3246  232d				   .__AP_Move_Up
   3247  232d							; __AP_Move_Up
   3248  232d
   3249  232d				   .
   3250  232d							; 
   3251  232d
   3252  232d				   .
   3253  232d							; 
   3254  232d
   3255  232d				   .
   3256  232d							; 
   3257  232d
   3258  232d				   .
   3259  232d							; 
   3260  232d
   3261  232d				   .L0124		;  if player0y  <=  _P_Edge_Top then goto __Skip_Joy0_Up
   3262  232d
   3263  232d		       a9 09		      LDA	#_P_Edge_Top
   3264  232f		       c5 85		      CMP	player0y
   3265  2331		       90 03		      BCC	.skipL0124
   3266  2333				   .condpart40
   3267  2333		       4c d0 33 	      jmp	.__Skip_Joy0_Up
   3268  2336
   3269  2336				   .skipL0124
   3270  2336				   .
   3271  2336							; 
   3272  2336
   3273  2336				   .
   3274  2336							; 
   3275  2336
   3276  2336				   .
   3277  2336							; 
   3278  2336
   3279  2336				   .
   3280  2336							; 
   3281  2336
   3282  2336				   .L0125		;  temp5  =   ( player0x - 10 )  / 4
   3283  2336
   3284  2336							; complex statement detected
   3285  2336		       a5 80		      LDA	player0x
   3286  2338		       38		      SEC
   3287  2339		       e9 0a		      SBC	#10
   3288  233b		       4a		      lsr
   3289  233c		       4a		      lsr
   3290  233d		       85 a0		      STA	temp5
   3291  233f				   .
   3292  233f							; 
   3293  233f
   3294  233f				   .L0126		;  temp4  =   ( player0x - 17 )  / 4
   3295  233f
   3296  233f							; complex statement detected
   3297  233f		       a5 80		      LDA	player0x
   3298  2341		       38		      SEC
   3299  2342		       e9 11		      SBC	#17
   3300  2344		       4a		      lsr
   3301  2345		       4a		      lsr
   3302  2346		       85 9f		      STA	temp4
   3303  2348				   .
   3304  2348							; 
   3305  2348
   3306  2348				   .L0127		;  temp3  =  temp5  -	1
   3307  2348
   3308  2348		       a5 a0		      LDA	temp5
   3309  234a		       38		      SEC
   3310  234b		       e9 01		      SBC	#1
   3311  234d		       85 9e		      STA	temp3
   3312  234f				   .
   3313  234f							; 
   3314  234f
   3315  234f				   .L0128		;  temp6  =   ( player0y - 9 )  / 8
   3316  234f
   3317  234f							; complex statement detected
   3318  234f		       a5 85		      LDA	player0y
   3319  2351		       38		      SEC
   3320  2352		       e9 09		      SBC	#9
   3321  2354		       4a		      lsr
   3322  2355		       4a		      lsr
   3323  2356		       4a		      lsr
   3324  2357		       85 a1		      STA	temp6
   3325  2359				   .
   3326  2359							; 
   3327  2359
   3328  2359				   .L0129		;  if temp5  <  34 then if pfread ( temp5 , temp6 )  then goto __Skip_Joy0_Up
   3329  2359
   3330  2359		       a5 a0		      LDA	temp5
   3331  235b		       c9 22		      CMP	#34
   3332  235d		       b0 21		      BCS	.skipL0129
   3333  235f				   .condpart41
   3334  235f		       a5 a0		      LDA	temp5
   3335  2361		       a4 a1		      LDY	temp6
   3336  2363		       85 ee		      sta	temp7
   3337  2365		       a9 33		      lda	#>(ret_point2-1)
   3338  2367		       48		      pha
   3339  2368		       a9 7a		      lda	#<(ret_point2-1)
   3340  236a		       48		      pha
   3341  236b		       a9 f2		      lda	#>(pfread-1)
   3342  236d		       48		      pha
   3343  236e		       a9 a9		      lda	#<(pfread-1)
   3344  2370		       48		      pha
   3345  2371		       a5 ee		      lda	temp7
   3346  2373		       48		      pha
   3347  2374		       8a		      txa
   3348  2375		       48		      pha
   3349  2376		       a2 08		      ldx	#8
   3350  2378		       4c eb ff 	      jmp	BS_jsr
   3351  237b				   ret_point2
   3352  237b		       d0 03		      BNE	.skip41then
   3353  237d				   .condpart42
   3354  237d		       4c d0 33 	      jmp	.__Skip_Joy0_Up
   3355  2380
   3356  2380				   .skip41then
   3357  2380				   .skipL0129
   3358  2380				   .
   3359  2380							; 
   3360  2380
   3361  2380				   .L0130		;  if temp4  <  34 then if pfread ( temp4 , temp6 )  then goto __Skip_Joy0_Up
   3362  2380
   3363  2380		       a5 9f		      LDA	temp4
   3364  2382		       c9 22		      CMP	#34
   3365  2384		       b0 21		      BCS	.skipL0130
   3366  2386				   .condpart43
   3367  2386		       a5 9f		      LDA	temp4
   3368  2388		       a4 a1		      LDY	temp6
   3369  238a		       85 ee		      sta	temp7
   3370  238c		       a9 33		      lda	#>(ret_point3-1)
   3371  238e		       48		      pha
   3372  238f		       a9 a1		      lda	#<(ret_point3-1)
   3373  2391		       48		      pha
   3374  2392		       a9 f2		      lda	#>(pfread-1)
   3375  2394		       48		      pha
   3376  2395		       a9 a9		      lda	#<(pfread-1)
   3377  2397		       48		      pha
   3378  2398		       a5 ee		      lda	temp7
   3379  239a		       48		      pha
   3380  239b		       8a		      txa
   3381  239c		       48		      pha
   3382  239d		       a2 08		      ldx	#8
   3383  239f		       4c eb ff 	      jmp	BS_jsr
   3384  23a2				   ret_point3
   3385  23a2		       d0 03		      BNE	.skip43then
   3386  23a4				   .condpart44
   3387  23a4		       4c d0 33 	      jmp	.__Skip_Joy0_Up
   3388  23a7
   3389  23a7				   .skip43then
   3390  23a7				   .skipL0130
   3391  23a7				   .
   3392  23a7							; 
   3393  23a7
   3394  23a7				   .L0131		;  if temp3  <  34 then if pfread ( temp3 , temp6 )  then goto __Skip_Joy0_Up
   3395  23a7
   3396  23a7		       a5 9e		      LDA	temp3
   3397  23a9		       c9 22		      CMP	#34
   3398  23ab		       b0 21		      BCS	.skipL0131
   3399  23ad				   .condpart45
   3400  23ad		       a5 9e		      LDA	temp3
   3401  23af		       a4 a1		      LDY	temp6
   3402  23b1		       85 ee		      sta	temp7
   3403  23b3		       a9 33		      lda	#>(ret_point4-1)
   3404  23b5		       48		      pha
   3405  23b6		       a9 c8		      lda	#<(ret_point4-1)
   3406  23b8		       48		      pha
   3407  23b9		       a9 f2		      lda	#>(pfread-1)
   3408  23bb		       48		      pha
   3409  23bc		       a9 a9		      lda	#<(pfread-1)
   3410  23be		       48		      pha
   3411  23bf		       a5 ee		      lda	temp7
   3412  23c1		       48		      pha
   3413  23c2		       8a		      txa
   3414  23c3		       48		      pha
   3415  23c4		       a2 08		      ldx	#8
   3416  23c6		       4c eb ff 	      jmp	BS_jsr
   3417  23c9				   ret_point4
   3418  23c9		       d0 03		      BNE	.skip45then
   3419  23cb				   .condpart46
   3420  23cb		       4c d0 33 	      jmp	.__Skip_Joy0_Up
   3421  23ce
   3422  23ce				   .skip45then
   3423  23ce				   .skipL0131
   3424  23ce				   .
   3425  23ce							; 
   3426  23ce
   3427  23ce				   .
   3428  23ce							; 
   3429  23ce
   3430  23ce				   .
   3431  23ce							; 
   3432  23ce
   3433  23ce				   .
   3434  23ce							; 
   3435  23ce
   3436  23ce				   .L0132		;  player0y  =  player0y  -  1
   3437  23ce
   3438  23ce		       c6 85		      DEC	player0y
   3439  23d0				   .
   3440  23d0							; 
   3441  23d0
   3442  23d0				   .__Skip_Joy0_Up
   3443  23d0							; __Skip_Joy0_Up
   3444  23d0
   3445  23d0				   .
   3446  23d0							; 
   3447  23d0
   3448  23d0				   .
   3449  23d0							; 
   3450  23d0
   3451  23d0				   .
   3452  23d0							; 
   3453  23d0
   3454  23d0				   .
   3455  23d0							; 
   3456  23d0
   3457  23d0				   .
   3458  23d0							; 
   3459  23d0
   3460  23d0				   .
   3461  23d0							; 
   3462  23d0
   3463  23d0				   .
   3464  23d0							; 
   3465  23d0
   3466  23d0				   .
   3467  23d0							; 
   3468  23d0
   3469  23d0				   .
   3470  23d0							; 
   3471  23d0
   3472  23d0				   .
   3473  23d0							; 
   3474  23d0
   3475  23d0				   .L0133		;  if _Bit3_Auto_Play{3}  &&  _Bit1_P0_Dir_Down{1} then goto __AP_Move_Down
   3476  23d0
   3477  23d0		       a5 ec		      LDA	_Bit3_Auto_Play
   3478  23d2		       29 08		      AND	#8
   3479  23d4		       f0 09		      BEQ	.skipL0133
   3480  23d6				   .condpart47
   3481  23d6		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3482  23d8		       29 02		      AND	#2
   3483  23da		       f0 03		      BEQ	.skip47then
   3484  23dc				   .condpart48
   3485  23dc		       4c ef 33 	      jmp	.__AP_Move_Down
   3486  23df
   3487  23df				   .skip47then
   3488  23df				   .skipL0133
   3489  23df				   .
   3490  23df							; 
   3491  23df
   3492  23df				   .
   3493  23df							; 
   3494  23df
   3495  23df				   .
   3496  23df							; 
   3497  23df
   3498  23df				   .
   3499  23df							; 
   3500  23df
   3501  23df				   .L0134		;  if !joy0down then goto __Skip_Joy0_Down
   3502  23df
   3503  23df		       a9 20		      lda	#$20
   3504  23e1		       2c 80 02 	      bit	SWCHA
   3505  23e4		       f0 03		      BEQ	.skipL0134
   3506  23e6				   .condpart49
   3507  23e6		       4c 92 34 	      jmp	.__Skip_Joy0_Down
   3508  23e9
   3509  23e9				   .skipL0134
   3510  23e9				   .
   3511  23e9							; 
   3512  23e9
   3513  23e9				   .
   3514  23e9							; 
   3515  23e9
   3516  23e9				   .
   3517  23e9							; 
   3518  23e9
   3519  23e9				   .
   3520  23e9							; 
   3521  23e9
   3522  23e9				   .L0135		;  _Bit1_P0_Dir_Down{1}  =  1
   3523  23e9
   3524  23e9		       a5 da		      LDA	_Bit1_P0_Dir_Down
   3525  23eb		       09 02		      ORA	#2
   3526  23ed		       85 da		      STA	_Bit1_P0_Dir_Down
   3527  23ef				   .
   3528  23ef							; 
   3529  23ef
   3530  23ef				   .__AP_Move_Down
   3531  23ef							; __AP_Move_Down
   3532  23ef
   3533  23ef				   .
   3534  23ef							; 
   3535  23ef
   3536  23ef				   .
   3537  23ef							; 
   3538  23ef
   3539  23ef				   .
   3540  23ef							; 
   3541  23ef
   3542  23ef				   .
   3543  23ef							; 
   3544  23ef
   3545  23ef				   .L0136		;  if player0y  >=  _P_Edge_Bottom then goto __Skip_Joy0_Down
   3546  23ef
   3547  23ef		       a5 85		      LDA	player0y
   3548  23f1		       c9 58		      CMP	#_P_Edge_Bottom
   3549  23f3		       90 03		      BCC	.skipL0136
   3550  23f5				   .condpart50
   3551  23f5		       4c 92 34 	      jmp	.__Skip_Joy0_Down
   3552  23f8
   3553  23f8				   .skipL0136
   3554  23f8				   .
   3555  23f8							; 
   3556  23f8
   3557  23f8				   .
   3558  23f8							; 
   3559  23f8
   3560  23f8				   .
   3561  23f8							; 
   3562  23f8
   3563  23f8				   .
   3564  23f8							; 
   3565  23f8
   3566  23f8				   .L0137		;  temp5  =   ( player0x - 10 )  / 4
   3567  23f8
   3568  23f8							; complex statement detected
   3569  23f8		       a5 80		      LDA	player0x
   3570  23fa		       38		      SEC
   3571  23fb		       e9 0a		      SBC	#10
   3572  23fd		       4a		      lsr
   3573  23fe		       4a		      lsr
   3574  23ff		       85 a0		      STA	temp5
   3575  2401				   .
   3576  2401							; 
   3577  2401
   3578  2401				   .L0138		;  temp4  =   ( player0x - 17 )  / 4
   3579  2401
   3580  2401							; complex statement detected
   3581  2401		       a5 80		      LDA	player0x
   3582  2403		       38		      SEC
   3583  2404		       e9 11		      SBC	#17
   3584  2406		       4a		      lsr
   3585  2407		       4a		      lsr
   3586  2408		       85 9f		      STA	temp4
   3587  240a				   .
   3588  240a							; 
   3589  240a
   3590  240a				   .L0139		;  temp3  =  temp5  -	1
   3591  240a
   3592  240a		       a5 a0		      LDA	temp5
   3593  240c		       38		      SEC
   3594  240d		       e9 01		      SBC	#1
   3595  240f		       85 9e		      STA	temp3
   3596  2411				   .
   3597  2411							; 
   3598  2411
   3599  2411				   .L0140		;  temp6  =   ( player0y + 1 )  / 8
   3600  2411
   3601  2411							; complex statement detected
   3602  2411		       a5 85		      LDA	player0y
   3603  2413		       18		      CLC
   3604  2414		       69 01		      ADC	#1
   3605  2416		       4a		      lsr
   3606  2417		       4a		      lsr
   3607  2418		       4a		      lsr
   3608  2419		       85 a1		      STA	temp6
   3609  241b				   .
   3610  241b							; 
   3611  241b
   3612  241b				   .L0141		;  if temp5  <  34 then if pfread ( temp5 , temp6 )  then goto __Skip_Joy0_Down
   3613  241b
   3614  241b		       a5 a0		      LDA	temp5
   3615  241d		       c9 22		      CMP	#34
   3616  241f		       b0 21		      BCS	.skipL0141
   3617  2421				   .condpart51
   3618  2421		       a5 a0		      LDA	temp5
   3619  2423		       a4 a1		      LDY	temp6
   3620  2425		       85 ee		      sta	temp7
   3621  2427		       a9 34		      lda	#>(ret_point5-1)
   3622  2429		       48		      pha
   3623  242a		       a9 3c		      lda	#<(ret_point5-1)
   3624  242c		       48		      pha
   3625  242d		       a9 f2		      lda	#>(pfread-1)
   3626  242f		       48		      pha
   3627  2430		       a9 a9		      lda	#<(pfread-1)
   3628  2432		       48		      pha
   3629  2433		       a5 ee		      lda	temp7
   3630  2435		       48		      pha
   3631  2436		       8a		      txa
   3632  2437		       48		      pha
   3633  2438		       a2 08		      ldx	#8
   3634  243a		       4c eb ff 	      jmp	BS_jsr
   3635  243d				   ret_point5
   3636  243d		       d0 03		      BNE	.skip51then
   3637  243f				   .condpart52
   3638  243f		       4c 92 34 	      jmp	.__Skip_Joy0_Down
   3639  2442
   3640  2442				   .skip51then
   3641  2442				   .skipL0141
   3642  2442				   .
   3643  2442							; 
   3644  2442
   3645  2442				   .L0142		;  if temp4  <  34 then if pfread ( temp4 , temp6 )  then goto __Skip_Joy0_Down
   3646  2442
   3647  2442		       a5 9f		      LDA	temp4
   3648  2444		       c9 22		      CMP	#34
   3649  2446		       b0 21		      BCS	.skipL0142
   3650  2448				   .condpart53
   3651  2448		       a5 9f		      LDA	temp4
   3652  244a		       a4 a1		      LDY	temp6
   3653  244c		       85 ee		      sta	temp7
   3654  244e		       a9 34		      lda	#>(ret_point6-1)
   3655  2450		       48		      pha
   3656  2451		       a9 63		      lda	#<(ret_point6-1)
   3657  2453		       48		      pha
   3658  2454		       a9 f2		      lda	#>(pfread-1)
   3659  2456		       48		      pha
   3660  2457		       a9 a9		      lda	#<(pfread-1)
   3661  2459		       48		      pha
   3662  245a		       a5 ee		      lda	temp7
   3663  245c		       48		      pha
   3664  245d		       8a		      txa
   3665  245e		       48		      pha
   3666  245f		       a2 08		      ldx	#8
   3667  2461		       4c eb ff 	      jmp	BS_jsr
   3668  2464				   ret_point6
   3669  2464		       d0 03		      BNE	.skip53then
   3670  2466				   .condpart54
   3671  2466		       4c 92 34 	      jmp	.__Skip_Joy0_Down
   3672  2469
   3673  2469				   .skip53then
   3674  2469				   .skipL0142
   3675  2469				   .
   3676  2469							; 
   3677  2469
   3678  2469				   .L0143		;  if temp3  <  34 then if pfread ( temp3 , temp6 )  then goto __Skip_Joy0_Down
   3679  2469
   3680  2469		       a5 9e		      LDA	temp3
   3681  246b		       c9 22		      CMP	#34
   3682  246d		       b0 21		      BCS	.skipL0143
   3683  246f				   .condpart55
   3684  246f		       a5 9e		      LDA	temp3
   3685  2471		       a4 a1		      LDY	temp6
   3686  2473		       85 ee		      sta	temp7
   3687  2475		       a9 34		      lda	#>(ret_point7-1)
   3688  2477		       48		      pha
   3689  2478		       a9 8a		      lda	#<(ret_point7-1)
   3690  247a		       48		      pha
   3691  247b		       a9 f2		      lda	#>(pfread-1)
   3692  247d		       48		      pha
   3693  247e		       a9 a9		      lda	#<(pfread-1)
   3694  2480		       48		      pha
   3695  2481		       a5 ee		      lda	temp7
   3696  2483		       48		      pha
   3697  2484		       8a		      txa
   3698  2485		       48		      pha
   3699  2486		       a2 08		      ldx	#8
   3700  2488		       4c eb ff 	      jmp	BS_jsr
   3701  248b				   ret_point7
   3702  248b		       d0 03		      BNE	.skip55then
   3703  248d				   .condpart56
   3704  248d		       4c 92 34 	      jmp	.__Skip_Joy0_Down
   3705  2490
   3706  2490				   .skip55then
   3707  2490				   .skipL0143
   3708  2490				   .
   3709  2490							; 
   3710  2490
   3711  2490				   .
   3712  2490							; 
   3713  2490
   3714  2490				   .
   3715  2490							; 
   3716  2490
   3717  2490				   .
   3718  2490							; 
   3719  2490
   3720  2490				   .L0144		;  player0y  =  player0y  +  1
   3721  2490
   3722  2490		       e6 85		      INC	player0y
   3723  2492				   .
   3724  2492							; 
   3725  2492
   3726  2492				   .__Skip_Joy0_Down
   3727  2492							; __Skip_Joy0_Down
   3728  2492
   3729  2492				   .
   3730  2492							; 
   3731  2492
   3732  2492				   .
   3733  2492							; 
   3734  2492
   3735  2492				   .
   3736  2492							; 
   3737  2492
   3738  2492				   .
   3739  2492							; 
   3740  2492
   3741  2492				   .
   3742  2492							; 
   3743  2492
   3744  2492				   .
   3745  2492							; 
   3746  2492
   3747  2492				   .
   3748  2492							; 
   3749  2492
   3750  2492				   .
   3751  2492							; 
   3752  2492
   3753  2492				   .
   3754  2492							; 
   3755  2492
   3756  2492				   .
   3757  2492							; 
   3758  2492
   3759  2492				   .L0145		;  if _Bit3_Auto_Play{3}  &&  _Bit2_P0_Dir_Left{2} then goto __AP_Move_Left
   3760  2492
   3761  2492		       a5 ec		      LDA	_Bit3_Auto_Play
   3762  2494		       29 08		      AND	#8
   3763  2496		       f0 09		      BEQ	.skipL0145
   3764  2498				   .condpart57
   3765  2498		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3766  249a		       29 04		      AND	#4
   3767  249c		       f0 03		      BEQ	.skip57then
   3768  249e				   .condpart58
   3769  249e		       4c af 34 	      jmp	.__AP_Move_Left
   3770  24a1
   3771  24a1				   .skip57then
   3772  24a1				   .skipL0145
   3773  24a1				   .
   3774  24a1							; 
   3775  24a1
   3776  24a1				   .
   3777  24a1							; 
   3778  24a1
   3779  24a1				   .
   3780  24a1							; 
   3781  24a1
   3782  24a1				   .
   3783  24a1							; 
   3784  24a1
   3785  24a1				   .L0146		;  if !joy0left then goto __Skip_Joy0_Left
   3786  24a1
   3787  24a1		       2c 80 02 	      bit	SWCHA
   3788  24a4		       50 03		      BVC	.skipL0146
   3789  24a6				   .condpart59
   3790  24a6		       4c 22 35 	      jmp	.__Skip_Joy0_Left
   3791  24a9
   3792  24a9				   .skipL0146
   3793  24a9				   .
   3794  24a9							; 
   3795  24a9
   3796  24a9				   .
   3797  24a9							; 
   3798  24a9
   3799  24a9				   .
   3800  24a9							; 
   3801  24a9
   3802  24a9				   .
   3803  24a9							; 
   3804  24a9
   3805  24a9				   .L0147		;  _Bit2_P0_Dir_Left{2}  =  1
   3806  24a9
   3807  24a9		       a5 da		      LDA	_Bit2_P0_Dir_Left
   3808  24ab		       09 04		      ORA	#4
   3809  24ad		       85 da		      STA	_Bit2_P0_Dir_Left
   3810  24af				   .
   3811  24af							; 
   3812  24af
   3813  24af				   .__AP_Move_Left
   3814  24af							; __AP_Move_Left
   3815  24af
   3816  24af				   .
   3817  24af							; 
   3818  24af
   3819  24af				   .
   3820  24af							; 
   3821  24af
   3822  24af				   .
   3823  24af							; 
   3824  24af
   3825  24af				   .
   3826  24af							; 
   3827  24af
   3828  24af				   .L0148		;  if player0x  <=  _P_Edge_Left then goto __Skip_Joy0_Left
   3829  24af
   3830  24af		       a9 01		      LDA	#_P_Edge_Left
   3831  24b1		       c5 80		      CMP	player0x
   3832  24b3		       90 03		      BCC	.skipL0148
   3833  24b5				   .condpart60
   3834  24b5		       4c 22 35 	      jmp	.__Skip_Joy0_Left
   3835  24b8
   3836  24b8				   .skipL0148
   3837  24b8				   .
   3838  24b8							; 
   3839  24b8
   3840  24b8				   .
   3841  24b8							; 
   3842  24b8
   3843  24b8				   .
   3844  24b8							; 
   3845  24b8
   3846  24b8				   .
   3847  24b8							; 
   3848  24b8
   3849  24b8				   .L0149		;  temp5  =   ( player0y )  / 8
   3850  24b8
   3851  24b8							; complex statement detected
   3852  24b8		       a5 85		      LDA	player0y
   3853  24ba		       4a		      lsr
   3854  24bb		       4a		      lsr
   3855  24bc		       4a		      lsr
   3856  24bd		       85 a0		      STA	temp5
   3857  24bf				   .
   3858  24bf							; 
   3859  24bf
   3860  24bf				   .L0150		;  temp3  =   ( player0y - 8 )  / 8
   3861  24bf
   3862  24bf							; complex statement detected
   3863  24bf		       a5 85		      LDA	player0y
   3864  24c1		       38		      SEC
   3865  24c2		       e9 08		      SBC	#8
   3866  24c4		       4a		      lsr
   3867  24c5		       4a		      lsr
   3868  24c6		       4a		      lsr
   3869  24c7		       85 9e		      STA	temp3
   3870  24c9				   .
   3871  24c9							; 
   3872  24c9
   3873  24c9				   .L0151		;  temp6  =   ( player0x - 18 )  / 4
   3874  24c9
   3875  24c9							; complex statement detected
   3876  24c9		       a5 80		      LDA	player0x
   3877  24cb		       38		      SEC
   3878  24cc		       e9 12		      SBC	#18
   3879  24ce		       4a		      lsr
   3880  24cf		       4a		      lsr
   3881  24d0		       85 a1		      STA	temp6
   3882  24d2				   .
   3883  24d2							; 
   3884  24d2
   3885  24d2				   .L0152		;  if temp6  <  34 then if pfread ( temp6 , temp5 )  then goto __Skip_Joy0_Left
   3886  24d2
   3887  24d2		       a5 a1		      LDA	temp6
   3888  24d4		       c9 22		      CMP	#34
   3889  24d6		       b0 21		      BCS	.skipL0152
   3890  24d8				   .condpart61
   3891  24d8		       a5 a1		      LDA	temp6
   3892  24da		       a4 a0		      LDY	temp5
   3893  24dc		       85 ee		      sta	temp7
   3894  24de		       a9 34		      lda	#>(ret_point8-1)
   3895  24e0		       48		      pha
   3896  24e1		       a9 f3		      lda	#<(ret_point8-1)
   3897  24e3		       48		      pha
   3898  24e4		       a9 f2		      lda	#>(pfread-1)
   3899  24e6		       48		      pha
   3900  24e7		       a9 a9		      lda	#<(pfread-1)
   3901  24e9		       48		      pha
   3902  24ea		       a5 ee		      lda	temp7
   3903  24ec		       48		      pha
   3904  24ed		       8a		      txa
   3905  24ee		       48		      pha
   3906  24ef		       a2 08		      ldx	#8
   3907  24f1		       4c eb ff 	      jmp	BS_jsr
   3908  24f4				   ret_point8
   3909  24f4		       d0 03		      BNE	.skip61then
   3910  24f6				   .condpart62
   3911  24f6		       4c 22 35 	      jmp	.__Skip_Joy0_Left
   3912  24f9
   3913  24f9				   .skip61then
   3914  24f9				   .skipL0152
   3915  24f9				   .
   3916  24f9							; 
   3917  24f9
   3918  24f9				   .L0153		;  if temp6  <  34 then if pfread ( temp6 , temp3 )  then goto __Skip_Joy0_Left
   3919  24f9
   3920  24f9		       a5 a1		      LDA	temp6
   3921  24fb		       c9 22		      CMP	#34
   3922  24fd		       b0 21		      BCS	.skipL0153
   3923  24ff				   .condpart63
   3924  24ff		       a5 a1		      LDA	temp6
   3925  2501		       a4 9e		      LDY	temp3
   3926  2503		       85 ee		      sta	temp7
   3927  2505		       a9 35		      lda	#>(ret_point9-1)
   3928  2507		       48		      pha
   3929  2508		       a9 1a		      lda	#<(ret_point9-1)
   3930  250a		       48		      pha
   3931  250b		       a9 f2		      lda	#>(pfread-1)
   3932  250d		       48		      pha
   3933  250e		       a9 a9		      lda	#<(pfread-1)
   3934  2510		       48		      pha
   3935  2511		       a5 ee		      lda	temp7
   3936  2513		       48		      pha
   3937  2514		       8a		      txa
   3938  2515		       48		      pha
   3939  2516		       a2 08		      ldx	#8
   3940  2518		       4c eb ff 	      jmp	BS_jsr
   3941  251b				   ret_point9
   3942  251b		       d0 03		      BNE	.skip63then
   3943  251d				   .condpart64
   3944  251d		       4c 22 35 	      jmp	.__Skip_Joy0_Left
   3945  2520
   3946  2520				   .skip63then
   3947  2520				   .skipL0153
   3948  2520				   .
   3949  2520							; 
   3950  2520
   3951  2520				   .
   3952  2520							; 
   3953  2520
   3954  2520				   .
   3955  2520							; 
   3956  2520
   3957  2520				   .
   3958  2520							; 
   3959  2520
   3960  2520				   .L0154		;  player0x  =  player0x  -  1
   3961  2520
   3962  2520		       c6 80		      DEC	player0x
   3963  2522				   .
   3964  2522							; 
   3965  2522
   3966  2522				   .__Skip_Joy0_Left
   3967  2522							; __Skip_Joy0_Left
   3968  2522
   3969  2522				   .
   3970  2522							; 
   3971  2522
   3972  2522				   .
   3973  2522							; 
   3974  2522
   3975  2522				   .
   3976  2522							; 
   3977  2522
   3978  2522				   .
   3979  2522							; 
   3980  2522
   3981  2522				   .
   3982  2522							; 
   3983  2522
   3984  2522				   .
   3985  2522							; 
   3986  2522
   3987  2522				   .
   3988  2522							; 
   3989  2522
   3990  2522				   .
   3991  2522							; 
   3992  2522
   3993  2522				   .
   3994  2522							; 
   3995  2522
   3996  2522				   .
   3997  2522							; 
   3998  2522
   3999  2522				   .L0155		;  if _Bit3_Auto_Play{3}  &&  _Bit3_P0_Dir_Right{3} then goto __AP_Move_Right
   4000  2522
   4001  2522		       a5 ec		      LDA	_Bit3_Auto_Play
   4002  2524		       29 08		      AND	#8
   4003  2526		       f0 09		      BEQ	.skipL0155
   4004  2528				   .condpart65
   4005  2528		       a5 da		      LDA	_Bit3_P0_Dir_Right
   4006  252a		       29 08		      AND	#8
   4007  252c		       f0 03		      BEQ	.skip65then
   4008  252e				   .condpart66
   4009  252e		       4c 3f 35 	      jmp	.__AP_Move_Right
   4010  2531
   4011  2531				   .skip65then
   4012  2531				   .skipL0155
   4013  2531				   .
   4014  2531							; 
   4015  2531
   4016  2531				   .
   4017  2531							; 
   4018  2531
   4019  2531				   .
   4020  2531							; 
   4021  2531
   4022  2531				   .
   4023  2531							; 
   4024  2531
   4025  2531				   .L0156		;  if !joy0right then goto __Skip_Joy0_Right
   4026  2531
   4027  2531		       2c 80 02 	      bit	SWCHA
   4028  2534		       10 03		      BPL	.skipL0156
   4029  2536				   .condpart67
   4030  2536		       4c b2 35 	      jmp	.__Skip_Joy0_Right
   4031  2539
   4032  2539				   .skipL0156
   4033  2539				   .
   4034  2539							; 
   4035  2539
   4036  2539				   .
   4037  2539							; 
   4038  2539
   4039  2539				   .
   4040  2539							; 
   4041  2539
   4042  2539				   .
   4043  2539							; 
   4044  2539
   4045  2539				   .L0157		;  _Bit3_P0_Dir_Right{3}  =  1
   4046  2539
   4047  2539		       a5 da		      LDA	_Bit3_P0_Dir_Right
   4048  253b		       09 08		      ORA	#8
   4049  253d		       85 da		      STA	_Bit3_P0_Dir_Right
   4050  253f				   .
   4051  253f							; 
   4052  253f
   4053  253f				   .__AP_Move_Right
   4054  253f							; __AP_Move_Right
   4055  253f
   4056  253f				   .
   4057  253f							; 
   4058  253f
   4059  253f				   .
   4060  253f							; 
   4061  253f
   4062  253f				   .
   4063  253f							; 
   4064  253f
   4065  253f				   .
   4066  253f							; 
   4067  253f
   4068  253f				   .L0158		;  if player0x  >=  _P_Edge_Right then goto __Skip_Joy0_Right
   4069  253f
   4070  253f		       a5 80		      LDA	player0x
   4071  2541		       c9 98		      CMP	#_P_Edge_Right
   4072  2543		       90 03		      BCC	.skipL0158
   4073  2545				   .condpart68
   4074  2545		       4c b2 35 	      jmp	.__Skip_Joy0_Right
   4075  2548
   4076  2548				   .skipL0158
   4077  2548				   .
   4078  2548							; 
   4079  2548
   4080  2548				   .
   4081  2548							; 
   4082  2548
   4083  2548				   .
   4084  2548							; 
   4085  2548
   4086  2548				   .
   4087  2548							; 
   4088  2548
   4089  2548				   .L0159		;  temp5  =   ( player0y )  / 8
   4090  2548
   4091  2548							; complex statement detected
   4092  2548		       a5 85		      LDA	player0y
   4093  254a		       4a		      lsr
   4094  254b		       4a		      lsr
   4095  254c		       4a		      lsr
   4096  254d		       85 a0		      STA	temp5
   4097  254f				   .
   4098  254f							; 
   4099  254f
   4100  254f				   .L0160		;  temp3  =   ( player0y - 8 )  / 8
   4101  254f
   4102  254f							; complex statement detected
   4103  254f		       a5 85		      LDA	player0y
   4104  2551		       38		      SEC
   4105  2552		       e9 08		      SBC	#8
   4106  2554		       4a		      lsr
   4107  2555		       4a		      lsr
   4108  2556		       4a		      lsr
   4109  2557		       85 9e		      STA	temp3
   4110  2559				   .
   4111  2559							; 
   4112  2559
   4113  2559				   .L0161		;  temp6  =   ( player0x - 9 )  / 4
   4114  2559
   4115  2559							; complex statement detected
   4116  2559		       a5 80		      LDA	player0x
   4117  255b		       38		      SEC
   4118  255c		       e9 09		      SBC	#9
   4119  255e		       4a		      lsr
   4120  255f		       4a		      lsr
   4121  2560		       85 a1		      STA	temp6
   4122  2562				   .
   4123  2562							; 
   4124  2562
   4125  2562				   .L0162		;  if temp6  <  34 then if pfread ( temp6 , temp5 )  then goto __Skip_Joy0_Right
   4126  2562
   4127  2562		       a5 a1		      LDA	temp6
   4128  2564		       c9 22		      CMP	#34
   4129  2566		       b0 21		      BCS	.skipL0162
   4130  2568				   .condpart69
   4131  2568		       a5 a1		      LDA	temp6
   4132  256a		       a4 a0		      LDY	temp5
   4133  256c		       85 ee		      sta	temp7
   4134  256e		       a9 35		      lda	#>(ret_point10-1)
   4135  2570		       48		      pha
   4136  2571		       a9 83		      lda	#<(ret_point10-1)
   4137  2573		       48		      pha
   4138  2574		       a9 f2		      lda	#>(pfread-1)
   4139  2576		       48		      pha
   4140  2577		       a9 a9		      lda	#<(pfread-1)
   4141  2579		       48		      pha
   4142  257a		       a5 ee		      lda	temp7
   4143  257c		       48		      pha
   4144  257d		       8a		      txa
   4145  257e		       48		      pha
   4146  257f		       a2 08		      ldx	#8
   4147  2581		       4c eb ff 	      jmp	BS_jsr
   4148  2584				   ret_point10
   4149  2584		       d0 03		      BNE	.skip69then
   4150  2586				   .condpart70
   4151  2586		       4c b2 35 	      jmp	.__Skip_Joy0_Right
   4152  2589
   4153  2589				   .skip69then
   4154  2589				   .skipL0162
   4155  2589				   .
   4156  2589							; 
   4157  2589
   4158  2589				   .L0163		;  if temp6  <  34 then if pfread ( temp6 , temp3 )  then goto __Skip_Joy0_Right
   4159  2589
   4160  2589		       a5 a1		      LDA	temp6
   4161  258b		       c9 22		      CMP	#34
   4162  258d		       b0 21		      BCS	.skipL0163
   4163  258f				   .condpart71
   4164  258f		       a5 a1		      LDA	temp6
   4165  2591		       a4 9e		      LDY	temp3
   4166  2593		       85 ee		      sta	temp7
   4167  2595		       a9 35		      lda	#>(ret_point11-1)
   4168  2597		       48		      pha
   4169  2598		       a9 aa		      lda	#<(ret_point11-1)
   4170  259a		       48		      pha
   4171  259b		       a9 f2		      lda	#>(pfread-1)
   4172  259d		       48		      pha
   4173  259e		       a9 a9		      lda	#<(pfread-1)
   4174  25a0		       48		      pha
   4175  25a1		       a5 ee		      lda	temp7
   4176  25a3		       48		      pha
   4177  25a4		       8a		      txa
   4178  25a5		       48		      pha
   4179  25a6		       a2 08		      ldx	#8
   4180  25a8		       4c eb ff 	      jmp	BS_jsr
   4181  25ab				   ret_point11
   4182  25ab		       d0 03		      BNE	.skip71then
   4183  25ad				   .condpart72
   4184  25ad		       4c b2 35 	      jmp	.__Skip_Joy0_Right
   4185  25b0
   4186  25b0				   .skip71then
   4187  25b0				   .skipL0163
   4188  25b0				   .
   4189  25b0							; 
   4190  25b0
   4191  25b0				   .
   4192  25b0							; 
   4193  25b0
   4194  25b0				   .
   4195  25b0							; 
   4196  25b0
   4197  25b0				   .
   4198  25b0							; 
   4199  25b0
   4200  25b0				   .L0164		;  player0x  =  player0x  +  1
   4201  25b0
   4202  25b0		       e6 80		      INC	player0x
   4203  25b2				   .
   4204  25b2							; 
   4205  25b2
   4206  25b2				   .__Skip_Joy0_Right
   4207  25b2							; __Skip_Joy0_Right
   4208  25b2
   4209  25b2				   .
   4210  25b2							; 
   4211  25b2
   4212  25b2				   .
   4213  25b2							; 
   4214  25b2
   4215  25b2				   .
   4216  25b2							; 
   4217  25b2
   4218  25b2				   .
   4219  25b2							; 
   4220  25b2
   4221  25b2				   .
   4222  25b2							; 
   4223  25b2
   4224  25b2				   .
   4225  25b2							; 
   4226  25b2
   4227  25b2				   .
   4228  25b2							; 
   4229  25b2
   4230  25b2				   .
   4231  25b2							; 
   4232  25b2
   4233  25b2				   .
   4234  25b2							; 
   4235  25b2
   4236  25b2				   .
   4237  25b2							; 
   4238  25b2
   4239  25b2				   .L0165		;  if !_Bit3_Auto_Play{3} then goto __AP_Inactivity
   4240  25b2
   4241  25b2		       a5 ec		      LDA	_Bit3_Auto_Play
   4242  25b4		       29 08		      AND	#8
   4243  25b6		       d0 03		      BNE	.skipL0165
   4244  25b8				   .condpart73
   4245  25b8		       4c d3 35 	      jmp	.__AP_Inactivity
   4246  25bb
   4247  25bb				   .skipL0165
   4248  25bb				   .
   4249  25bb							; 
   4250  25bb
   4251  25bb				   .
   4252  25bb							; 
   4253  25bb
   4254  25bb				   .
   4255  25bb							; 
   4256  25bb
   4257  25bb				   .
   4258  25bb							; 
   4259  25bb
   4260  25bb				   .L0166		;  if _AP_Mem_P0x  =  player0x  &&  _AP_Mem_P0y  =  player0y then _AP_Dir_Counter  =  254
   4261  25bb
   4262  25bb		       a5 dc		      LDA	_AP_Mem_P0x
   4263  25bd		       c5 80		      CMP	player0x
   4264  25bf		       d0 0a		      BNE	.skipL0166
   4265  25c1				   .condpart74
   4266  25c1		       a5 dd		      LDA	_AP_Mem_P0y
   4267  25c3		       c5 85		      CMP	player0y
   4268  25c5		       d0 04		      BNE	.skip74then
   4269  25c7				   .condpart75
   4270  25c7		       a9 fe		      LDA	#254
   4271  25c9		       85 df		      STA	_AP_Dir_Counter
   4272  25cb				   .skip74then
   4273  25cb				   .skipL0166
   4274  25cb				   .
   4275  25cb							; 
   4276  25cb
   4277  25cb				   .
   4278  25cb							; 
   4279  25cb
   4280  25cb				   .
   4281  25cb							; 
   4282  25cb
   4283  25cb				   .
   4284  25cb							; 
   4285  25cb
   4286  25cb				   .L0167		;  _AP_Mem_P0x  =  player0x  :  _AP_Mem_P0y  =  player0y
   4287  25cb
   4288  25cb		       a5 80		      LDA	player0x
   4289  25cd		       85 dc		      STA	_AP_Mem_P0x
   4290  25cf		       a5 85		      LDA	player0y
   4291  25d1		       85 dd		      STA	_AP_Mem_P0y
   4292  25d3				   .
   4293  25d3							; 
   4294  25d3
   4295  25d3				   .__AP_Inactivity
   4296  25d3							; __AP_Inactivity
   4297  25d3
   4298  25d3				   .
   4299  25d3							; 
   4300  25d3
   4301  25d3				   .
   4302  25d3							; 
   4303  25d3
   4304  25d3				   .
   4305  25d3							; 
   4306  25d3
   4307  25d3				   .
   4308  25d3							; 
   4309  25d3
   4310  25d3				   .
   4311  25d3							; 
   4312  25d3
   4313  25d3				   .
   4314  25d3							; 
   4315  25d3
   4316  25d3				   .
   4317  25d3							; 
   4318  25d3
   4319  25d3				   .
   4320  25d3							; 
   4321  25d3
   4322  25d3				   .
   4323  25d3							; 
   4324  25d3
   4325  25d3				   .
   4326  25d3							; 
   4327  25d3
   4328  25d3				   .
   4329  25d3							; 
   4330  25d3
   4331  25d3				   .
   4332  25d3							; 
   4333  25d3
   4334  25d3				   .
   4335  25d3							; 
   4336  25d3
   4337  25d3				   .L0168		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Fire_Missile
   4338  25d3
   4339  25d3		       a5 ec		      LDA	_Bit3_Auto_Play
   4340  25d5		       29 08		      AND	#8
   4341  25d7		       d0 03		      BNE	.skipL0168
   4342  25d9				   .condpart76
   4343  25d9		       4c f7 35 	      jmp	.__AP_Skip_Fire_Missile
   4344  25dc
   4345  25dc				   .skipL0168
   4346  25dc				   .
   4347  25dc							; 
   4348  25dc
   4349  25dc				   .
   4350  25dc							; 
   4351  25dc
   4352  25dc				   .
   4353  25dc							; 
   4354  25dc
   4355  25dc				   .
   4356  25dc							; 
   4357  25dc
   4358  25dc				   .
   4359  25dc							; 
   4360  25dc
   4361  25dc				   .L0169		;  temp5  =  rand  :  if temp5  <  230 then goto __Skip_Fire
   4362  25dc
   4363  25dc		       a5 a2		      lda	rand
   4364  25de		       4a		      lsr
   4365  25df					      ifconst	rand16
   4366  25df		       26 ed		      rol	rand16
   4367  25e1					      endif
   4368  25e1		       90 02		      bcc	*+4
   4369  25e3		       49 b4		      eor	#$B4
   4370  25e5		       85 a2		      sta	rand
   4371  25e7					      ifconst	rand16
   4372  25e7		       45 ed		      eor	rand16
   4373  25e9					      endif
   4374  25e9		       85 a0		      STA	temp5
   4375  25eb		       a5 a0		      LDA	temp5
   4376  25ed		       c9 e6		      CMP	#230
   4377  25ef		       b0 03		      BCS	.skipL0169
   4378  25f1				   .condpart77
   4379  25f1		       4c a6 36 	      jmp	.__Skip_Fire
   4380  25f4
   4381  25f4				   .skipL0169
   4382  25f4				   .
   4383  25f4							; 
   4384  25f4
   4385  25f4				   .L0170		;  goto __AP_Fire
   4386  25f4
   4387  25f4		       4c 0d 36 	      jmp	.__AP_Fire
   4388  25f7
   4389  25f7				   .
   4390  25f7							; 
   4391  25f7
   4392  25f7				   .__AP_Skip_Fire_Missile
   4393  25f7							; __AP_Skip_Fire_Missile
   4394  25f7
   4395  25f7				   .
   4396  25f7							; 
   4397  25f7
   4398  25f7				   .
   4399  25f7							; 
   4400  25f7
   4401  25f7				   .
   4402  25f7							; 
   4403  25f7
   4404  25f7				   .
   4405  25f7							; 
   4406  25f7
   4407  25f7				   .
   4408  25f7							; 
   4409  25f7
   4410  25f7				   .L0171		;  if !joy0fire then _Bit1_FireB_Restrainer{1}  =  0  :  goto __Skip_Fire
   4411  25f7
   4412  25f7		       24 0c		      bit	INPT4
   4413  25f9		       10 09		      BPL	.skipL0171
   4414  25fb				   .condpart78
   4415  25fb		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   4416  25fd		       29 fd		      AND	#253
   4417  25ff		       85 ec		      STA	_Bit1_FireB_Restrainer
   4418  2601		       4c a6 36 	      jmp	.__Skip_Fire
   4419  2604
   4420  2604				   .skipL0171
   4421  2604				   .
   4422  2604							; 
   4423  2604
   4424  2604				   .
   4425  2604							; 
   4426  2604
   4427  2604				   .
   4428  2604							; 
   4429  2604
   4430  2604				   .
   4431  2604							; 
   4432  2604
   4433  2604				   .
   4434  2604							; 
   4435  2604
   4436  2604				   .L0172		;  if _Bit1_FireB_Restrainer{1} then goto __Skip_Fire
   4437  2604
   4438  2604		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   4439  2606		       29 02		      AND	#2
   4440  2608		       f0 03		      BEQ	.skipL0172
   4441  260a				   .condpart79
   4442  260a		       4c a6 36 	      jmp	.__Skip_Fire
   4443  260d
   4444  260d				   .skipL0172
   4445  260d				   .
   4446  260d							; 
   4447  260d
   4448  260d				   .__AP_Fire
   4449  260d							; __AP_Fire
   4450  260d
   4451  260d				   .
   4452  260d							; 
   4453  260d
   4454  260d				   .
   4455  260d							; 
   4456  260d
   4457  260d				   .
   4458  260d							; 
   4459  260d
   4460  260d				   .
   4461  260d							; 
   4462  260d
   4463  260d				   .L0173		;  if _Bit7_M1_Moving{7} then goto __Skip_Fire
   4464  260d
   4465  260d		       24 ec		      BIT	_Bit7_M1_Moving
   4466  260f		       10 03		      BPL	.skipL0173
   4467  2611				   .condpart80
   4468  2611		       4c a6 36 	      jmp	.__Skip_Fire
   4469  2614
   4470  2614				   .skipL0173
   4471  2614				   .
   4472  2614							; 
   4473  2614
   4474  2614				   .
   4475  2614							; 
   4476  2614
   4477  2614				   .
   4478  2614							; 
   4479  2614
   4480  2614				   .
   4481  2614							; 
   4482  2614
   4483  2614				   .L0174		;  _Bit7_M1_Moving{7}	=  1
   4484  2614
   4485  2614		       a5 ec		      LDA	_Bit7_M1_Moving
   4486  2616		       09 80		      ORA	#128
   4487  2618		       85 ec		      STA	_Bit7_M1_Moving
   4488  261a				   .
   4489  261a							; 
   4490  261a
   4491  261a				   .
   4492  261a							; 
   4493  261a
   4494  261a				   .
   4495  261a							; 
   4496  261a
   4497  261a				   .
   4498  261a							; 
   4499  261a
   4500  261a				   .
   4501  261a							; 
   4502  261a
   4503  261a				   .L0175		;  _Bit4_M1_Dir_Up{4}	=  _Bit0_P0_Dir_Up{0}
   4504  261a
   4505  261a		       a5 da		      LDA	_Bit0_P0_Dir_Up
   4506  261c		       29 01		      AND	#1
   4507  261e		       08		      PHP
   4508  261f		       a5 da		      LDA	_Bit4_M1_Dir_Up
   4509  2621		       29 ef		      AND	#239
   4510  2623		       28		      PLP
   4511  2624		       f0 02		      .byte.b	$F0, $02
   4512  2626		       09 10		      ORA	#16
   4513  2628		       85 da		      STA	_Bit4_M1_Dir_Up
   4514  262a				   .L0176		;  _Bit5_M1_Dir_Down{5}  =  _Bit1_P0_Dir_Down{1}
   4515  262a
   4516  262a		       a5 da		      LDA	_Bit1_P0_Dir_Down
   4517  262c		       29 02		      AND	#2
   4518  262e		       08		      PHP
   4519  262f		       a5 da		      LDA	_Bit5_M1_Dir_Down
   4520  2631		       29 df		      AND	#223
   4521  2633		       28		      PLP
   4522  2634		       f0 02		      .byte.b	$F0, $02
   4523  2636		       09 20		      ORA	#32
   4524  2638		       85 da		      STA	_Bit5_M1_Dir_Down
   4525  263a				   .L0177		;  _Bit6_M1_Dir_Left{6}  =  _Bit2_P0_Dir_Left{2}
   4526  263a
   4527  263a		       a5 da		      LDA	_Bit2_P0_Dir_Left
   4528  263c		       29 04		      AND	#4
   4529  263e		       08		      PHP
   4530  263f		       a5 da		      LDA	_Bit6_M1_Dir_Left
   4531  2641		       29 bf		      AND	#191
   4532  2643		       28		      PLP
   4533  2644		       f0 02		      .byte.b	$F0, $02
   4534  2646		       09 40		      ORA	#64
   4535  2648		       85 da		      STA	_Bit6_M1_Dir_Left
   4536  264a				   .L0178		;  _Bit7_M1_Dir_Right{7}  =  _Bit3_P0_Dir_Right{3}
   4537  264a
   4538  264a		       a5 da		      LDA	_Bit3_P0_Dir_Right
   4539  264c		       29 08		      AND	#8
   4540  264e		       08		      PHP
   4541  264f		       a5 da		      LDA	_Bit7_M1_Dir_Right
   4542  2651		       29 7f		      AND	#127
   4543  2653		       28		      PLP
   4544  2654		       f0 02		      .byte.b	$F0, $02
   4545  2656		       09 80		      ORA	#128
   4546  2658		       85 da		      STA	_Bit7_M1_Dir_Right
   4547  265a				   .
   4548  265a							; 
   4549  265a
   4550  265a				   .
   4551  265a							; 
   4552  265a
   4553  265a				   .
   4554  265a							; 
   4555  265a
   4556  265a				   .
   4557  265a							; 
   4558  265a
   4559  265a				   .L0179		;  if _Bit4_M1_Dir_Up{4} then missile1x  =  player0x  +  4  :	missile1y  =  player0y	-  5
   4560  265a
   4561  265a		       a5 da		      LDA	_Bit4_M1_Dir_Up
   4562  265c		       29 10		      AND	#16
   4563  265e		       f0 0e		      BEQ	.skipL0179
   4564  2660				   .condpart81
   4565  2660		       a5 80		      LDA	player0x
   4566  2662		       18		      CLC
   4567  2663		       69 04		      ADC	#4
   4568  2665		       85 83		      STA	missile1x
   4569  2667		       a5 85		      LDA	player0y
   4570  2669		       38		      SEC
   4571  266a		       e9 05		      SBC	#5
   4572  266c		       85 88		      STA	missile1y
   4573  266e				   .skipL0179
   4574  266e				   .L0180		;  if _Bit5_M1_Dir_Down{5} then missile1x  =  player0x  +  4  :  missile1y  =	player0y  -  1
   4575  266e
   4576  266e		       a5 da		      LDA	_Bit5_M1_Dir_Down
   4577  2670		       29 20		      AND	#32
   4578  2672		       f0 0e		      BEQ	.skipL0180
   4579  2674				   .condpart82
   4580  2674		       a5 80		      LDA	player0x
   4581  2676		       18		      CLC
   4582  2677		       69 04		      ADC	#4
   4583  2679		       85 83		      STA	missile1x
   4584  267b		       a5 85		      LDA	player0y
   4585  267d		       38		      SEC
   4586  267e		       e9 01		      SBC	#1
   4587  2680		       85 88		      STA	missile1y
   4588  2682				   .skipL0180
   4589  2682				   .L0181		;  if _Bit6_M1_Dir_Left{6} then missile1x  =  player0x  +  2  :  missile1y  =	player0y  -  3
   4590  2682
   4591  2682		       24 da		      BIT	_Bit6_M1_Dir_Left
   4592  2684		       50 0e		      BVC	.skipL0181
   4593  2686				   .condpart83
   4594  2686		       a5 80		      LDA	player0x
   4595  2688		       18		      CLC
   4596  2689		       69 02		      ADC	#2
   4597  268b		       85 83		      STA	missile1x
   4598  268d		       a5 85		      LDA	player0y
   4599  268f		       38		      SEC
   4600  2690		       e9 03		      SBC	#3
   4601  2692		       85 88		      STA	missile1y
   4602  2694				   .skipL0181
   4603  2694				   .L0182		;  if _Bit7_M1_Dir_Right{7} then missile1x  =	player0x  +  6	:  missile1y  =  player0y  -  3
   4604  2694
   4605  2694		       24 da		      BIT	_Bit7_M1_Dir_Right
   4606  2696		       10 0e		      BPL	.skipL0182
   4607  2698				   .condpart84
   4608  2698		       a5 80		      LDA	player0x
   4609  269a		       18		      CLC
   4610  269b		       69 06		      ADC	#6
   4611  269d		       85 83		      STA	missile1x
   4612  269f		       a5 85		      LDA	player0y
   4613  26a1		       38		      SEC
   4614  26a2		       e9 03		      SBC	#3
   4615  26a4		       85 88		      STA	missile1y
   4616  26a6				   .skipL0182
   4617  26a6				   .
   4618  26a6							; 
   4619  26a6
   4620  26a6				   .__Skip_Fire
   4621  26a6							; __Skip_Fire
   4622  26a6
   4623  26a6				   .
   4624  26a6							; 
   4625  26a6
   4626  26a6				   .
   4627  26a6							; 
   4628  26a6
   4629  26a6				   .
   4630  26a6							; 
   4631  26a6
   4632  26a6				   .
   4633  26a6							; 
   4634  26a6
   4635  26a6				   .
   4636  26a6							; 
   4637  26a6
   4638  26a6				   .
   4639  26a6							; 
   4640  26a6
   4641  26a6				   .
   4642  26a6							; 
   4643  26a6
   4644  26a6				   .
   4645  26a6							; 
   4646  26a6
   4647  26a6				   .
   4648  26a6							; 
   4649  26a6
   4650  26a6				   .
   4651  26a6							; 
   4652  26a6
   4653  26a6				   .L0183		;  if !_Bit7_M1_Moving{7} then goto __Skip_Missile
   4654  26a6
   4655  26a6		       24 ec		      BIT	_Bit7_M1_Moving
   4656  26a8		       30 03		      BMI	.skipL0183
   4657  26aa				   .condpart85
   4658  26aa		       4c 32 37 	      jmp	.__Skip_Missile
   4659  26ad
   4660  26ad				   .skipL0183
   4661  26ad				   .
   4662  26ad							; 
   4663  26ad
   4664  26ad				   .
   4665  26ad							; 
   4666  26ad
   4667  26ad				   .
   4668  26ad							; 
   4669  26ad
   4670  26ad				   .
   4671  26ad							; 
   4672  26ad
   4673  26ad				   .L0184		;  if _Bit4_M1_Dir_Up{4} then missile1y  =  missile1y	-  2
   4674  26ad
   4675  26ad		       a5 da		      LDA	_Bit4_M1_Dir_Up
   4676  26af		       29 10		      AND	#16
   4677  26b1		       f0 07		      BEQ	.skipL0184
   4678  26b3				   .condpart86
   4679  26b3		       a5 88		      LDA	missile1y
   4680  26b5		       38		      SEC
   4681  26b6		       e9 02		      SBC	#2
   4682  26b8		       85 88		      STA	missile1y
   4683  26ba				   .skipL0184
   4684  26ba				   .L0185		;  if _Bit5_M1_Dir_Down{5} then missile1y  =  missile1y  +  2
   4685  26ba
   4686  26ba		       a5 da		      LDA	_Bit5_M1_Dir_Down
   4687  26bc		       29 20		      AND	#32
   4688  26be		       f0 07		      BEQ	.skipL0185
   4689  26c0				   .condpart87
   4690  26c0		       a5 88		      LDA	missile1y
   4691  26c2		       18		      CLC
   4692  26c3		       69 02		      ADC	#2
   4693  26c5		       85 88		      STA	missile1y
   4694  26c7				   .skipL0185
   4695  26c7				   .L0186		;  if _Bit6_M1_Dir_Left{6} then missile1x  =  missile1x  -  2
   4696  26c7
   4697  26c7		       24 da		      BIT	_Bit6_M1_Dir_Left
   4698  26c9		       50 07		      BVC	.skipL0186
   4699  26cb				   .condpart88
   4700  26cb		       a5 83		      LDA	missile1x
   4701  26cd		       38		      SEC
   4702  26ce		       e9 02		      SBC	#2
   4703  26d0		       85 83		      STA	missile1x
   4704  26d2				   .skipL0186
   4705  26d2				   .L0187		;  if _Bit7_M1_Dir_Right{7} then missile1x  =	missile1x  +  2
   4706  26d2
   4707  26d2		       24 da		      BIT	_Bit7_M1_Dir_Right
   4708  26d4		       10 07		      BPL	.skipL0187
   4709  26d6				   .condpart89
   4710  26d6		       a5 83		      LDA	missile1x
   4711  26d8		       18		      CLC
   4712  26d9		       69 02		      ADC	#2
   4713  26db		       85 83		      STA	missile1x
   4714  26dd				   .skipL0187
   4715  26dd				   .
   4716  26dd							; 
   4717  26dd
   4718  26dd				   .
   4719  26dd							; 
   4720  26dd
   4721  26dd				   .
   4722  26dd							; 
   4723  26dd
   4724  26dd				   .
   4725  26dd							; 
   4726  26dd
   4727  26dd				   .L0188		;  if missile1y  <  _M_Edge_Top then goto __Delete_Missile
   4728  26dd
   4729  26dd		       a5 88		      LDA	missile1y
   4730  26df		       c9 02		      CMP	#_M_Edge_Top
   4731  26e1		       b0 03		      BCS	.skipL0188
   4732  26e3				   .condpart90
   4733  26e3		       4c 26 37 	      jmp	.__Delete_Missile
   4734  26e6
   4735  26e6				   .skipL0188
   4736  26e6				   .L0189		;  if missile1y  >  _M_Edge_Bottom then goto __Delete_Missile
   4737  26e6
   4738  26e6		       a9 58		      LDA	#_M_Edge_Bottom
   4739  26e8		       c5 88		      CMP	missile1y
   4740  26ea		       b0 03		      BCS	.skipL0189
   4741  26ec				   .condpart91
   4742  26ec		       4c 26 37 	      jmp	.__Delete_Missile
   4743  26ef
   4744  26ef				   .skipL0189
   4745  26ef				   .L0190		;  if missile1x  <  _M_Edge_Left then goto __Delete_Missile
   4746  26ef
   4747  26ef		       a5 83		      LDA	missile1x
   4748  26f1		       c9 02		      CMP	#_M_Edge_Left
   4749  26f3		       b0 03		      BCS	.skipL0190
   4750  26f5				   .condpart92
   4751  26f5		       4c 26 37 	      jmp	.__Delete_Missile
   4752  26f8
   4753  26f8				   .skipL0190
   4754  26f8				   .L0191		;  if missile1x  >  _M_Edge_Right then goto __Delete_Missile
   4755  26f8
   4756  26f8		       a9 9f		      LDA	#_M_Edge_Right
   4757  26fa		       c5 83		      CMP	missile1x
   4758  26fc		       b0 03		      BCS	.skipL0191
   4759  26fe				   .condpart93
   4760  26fe		       4c 26 37 	      jmp	.__Delete_Missile
   4761  2701
   4762  2701				   .skipL0191
   4763  2701				   .
   4764  2701							; 
   4765  2701
   4766  2701				   .
   4767  2701							; 
   4768  2701
   4769  2701				   .
   4770  2701							; 
   4771  2701
   4772  2701				   .
   4773  2701							; 
   4774  2701
   4775  2701				   .L0192		;  if !collision(playfield,missile1) then goto __Skip_Missile
   4776  2701
   4777  2701		       24 05		      bit	CXM1FB
   4778  2703		       30 03		      BMI	.skipL0192
   4779  2705				   .condpart94
   4780  2705		       4c 32 37 	      jmp	.__Skip_Missile
   4781  2708
   4782  2708				   .skipL0192
   4783  2708				   .
   4784  2708							; 
   4785  2708
   4786  2708				   .
   4787  2708							; 
   4788  2708
   4789  2708				   .
   4790  2708							; 
   4791  2708
   4792  2708				   .
   4793  2708							; 
   4794  2708
   4795  2708				   .L0193		;  if _Bit3_Auto_Play{3} then goto __Delete_Missile
   4796  2708
   4797  2708		       a5 ec		      LDA	_Bit3_Auto_Play
   4798  270a		       29 08		      AND	#8
   4799  270c		       f0 03		      BEQ	.skipL0193
   4800  270e				   .condpart95
   4801  270e		       4c 26 37 	      jmp	.__Delete_Missile
   4802  2711
   4803  2711				   .skipL0193
   4804  2711				   .
   4805  2711							; 
   4806  2711
   4807  2711				   .
   4808  2711							; 
   4809  2711
   4810  2711				   .
   4811  2711							; 
   4812  2711
   4813  2711				   .
   4814  2711							; 
   4815  2711
   4816  2711				   .L0194		;  score  =  score  +	1
   4817  2711
   4818  2711		       f8		      SED
   4819  2712		       18		      CLC
   4820  2713		       a5 95		      LDA	score+2
   4821  2715		       69 01		      ADC	#$01
   4822  2717		       85 95		      STA	score+2
   4823  2719		       a5 94		      LDA	score+1
   4824  271b		       69 00		      ADC	#$00
   4825  271d		       85 94		      STA	score+1
   4826  271f		       a5 93		      LDA	score
   4827  2721		       69 00		      ADC	#$00
   4828  2723		       85 93		      STA	score
   4829  2725		       d8		      CLD
   4830  2726				   .
   4831  2726							; 
   4832  2726
   4833  2726				   .__Delete_Missile
   4834  2726							; __Delete_Missile
   4835  2726
   4836  2726				   .
   4837  2726							; 
   4838  2726
   4839  2726				   .
   4840  2726							; 
   4841  2726
   4842  2726				   .
   4843  2726							; 
   4844  2726
   4845  2726				   .
   4846  2726							; 
   4847  2726
   4848  2726				   .L0195		;  _Bit7_M1_Moving{7}	=  0  :  missile1x  =  200  :  missile1y  =  200
   4849  2726
   4850  2726		       a5 ec		      LDA	_Bit7_M1_Moving
   4851  2728		       29 7f		      AND	#127
   4852  272a		       85 ec		      STA	_Bit7_M1_Moving
   4853  272c		       a9 c8		      LDA	#200
   4854  272e		       85 83		      STA	missile1x
   4855  2730		       85 88		      STA	missile1y
   4856  2732				   .
   4857  2732							; 
   4858  2732
   4859  2732				   .__Skip_Missile
   4860  2732							; __Skip_Missile
   4861  2732
   4862  2732				   .
   4863  2732							; 
   4864  2732
   4865  2732				   .
   4866  2732							; 
   4867  2732
   4868  2732				   .
   4869  2732							; 
   4870  2732
   4871  2732				   .
   4872  2732							; 
   4873  2732
   4874  2732				   .
   4875  2732							; 
   4876  2732
   4877  2732				   .
   4878  2732							; 
   4879  2732
   4880  2732				   .
   4881  2732							; 
   4882  2732
   4883  2732				   .L0196		;  if collision(player0,player1) then _Bit2_Game_Control{2}  =  1
   4884  2732
   4885  2732		       24 07		      bit	CXPPMM
   4886  2734		       10 06		      BPL	.skipL0196
   4887  2736				   .condpart96
   4888  2736		       a5 ec		      LDA	_Bit2_Game_Control
   4889  2738		       09 04		      ORA	#4
   4890  273a		       85 ec		      STA	_Bit2_Game_Control
   4891  273c				   .skipL0196
   4892  273c				   .
   4893  273c							; 
   4894  273c
   4895  273c				   .
   4896  273c							; 
   4897  273c
   4898  273c				   .
   4899  273c							; 
   4900  273c
   4901  273c				   .
   4902  273c							; 
   4903  273c
   4904  273c				   .
   4905  273c							; 
   4906  273c
   4907  273c				   .
   4908  273c							; 
   4909  273c
   4910  273c				   .
   4911  273c							; 
   4912  273c
   4913  273c				   .
   4914  273c							; 
   4915  273c
   4916  273c				   .
   4917  273c							; 
   4918  273c
   4919  273c				   .
   4920  273c							; 
   4921  273c
   4922  273c				   .L0197		;  if !collision(player1,missile1) then goto __Skip_Shot_Enemy
   4923  273c
   4924  273c		       24 01		      bit	CXM1P
   4925  273e		       70 03		      BVS	.skipL0197
   4926  2740				   .condpart97
   4927  2740		       4c b2 37 	      jmp	.__Skip_Shot_Enemy
   4928  2743
   4929  2743				   .skipL0197
   4930  2743				   .
   4931  2743							; 
   4932  2743
   4933  2743				   .
   4934  2743							; 
   4935  2743
   4936  2743				   .
   4937  2743							; 
   4938  2743
   4939  2743				   .
   4940  2743							; 
   4941  2743
   4942  2743				   .L0198		;  _Bit7_M1_Moving{7}	=  0  :  missile1x  =  200  :  missile1y  =  200
   4943  2743
   4944  2743		       a5 ec		      LDA	_Bit7_M1_Moving
   4945  2745		       29 7f		      AND	#127
   4946  2747		       85 ec		      STA	_Bit7_M1_Moving
   4947  2749		       a9 c8		      LDA	#200
   4948  274b		       85 83		      STA	missile1x
   4949  274d		       85 88		      STA	missile1y
   4950  274f				   .
   4951  274f							; 
   4952  274f
   4953  274f				   .
   4954  274f							; 
   4955  274f
   4956  274f				   .
   4957  274f							; 
   4958  274f
   4959  274f				   .
   4960  274f							; 
   4961  274f
   4962  274f				   .L0199		;  if _Bit3_Auto_Play{3} then goto __AP_Skip_Enemy_Points
   4963  274f
   4964  274f		       a5 ec		      LDA	_Bit3_Auto_Play
   4965  2751		       29 08		      AND	#8
   4966  2753		       f0 03		      BEQ	.skipL0199
   4967  2755				   .condpart98
   4968  2755		       4c 6d 37 	      jmp	.__AP_Skip_Enemy_Points
   4969  2758
   4970  2758				   .skipL0199
   4971  2758				   .
   4972  2758							; 
   4973  2758
   4974  2758				   .
   4975  2758							; 
   4976  2758
   4977  2758				   .
   4978  2758							; 
   4979  2758
   4980  2758				   .
   4981  2758							; 
   4982  2758
   4983  2758				   .L0200		;  score  =  score  +	20
   4984  2758
   4985  2758		       f8		      SED
   4986  2759		       18		      CLC
   4987  275a		       a5 95		      LDA	score+2
   4988  275c		       69 20		      ADC	#$20
   4989  275e		       85 95		      STA	score+2
   4990  2760		       a5 94		      LDA	score+1
   4991  2762		       69 00		      ADC	#$00
   4992  2764		       85 94		      STA	score+1
   4993  2766		       a5 93		      LDA	score
   4994  2768		       69 00		      ADC	#$00
   4995  276a		       85 93		      STA	score
   4996  276c		       d8		      CLD
   4997  276d				   .
   4998  276d							; 
   4999  276d
   5000  276d				   .__AP_Skip_Enemy_Points
   5001  276d							; __AP_Skip_Enemy_Points
   5002  276d
   5003  276d				   .
   5004  276d							; 
   5005  276d
   5006  276d				   .
   5007  276d							; 
   5008  276d
   5009  276d				   .
   5010  276d							; 
   5011  276d
   5012  276d				   .
   5013  276d							; 
   5014  276d
   5015  276d				   .L0201		;  player1y  =   ( rand & 63 )   +  15
   5016  276d
   5017  276d							; complex statement detected
   5018  276d		       a5 a2		      lda	rand
   5019  276f		       4a		      lsr
   5020  2770					      ifconst	rand16
   5021  2770		       26 ed		      rol	rand16
   5022  2772					      endif
   5023  2772		       90 02		      bcc	*+4
   5024  2774		       49 b4		      eor	#$B4
   5025  2776		       85 a2		      sta	rand
   5026  2778					      ifconst	rand16
   5027  2778		       45 ed		      eor	rand16
   5028  277a					      endif
   5029  277a		       29 3f		      AND	#63
   5030  277c		       18		      CLC
   5031  277d		       69 0f		      ADC	#15
   5032  277f		       85 86		      STA	player1y
   5033  2781				   .
   5034  2781							; 
   5035  2781
   5036  2781				   .L0202		;  if player0x  >=  77 then player1x  =   ( rand & 7 )   +  5	:  goto __Skip_Shot_Enemy
   5037  2781
   5038  2781		       a5 80		      LDA	player0x
   5039  2783		       c9 4d		      CMP	#77
   5040  2785		       90 17		      BCC	.skipL0202
   5041  2787				   .condpart99
   5042  2787							; complex statement detected
   5043  2787		       a5 a2		      lda	rand
   5044  2789		       4a		      lsr
   5045  278a					      ifconst	rand16
   5046  278a		       26 ed		      rol	rand16
   5047  278c					      endif
   5048  278c		       90 02		      bcc	*+4
   5049  278e		       49 b4		      eor	#$B4
   5050  2790		       85 a2		      sta	rand
   5051  2792					      ifconst	rand16
   5052  2792		       45 ed		      eor	rand16
   5053  2794					      endif
   5054  2794		       29 07		      AND	#7
   5055  2796		       18		      CLC
   5056  2797		       69 05		      ADC	#5
   5057  2799		       85 81		      STA	player1x
   5058  279b		       4c b2 37 	      jmp	.__Skip_Shot_Enemy
   5059  279e
   5060  279e				   .skipL0202
   5061  279e				   .
   5062  279e							; 
   5063  279e
   5064  279e				   .L0203		;  player1x  =   ( rand & 7 )	 +  140
   5065  279e
   5066  279e							; complex statement detected
   5067  279e		       a5 a2		      lda	rand
   5068  27a0		       4a		      lsr
   5069  27a1					      ifconst	rand16
   5070  27a1		       26 ed		      rol	rand16
   5071  27a3					      endif
   5072  27a3		       90 02		      bcc	*+4
   5073  27a5		       49 b4		      eor	#$B4
   5074  27a7		       85 a2		      sta	rand
   5075  27a9					      ifconst	rand16
   5076  27a9		       45 ed		      eor	rand16
   5077  27ab					      endif
   5078  27ab		       29 07		      AND	#7
   5079  27ad		       18		      CLC
   5080  27ae		       69 8c		      ADC	#140
   5081  27b0		       85 81		      STA	player1x
   5082  27b2				   .
   5083  27b2							; 
   5084  27b2
   5085  27b2				   .__Skip_Shot_Enemy
   5086  27b2							; __Skip_Shot_Enemy
   5087  27b2
   5088  27b2				   .
   5089  27b2							; 
   5090  27b2
   5091  27b2				   .
   5092  27b2							; 
   5093  27b2
   5094  27b2				   .
   5095  27b2							; 
   5096  27b2
   5097  27b2				   .
   5098  27b2							; 
   5099  27b2
   5100  27b2				   .
   5101  27b2							; 
   5102  27b2
   5103  27b2				   .
   5104  27b2							; 
   5105  27b2
   5106  27b2				   .
   5107  27b2							; 
   5108  27b2
   5109  27b2				   .
   5110  27b2							; 
   5111  27b2
   5112  27b2				   .
   5113  27b2							; 
   5114  27b2
   5115  27b2				   .
   5116  27b2							; 
   5117  27b2
   5118  27b2				   .
   5119  27b2							; 
   5120  27b2
   5121  27b2				   .
   5122  27b2							; 
   5123  27b2
   5124  27b2				   .L0204		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Flip
   5125  27b2
   5126  27b2		       a5 ec		      LDA	_Bit3_Auto_Play
   5127  27b4		       29 08		      AND	#8
   5128  27b6		       d0 03		      BNE	.skipL0204
   5129  27b8				   .condpart100
   5130  27b8		       4c 04 38 	      jmp	.__AP_Skip_Flip
   5131  27bb
   5132  27bb				   .skipL0204
   5133  27bb				   .
   5134  27bb							; 
   5135  27bb
   5136  27bb				   .
   5137  27bb							; 
   5138  27bb
   5139  27bb				   .
   5140  27bb							; 
   5141  27bb
   5142  27bb				   .
   5143  27bb							; 
   5144  27bb
   5145  27bb				   .L0205		;  _AP_2_Sec_Score_Flip  =  _AP_2_Sec_Score_Flip  +  1
   5146  27bb
   5147  27bb		       e6 de		      INC	_AP_2_Sec_Score_Flip
   5148  27bd				   .
   5149  27bd							; 
   5150  27bd
   5151  27bd				   .
   5152  27bd							; 
   5153  27bd
   5154  27bd				   .
   5155  27bd							; 
   5156  27bd
   5157  27bd				   .
   5158  27bd							; 
   5159  27bd
   5160  27bd				   .
   5161  27bd							; 
   5162  27bd
   5163  27bd				   .L0206		;  if _AP_2_Sec_Score_Flip  <	120 then goto __AP_Skip_Flip
   5164  27bd
   5165  27bd		       a5 de		      LDA	_AP_2_Sec_Score_Flip
   5166  27bf		       c9 78		      CMP	#120
   5167  27c1		       b0 03		      BCS	.skipL0206
   5168  27c3				   .condpart101
   5169  27c3		       4c 04 38 	      jmp	.__AP_Skip_Flip
   5170  27c6
   5171  27c6				   .skipL0206
   5172  27c6				   .
   5173  27c6							; 
   5174  27c6
   5175  27c6				   .
   5176  27c6							; 
   5177  27c6
   5178  27c6				   .
   5179  27c6							; 
   5180  27c6
   5181  27c6				   .
   5182  27c6							; 
   5183  27c6
   5184  27c6				   .L0207		;  _AP_2_Sec_Score_Flip  =  0	:  _Bit6_Swap_Scores{6}  =  !_Bit6_Swap_Scores{6}
   5185  27c6
   5186  27c6		       a9 00		      LDA	#0
   5187  27c8		       85 de		      STA	_AP_2_Sec_Score_Flip
   5188  27ca		       a5 ec		      LDA	_Bit6_Swap_Scores
   5189  27cc		       29 40		      AND	#64
   5190  27ce		       08		      PHP
   5191  27cf		       a5 ec		      LDA	_Bit6_Swap_Scores
   5192  27d1		       29 bf		      AND	#191
   5193  27d3		       28		      PLP
   5194  27d4		       d0 02		      .byte.b	$D0, $02
   5195  27d6		       09 40		      ORA	#64
   5196  27d8		       85 ec		      STA	_Bit6_Swap_Scores
   5197  27da				   .
   5198  27da							; 
   5199  27da
   5200  27da				   .
   5201  27da							; 
   5202  27da
   5203  27da				   .
   5204  27da							; 
   5205  27da
   5206  27da				   .
   5207  27da							; 
   5208  27da
   5209  27da				   .L0208		;  if !_Bit6_Swap_Scores{6} then goto __AP_Skip_HiScore_Swap
   5210  27da
   5211  27da		       24 ec		      BIT	_Bit6_Swap_Scores
   5212  27dc		       70 03		      BVS	.skipL0208
   5213  27de				   .condpart102
   5214  27de		       4c f4 37 	      jmp	.__AP_Skip_HiScore_Swap
   5215  27e1
   5216  27e1				   .skipL0208
   5217  27e1				   .
   5218  27e1							; 
   5219  27e1
   5220  27e1				   .
   5221  27e1							; 
   5222  27e1
   5223  27e1				   .
   5224  27e1							; 
   5225  27e1
   5226  27e1				   .
   5227  27e1							; 
   5228  27e1
   5229  27e1				   .L0209		;  scorecolor	=  $AE
   5230  27e1
   5231  27e1		       a9 ae		      LDA	#$AE
   5232  27e3		       85 a3		      STA	scorecolor
   5233  27e5				   .
   5234  27e5							; 
   5235  27e5
   5236  27e5				   .L0210		;  _sc1  =  _High_Score1  :  _sc2  =  _High_Score2  :	_sc3  =  _High_Score3
   5237  27e5
   5238  27e5		       a5 e9		      LDA	_High_Score1
   5239  27e7		       85 93		      STA	_sc1
   5240  27e9		       a5 ea		      LDA	_High_Score2
   5241  27eb		       85 94		      STA	_sc2
   5242  27ed		       a5 eb		      LDA	_High_Score3
   5243  27ef		       85 95		      STA	_sc3
   5244  27f1				   .
   5245  27f1							; 
   5246  27f1
   5247  27f1				   .L0211		;  goto __AP_Skip_Flip
   5248  27f1
   5249  27f1		       4c 04 38 	      jmp	.__AP_Skip_Flip
   5250  27f4
   5251  27f4				   .
   5252  27f4							; 
   5253  27f4
   5254  27f4				   .__AP_Skip_HiScore_Swap
   5255  27f4							; __AP_Skip_HiScore_Swap
   5256  27f4
   5257  27f4				   .
   5258  27f4							; 
   5259  27f4
   5260  27f4				   .
   5261  27f4							; 
   5262  27f4
   5263  27f4				   .
   5264  27f4							; 
   5265  27f4
   5266  27f4				   .
   5267  27f4							; 
   5268  27f4
   5269  27f4				   .L0212		;  scorecolor	=  $1C
   5270  27f4
   5271  27f4		       a9 1c		      LDA	#$1C
   5272  27f6		       85 a3		      STA	scorecolor
   5273  27f8				   .
   5274  27f8							; 
   5275  27f8
   5276  27f8				   .L0213		;  _sc1  =  _Score1_Mem  :  _sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem
   5277  27f8
   5278  27f8		       a5 e6		      LDA	_Score1_Mem
   5279  27fa		       85 93		      STA	_sc1
   5280  27fc		       a5 e7		      LDA	_Score2_Mem
   5281  27fe		       85 94		      STA	_sc2
   5282  2800		       a5 e8		      LDA	_Score3_Mem
   5283  2802		       85 95		      STA	_sc3
   5284  2804				   .
   5285  2804							; 
   5286  2804
   5287  2804				   .__AP_Skip_Flip
   5288  2804							; __AP_Skip_Flip
   5289  2804
   5290  2804				   .
   5291  2804							; 
   5292  2804
   5293  2804				   .
   5294  2804							; 
   5295  2804
   5296  2804				   .
   5297  2804							; 
   5298  2804
   5299  2804				   .
   5300  2804							; 
   5301  2804
   5302  2804				   .
   5303  2804							; 
   5304  2804
   5305  2804				   .
   5306  2804							; 
   5307  2804
   5308  2804				   .
   5309  2804							; 
   5310  2804
   5311  2804				   .
   5312  2804							; 
   5313  2804
   5314  2804				   .
   5315  2804							; 
   5316  2804
   5317  2804				   .
   5318  2804							; 
   5319  2804
   5320  2804				   .L0214		;  if _Bit3_Auto_Play{3} then goto __AP_Skip_Pause
   5321  2804
   5322  2804		       a5 ec		      LDA	_Bit3_Auto_Play
   5323  2806		       29 08		      AND	#8
   5324  2808		       f0 03		      BEQ	.skipL0214
   5325  280a				   .condpart103
   5326  280a		       4c 76 38 	      jmp	.__AP_Skip_Pause
   5327  280d
   5328  280d				   .skipL0214
   5329  280d				   .
   5330  280d							; 
   5331  280d
   5332  280d				   .
   5333  280d							; 
   5334  280d
   5335  280d				   .
   5336  280d							; 
   5337  280d
   5338  280d				   .
   5339  280d							; 
   5340  280d
   5341  280d				   .L0215		;  _Bit1_BW_Check{1}  =  0
   5342  280d
   5343  280d		       a5 e5		      LDA	_Bit1_BW_Check
   5344  280f		       29 fd		      AND	#253
   5345  2811		       85 e5		      STA	_Bit1_BW_Check
   5346  2813				   .
   5347  2813							; 
   5348  2813
   5349  2813				   .L0216		;  if switchbw then _Bit1_BW_Check{1}	=  1
   5350  2813
   5351  2813		       a9 08		      lda	#8
   5352  2815		       2c 82 02 	      bit	SWCHB
   5353  2818		       d0 06		      BNE	.skipL0216
   5354  281a				   .condpart104
   5355  281a		       a5 e5		      LDA	_Bit1_BW_Check
   5356  281c		       09 02		      ORA	#2
   5357  281e		       85 e5		      STA	_Bit1_BW_Check
   5358  2820				   .skipL0216
   5359  2820				   .
   5360  2820							; 
   5361  2820
   5362  2820				   .
   5363  2820							; 
   5364  2820
   5365  2820				   .
   5366  2820							; 
   5367  2820
   5368  2820				   .
   5369  2820							; 
   5370  2820
   5371  2820				   .
   5372  2820							; 
   5373  2820
   5374  2820				   .L0217		;  if _Bit0_BW_Mem{0} then if !_Bit1_BW_Check{1} then goto __Pause_Setup bank3
   5375  2820
   5376  2820		       a5 e5		      LDA	_Bit0_BW_Mem
   5377  2822		       4a		      LSR
   5378  2823		       90 18		      BCC	.skipL0217
   5379  2825				   .condpart105
   5380  2825		       a5 e5		      LDA	_Bit1_BW_Check
   5381  2827		       29 02		      AND	#2
   5382  2829		       d0 12		      BNE	.skip105then
   5383  282b				   .condpart106
   5384  282b		       85 ee		      sta	temp7
   5385  282d		       a9 51		      lda	#>(.__Pause_Setup-1)
   5386  282f		       48		      pha
   5387  2830		       a9 a3		      lda	#<(.__Pause_Setup-1)
   5388  2832		       48		      pha
   5389  2833		       a5 ee		      lda	temp7
   5390  2835		       48		      pha
   5391  2836		       8a		      txa
   5392  2837		       48		      pha
   5393  2838		       a2 03		      ldx	#3
   5394  283a		       4c eb ff 	      jmp	BS_jsr
   5395  283d				   .skip105then
   5396  283d				   .skipL0217
   5397  283d				   .
   5398  283d							; 
   5399  283d
   5400  283d				   .L0218		;  if !_Bit0_BW_Mem{0} then if _Bit1_BW_Check{1} then goto __Pause_Setup bank3
   5401  283d
   5402  283d		       a5 e5		      LDA	_Bit0_BW_Mem
   5403  283f		       4a		      LSR
   5404  2840		       b0 18		      BCS	.skipL0218
   5405  2842				   .condpart107
   5406  2842		       a5 e5		      LDA	_Bit1_BW_Check
   5407  2844		       29 02		      AND	#2
   5408  2846		       f0 12		      BEQ	.skip107then
   5409  2848				   .condpart108
   5410  2848		       85 ee		      sta	temp7
   5411  284a		       a9 51		      lda	#>(.__Pause_Setup-1)
   5412  284c		       48		      pha
   5413  284d		       a9 a3		      lda	#<(.__Pause_Setup-1)
   5414  284f		       48		      pha
   5415  2850		       a5 ee		      lda	temp7
   5416  2852		       48		      pha
   5417  2853		       8a		      txa
   5418  2854		       48		      pha
   5419  2855		       a2 03		      ldx	#3
   5420  2857		       4c eb ff 	      jmp	BS_jsr
   5421  285a				   .skip107then
   5422  285a				   .skipL0218
   5423  285a				   .
   5424  285a							; 
   5425  285a
   5426  285a				   .
   5427  285a							; 
   5428  285a
   5429  285a				   .
   5430  285a							; 
   5431  285a
   5432  285a				   .
   5433  285a							; 
   5434  285a
   5435  285a				   .L0219		;  if joy1fire  &&  !_Bit1_FireB_Restrainer{1} then goto __Pause_Setup bank3
   5436  285a
   5437  285a		       24 0d		      bit	INPT5
   5438  285c		       30 18		      BMI	.skipL0219
   5439  285e				   .condpart109
   5440  285e		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   5441  2860		       29 02		      AND	#2
   5442  2862		       d0 12		      BNE	.skip109then
   5443  2864				   .condpart110
   5444  2864		       85 ee		      sta	temp7
   5445  2866		       a9 51		      lda	#>(.__Pause_Setup-1)
   5446  2868		       48		      pha
   5447  2869		       a9 a3		      lda	#<(.__Pause_Setup-1)
   5448  286b		       48		      pha
   5449  286c		       a5 ee		      lda	temp7
   5450  286e		       48		      pha
   5451  286f		       8a		      txa
   5452  2870		       48		      pha
   5453  2871		       a2 03		      ldx	#3
   5454  2873		       4c eb ff 	      jmp	BS_jsr
   5455  2876				   .skip109then
   5456  2876				   .skipL0219
   5457  2876				   .
   5458  2876							; 
   5459  2876
   5460  2876				   .__AP_Skip_Pause
   5461  2876							; __AP_Skip_Pause
   5462  2876
   5463  2876				   .
   5464  2876							; 
   5465  2876
   5466  2876				   .
   5467  2876							; 
   5468  2876
   5469  2876				   .
   5470  2876							; 
   5471  2876
   5472  2876				   .
   5473  2876							; 
   5474  2876
   5475  2876				   .
   5476  2876							; 
   5477  2876
   5478  2876				   .
   5479  2876							; 
   5480  2876
   5481  2876				   .
   5482  2876							; 
   5483  2876
   5484  2876				   .L0220		;  drawscreen
   5485  2876
   5486  2876		       85 ee		      sta	temp7
   5487  2878		       a9 38		      lda	#>(ret_point12-1)
   5488  287a		       48		      pha
   5489  287b		       a9 8d		      lda	#<(ret_point12-1)
   5490  287d		       48		      pha
   5491  287e		       a9 f4		      lda	#>(drawscreen-1)
   5492  2880		       48		      pha
   5493  2881		       a9 39		      lda	#<(drawscreen-1)
   5494  2883		       48		      pha
   5495  2884		       a5 ee		      lda	temp7
   5496  2886		       48		      pha
   5497  2887		       8a		      txa
   5498  2888		       48		      pha
   5499  2889		       a2 08		      ldx	#8
   5500  288b		       4c eb ff 	      jmp	BS_jsr
   5501  288e				   ret_point12
   5502  288e				   .
   5503  288e							; 
   5504  288e
   5505  288e				   .
   5506  288e							; 
   5507  288e
   5508  288e				   .
   5509  288e							; 
   5510  288e
   5511  288e				   .
   5512  288e							; 
   5513  288e
   5514  288e				   .
   5515  288e							; 
   5516  288e
   5517  288e				   .
   5518  288e							; 
   5519  288e
   5520  288e				   .
   5521  288e							; 
   5522  288e
   5523  288e				   .
   5524  288e							; 
   5525  288e
   5526  288e				   .
   5527  288e							; 
   5528  288e
   5529  288e				   .
   5530  288e							; 
   5531  288e
   5532  288e				   .
   5533  288e							; 
   5534  288e
   5535  288e				   .
   5536  288e							; 
   5537  288e
   5538  288e				   .
   5539  288e							; 
   5540  288e
   5541  288e				   .
   5542  288e							; 
   5543  288e
   5544  288e				   .
   5545  288e							; 
   5546  288e
   5547  288e				   .L0221		;  if !_Bit2_Game_Control{2} then goto __Skip_Check_G_Over
   5548  288e
   5549  288e		       a5 ec		      LDA	_Bit2_Game_Control
   5550  2890		       29 04		      AND	#4
   5551  2892		       d0 03		      BNE	.skipL0221
   5552  2894				   .condpart111
   5553  2894		       4c d3 38 	      jmp	.__Skip_Check_G_Over
   5554  2897
   5555  2897				   .skipL0221
   5556  2897				   .
   5557  2897							; 
   5558  2897
   5559  2897				   .
   5560  2897							; 
   5561  2897
   5562  2897				   .
   5563  2897							; 
   5564  2897
   5565  2897				   .
   5566  2897							; 
   5567  2897
   5568  2897				   .
   5569  2897							; 
   5570  2897
   5571  2897				   .L0222		;  if _Bit3_Auto_Play{3} then _Bit2_Game_Control{2}  =  0  :  _sc1  =	_Score1_Mem  :	_sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem  :  goto __Start_Restart bank1
   5572  2897
   5573  2897		       a5 ec		      LDA	_Bit3_Auto_Play
   5574  2899		       29 08		      AND	#8
   5575  289b		       f0 24		      BEQ	.skipL0222
   5576  289d				   .condpart112
   5577  289d		       a5 ec		      LDA	_Bit2_Game_Control
   5578  289f		       29 fb		      AND	#251
   5579  28a1		       85 ec		      STA	_Bit2_Game_Control
   5580  28a3		       a5 e6		      LDA	_Score1_Mem
   5581  28a5		       85 93		      STA	_sc1
   5582  28a7		       a5 e7		      LDA	_Score2_Mem
   5583  28a9		       85 94		      STA	_sc2
   5584  28ab		       a5 e8		      LDA	_Score3_Mem
   5585  28ad		       85 95		      STA	_sc3
   5586  28af		       85 ee		      sta	temp7
   5587  28b1		       a9 0f		      lda	#>(.__Start_Restart-1)
   5588  28b3		       48		      pha
   5589  28b4		       a9 ff		      lda	#<(.__Start_Restart-1)
   5590  28b6		       48		      pha
   5591  28b7		       a5 ee		      lda	temp7
   5592  28b9		       48		      pha
   5593  28ba		       8a		      txa
   5594  28bb		       48		      pha
   5595  28bc		       a2 01		      ldx	#1
   5596  28be		       4c eb ff 	      jmp	BS_jsr
   5597  28c1				   .skipL0222
   5598  28c1				   .
   5599  28c1							; 
   5600  28c1
   5601  28c1				   .
   5602  28c1							; 
   5603  28c1
   5604  28c1				   .
   5605  28c1							; 
   5606  28c1
   5607  28c1				   .
   5608  28c1							; 
   5609  28c1
   5610  28c1				   .L0223		;  goto __Game_Over_Setup bank3
   5611  28c1
   5612  28c1		       85 ee		      sta	temp7
   5613  28c3		       a9 4f		      lda	#>(.__Game_Over_Setup-1)
   5614  28c5		       48		      pha
   5615  28c6		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
   5616  28c8		       48		      pha
   5617  28c9		       a5 ee		      lda	temp7
   5618  28cb		       48		      pha
   5619  28cc		       8a		      txa
   5620  28cd		       48		      pha
   5621  28ce		       a2 03		      ldx	#3
   5622  28d0		       4c eb ff 	      jmp	BS_jsr
   5623  28d3				   .
   5624  28d3							; 
   5625  28d3
   5626  28d3				   .__Skip_Check_G_Over
   5627  28d3							; __Skip_Check_G_Over
   5628  28d3
   5629  28d3				   .
   5630  28d3							; 
   5631  28d3
   5632  28d3				   .
   5633  28d3							; 
   5634  28d3
   5635  28d3				   .
   5636  28d3							; 
   5637  28d3
   5638  28d3				   .
   5639  28d3							; 
   5640  28d3
   5641  28d3				   .
   5642  28d3							; 
   5643  28d3
   5644  28d3				   .
   5645  28d3							; 
   5646  28d3
   5647  28d3				   .
   5648  28d3							; 
   5649  28d3
   5650  28d3				   .
   5651  28d3							; 
   5652  28d3
   5653  28d3				   .
   5654  28d3							; 
   5655  28d3
   5656  28d3				   .
   5657  28d3							; 
   5658  28d3
   5659  28d3				   .
   5660  28d3							; 
   5661  28d3
   5662  28d3				   .
   5663  28d3							; 
   5664  28d3
   5665  28d3				   .
   5666  28d3							; 
   5667  28d3
   5668  28d3				   .
   5669  28d3							; 
   5670  28d3
   5671  28d3				   .L0224		;  if !_Bit3_Auto_Play{3} then goto __AP_Skip_Reset
   5672  28d3
   5673  28d3		       a5 ec		      LDA	_Bit3_Auto_Play
   5674  28d5		       29 08		      AND	#8
   5675  28d7		       d0 03		      BNE	.skipL0224
   5676  28d9				   .condpart113
   5677  28d9		       4c 08 39 	      jmp	.__AP_Skip_Reset
   5678  28dc
   5679  28dc				   .skipL0224
   5680  28dc				   .
   5681  28dc							; 
   5682  28dc
   5683  28dc				   .
   5684  28dc							; 
   5685  28dc
   5686  28dc				   .
   5687  28dc							; 
   5688  28dc
   5689  28dc				   .
   5690  28dc							; 
   5691  28dc
   5692  28dc				   .
   5693  28dc							; 
   5694  28dc
   5695  28dc				   .
   5696  28dc							; 
   5697  28dc
   5698  28dc				   .L0225		;  if switchreset  ||	joy0fire then _Bit3_Auto_Play{3}  =  0	:  _Bit2_Game_Control{2}  =  1	:  goto __Start_Restart bank1
   5699  28dc
   5700  28dc		       a9 01		      lda	#1
   5701  28de		       2c 82 02 	      bit	SWCHB
   5702  28e1		       d0 03		      BNE	.skipL0225
   5703  28e3				   .condpart114
   5704  28e3		       4c ea 38 	      jmp	.condpart115
   5705  28e6				   .skipL0225
   5706  28e6		       24 0c		      bit	INPT4
   5707  28e8		       30 1e		      BMI	.skip10OR
   5708  28ea				   .condpart115
   5709  28ea		       a5 ec		      LDA	_Bit3_Auto_Play
   5710  28ec		       29 f7		      AND	#247
   5711  28ee		       85 ec		      STA	_Bit3_Auto_Play
   5712  28f0		       a5 ec		      LDA	_Bit2_Game_Control
   5713  28f2		       09 04		      ORA	#4
   5714  28f4		       85 ec		      STA	_Bit2_Game_Control
   5715  28f6		       85 ee		      sta	temp7
   5716  28f8		       a9 0f		      lda	#>(.__Start_Restart-1)
   5717  28fa		       48		      pha
   5718  28fb		       a9 ff		      lda	#<(.__Start_Restart-1)
   5719  28fd		       48		      pha
   5720  28fe		       a5 ee		      lda	temp7
   5721  2900		       48		      pha
   5722  2901		       8a		      txa
   5723  2902		       48		      pha
   5724  2903		       a2 01		      ldx	#1
   5725  2905		       4c eb ff 	      jmp	BS_jsr
   5726  2908				   .skip10OR
   5727  2908				   .
   5728  2908							; 
   5729  2908
   5730  2908				   .__AP_Skip_Reset
   5731  2908							; __AP_Skip_Reset
   5732  2908
   5733  2908				   .
   5734  2908							; 
   5735  2908
   5736  2908				   .
   5737  2908							; 
   5738  2908
   5739  2908				   .
   5740  2908							; 
   5741  2908
   5742  2908				   .
   5743  2908							; 
   5744  2908
   5745  2908				   .
   5746  2908							; 
   5747  2908
   5748  2908				   .L0226		;  if !switchreset then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Main_Loop
   5749  2908
   5750  2908		       a9 01		      lda	#1
   5751  290a		       2c 82 02 	      bit	SWCHB
   5752  290d		       f0 09		      BEQ	.skipL0226
   5753  290f				   .condpart116
   5754  290f		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   5755  2911		       29 fe		      AND	#254
   5756  2913		       85 ec		      STA	_Bit0_Reset_Restrainer
   5757  2915		       4c 07 31 	      jmp	.__Main_Loop
   5758  2918
   5759  2918				   .skipL0226
   5760  2918				   .
   5761  2918							; 
   5762  2918
   5763  2918				   .
   5764  2918							; 
   5765  2918
   5766  2918				   .
   5767  2918							; 
   5768  2918
   5769  2918				   .
   5770  2918							; 
   5771  2918
   5772  2918				   .
   5773  2918							; 
   5774  2918
   5775  2918				   .L0227		;  if _Bit0_Reset_Restrainer{0} then goto __Main_Loop
   5776  2918
   5777  2918		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   5778  291a		       4a		      LSR
   5779  291b		       90 03		      BCC	.skipL0227
   5780  291d				   .condpart117
   5781  291d		       4c 07 31 	      jmp	.__Main_Loop
   5782  2920
   5783  2920				   .skipL0227
   5784  2920				   .
   5785  2920							; 
   5786  2920
   5787  2920				   .
   5788  2920							; 
   5789  2920
   5790  2920				   .
   5791  2920							; 
   5792  2920
   5793  2920				   .
   5794  2920							; 
   5795  2920
   5796  2920				   .L0228		;  _Bit2_Game_Control{2}  =  0
   5797  2920
   5798  2920		       a5 ec		      LDA	_Bit2_Game_Control
   5799  2922		       29 fb		      AND	#251
   5800  2924		       85 ec		      STA	_Bit2_Game_Control
   5801  2926				   .
   5802  2926							; 
   5803  2926
   5804  2926				   .
   5805  2926							; 
   5806  2926
   5807  2926				   .
   5808  2926							; 
   5809  2926
   5810  2926				   .
   5811  2926							; 
   5812  2926
   5813  2926				   .
   5814  2926							; 
   5815  2926
   5816  2926				   .L0229		;  goto __Game_Over_Setup bank3
   5817  2926
   5818  2926		       85 ee		      sta	temp7
   5819  2928		       a9 4f		      lda	#>(.__Game_Over_Setup-1)
   5820  292a		       48		      pha
   5821  292b		       a9 ff		      lda	#<(.__Game_Over_Setup-1)
   5822  292d		       48		      pha
   5823  292e		       a5 ee		      lda	temp7
   5824  2930		       48		      pha
   5825  2931		       8a		      txa
   5826  2932		       48		      pha
   5827  2933		       a2 03		      ldx	#3
   5828  2935		       4c eb ff 	      jmp	BS_jsr
   5829  2938				   .
   5830  2938							; 
   5831  2938
   5832  2938				   .
   5833  2938							; 
   5834  2938
   5835  2938				   .
   5836  2938							; 
   5837  2938
   5838  2938				   .
   5839  2938							; 
   5840  2938
   5841  2938				   .
   5842  2938							; 
   5843  2938
   5844  2938				   .
   5845  2938							; 
   5846  2938
   5847  2938				   .
   5848  2938							; 
   5849  2938
   5850  2938				   .
   5851  2938							; 
   5852  2938
   5853  2938				   .
   5854  2938							; 
   5855  2938
   5856  2938				   .
   5857  2938							; 
   5858  2938
   5859  2938				   .
   5860  2938							; 
   5861  2938
   5862  2938				   .
   5863  2938							; 
   5864  2938
   5865  2938				   .
   5866  2938							; 
   5867  2938
   5868  2938				   .
   5869  2938							; 
   5870  2938
   5871  2938				   .
   5872  2938							; 
   5873  2938
   5874  2938				   .
   5875  2938							; 
   5876  2938
   5877  2938				   .
   5878  2938							; 
   5879  2938
   5880  2938				   .L0230		;  bank 3
   5881  2938
   5882  2938					      if	ECHO2
      1692 bytes of ROM space left in bank 2
   5883  2938					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   5884  2938					      endif
   5885  2938		       00 01	   ECHO2      =	1
   5886  2fd4					      ORG	$2FF4-bscode_length
   5887  2fd4					      RORG	$3FF4-bscode_length
   5888  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   5889  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5890  2fd6				  -	      stx	FASTFETCH
   5891  2fd6					      endif
   5892  2fd6		       9a		      txs
   5893  2fd7				  -	      if	bankswitch == 64
   5894  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5895  2fd7					      else
   5896  2fd7		       a9 f2		      lda	#>(start-1)
   5897  2fd9					      endif
   5898  2fd9		       48		      pha
   5899  2fda		       a9 4f		      lda	#<(start-1)
   5900  2fdc		       48		      pha
   5901  2fdd		       48		      pha
   5902  2fde		       8a		      txa
   5903  2fdf		       48		      pha
   5904  2fe0		       ba		      tsx
   5905  2fe1					      if	bankswitch != 64
   5906  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   5907  2fe3		       2a		      rol
   5908  2fe4		       2a		      rol
   5909  2fe5		       2a		      rol
   5910  2fe6		       2a		      rol
   5911  2fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5912  2fe9		       aa		      tax
   5913  2fea		       e8		      inx
   5914  2feb				  -	      else
   5915  2feb				  -	      lda	4,x	; get high byte of return address
   5916  2feb				  -	      tay
   5917  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5918  2feb				  -	      sta	4,x
   5919  2feb				  -	      tya
   5920  2feb				  -	      lsr
   5921  2feb				  -	      lsr
   5922  2feb				  -	      lsr
   5923  2feb				  -	      lsr
   5924  2feb				  -	      tax
   5925  2feb				  -	      inx
   5926  2feb					      endif
   5927  2feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5928  2fee		       68		      pla
   5929  2fef		       aa		      tax
   5930  2ff0		       68		      pla
   5931  2ff1		       60		      rts
   5932  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5933  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5934  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5935  2ff2					      endif
   5936  2ffc					      ORG	$2FFC
   5937  2ffc					      RORG	$3FFC
   5938  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   5939  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   5940  3000					      ORG	$3000
   5941  3000					      RORG	$5000
   5942  3000				   .
   5943  3000							; 
   5944  3000
   5945  3000				   .
   5946  3000							; 
   5947  3000
   5948  3000				   .
   5949  3000							; 
   5950  3000
   5951  3000				   .
   5952  3000							; 
   5953  3000
   5954  3000				   .
   5955  3000							; 
   5956  3000
   5957  3000				   .
   5958  3000							; 
   5959  3000
   5960  3000				   .
   5961  3000							; 
   5962  3000
   5963  3000				   .
   5964  3000							; 
   5965  3000
   5966  3000				   .
   5967  3000							; 
   5968  3000
   5969  3000				   .
   5970  3000							; 
   5971  3000
   5972  3000				   .
   5973  3000							; 
   5974  3000
   5975  3000				   .__Game_Over_Setup
   5976  3000							; __Game_Over_Setup
   5977  3000
   5978  3000				   .
   5979  3000							; 
   5980  3000
   5981  3000				   .
   5982  3000							; 
   5983  3000
   5984  3000				   .
   5985  3000							; 
   5986  3000
   5987  3000				   .
   5988  3000							; 
   5989  3000
   5990  3000				   .
   5991  3000							; 
   5992  3000
   5993  3000				   .
   5994  3000							; 
   5995  3000
   5996  3000				   .
   5997  3000							; 
   5998  3000
   5999  3000				   .
   6000  3000							; 
   6001  3000
   6002  3000				   .
   6003  3000							; 
   6004  3000
   6005  3000				   .
   6006  3000							; 
   6007  3000
   6008  3000				   .
   6009  3000							; 
   6010  3000
   6011  3000				   .L0231		;  if _sc1  >	_High_Score1 then goto __New_High_Score
   6012  3000
   6013  3000		       a5 e9		      LDA	_High_Score1
   6014  3002		       c5 93		      CMP	_sc1
   6015  3004		       b0 03		      BCS	.skipL0231
   6016  3006				   .condpart118
   6017  3006		       4c 39 50 	      jmp	.__New_High_Score
   6018  3009
   6019  3009				   .skipL0231
   6020  3009				   .L0232		;  if _sc1  <	_High_Score1 then goto __Skip_High_Score
   6021  3009
   6022  3009		       a5 93		      LDA	_sc1
   6023  300b		       c5 e9		      CMP	_High_Score1
   6024  300d		       b0 03		      BCS	.skipL0232
   6025  300f				   .condpart119
   6026  300f		       4c 45 50 	      jmp	.__Skip_High_Score
   6027  3012
   6028  3012				   .skipL0232
   6029  3012				   .
   6030  3012							; 
   6031  3012
   6032  3012				   .
   6033  3012							; 
   6034  3012
   6035  3012				   .
   6036  3012							; 
   6037  3012
   6038  3012				   .
   6039  3012							; 
   6040  3012
   6041  3012				   .L0233		;  if _sc2  >	_High_Score2 then goto __New_High_Score
   6042  3012
   6043  3012		       a5 ea		      LDA	_High_Score2
   6044  3014		       c5 94		      CMP	_sc2
   6045  3016		       b0 03		      BCS	.skipL0233
   6046  3018				   .condpart120
   6047  3018		       4c 39 50 	      jmp	.__New_High_Score
   6048  301b
   6049  301b				   .skipL0233
   6050  301b				   .L0234		;  if _sc2  <	_High_Score2 then goto __Skip_High_Score
   6051  301b
   6052  301b		       a5 94		      LDA	_sc2
   6053  301d		       c5 ea		      CMP	_High_Score2
   6054  301f		       b0 03		      BCS	.skipL0234
   6055  3021				   .condpart121
   6056  3021		       4c 45 50 	      jmp	.__Skip_High_Score
   6057  3024
   6058  3024				   .skipL0234
   6059  3024				   .
   6060  3024							; 
   6061  3024
   6062  3024				   .
   6063  3024							; 
   6064  3024
   6065  3024				   .
   6066  3024							; 
   6067  3024
   6068  3024				   .
   6069  3024							; 
   6070  3024
   6071  3024				   .L0235		;  if _sc3  >	_High_Score3 then goto __New_High_Score
   6072  3024
   6073  3024		       a5 eb		      LDA	_High_Score3
   6074  3026		       c5 95		      CMP	_sc3
   6075  3028		       b0 03		      BCS	.skipL0235
   6076  302a				   .condpart122
   6077  302a		       4c 39 50 	      jmp	.__New_High_Score
   6078  302d
   6079  302d				   .skipL0235
   6080  302d				   .L0236		;  if _sc3  <	_High_Score3 then goto __Skip_High_Score
   6081  302d
   6082  302d		       a5 95		      LDA	_sc3
   6083  302f		       c5 eb		      CMP	_High_Score3
   6084  3031		       b0 03		      BCS	.skipL0236
   6085  3033				   .condpart123
   6086  3033		       4c 45 50 	      jmp	.__Skip_High_Score
   6087  3036
   6088  3036				   .skipL0236
   6089  3036				   .
   6090  3036							; 
   6091  3036
   6092  3036				   .
   6093  3036							; 
   6094  3036
   6095  3036				   .
   6096  3036							; 
   6097  3036
   6098  3036				   .
   6099  3036							; 
   6100  3036
   6101  3036				   .L0237		;  goto __Skip_High_Score
   6102  3036
   6103  3036		       4c 45 50 	      jmp	.__Skip_High_Score
   6104  3039
   6105  3039				   .
   6106  3039							; 
   6107  3039
   6108  3039				   .
   6109  3039							; 
   6110  3039
   6111  3039				   .
   6112  3039							; 
   6113  3039
   6114  3039				   .
   6115  3039							; 
   6116  3039
   6117  3039				   .__New_High_Score
   6118  3039							; __New_High_Score
   6119  3039
   6120  3039				   .
   6121  3039							; 
   6122  3039
   6123  3039				   .L0238		;  _High_Score1  =  _sc1  :  _High_Score2  =  _sc2  :	_High_Score3  =  _sc3
   6124  3039
   6125  3039		       a5 93		      LDA	_sc1
   6126  303b		       85 e9		      STA	_High_Score1
   6127  303d		       a5 94		      LDA	_sc2
   6128  303f		       85 ea		      STA	_High_Score2
   6129  3041		       a5 95		      LDA	_sc3
   6130  3043		       85 eb		      STA	_High_Score3
   6131  3045				   .
   6132  3045							; 
   6133  3045
   6134  3045				   .__Skip_High_Score
   6135  3045							; __Skip_High_Score
   6136  3045
   6137  3045				   .
   6138  3045							; 
   6139  3045
   6140  3045				   .
   6141  3045							; 
   6142  3045
   6143  3045				   .
   6144  3045							; 
   6145  3045
   6146  3045				   .
   6147  3045							; 
   6148  3045
   6149  3045				   .
   6150  3045							; 
   6151  3045
   6152  3045				   .L0239		;  if !_Bit2_Game_Control{2} then goto __Start_Restart bank1
   6153  3045
   6154  3045		       a5 ec		      LDA	_Bit2_Game_Control
   6155  3047		       29 04		      AND	#4
   6156  3049		       d0 12		      BNE	.skipL0239
   6157  304b				   .condpart124
   6158  304b		       85 ee		      sta	temp7
   6159  304d		       a9 0f		      lda	#>(.__Start_Restart-1)
   6160  304f		       48		      pha
   6161  3050		       a9 ff		      lda	#<(.__Start_Restart-1)
   6162  3052		       48		      pha
   6163  3053		       a5 ee		      lda	temp7
   6164  3055		       48		      pha
   6165  3056		       8a		      txa
   6166  3057		       48		      pha
   6167  3058		       a2 01		      ldx	#1
   6168  305a		       4c eb ff 	      jmp	BS_jsr
   6169  305d				   .skipL0239
   6170  305d				   .
   6171  305d							; 
   6172  305d
   6173  305d				   .
   6174  305d							; 
   6175  305d
   6176  305d				   .
   6177  305d							; 
   6178  305d
   6179  305d				   .
   6180  305d							; 
   6181  305d
   6182  305d				   .
   6183  305d							; 
   6184  305d
   6185  305d				   .
   6186  305d							; 
   6187  305d
   6188  305d				   .L0240		;  _Score1_Mem  =  _sc1  :  _Score2_Mem  =  _sc2  :  _Score3_Mem  =  _sc3
   6189  305d
   6190  305d		       a5 93		      LDA	_sc1
   6191  305f		       85 e6		      STA	_Score1_Mem
   6192  3061		       a5 94		      LDA	_sc2
   6193  3063		       85 e7		      STA	_Score2_Mem
   6194  3065		       a5 95		      LDA	_sc3
   6195  3067		       85 e8		      STA	_Score3_Mem
   6196  3069				   .
   6197  3069							; 
   6198  3069
   6199  3069				   .
   6200  3069							; 
   6201  3069
   6202  3069				   .
   6203  3069							; 
   6204  3069
   6205  3069				   .
   6206  3069							; 
   6207  3069
   6208  3069				   .
   6209  3069							; 
   6210  3069
   6211  3069				   .
   6212  3069							; 
   6213  3069
   6214  3069				   .L0241		;  _Master_Counter  =	0  :  _Frame_Counter  =  0
   6215  3069
   6216  3069		       a9 00		      LDA	#0
   6217  306b		       85 d8		      STA	_Master_Counter
   6218  306d		       85 d9		      STA	_Frame_Counter
   6219  306f				   .
   6220  306f							; 
   6221  306f
   6222  306f				   .
   6223  306f							; 
   6224  306f
   6225  306f				   .
   6226  306f							; 
   6227  306f
   6228  306f				   .
   6229  306f							; 
   6230  306f
   6231  306f				   .
   6232  306f							; 
   6233  306f
   6234  306f				   .
   6235  306f							; 
   6236  306f
   6237  306f				   .L0242		;  player0y  =  200  :  player1y  =  200  :  missile1y  =  200
   6238  306f
   6239  306f		       a9 c8		      LDA	#200
   6240  3071		       85 85		      STA	player0y
   6241  3073		       85 86		      STA	player1y
   6242  3075		       85 88		      STA	missile1y
   6243  3077				   .
   6244  3077							; 
   6245  3077
   6246  3077				   .
   6247  3077							; 
   6248  3077
   6249  3077				   .
   6250  3077							; 
   6251  3077
   6252  3077				   .
   6253  3077							; 
   6254  3077
   6255  3077				   .
   6256  3077							; 
   6257  3077
   6258  3077				   .
   6259  3077							; 
   6260  3077
   6261  3077				   .
   6262  3077							; 
   6263  3077
   6264  3077				   .
   6265  3077							; 
   6266  3077
   6267  3077				   .
   6268  3077							; 
   6269  3077
   6270  3077				   .
   6271  3077							; 
   6272  3077
   6273  3077				   .
   6274  3077							; 
   6275  3077
   6276  3077				   .L0243		;  _Bit0_Reset_Restrainer{0}  =  1
   6277  3077
   6278  3077		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6279  3079		       09 01		      ORA	#1
   6280  307b		       85 ec		      STA	_Bit0_Reset_Restrainer
   6281  307d				   .
   6282  307d							; 
   6283  307d
   6284  307d				   .
   6285  307d							; 
   6286  307d
   6287  307d				   .
   6288  307d							; 
   6289  307d
   6290  307d				   .
   6291  307d							; 
   6292  307d
   6293  307d				   .
   6294  307d							; 
   6295  307d
   6296  307d				   .
   6297  307d							; 
   6298  307d
   6299  307d				   .L0244		;  playfield:
   6300  307d
   6301  307d				  -	      ifconst	pfres
   6302  307d				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
   6303  307d					      else
   6304  307d		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
   6305  307f					      endif
   6306  307f		       4c ae 50 	      jmp	pflabel2
   6307  3082				   PF_data2
   6308  3082		       7e bf		      .byte.b	%01111110, %10111111
   6309  3084					      if	(pfwidth>2)
   6310  3084		       ff 7d		      .byte.b	%11111111, %01111101
   6311  3086					      endif
   6312  3086		       60 b3		      .byte.b	%01100000, %10110011
   6313  3088					      if	(pfwidth>2)
   6314  3088		       99 0d		      .byte.b	%10011001, %00001101
   6315  308a					      endif
   6316  308a		       6e bf		      .byte.b	%01101110, %10111111
   6317  308c					      if	(pfwidth>2)
   6318  308c		       99 3d		      .byte.b	%10011001, %00111101
   6319  308e					      endif
   6320  308e		       66 b3		      .byte.b	%01100110, %10110011
   6321  3090					      if	(pfwidth>2)
   6322  3090		       99 0d		      .byte.b	%10011001, %00001101
   6323  3092					      endif
   6324  3092		       7e b3		      .byte.b	%01111110, %10110011
   6325  3094					      if	(pfwidth>2)
   6326  3094		       99 7d		      .byte.b	%10011001, %01111101
   6327  3096					      endif
   6328  3096		       00 00		      .byte.b	%00000000, %00000000
   6329  3098					      if	(pfwidth>2)
   6330  3098		       00 00		      .byte.b	%00000000, %00000000
   6331  309a					      endif
   6332  309a		       1f cd		      .byte.b	%00011111, %11001101
   6333  309c					      if	(pfwidth>2)
   6334  309c		       7d 1f		      .byte.b	%01111101, %00011111
   6335  309e					      endif
   6336  309e		       19 cd		      .byte.b	%00011001, %11001101
   6337  30a0					      if	(pfwidth>2)
   6338  30a0		       61 19		      .byte.b	%01100001, %00011001
   6339  30a2					      endif
   6340  30a2		       19 cd		      .byte.b	%00011001, %11001101
   6341  30a4					      if	(pfwidth>2)
   6342  30a4		       79 0f		      .byte.b	%01111001, %00001111
   6343  30a6					      endif
   6344  30a6		       19 cd		      .byte.b	%00011001, %11001101
   6345  30a8					      if	(pfwidth>2)
   6346  30a8		       61 19		      .byte.b	%01100001, %00011001
   6347  30aa					      endif
   6348  30aa		       1f 31		      .byte.b	%00011111, %00110001
   6349  30ac					      if	(pfwidth>2)
   6350  30ac		       7d 19		      .byte.b	%01111101, %00011001
   6351  30ae					      endif
   6352  30ae				   pflabel2
   6353  30ae		       bd 82 50 	      lda	PF_data2,x
   6354  30b1		       95 a4		      sta	playfield,x
   6355  30b3		       ca		      dex
   6356  30b4		       10 f8		      bpl	pflabel2
   6357  30b6				   .
   6358  30b6							; 
   6359  30b6
   6360  30b6				   .
   6361  30b6							; 
   6362  30b6
   6363  30b6				   .
   6364  30b6							; 
   6365  30b6
   6366  30b6				   .
   6367  30b6							; 
   6368  30b6
   6369  30b6				   .
   6370  30b6							; 
   6371  30b6
   6372  30b6				   .
   6373  30b6							; 
   6374  30b6
   6375  30b6				   .
   6376  30b6							; 
   6377  30b6
   6378  30b6				   .
   6379  30b6							; 
   6380  30b6
   6381  30b6				   .
   6382  30b6							; 
   6383  30b6
   6384  30b6				   .
   6385  30b6							; 
   6386  30b6
   6387  30b6				   .
   6388  30b6							; 
   6389  30b6
   6390  30b6				   .__Game_Over_Loop
   6391  30b6							; __Game_Over_Loop
   6392  30b6
   6393  30b6				   .
   6394  30b6							; 
   6395  30b6
   6396  30b6				   .
   6397  30b6							; 
   6398  30b6
   6399  30b6				   .
   6400  30b6							; 
   6401  30b6
   6402  30b6				   .
   6403  30b6							; 
   6404  30b6
   6405  30b6				   .
   6406  30b6							; 
   6407  30b6
   6408  30b6				   .
   6409  30b6							; 
   6410  30b6
   6411  30b6				   .
   6412  30b6							; 
   6413  30b6
   6414  30b6				   .
   6415  30b6							; 
   6416  30b6
   6417  30b6				   .
   6418  30b6							; 
   6419  30b6
   6420  30b6				   .
   6421  30b6							; 
   6422  30b6
   6423  30b6				   .
   6424  30b6							; 
   6425  30b6
   6426  30b6				   .
   6427  30b6							; 
   6428  30b6
   6429  30b6				   .
   6430  30b6							; 
   6431  30b6
   6432  30b6				   .
   6433  30b6							; 
   6434  30b6
   6435  30b6				   .
   6436  30b6							; 
   6437  30b6
   6438  30b6				   .
   6439  30b6							; 
   6440  30b6
   6441  30b6				   .
   6442  30b6							; 
   6443  30b6
   6444  30b6				   .
   6445  30b6							; 
   6446  30b6
   6447  30b6				   .
   6448  30b6							; 
   6449  30b6
   6450  30b6				   .L0245		;  _Master_Counter  =	_Master_Counter  +  1
   6451  30b6
   6452  30b6		       e6 d8		      INC	_Master_Counter
   6453  30b8				   .
   6454  30b8							; 
   6455  30b8
   6456  30b8				   .
   6457  30b8							; 
   6458  30b8
   6459  30b8				   .
   6460  30b8							; 
   6461  30b8
   6462  30b8				   .
   6463  30b8							; 
   6464  30b8
   6465  30b8				   .
   6466  30b8							; 
   6467  30b8
   6468  30b8				   .L0246		;  if _Master_Counter	<  120 then goto __Skip_20_Second_Counter
   6469  30b8
   6470  30b8		       a5 d8		      LDA	_Master_Counter
   6471  30ba		       c9 78		      CMP	#120
   6472  30bc		       b0 03		      BCS	.skipL0246
   6473  30be				   .condpart125
   6474  30be		       4c 2b 51 	      jmp	.__Skip_20_Second_Counter
   6475  30c1
   6476  30c1				   .skipL0246
   6477  30c1				   .
   6478  30c1							; 
   6479  30c1
   6480  30c1				   .
   6481  30c1							; 
   6482  30c1
   6483  30c1				   .
   6484  30c1							; 
   6485  30c1
   6486  30c1				   .
   6487  30c1							; 
   6488  30c1
   6489  30c1				   .
   6490  30c1							; 
   6491  30c1
   6492  30c1				   .L0247		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
   6493  30c1
   6494  30c1		       e6 d9		      INC	_Frame_Counter
   6495  30c3		       a9 00		      LDA	#0
   6496  30c5		       85 d8		      STA	_Master_Counter
   6497  30c7				   .
   6498  30c7							; 
   6499  30c7
   6500  30c7				   .
   6501  30c7							; 
   6502  30c7
   6503  30c7				   .
   6504  30c7							; 
   6505  30c7
   6506  30c7				   .
   6507  30c7							; 
   6508  30c7
   6509  30c7				   .
   6510  30c7							; 
   6511  30c7
   6512  30c7				   .
   6513  30c7							; 
   6514  30c7
   6515  30c7				   .
   6516  30c7							; 
   6517  30c7
   6518  30c7				   .
   6519  30c7							; 
   6520  30c7
   6521  30c7				   .L0248		;  if _Frame_Counter  >  9 then _Bit2_Game_Control{2}	=  0  :  _sc1 = _Score1_Mem  :	_sc2 = _Score2_Mem  :  _sc3 = _Score3_Mem :  goto __Start_Restart bank1
   6522  30c7
   6523  30c7		       a9 09		      LDA	#9
   6524  30c9		       c5 d9		      CMP	_Frame_Counter
   6525  30cb		       b0 24		      BCS	.skipL0248
   6526  30cd				   .condpart126
   6527  30cd		       a5 ec		      LDA	_Bit2_Game_Control
   6528  30cf		       29 fb		      AND	#251
   6529  30d1		       85 ec		      STA	_Bit2_Game_Control
   6530  30d3		       a5 e6		      LDA	_Score1_Mem
   6531  30d5		       85 93		      STA	_sc1
   6532  30d7		       a5 e7		      LDA	_Score2_Mem
   6533  30d9		       85 94		      STA	_sc2
   6534  30db		       a5 e8		      LDA	_Score3_Mem
   6535  30dd		       85 95		      STA	_sc3
   6536  30df		       85 ee		      sta	temp7
   6537  30e1		       a9 0f		      lda	#>(.__Start_Restart-1)
   6538  30e3		       48		      pha
   6539  30e4		       a9 ff		      lda	#<(.__Start_Restart-1)
   6540  30e6		       48		      pha
   6541  30e7		       a5 ee		      lda	temp7
   6542  30e9		       48		      pha
   6543  30ea		       8a		      txa
   6544  30eb		       48		      pha
   6545  30ec		       a2 01		      ldx	#1
   6546  30ee		       4c eb ff 	      jmp	BS_jsr
   6547  30f1				   .skipL0248
   6548  30f1				   .
   6549  30f1							; 
   6550  30f1
   6551  30f1				   .
   6552  30f1							; 
   6553  30f1
   6554  30f1				   .
   6555  30f1							; 
   6556  30f1
   6557  30f1				   .
   6558  30f1							; 
   6559  30f1
   6560  30f1				   .L0249		;  _Bit6_Swap_Scores{6}  =  !_Bit6_Swap_Scores{6}
   6561  30f1
   6562  30f1		       a5 ec		      LDA	_Bit6_Swap_Scores
   6563  30f3		       29 40		      AND	#64
   6564  30f5		       08		      PHP
   6565  30f6		       a5 ec		      LDA	_Bit6_Swap_Scores
   6566  30f8		       29 bf		      AND	#191
   6567  30fa		       28		      PLP
   6568  30fb		       d0 02		      .byte.b	$D0, $02
   6569  30fd		       09 40		      ORA	#64
   6570  30ff		       85 ec		      STA	_Bit6_Swap_Scores
   6571  3101				   .
   6572  3101							; 
   6573  3101
   6574  3101				   .
   6575  3101							; 
   6576  3101
   6577  3101				   .
   6578  3101							; 
   6579  3101
   6580  3101				   .
   6581  3101							; 
   6582  3101
   6583  3101				   .L0250		;  if !_Bit6_Swap_Scores{6} then goto __GO_Current_Score
   6584  3101
   6585  3101		       24 ec		      BIT	_Bit6_Swap_Scores
   6586  3103		       70 03		      BVS	.skipL0250
   6587  3105				   .condpart127
   6588  3105		       4c 1b 51 	      jmp	.__GO_Current_Score
   6589  3108
   6590  3108				   .skipL0250
   6591  3108				   .
   6592  3108							; 
   6593  3108
   6594  3108				   .
   6595  3108							; 
   6596  3108
   6597  3108				   .
   6598  3108							; 
   6599  3108
   6600  3108				   .
   6601  3108							; 
   6602  3108
   6603  3108				   .L0251		;  scorecolor	=  $AE
   6604  3108
   6605  3108		       a9 ae		      LDA	#$AE
   6606  310a		       85 a3		      STA	scorecolor
   6607  310c				   .
   6608  310c							; 
   6609  310c
   6610  310c				   .L0252		;  _sc1  =  _High_Score1  :  _sc2  =  _High_Score2  :	_sc3  =  _High_Score3
   6611  310c
   6612  310c		       a5 e9		      LDA	_High_Score1
   6613  310e		       85 93		      STA	_sc1
   6614  3110		       a5 ea		      LDA	_High_Score2
   6615  3112		       85 94		      STA	_sc2
   6616  3114		       a5 eb		      LDA	_High_Score3
   6617  3116		       85 95		      STA	_sc3
   6618  3118				   .
   6619  3118							; 
   6620  3118
   6621  3118				   .L0253		;  goto __Skip_20_Second_Counter
   6622  3118
   6623  3118		       4c 2b 51 	      jmp	.__Skip_20_Second_Counter
   6624  311b
   6625  311b				   .
   6626  311b							; 
   6627  311b
   6628  311b				   .
   6629  311b							; 
   6630  311b
   6631  311b				   .
   6632  311b							; 
   6633  311b
   6634  311b				   .
   6635  311b							; 
   6636  311b
   6637  311b				   .__GO_Current_Score
   6638  311b							; __GO_Current_Score
   6639  311b
   6640  311b				   .
   6641  311b							; 
   6642  311b
   6643  311b				   .L0254		;  scorecolor	=  $1C
   6644  311b
   6645  311b		       a9 1c		      LDA	#$1C
   6646  311d		       85 a3		      STA	scorecolor
   6647  311f				   .
   6648  311f							; 
   6649  311f
   6650  311f				   .L0255		;  _sc1  =  _Score1_Mem  :  _sc2  =  _Score2_Mem  :  _sc3  =  _Score3_Mem
   6651  311f
   6652  311f		       a5 e6		      LDA	_Score1_Mem
   6653  3121		       85 93		      STA	_sc1
   6654  3123		       a5 e7		      LDA	_Score2_Mem
   6655  3125		       85 94		      STA	_sc2
   6656  3127		       a5 e8		      LDA	_Score3_Mem
   6657  3129		       85 95		      STA	_sc3
   6658  312b				   .
   6659  312b							; 
   6660  312b
   6661  312b				   .__Skip_20_Second_Counter
   6662  312b							; __Skip_20_Second_Counter
   6663  312b
   6664  312b				   .
   6665  312b							; 
   6666  312b
   6667  312b				   .
   6668  312b							; 
   6669  312b
   6670  312b				   .
   6671  312b							; 
   6672  312b
   6673  312b				   .
   6674  312b							; 
   6675  312b
   6676  312b				   .
   6677  312b							; 
   6678  312b
   6679  312b				   .
   6680  312b							; 
   6681  312b
   6682  312b				   .
   6683  312b							; 
   6684  312b
   6685  312b				   .
   6686  312b							; 
   6687  312b
   6688  312b				   .
   6689  312b							; 
   6690  312b
   6691  312b				   .
   6692  312b							; 
   6693  312b
   6694  312b				   .
   6695  312b							; 
   6696  312b
   6697  312b				   .
   6698  312b							; 
   6699  312b
   6700  312b				   .
   6701  312b							; 
   6702  312b
   6703  312b				   .
   6704  312b							; 
   6705  312b
   6706  312b				   .L0256		;  if _Frame_Counter then goto __Skip_First_Colors
   6707  312b
   6708  312b		       a5 d9		      LDA	_Frame_Counter
   6709  312d		       f0 03		      BEQ	.skipL0256
   6710  312f				   .condpart128
   6711  312f		       4c 45 51 	      jmp	.__Skip_First_Colors
   6712  3132
   6713  3132				   .skipL0256
   6714  3132				   .
   6715  3132							; 
   6716  3132
   6717  3132				   .
   6718  3132							; 
   6719  3132
   6720  3132				   .
   6721  3132							; 
   6722  3132
   6723  3132				   .
   6724  3132							; 
   6725  3132
   6726  3132				   .L0257		;  COLUBK  =  $44
   6727  3132
   6728  3132		       a9 44		      LDA	#$44
   6729  3134		       85 09		      STA	COLUBK
   6730  3136				   .
   6731  3136							; 
   6732  3136
   6733  3136				   .
   6734  3136							; 
   6735  3136
   6736  3136				   .
   6737  3136							; 
   6738  3136
   6739  3136				   .
   6740  3136							; 
   6741  3136
   6742  3136				   .L0258		;  pfcolors:
   6743  3136
   6744  3136		       a9 2e		      lda	# $2E
   6745  3138		       85 08		      sta	COLUPF
   6746  313a				  -	      ifconst	pfres
   6747  313a				  -	      lda	#>(pfcolorlabel13-130+pfres*pfwidth)
   6748  313a					      else
   6749  313a		       a9 f5		      lda	#>(pfcolorlabel13-82)
   6750  313c					      endif
   6751  313c		       85 f1		      sta	pfcolortable+1
   6752  313e				  -	      ifconst	pfres
   6753  313e				  -	      lda	#<(pfcolorlabel13-130+pfres*pfwidth)
   6754  313e					      else
   6755  313e		       a9 06		      lda	#<(pfcolorlabel13-82)
   6756  3140					      endif
   6757  3140		       85 f0		      sta	pfcolortable
   6758  3142				   .
   6759  3142							; 
   6760  3142
   6761  3142				   .L0259		;  goto __Skip_Second_Colors
   6762  3142
   6763  3142		       4c 55 51 	      jmp	.__Skip_Second_Colors
   6764  3145
   6765  3145				   .
   6766  3145							; 
   6767  3145
   6768  3145				   .__Skip_First_Colors
   6769  3145							; __Skip_First_Colors
   6770  3145
   6771  3145				   .
   6772  3145							; 
   6773  3145
   6774  3145				   .
   6775  3145							; 
   6776  3145
   6777  3145				   .
   6778  3145							; 
   6779  3145
   6780  3145				   .
   6781  3145							; 
   6782  3145
   6783  3145				   .L0260		;  COLUBK  =  $D2
   6784  3145
   6785  3145		       a9 d2		      LDA	#$D2
   6786  3147		       85 09		      STA	COLUBK
   6787  3149				   .
   6788  3149							; 
   6789  3149
   6790  3149				   .
   6791  3149							; 
   6792  3149
   6793  3149				   .
   6794  3149							; 
   6795  3149
   6796  3149				   .
   6797  3149							; 
   6798  3149
   6799  3149				   .L0261		;  pfcolors:
   6800  3149
   6801  3149		       a9 de		      lda	# $DE
   6802  314b		       85 08		      sta	COLUPF
   6803  314d				  -	      ifconst	pfres
   6804  314d				  -	      lda	#>(pfcolorlabel13-129+pfres*pfwidth)
   6805  314d					      else
   6806  314d		       a9 f5		      lda	#>(pfcolorlabel13-81)
   6807  314f					      endif
   6808  314f		       85 f1		      sta	pfcolortable+1
   6809  3151				  -	      ifconst	pfres
   6810  3151				  -	      lda	#<(pfcolorlabel13-129+pfres*pfwidth)
   6811  3151					      else
   6812  3151		       a9 07		      lda	#<(pfcolorlabel13-81)
   6813  3153					      endif
   6814  3153		       85 f0		      sta	pfcolortable
   6815  3155				   .
   6816  3155							; 
   6817  3155
   6818  3155				   .__Skip_Second_Colors
   6819  3155							; __Skip_Second_Colors
   6820  3155
   6821  3155				   .
   6822  3155							; 
   6823  3155
   6824  3155				   .
   6825  3155							; 
   6826  3155
   6827  3155				   .
   6828  3155							; 
   6829  3155
   6830  3155				   .
   6831  3155							; 
   6832  3155
   6833  3155				   .
   6834  3155							; 
   6835  3155
   6836  3155				   .
   6837  3155							; 
   6838  3155
   6839  3155				   .
   6840  3155							; 
   6841  3155
   6842  3155				   .L0262		;  drawscreen
   6843  3155
   6844  3155		       85 ee		      sta	temp7
   6845  3157		       a9 51		      lda	#>(ret_point13-1)
   6846  3159		       48		      pha
   6847  315a		       a9 6c		      lda	#<(ret_point13-1)
   6848  315c		       48		      pha
   6849  315d		       a9 f4		      lda	#>(drawscreen-1)
   6850  315f		       48		      pha
   6851  3160		       a9 39		      lda	#<(drawscreen-1)
   6852  3162		       48		      pha
   6853  3163		       a5 ee		      lda	temp7
   6854  3165		       48		      pha
   6855  3166		       8a		      txa
   6856  3167		       48		      pha
   6857  3168		       a2 08		      ldx	#8
   6858  316a		       4c eb ff 	      jmp	BS_jsr
   6859  316d				   ret_point13
   6860  316d				   .
   6861  316d							; 
   6862  316d
   6863  316d				   .
   6864  316d							; 
   6865  316d
   6866  316d				   .
   6867  316d							; 
   6868  316d
   6869  316d				   .
   6870  316d							; 
   6871  316d
   6872  316d				   .
   6873  316d							; 
   6874  316d
   6875  316d				   .
   6876  316d							; 
   6877  316d
   6878  316d				   .
   6879  316d							; 
   6880  316d
   6881  316d				   .
   6882  316d							; 
   6883  316d
   6884  316d				   .
   6885  316d							; 
   6886  316d
   6887  316d				   .
   6888  316d							; 
   6889  316d
   6890  316d				   .
   6891  316d							; 
   6892  316d
   6893  316d				   .
   6894  316d							; 
   6895  316d
   6896  316d				   .
   6897  316d							; 
   6898  316d
   6899  316d				   .
   6900  316d							; 
   6901  316d
   6902  316d				   .L0263		;  if _Frame_Counter  =  0 then goto __Game_Over_Loop
   6903  316d
   6904  316d		       a5 d9		      LDA	_Frame_Counter
   6905  316f		       c9 00		      CMP	#0
   6906  3171		       d0 03		      BNE	.skipL0263
   6907  3173				   .condpart129
   6908  3173		       4c b6 50 	      jmp	.__Game_Over_Loop
   6909  3176
   6910  3176				   .skipL0263
   6911  3176				   .
   6912  3176							; 
   6913  3176
   6914  3176				   .
   6915  3176							; 
   6916  3176
   6917  3176				   .
   6918  3176							; 
   6919  3176
   6920  3176				   .
   6921  3176							; 
   6922  3176
   6923  3176				   .
   6924  3176							; 
   6925  3176
   6926  3176				   .L0264		;  if !switchreset  &&  !joy0fire then _Bit0_Reset_Restrainer{0}  =  0  :  goto __Game_Over_Loop
   6927  3176
   6928  3176		       a9 01		      lda	#1
   6929  3178		       2c 82 02 	      bit	SWCHB
   6930  317b		       f0 0d		      BEQ	.skipL0264
   6931  317d				   .condpart130
   6932  317d		       24 0c		      bit	INPT4
   6933  317f		       10 09		      BPL	.skip130then
   6934  3181				   .condpart131
   6935  3181		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6936  3183		       29 fe		      AND	#254
   6937  3185		       85 ec		      STA	_Bit0_Reset_Restrainer
   6938  3187		       4c b6 50 	      jmp	.__Game_Over_Loop
   6939  318a
   6940  318a				   .skip130then
   6941  318a				   .skipL0264
   6942  318a				   .
   6943  318a							; 
   6944  318a
   6945  318a				   .
   6946  318a							; 
   6947  318a
   6948  318a				   .
   6949  318a							; 
   6950  318a
   6951  318a				   .
   6952  318a							; 
   6953  318a
   6954  318a				   .
   6955  318a							; 
   6956  318a
   6957  318a				   .L0265		;  if _Bit0_Reset_Restrainer{0} then goto __Game_Over_Loop
   6958  318a
   6959  318a		       a5 ec		      LDA	_Bit0_Reset_Restrainer
   6960  318c		       4a		      LSR
   6961  318d		       90 03		      BCC	.skipL0265
   6962  318f				   .condpart132
   6963  318f		       4c b6 50 	      jmp	.__Game_Over_Loop
   6964  3192
   6965  3192				   .skipL0265
   6966  3192				   .
   6967  3192							; 
   6968  3192
   6969  3192				   .
   6970  3192							; 
   6971  3192
   6972  3192				   .
   6973  3192							; 
   6974  3192
   6975  3192				   .
   6976  3192							; 
   6977  3192
   6978  3192				   .L0266		;  goto __Start_Restart bank1
   6979  3192
   6980  3192		       85 ee		      sta	temp7
   6981  3194		       a9 0f		      lda	#>(.__Start_Restart-1)
   6982  3196		       48		      pha
   6983  3197		       a9 ff		      lda	#<(.__Start_Restart-1)
   6984  3199		       48		      pha
   6985  319a		       a5 ee		      lda	temp7
   6986  319c		       48		      pha
   6987  319d		       8a		      txa
   6988  319e		       48		      pha
   6989  319f		       a2 01		      ldx	#1
   6990  31a1		       4c eb ff 	      jmp	BS_jsr
   6991  31a4				   .
   6992  31a4							; 
   6993  31a4
   6994  31a4				   .
   6995  31a4							; 
   6996  31a4
   6997  31a4				   .
   6998  31a4							; 
   6999  31a4
   7000  31a4				   .
   7001  31a4							; 
   7002  31a4
   7003  31a4				   .
   7004  31a4							; 
   7005  31a4
   7006  31a4				   .
   7007  31a4							; 
   7008  31a4
   7009  31a4				   .
   7010  31a4							; 
   7011  31a4
   7012  31a4				   .
   7013  31a4							; 
   7014  31a4
   7015  31a4				   .
   7016  31a4							; 
   7017  31a4
   7018  31a4				   .
   7019  31a4							; 
   7020  31a4
   7021  31a4				   .
   7022  31a4							; 
   7023  31a4
   7024  31a4				   .
   7025  31a4							; 
   7026  31a4
   7027  31a4				   .
   7028  31a4							; 
   7029  31a4
   7030  31a4				   .
   7031  31a4							; 
   7032  31a4
   7033  31a4				   .
   7034  31a4							; 
   7035  31a4
   7036  31a4				   .
   7037  31a4							; 
   7038  31a4
   7039  31a4				   .
   7040  31a4							; 
   7041  31a4
   7042  31a4				   .
   7043  31a4							; 
   7044  31a4
   7045  31a4				   .
   7046  31a4							; 
   7047  31a4
   7048  31a4				   .
   7049  31a4							; 
   7050  31a4
   7051  31a4				   .
   7052  31a4							; 
   7053  31a4
   7054  31a4				   .
   7055  31a4							; 
   7056  31a4
   7057  31a4				   .__Pause_Setup
   7058  31a4							; __Pause_Setup
   7059  31a4
   7060  31a4				   .
   7061  31a4							; 
   7062  31a4
   7063  31a4				   .
   7064  31a4							; 
   7065  31a4
   7066  31a4				   .
   7067  31a4							; 
   7068  31a4
   7069  31a4				   .
   7070  31a4							; 
   7071  31a4
   7072  31a4				   .
   7073  31a4							; 
   7074  31a4
   7075  31a4				   .
   7076  31a4							; 
   7077  31a4
   7078  31a4				   .L0267		;  AUDV0  =  0  :  AUDV1  =  0
   7079  31a4
   7080  31a4		       a9 00		      LDA	#0
   7081  31a6		       85 19		      STA	AUDV0
   7082  31a8		       85 1a		      STA	AUDV1
   7083  31aa				   .
   7084  31aa							; 
   7085  31aa
   7086  31aa				   .
   7087  31aa							; 
   7088  31aa
   7089  31aa				   .
   7090  31aa							; 
   7091  31aa
   7092  31aa				   .
   7093  31aa							; 
   7094  31aa
   7095  31aa				   .
   7096  31aa							; 
   7097  31aa
   7098  31aa				   .
   7099  31aa							; 
   7100  31aa
   7101  31aa				   .L0268		;  _Bit1_FireB_Restrainer{1}  =  1
   7102  31aa
   7103  31aa		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   7104  31ac		       09 02		      ORA	#2
   7105  31ae		       85 ec		      STA	_Bit1_FireB_Restrainer
   7106  31b0				   .
   7107  31b0							; 
   7108  31b0
   7109  31b0				   .
   7110  31b0							; 
   7111  31b0
   7112  31b0				   .
   7113  31b0							; 
   7114  31b0
   7115  31b0				   .
   7116  31b0							; 
   7117  31b0
   7118  31b0				   .
   7119  31b0							; 
   7120  31b0
   7121  31b0				   .
   7122  31b0							; 
   7123  31b0
   7124  31b0				   .L0269		;  _Pause_Counter_Tmp	=  0
   7125  31b0
   7126  31b0		       a9 00		      LDA	#0
   7127  31b2		       85 db		      STA	_Pause_Counter_Tmp
   7128  31b4				   .
   7129  31b4							; 
   7130  31b4
   7131  31b4				   .
   7132  31b4							; 
   7133  31b4
   7134  31b4				   .
   7135  31b4							; 
   7136  31b4
   7137  31b4				   .
   7138  31b4							; 
   7139  31b4
   7140  31b4				   .
   7141  31b4							; 
   7142  31b4
   7143  31b4				   .
   7144  31b4							; 
   7145  31b4
   7146  31b4				   .L0270		;  _Pause_Color_Tmp  =   ( rand & 7 ) 
   7147  31b4
   7148  31b4							; complex statement detected
   7149  31b4		       a5 a2		      lda	rand
   7150  31b6		       4a		      lsr
   7151  31b7					      ifconst	rand16
   7152  31b7		       26 ed		      rol	rand16
   7153  31b9					      endif
   7154  31b9		       90 02		      bcc	*+4
   7155  31bb		       49 b4		      eor	#$B4
   7156  31bd		       85 a2		      sta	rand
   7157  31bf					      ifconst	rand16
   7158  31bf		       45 ed		      eor	rand16
   7159  31c1					      endif
   7160  31c1		       29 07		      AND	#7
   7161  31c3		       85 df		      STA	_Pause_Color_Tmp
   7162  31c5				   .
   7163  31c5							; 
   7164  31c5
   7165  31c5				   .L0271		;  _Pause_Mem_Color_Tmp  =  _Pause_Color_Tmp
   7166  31c5
   7167  31c5		       a5 df		      LDA	_Pause_Color_Tmp
   7168  31c7		       85 de		      STA	_Pause_Mem_Color_Tmp
   7169  31c9				   .
   7170  31c9							; 
   7171  31c9
   7172  31c9				   .
   7173  31c9							; 
   7174  31c9
   7175  31c9				   .
   7176  31c9							; 
   7177  31c9
   7178  31c9				   .
   7179  31c9							; 
   7180  31c9
   7181  31c9				   .
   7182  31c9							; 
   7183  31c9
   7184  31c9				   .
   7185  31c9							; 
   7186  31c9
   7187  31c9				   .
   7188  31c9							; 
   7189  31c9
   7190  31c9				   .
   7191  31c9							; 
   7192  31c9
   7193  31c9				   .
   7194  31c9							; 
   7195  31c9
   7196  31c9				   .
   7197  31c9							; 
   7198  31c9
   7199  31c9				   .__Pause_Game
   7200  31c9							; __Pause_Game
   7201  31c9
   7202  31c9				   .
   7203  31c9							; 
   7204  31c9
   7205  31c9				   .
   7206  31c9							; 
   7207  31c9
   7208  31c9				   .
   7209  31c9							; 
   7210  31c9
   7211  31c9				   .
   7212  31c9							; 
   7213  31c9
   7214  31c9				   .
   7215  31c9							; 
   7216  31c9
   7217  31c9				   .
   7218  31c9							; 
   7219  31c9
   7220  31c9				   .
   7221  31c9							; 
   7222  31c9
   7223  31c9				   .L0272		;  NUSIZ1  =  $10
   7224  31c9
   7225  31c9		       a9 10		      LDA	#$10
   7226  31cb		       85 05		      STA	NUSIZ1
   7227  31cd				   .
   7228  31cd							; 
   7229  31cd
   7230  31cd				   .
   7231  31cd							; 
   7232  31cd
   7233  31cd				   .
   7234  31cd							; 
   7235  31cd
   7236  31cd				   .
   7237  31cd							; 
   7238  31cd
   7239  31cd				   .
   7240  31cd							; 
   7241  31cd
   7242  31cd				   .
   7243  31cd							; 
   7244  31cd
   7245  31cd				   .
   7246  31cd							; 
   7247  31cd
   7248  31cd				   .
   7249  31cd							; 
   7250  31cd
   7251  31cd				   .
   7252  31cd							; 
   7253  31cd
   7254  31cd				   .
   7255  31cd							; 
   7256  31cd
   7257  31cd				   .L0273		;  _Pause_Counter_Tmp	=  _Pause_Counter_Tmp  +  1
   7258  31cd
   7259  31cd		       e6 db		      INC	_Pause_Counter_Tmp
   7260  31cf				   .
   7261  31cf							; 
   7262  31cf
   7263  31cf				   .
   7264  31cf							; 
   7265  31cf
   7266  31cf				   .
   7267  31cf							; 
   7268  31cf
   7269  31cf				   .
   7270  31cf							; 
   7271  31cf
   7272  31cf				   .L0274		;  if _Pause_Counter_Tmp  <  240 then goto __Skip_Pause_Counter
   7273  31cf
   7274  31cf		       a5 db		      LDA	_Pause_Counter_Tmp
   7275  31d1		       c9 f0		      CMP	#240
   7276  31d3		       b0 03		      BCS	.skipL0274
   7277  31d5				   .condpart133
   7278  31d5		       4c 42 52 	      jmp	.__Skip_Pause_Counter
   7279  31d8
   7280  31d8				   .skipL0274
   7281  31d8				   .
   7282  31d8							; 
   7283  31d8
   7284  31d8				   .
   7285  31d8							; 
   7286  31d8
   7287  31d8				   .
   7288  31d8							; 
   7289  31d8
   7290  31d8				   .
   7291  31d8							; 
   7292  31d8
   7293  31d8				   .L0275		;  _Pause_Counter_Tmp	=  0
   7294  31d8
   7295  31d8		       a9 00		      LDA	#0
   7296  31da		       85 db		      STA	_Pause_Counter_Tmp
   7297  31dc				   .
   7298  31dc							; 
   7299  31dc
   7300  31dc				   .
   7301  31dc							; 
   7302  31dc
   7303  31dc				   .
   7304  31dc							; 
   7305  31dc
   7306  31dc				   .
   7307  31dc							; 
   7308  31dc
   7309  31dc				   .L0276		;  _Pause_Color_Tmp  =   ( rand & 7 ) 
   7310  31dc
   7311  31dc							; complex statement detected
   7312  31dc		       a5 a2		      lda	rand
   7313  31de		       4a		      lsr
   7314  31df					      ifconst	rand16
   7315  31df		       26 ed		      rol	rand16
   7316  31e1					      endif
   7317  31e1		       90 02		      bcc	*+4
   7318  31e3		       49 b4		      eor	#$B4
   7319  31e5		       85 a2		      sta	rand
   7320  31e7					      ifconst	rand16
   7321  31e7		       45 ed		      eor	rand16
   7322  31e9					      endif
   7323  31e9		       29 07		      AND	#7
   7324  31eb		       85 df		      STA	_Pause_Color_Tmp
   7325  31ed				   .
   7326  31ed							; 
   7327  31ed
   7328  31ed				   .
   7329  31ed							; 
   7330  31ed
   7331  31ed				   .
   7332  31ed							; 
   7333  31ed
   7334  31ed				   .
   7335  31ed							; 
   7336  31ed
   7337  31ed				   .
   7338  31ed							; 
   7339  31ed
   7340  31ed				   .L0277		;  if _Pause_Color_Tmp  =  _Pause_Mem_Color_Tmp then _Pause_Color_Tmp	=  _Pause_Color_Tmp  +	 ( rand & 3 )	+  1  :  if _Pause_Color_Tmp  >  7 then _Pause_Color_Tmp  =  _Pause_Color_Tmp  -  8
   7341  31ed
   7342  31ed		       a5 df		      LDA	_Pause_Color_Tmp
   7343  31ef		       c5 de		      CMP	_Pause_Mem_Color_Tmp
   7344  31f1		       d0 2a		      BNE	.skipL0277
   7345  31f3				   .condpart134
   7346  31f3							; complex statement detected
   7347  31f3		       a5 df		      LDA	_Pause_Color_Tmp
   7348  31f5		       48		      PHA
   7349  31f6		       a5 a2		      lda	rand
   7350  31f8		       4a		      lsr
   7351  31f9					      ifconst	rand16
   7352  31f9		       26 ed		      rol	rand16
   7353  31fb					      endif
   7354  31fb		       90 02		      bcc	*+4
   7355  31fd		       49 b4		      eor	#$B4
   7356  31ff		       85 a2		      sta	rand
   7357  3201					      ifconst	rand16
   7358  3201		       45 ed		      eor	rand16
   7359  3203					      endif
   7360  3203		       29 03		      AND	#3
   7361  3205		       ba		      TSX
   7362  3206		       e8		      INX
   7363  3207		       9a		      TXS
   7364  3208		       18		      CLC
   7365  3209		       75 00		      ADC	$00,x
   7366  320b		       18		      CLC
   7367  320c		       69 01		      ADC	#1
   7368  320e		       85 df		      STA	_Pause_Color_Tmp
   7369  3210		       a9 07		      LDA	#7
   7370  3212		       c5 df		      CMP	_Pause_Color_Tmp
   7371  3214		       b0 07		      BCS	.skip134then
   7372  3216				   .condpart135
   7373  3216		       a5 df		      LDA	_Pause_Color_Tmp
   7374  3218		       38		      SEC
   7375  3219		       e9 08		      SBC	#8
   7376  321b		       85 df		      STA	_Pause_Color_Tmp
   7377  321d				   .skip134then
   7378  321d				   .skipL0277
   7379  321d				   .
   7380  321d							; 
   7381  321d
   7382  321d				   .
   7383  321d							; 
   7384  321d
   7385  321d				   .
   7386  321d							; 
   7387  321d
   7388  321d				   .
   7389  321d							; 
   7390  321d
   7391  321d				   .L0278		;  _Pause_Mem_Color_Tmp  =  _Pause_Color_Tmp
   7392  321d
   7393  321d		       a5 df		      LDA	_Pause_Color_Tmp
   7394  321f		       85 de		      STA	_Pause_Mem_Color_Tmp
   7395  3221				   .
   7396  3221							; 
   7397  3221
   7398  3221				   .
   7399  3221							; 
   7400  3221
   7401  3221				   .
   7402  3221							; 
   7403  3221
   7404  3221				   .
   7405  3221							; 
   7406  3221
   7407  3221				   .L0279		;  _Bit2_Pause_Clr_Scheme{2}  =  0
   7408  3221
   7409  3221		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7410  3223		       29 fb		      AND	#251
   7411  3225		       85 e5		      STA	_Bit2_Pause_Clr_Scheme
   7412  3227				   .
   7413  3227							; 
   7414  3227
   7415  3227				   .L0280		;  temp5  =  rand  :  if temp5  <  128 then _Bit2_Pause_Clr_Scheme{2}	=  1
   7416  3227
   7417  3227		       a5 a2		      lda	rand
   7418  3229		       4a		      lsr
   7419  322a					      ifconst	rand16
   7420  322a		       26 ed		      rol	rand16
   7421  322c					      endif
   7422  322c		       90 02		      bcc	*+4
   7423  322e		       49 b4		      eor	#$B4
   7424  3230		       85 a2		      sta	rand
   7425  3232					      ifconst	rand16
   7426  3232		       45 ed		      eor	rand16
   7427  3234					      endif
   7428  3234		       85 a0		      STA	temp5
   7429  3236		       a5 a0		      LDA	temp5
   7430  3238		       c9 80		      CMP	#128
   7431  323a		       b0 06		      BCS	.skipL0280
   7432  323c				   .condpart136
   7433  323c		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7434  323e		       09 04		      ORA	#4
   7435  3240		       85 e5		      STA	_Bit2_Pause_Clr_Scheme
   7436  3242				   .skipL0280
   7437  3242				   .
   7438  3242							; 
   7439  3242
   7440  3242				   .__Skip_Pause_Counter
   7441  3242							; __Skip_Pause_Counter
   7442  3242
   7443  3242				   .
   7444  3242							; 
   7445  3242
   7446  3242				   .
   7447  3242							; 
   7448  3242
   7449  3242				   .
   7450  3242							; 
   7451  3242
   7452  3242				   .
   7453  3242							; 
   7454  3242
   7455  3242				   .
   7456  3242							; 
   7457  3242
   7458  3242				   .
   7459  3242							; 
   7460  3242
   7461  3242				   .
   7462  3242							; 
   7463  3242
   7464  3242				   .L0281		;  on _Pause_Color_Tmp goto __Ps0 __Ps1 __Ps2 __Ps3 __Ps4 __Ps5 __Ps6 __Ps7
   7465  3242
   7466  3242		       a6 df		      LDX	_Pause_Color_Tmp
   7467  3244		       bd 4d 52 	      LDA	.L0281jumptablehi,x
   7468  3247		       48		      PHA
   7469  3248		       bd 55 52 	      LDA	.L0281jumptablelo,x
   7470  324b		       48		      PHA
   7471  324c		       60		      RTS
   7472  324d				   .L0281jumptablehi
   7473  324d		       52		      .byte.b	>(.__Ps0-1)
   7474  324e		       52		      .byte.b	>(.__Ps1-1)
   7475  324f		       53		      .byte.b	>(.__Ps2-1)
   7476  3250		       53		      .byte.b	>(.__Ps3-1)
   7477  3251		       53		      .byte.b	>(.__Ps4-1)
   7478  3252		       54		      .byte.b	>(.__Ps5-1)
   7479  3253		       54		      .byte.b	>(.__Ps6-1)
   7480  3254		       54		      .byte.b	>(.__Ps7-1)
   7481  3255				   .L0281jumptablelo
   7482  3255		       b9		      .byte.b	<(.__Ps0-1)
   7483  3256		       fc		      .byte.b	<(.__Ps1-1)
   7484  3257		       3f		      .byte.b	<(.__Ps2-1)
   7485  3258		       82		      .byte.b	<(.__Ps3-1)
   7486  3259		       c5		      .byte.b	<(.__Ps4-1)
   7487  325a		       08		      .byte.b	<(.__Ps5-1)
   7488  325b		       4b		      .byte.b	<(.__Ps6-1)
   7489  325c		       8e		      .byte.b	<(.__Ps7-1)
   7490  325d				   .
   7491  325d							; 
   7492  325d
   7493  325d				   .__Got_Pause_Colors
   7494  325d							; __Got_Pause_Colors
   7495  325d
   7496  325d				   .
   7497  325d							; 
   7498  325d
   7499  325d				   .
   7500  325d							; 
   7501  325d
   7502  325d				   .
   7503  325d							; 
   7504  325d
   7505  325d				   .
   7506  325d							; 
   7507  325d
   7508  325d				   .
   7509  325d							; 
   7510  325d
   7511  325d				   .
   7512  325d							; 
   7513  325d
   7514  325d				   .
   7515  325d							; 
   7516  325d
   7517  325d				   .L0282		;  drawscreen
   7518  325d
   7519  325d		       85 ee		      sta	temp7
   7520  325f		       a9 52		      lda	#>(ret_point14-1)
   7521  3261		       48		      pha
   7522  3262		       a9 74		      lda	#<(ret_point14-1)
   7523  3264		       48		      pha
   7524  3265		       a9 f4		      lda	#>(drawscreen-1)
   7525  3267		       48		      pha
   7526  3268		       a9 39		      lda	#<(drawscreen-1)
   7527  326a		       48		      pha
   7528  326b		       a5 ee		      lda	temp7
   7529  326d		       48		      pha
   7530  326e		       8a		      txa
   7531  326f		       48		      pha
   7532  3270		       a2 08		      ldx	#8
   7533  3272		       4c eb ff 	      jmp	BS_jsr
   7534  3275				   ret_point14
   7535  3275				   .
   7536  3275							; 
   7537  3275
   7538  3275				   .
   7539  3275							; 
   7540  3275
   7541  3275				   .
   7542  3275							; 
   7543  3275
   7544  3275				   .
   7545  3275							; 
   7546  3275
   7547  3275				   .
   7548  3275							; 
   7549  3275
   7550  3275				   .
   7551  3275							; 
   7552  3275
   7553  3275				   .
   7554  3275							; 
   7555  3275
   7556  3275				   .
   7557  3275							; 
   7558  3275
   7559  3275				   .
   7560  3275							; 
   7561  3275
   7562  3275				   .
   7563  3275							; 
   7564  3275
   7565  3275				   .
   7566  3275							; 
   7567  3275
   7568  3275				   .L0283		;  if !joy0fire then _Bit1_FireB_Restrainer{1}  =  0  :  goto __Pause_Game
   7569  3275
   7570  3275		       24 0c		      bit	INPT4
   7571  3277		       10 09		      BPL	.skipL0283
   7572  3279				   .condpart137
   7573  3279		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   7574  327b		       29 fd		      AND	#253
   7575  327d		       85 ec		      STA	_Bit1_FireB_Restrainer
   7576  327f		       4c c9 51 	      jmp	.__Pause_Game
   7577  3282
   7578  3282				   .skipL0283
   7579  3282				   .
   7580  3282							; 
   7581  3282
   7582  3282				   .
   7583  3282							; 
   7584  3282
   7585  3282				   .
   7586  3282							; 
   7587  3282
   7588  3282				   .
   7589  3282							; 
   7590  3282
   7591  3282				   .
   7592  3282							; 
   7593  3282
   7594  3282				   .L0284		;  if _Bit1_FireB_Restrainer{1} then goto __Pause_Game
   7595  3282
   7596  3282		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   7597  3284		       29 02		      AND	#2
   7598  3286		       f0 03		      BEQ	.skipL0284
   7599  3288				   .condpart138
   7600  3288		       4c c9 51 	      jmp	.__Pause_Game
   7601  328b
   7602  328b				   .skipL0284
   7603  328b				   .
   7604  328b							; 
   7605  328b
   7606  328b				   .
   7607  328b							; 
   7608  328b
   7609  328b				   .
   7610  328b							; 
   7611  328b
   7612  328b				   .
   7613  328b							; 
   7614  328b
   7615  328b				   .L0285		;  _Bit0_BW_Mem{0}  =	0  :  if switchbw then _Bit0_BW_Mem{0}	=  1
   7616  328b
   7617  328b		       a5 e5		      LDA	_Bit0_BW_Mem
   7618  328d		       29 fe		      AND	#254
   7619  328f		       85 e5		      STA	_Bit0_BW_Mem
   7620  3291		       a9 08		      lda	#8
   7621  3293		       2c 82 02 	      bit	SWCHB
   7622  3296		       d0 06		      BNE	.skipL0285
   7623  3298				   .condpart139
   7624  3298		       a5 e5		      LDA	_Bit0_BW_Mem
   7625  329a		       09 01		      ORA	#1
   7626  329c		       85 e5		      STA	_Bit0_BW_Mem
   7627  329e				   .skipL0285
   7628  329e				   .
   7629  329e							; 
   7630  329e
   7631  329e				   .
   7632  329e							; 
   7633  329e
   7634  329e				   .
   7635  329e							; 
   7636  329e
   7637  329e				   .
   7638  329e							; 
   7639  329e
   7640  329e				   .
   7641  329e							; 
   7642  329e
   7643  329e				   .
   7644  329e							; 
   7645  329e
   7646  329e				   .
   7647  329e							; 
   7648  329e
   7649  329e				   .
   7650  329e							; 
   7651  329e
   7652  329e				   .
   7653  329e							; 
   7654  329e
   7655  329e				   .
   7656  329e							; 
   7657  329e
   7658  329e				   .
   7659  329e							; 
   7660  329e
   7661  329e				   .
   7662  329e							; 
   7663  329e
   7664  329e				   .
   7665  329e							; 
   7666  329e
   7667  329e				   .
   7668  329e							; 
   7669  329e
   7670  329e				   .
   7671  329e							; 
   7672  329e
   7673  329e				   .
   7674  329e							; 
   7675  329e
   7676  329e				   .
   7677  329e							; 
   7678  329e
   7679  329e				   .
   7680  329e							; 
   7681  329e
   7682  329e				   .
   7683  329e							; 
   7684  329e
   7685  329e				   .
   7686  329e							; 
   7687  329e
   7688  329e				   .
   7689  329e							; 
   7690  329e
   7691  329e				   .
   7692  329e							; 
   7693  329e
   7694  329e				   .
   7695  329e							; 
   7696  329e
   7697  329e				   .
   7698  329e							; 
   7699  329e
   7700  329e				   .__Restore_Game_from_Pause
   7701  329e							; __Restore_Game_from_Pause
   7702  329e
   7703  329e				   .
   7704  329e							; 
   7705  329e
   7706  329e				   .
   7707  329e							; 
   7708  329e
   7709  329e				   .
   7710  329e							; 
   7711  329e
   7712  329e				   .
   7713  329e							; 
   7714  329e
   7715  329e				   .
   7716  329e							; 
   7717  329e
   7718  329e				   .
   7719  329e							; 
   7720  329e
   7721  329e				   .L0286		;  _Bit1_FireB_Restrainer{1}  =  1
   7722  329e
   7723  329e		       a5 ec		      LDA	_Bit1_FireB_Restrainer
   7724  32a0		       09 02		      ORA	#2
   7725  32a2		       85 ec		      STA	_Bit1_FireB_Restrainer
   7726  32a4				   .
   7727  32a4							; 
   7728  32a4
   7729  32a4				   .
   7730  32a4							; 
   7731  32a4
   7732  32a4				   .
   7733  32a4							; 
   7734  32a4
   7735  32a4				   .
   7736  32a4							; 
   7737  32a4
   7738  32a4				   .
   7739  32a4							; 
   7740  32a4
   7741  32a4				   .
   7742  32a4							; 
   7743  32a4
   7744  32a4				   .L0287		;  scorecolor	=  $1C
   7745  32a4
   7746  32a4		       a9 1c		      LDA	#$1C
   7747  32a6		       85 a3		      STA	scorecolor
   7748  32a8				   .
   7749  32a8							; 
   7750  32a8
   7751  32a8				   .
   7752  32a8							; 
   7753  32a8
   7754  32a8				   .L0288		;  goto __Main_Loop bank2
   7755  32a8
   7756  32a8		       85 ee		      sta	temp7
   7757  32aa		       a9 31		      lda	#>(.__Main_Loop-1)
   7758  32ac		       48		      pha
   7759  32ad		       a9 06		      lda	#<(.__Main_Loop-1)
   7760  32af		       48		      pha
   7761  32b0		       a5 ee		      lda	temp7
   7762  32b2		       48		      pha
   7763  32b3		       8a		      txa
   7764  32b4		       48		      pha
   7765  32b5		       a2 02		      ldx	#2
   7766  32b7		       4c eb ff 	      jmp	BS_jsr
   7767  32ba				   .
   7768  32ba							; 
   7769  32ba
   7770  32ba				   .
   7771  32ba							; 
   7772  32ba
   7773  32ba				   .
   7774  32ba							; 
   7775  32ba
   7776  32ba				   .
   7777  32ba							; 
   7778  32ba
   7779  32ba				   .
   7780  32ba							; 
   7781  32ba
   7782  32ba				   .
   7783  32ba							; 
   7784  32ba
   7785  32ba				   .
   7786  32ba							; 
   7787  32ba
   7788  32ba				   .
   7789  32ba							; 
   7790  32ba
   7791  32ba				   .
   7792  32ba							; 
   7793  32ba
   7794  32ba				   .__Ps0
   7795  32ba							; __Ps0
   7796  32ba
   7797  32ba				   .
   7798  32ba							; 
   7799  32ba
   7800  32ba				   .L0289		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps0B
   7801  32ba
   7802  32ba		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7803  32bc		       29 04		      AND	#4
   7804  32be		       f0 03		      BEQ	.skipL0289
   7805  32c0				   .condpart140
   7806  32c0		       4c e0 52 	      jmp	.__Ps0B
   7807  32c3
   7808  32c3				   .skipL0289
   7809  32c3				   .
   7810  32c3							; 
   7811  32c3
   7812  32c3				   .L0290		;  pfcolors:
   7813  32c3
   7814  32c3		       a9 0c		      lda	# $0C
   7815  32c5		       85 08		      sta	COLUPF
   7816  32c7				  -	      ifconst	pfres
   7817  32c7				  -	      lda	#>(pfcolorlabel62-132+pfres*pfwidth)
   7818  32c7					      else
   7819  32c7		       a9 f5		      lda	#>(pfcolorlabel62-84)
   7820  32c9					      endif
   7821  32c9		       85 f1		      sta	pfcolortable+1
   7822  32cb				  -	      ifconst	pfres
   7823  32cb				  -	      lda	#<(pfcolorlabel62-132+pfres*pfwidth)
   7824  32cb					      else
   7825  32cb		       a9 40		      lda	#<(pfcolorlabel62-84)
   7826  32cd					      endif
   7827  32cd		       85 f0		      sta	pfcolortable
   7828  32cf				   .
   7829  32cf							; 
   7830  32cf
   7831  32cf				   .L0291		;  COLUP0  =  $0C  :  COLUP1  =  $0C
   7832  32cf
   7833  32cf		       a9 0c		      LDA	#$0C
   7834  32d1		       85 06		      STA	COLUP0
   7835  32d3		       85 07		      STA	COLUP1
   7836  32d5				   .
   7837  32d5							; 
   7838  32d5
   7839  32d5				   .L0292		;  COLUBK  =  $0A
   7840  32d5
   7841  32d5		       a9 0a		      LDA	#$0A
   7842  32d7		       85 09		      STA	COLUBK
   7843  32d9				   .
   7844  32d9							; 
   7845  32d9
   7846  32d9				   .L0293		;  scorecolor	=  $0C
   7847  32d9
   7848  32d9		       a9 0c		      LDA	#$0C
   7849  32db		       85 a3		      STA	scorecolor
   7850  32dd				   .
   7851  32dd							; 
   7852  32dd
   7853  32dd				   .L0294		;  goto __Got_Pause_Colors
   7854  32dd
   7855  32dd		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   7856  32e0
   7857  32e0				   .
   7858  32e0							; 
   7859  32e0
   7860  32e0				   .
   7861  32e0							; 
   7862  32e0
   7863  32e0				   .
   7864  32e0							; 
   7865  32e0
   7866  32e0				   .
   7867  32e0							; 
   7868  32e0
   7869  32e0				   .
   7870  32e0							; 
   7871  32e0
   7872  32e0				   .
   7873  32e0							; 
   7874  32e0
   7875  32e0				   .
   7876  32e0							; 
   7877  32e0
   7878  32e0				   .__Ps0B
   7879  32e0							; __Ps0B
   7880  32e0
   7881  32e0				   .
   7882  32e0							; 
   7883  32e0
   7884  32e0				   .L0295		;  pfcolors:
   7885  32e0
   7886  32e0		       a9 0a		      lda	# $0A
   7887  32e2		       85 08		      sta	COLUPF
   7888  32e4				  -	      ifconst	pfres
   7889  32e4				  -	      lda	#>(pfcolorlabel62-131+pfres*pfwidth)
   7890  32e4					      else
   7891  32e4		       a9 f5		      lda	#>(pfcolorlabel62-83)
   7892  32e6					      endif
   7893  32e6		       85 f1		      sta	pfcolortable+1
   7894  32e8				  -	      ifconst	pfres
   7895  32e8				  -	      lda	#<(pfcolorlabel62-131+pfres*pfwidth)
   7896  32e8					      else
   7897  32e8		       a9 41		      lda	#<(pfcolorlabel62-83)
   7898  32ea					      endif
   7899  32ea		       85 f0		      sta	pfcolortable
   7900  32ec				   .
   7901  32ec							; 
   7902  32ec
   7903  32ec				   .L0296		;  COLUP0  =  $0A  :  COLUP1  =  $0A
   7904  32ec
   7905  32ec		       a9 0a		      LDA	#$0A
   7906  32ee		       85 06		      STA	COLUP0
   7907  32f0		       85 07		      STA	COLUP1
   7908  32f2				   .
   7909  32f2							; 
   7910  32f2
   7911  32f2				   .L0297		;  COLUBK  =  $0C
   7912  32f2
   7913  32f2		       a9 0c		      LDA	#$0C
   7914  32f4		       85 09		      STA	COLUBK
   7915  32f6				   .
   7916  32f6							; 
   7917  32f6
   7918  32f6				   .L0298		;  scorecolor	=  $0A
   7919  32f6
   7920  32f6		       a9 0a		      LDA	#$0A
   7921  32f8		       85 a3		      STA	scorecolor
   7922  32fa				   .
   7923  32fa							; 
   7924  32fa
   7925  32fa				   .L0299		;  goto __Got_Pause_Colors
   7926  32fa
   7927  32fa		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   7928  32fd
   7929  32fd				   .
   7930  32fd							; 
   7931  32fd
   7932  32fd				   .
   7933  32fd							; 
   7934  32fd
   7935  32fd				   .
   7936  32fd							; 
   7937  32fd
   7938  32fd				   .
   7939  32fd							; 
   7940  32fd
   7941  32fd				   .
   7942  32fd							; 
   7943  32fd
   7944  32fd				   .
   7945  32fd							; 
   7946  32fd
   7947  32fd				   .
   7948  32fd							; 
   7949  32fd
   7950  32fd				   .__Ps1
   7951  32fd							; __Ps1
   7952  32fd
   7953  32fd				   .
   7954  32fd							; 
   7955  32fd
   7956  32fd				   .L0300		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps1B
   7957  32fd
   7958  32fd		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   7959  32ff		       29 04		      AND	#4
   7960  3301		       f0 03		      BEQ	.skipL0300
   7961  3303				   .condpart141
   7962  3303		       4c 23 53 	      jmp	.__Ps1B
   7963  3306
   7964  3306				   .skipL0300
   7965  3306				   .
   7966  3306							; 
   7967  3306
   7968  3306				   .L0301		;  pfcolors:
   7969  3306
   7970  3306		       a9 3c		      lda	# $3C
   7971  3308		       85 08		      sta	COLUPF
   7972  330a				  -	      ifconst	pfres
   7973  330a				  -	      lda	#>(pfcolorlabel62-130+pfres*pfwidth)
   7974  330a					      else
   7975  330a		       a9 f5		      lda	#>(pfcolorlabel62-82)
   7976  330c					      endif
   7977  330c		       85 f1		      sta	pfcolortable+1
   7978  330e				  -	      ifconst	pfres
   7979  330e				  -	      lda	#<(pfcolorlabel62-130+pfres*pfwidth)
   7980  330e					      else
   7981  330e		       a9 42		      lda	#<(pfcolorlabel62-82)
   7982  3310					      endif
   7983  3310		       85 f0		      sta	pfcolortable
   7984  3312				   .
   7985  3312							; 
   7986  3312
   7987  3312				   .L0302		;  COLUP0  =  $3C  :  COLUP1  =  $3C
   7988  3312
   7989  3312		       a9 3c		      LDA	#$3C
   7990  3314		       85 06		      STA	COLUP0
   7991  3316		       85 07		      STA	COLUP1
   7992  3318				   .
   7993  3318							; 
   7994  3318
   7995  3318				   .L0303		;  COLUBK  =  $3A
   7996  3318
   7997  3318		       a9 3a		      LDA	#$3A
   7998  331a		       85 09		      STA	COLUBK
   7999  331c				   .
   8000  331c							; 
   8001  331c
   8002  331c				   .L0304		;  scorecolor	=  $3C
   8003  331c
   8004  331c		       a9 3c		      LDA	#$3C
   8005  331e		       85 a3		      STA	scorecolor
   8006  3320				   .
   8007  3320							; 
   8008  3320
   8009  3320				   .L0305		;  goto __Got_Pause_Colors
   8010  3320
   8011  3320		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8012  3323
   8013  3323				   .
   8014  3323							; 
   8015  3323
   8016  3323				   .
   8017  3323							; 
   8018  3323
   8019  3323				   .
   8020  3323							; 
   8021  3323
   8022  3323				   .
   8023  3323							; 
   8024  3323
   8025  3323				   .
   8026  3323							; 
   8027  3323
   8028  3323				   .
   8029  3323							; 
   8030  3323
   8031  3323				   .
   8032  3323							; 
   8033  3323
   8034  3323				   .__Ps1B
   8035  3323							; __Ps1B
   8036  3323
   8037  3323				   .
   8038  3323							; 
   8039  3323
   8040  3323				   .L0306		;  pfcolors:
   8041  3323
   8042  3323		       a9 3a		      lda	# $3A
   8043  3325		       85 08		      sta	COLUPF
   8044  3327				  -	      ifconst	pfres
   8045  3327				  -	      lda	#>(pfcolorlabel62-129+pfres*pfwidth)
   8046  3327					      else
   8047  3327		       a9 f5		      lda	#>(pfcolorlabel62-81)
   8048  3329					      endif
   8049  3329		       85 f1		      sta	pfcolortable+1
   8050  332b				  -	      ifconst	pfres
   8051  332b				  -	      lda	#<(pfcolorlabel62-129+pfres*pfwidth)
   8052  332b					      else
   8053  332b		       a9 43		      lda	#<(pfcolorlabel62-81)
   8054  332d					      endif
   8055  332d		       85 f0		      sta	pfcolortable
   8056  332f				   .
   8057  332f							; 
   8058  332f
   8059  332f				   .L0307		;  COLUP0  =  $3A  :  COLUP1  =  $3A
   8060  332f
   8061  332f		       a9 3a		      LDA	#$3A
   8062  3331		       85 06		      STA	COLUP0
   8063  3333		       85 07		      STA	COLUP1
   8064  3335				   .
   8065  3335							; 
   8066  3335
   8067  3335				   .L0308		;  COLUBK  =  $3C
   8068  3335
   8069  3335		       a9 3c		      LDA	#$3C
   8070  3337		       85 09		      STA	COLUBK
   8071  3339				   .
   8072  3339							; 
   8073  3339
   8074  3339				   .L0309		;  scorecolor	=  $3A
   8075  3339
   8076  3339		       a9 3a		      LDA	#$3A
   8077  333b		       85 a3		      STA	scorecolor
   8078  333d				   .
   8079  333d							; 
   8080  333d
   8081  333d				   .L0310		;  goto __Got_Pause_Colors
   8082  333d
   8083  333d		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8084  3340
   8085  3340				   .
   8086  3340							; 
   8087  3340
   8088  3340				   .
   8089  3340							; 
   8090  3340
   8091  3340				   .
   8092  3340							; 
   8093  3340
   8094  3340				   .
   8095  3340							; 
   8096  3340
   8097  3340				   .
   8098  3340							; 
   8099  3340
   8100  3340				   .
   8101  3340							; 
   8102  3340
   8103  3340				   .
   8104  3340							; 
   8105  3340
   8106  3340				   .__Ps2
   8107  3340							; __Ps2
   8108  3340
   8109  3340				   .
   8110  3340							; 
   8111  3340
   8112  3340				   .L0311		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps2B
   8113  3340
   8114  3340		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8115  3342		       29 04		      AND	#4
   8116  3344		       f0 03		      BEQ	.skipL0311
   8117  3346				   .condpart142
   8118  3346		       4c 66 53 	      jmp	.__Ps2B
   8119  3349
   8120  3349				   .skipL0311
   8121  3349				   .
   8122  3349							; 
   8123  3349
   8124  3349				   .L0312		;  pfcolors:
   8125  3349
   8126  3349		       a9 6c		      lda	# $6C
   8127  334b		       85 08		      sta	COLUPF
   8128  334d				  -	      ifconst	pfres
   8129  334d				  -	      lda	#>(pfcolorlabel87-132+pfres*pfwidth)
   8130  334d					      else
   8131  334d		       a9 f5		      lda	#>(pfcolorlabel87-84)
   8132  334f					      endif
   8133  334f		       85 f1		      sta	pfcolortable+1
   8134  3351				  -	      ifconst	pfres
   8135  3351				  -	      lda	#<(pfcolorlabel87-132+pfres*pfwidth)
   8136  3351					      else
   8137  3351		       a9 6c		      lda	#<(pfcolorlabel87-84)
   8138  3353					      endif
   8139  3353		       85 f0		      sta	pfcolortable
   8140  3355				   .
   8141  3355							; 
   8142  3355
   8143  3355				   .L0313		;  COLUP0  =  $6C  :  COLUP1  =  $6C
   8144  3355
   8145  3355		       a9 6c		      LDA	#$6C
   8146  3357		       85 06		      STA	COLUP0
   8147  3359		       85 07		      STA	COLUP1
   8148  335b				   .
   8149  335b							; 
   8150  335b
   8151  335b				   .L0314		;  COLUBK  =  $6A
   8152  335b
   8153  335b		       a9 6a		      LDA	#$6A
   8154  335d		       85 09		      STA	COLUBK
   8155  335f				   .
   8156  335f							; 
   8157  335f
   8158  335f				   .L0315		;  scorecolor	=  $6C
   8159  335f
   8160  335f		       a9 6c		      LDA	#$6C
   8161  3361		       85 a3		      STA	scorecolor
   8162  3363				   .
   8163  3363							; 
   8164  3363
   8165  3363				   .L0316		;  goto __Got_Pause_Colors
   8166  3363
   8167  3363		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8168  3366
   8169  3366				   .
   8170  3366							; 
   8171  3366
   8172  3366				   .
   8173  3366							; 
   8174  3366
   8175  3366				   .
   8176  3366							; 
   8177  3366
   8178  3366				   .
   8179  3366							; 
   8180  3366
   8181  3366				   .
   8182  3366							; 
   8183  3366
   8184  3366				   .
   8185  3366							; 
   8186  3366
   8187  3366				   .
   8188  3366							; 
   8189  3366
   8190  3366				   .__Ps2B
   8191  3366							; __Ps2B
   8192  3366
   8193  3366				   .
   8194  3366							; 
   8195  3366
   8196  3366				   .L0317		;  pfcolors:
   8197  3366
   8198  3366		       a9 6a		      lda	# $6A
   8199  3368		       85 08		      sta	COLUPF
   8200  336a				  -	      ifconst	pfres
   8201  336a				  -	      lda	#>(pfcolorlabel87-131+pfres*pfwidth)
   8202  336a					      else
   8203  336a		       a9 f5		      lda	#>(pfcolorlabel87-83)
   8204  336c					      endif
   8205  336c		       85 f1		      sta	pfcolortable+1
   8206  336e				  -	      ifconst	pfres
   8207  336e				  -	      lda	#<(pfcolorlabel87-131+pfres*pfwidth)
   8208  336e					      else
   8209  336e		       a9 6d		      lda	#<(pfcolorlabel87-83)
   8210  3370					      endif
   8211  3370		       85 f0		      sta	pfcolortable
   8212  3372				   .
   8213  3372							; 
   8214  3372
   8215  3372				   .L0318		;  COLUP0  =  $6A  :  COLUP1  =  $6A
   8216  3372
   8217  3372		       a9 6a		      LDA	#$6A
   8218  3374		       85 06		      STA	COLUP0
   8219  3376		       85 07		      STA	COLUP1
   8220  3378				   .
   8221  3378							; 
   8222  3378
   8223  3378				   .L0319		;  COLUBK  =  $6C
   8224  3378
   8225  3378		       a9 6c		      LDA	#$6C
   8226  337a		       85 09		      STA	COLUBK
   8227  337c				   .
   8228  337c							; 
   8229  337c
   8230  337c				   .L0320		;  scorecolor	=  $6A
   8231  337c
   8232  337c		       a9 6a		      LDA	#$6A
   8233  337e		       85 a3		      STA	scorecolor
   8234  3380				   .
   8235  3380							; 
   8236  3380
   8237  3380				   .L0321		;  goto __Got_Pause_Colors
   8238  3380
   8239  3380		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8240  3383
   8241  3383				   .
   8242  3383							; 
   8243  3383
   8244  3383				   .
   8245  3383							; 
   8246  3383
   8247  3383				   .
   8248  3383							; 
   8249  3383
   8250  3383				   .
   8251  3383							; 
   8252  3383
   8253  3383				   .
   8254  3383							; 
   8255  3383
   8256  3383				   .
   8257  3383							; 
   8258  3383
   8259  3383				   .
   8260  3383							; 
   8261  3383
   8262  3383				   .__Ps3
   8263  3383							; __Ps3
   8264  3383
   8265  3383				   .
   8266  3383							; 
   8267  3383
   8268  3383				   .L0322		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps3B
   8269  3383
   8270  3383		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8271  3385		       29 04		      AND	#4
   8272  3387		       f0 03		      BEQ	.skipL0322
   8273  3389				   .condpart143
   8274  3389		       4c a9 53 	      jmp	.__Ps3B
   8275  338c
   8276  338c				   .skipL0322
   8277  338c				   .
   8278  338c							; 
   8279  338c
   8280  338c				   .L0323		;  pfcolors:
   8281  338c
   8282  338c		       a9 9c		      lda	# $9C
   8283  338e		       85 08		      sta	COLUPF
   8284  3390				  -	      ifconst	pfres
   8285  3390				  -	      lda	#>(pfcolorlabel87-130+pfres*pfwidth)
   8286  3390					      else
   8287  3390		       a9 f5		      lda	#>(pfcolorlabel87-82)
   8288  3392					      endif
   8289  3392		       85 f1		      sta	pfcolortable+1
   8290  3394				  -	      ifconst	pfres
   8291  3394				  -	      lda	#<(pfcolorlabel87-130+pfres*pfwidth)
   8292  3394					      else
   8293  3394		       a9 6e		      lda	#<(pfcolorlabel87-82)
   8294  3396					      endif
   8295  3396		       85 f0		      sta	pfcolortable
   8296  3398				   .
   8297  3398							; 
   8298  3398
   8299  3398				   .L0324		;  COLUP0  =  $9C  :  COLUP1  =  $9C
   8300  3398
   8301  3398		       a9 9c		      LDA	#$9C
   8302  339a		       85 06		      STA	COLUP0
   8303  339c		       85 07		      STA	COLUP1
   8304  339e				   .
   8305  339e							; 
   8306  339e
   8307  339e				   .L0325		;  COLUBK  =  $9A
   8308  339e
   8309  339e		       a9 9a		      LDA	#$9A
   8310  33a0		       85 09		      STA	COLUBK
   8311  33a2				   .
   8312  33a2							; 
   8313  33a2
   8314  33a2				   .L0326		;  scorecolor	=  $9C
   8315  33a2
   8316  33a2		       a9 9c		      LDA	#$9C
   8317  33a4		       85 a3		      STA	scorecolor
   8318  33a6				   .
   8319  33a6							; 
   8320  33a6
   8321  33a6				   .L0327		;  goto __Got_Pause_Colors
   8322  33a6
   8323  33a6		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8324  33a9
   8325  33a9				   .
   8326  33a9							; 
   8327  33a9
   8328  33a9				   .
   8329  33a9							; 
   8330  33a9
   8331  33a9				   .
   8332  33a9							; 
   8333  33a9
   8334  33a9				   .
   8335  33a9							; 
   8336  33a9
   8337  33a9				   .
   8338  33a9							; 
   8339  33a9
   8340  33a9				   .
   8341  33a9							; 
   8342  33a9
   8343  33a9				   .
   8344  33a9							; 
   8345  33a9
   8346  33a9				   .__Ps3B
   8347  33a9							; __Ps3B
   8348  33a9
   8349  33a9				   .
   8350  33a9							; 
   8351  33a9
   8352  33a9				   .L0328		;  pfcolors:
   8353  33a9
   8354  33a9		       a9 9a		      lda	# $9A
   8355  33ab		       85 08		      sta	COLUPF
   8356  33ad				  -	      ifconst	pfres
   8357  33ad				  -	      lda	#>(pfcolorlabel87-129+pfres*pfwidth)
   8358  33ad					      else
   8359  33ad		       a9 f5		      lda	#>(pfcolorlabel87-81)
   8360  33af					      endif
   8361  33af		       85 f1		      sta	pfcolortable+1
   8362  33b1				  -	      ifconst	pfres
   8363  33b1				  -	      lda	#<(pfcolorlabel87-129+pfres*pfwidth)
   8364  33b1					      else
   8365  33b1		       a9 6f		      lda	#<(pfcolorlabel87-81)
   8366  33b3					      endif
   8367  33b3		       85 f0		      sta	pfcolortable
   8368  33b5				   .
   8369  33b5							; 
   8370  33b5
   8371  33b5				   .L0329		;  COLUP0  =  $9A  :  COLUP1  =  $9A
   8372  33b5
   8373  33b5		       a9 9a		      LDA	#$9A
   8374  33b7		       85 06		      STA	COLUP0
   8375  33b9		       85 07		      STA	COLUP1
   8376  33bb				   .
   8377  33bb							; 
   8378  33bb
   8379  33bb				   .L0330		;  COLUBK  =  $9C
   8380  33bb
   8381  33bb		       a9 9c		      LDA	#$9C
   8382  33bd		       85 09		      STA	COLUBK
   8383  33bf				   .
   8384  33bf							; 
   8385  33bf
   8386  33bf				   .L0331		;  scorecolor	=  $9A
   8387  33bf
   8388  33bf		       a9 9a		      LDA	#$9A
   8389  33c1		       85 a3		      STA	scorecolor
   8390  33c3				   .
   8391  33c3							; 
   8392  33c3
   8393  33c3				   .L0332		;  goto __Got_Pause_Colors
   8394  33c3
   8395  33c3		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8396  33c6
   8397  33c6				   .
   8398  33c6							; 
   8399  33c6
   8400  33c6				   .
   8401  33c6							; 
   8402  33c6
   8403  33c6				   .
   8404  33c6							; 
   8405  33c6
   8406  33c6				   .
   8407  33c6							; 
   8408  33c6
   8409  33c6				   .
   8410  33c6							; 
   8411  33c6
   8412  33c6				   .
   8413  33c6							; 
   8414  33c6
   8415  33c6				   .
   8416  33c6							; 
   8417  33c6
   8418  33c6				   .__Ps4
   8419  33c6							; __Ps4
   8420  33c6
   8421  33c6				   .
   8422  33c6							; 
   8423  33c6
   8424  33c6				   .L0333		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps4B
   8425  33c6
   8426  33c6		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8427  33c8		       29 04		      AND	#4
   8428  33ca		       f0 03		      BEQ	.skipL0333
   8429  33cc				   .condpart144
   8430  33cc		       4c ec 53 	      jmp	.__Ps4B
   8431  33cf
   8432  33cf				   .skipL0333
   8433  33cf				   .
   8434  33cf							; 
   8435  33cf
   8436  33cf				   .L0334		;  pfcolors:
   8437  33cf
   8438  33cf		       a9 cc		      lda	# $CC
   8439  33d1		       85 08		      sta	COLUPF
   8440  33d3				  -	      ifconst	pfres
   8441  33d3				  -	      lda	#>(pfcolorlabel112-132+pfres*pfwidth)
   8442  33d3					      else
   8443  33d3		       a9 f6		      lda	#>(pfcolorlabel112-84)
   8444  33d5					      endif
   8445  33d5		       85 f1		      sta	pfcolortable+1
   8446  33d7				  -	      ifconst	pfres
   8447  33d7				  -	      lda	#<(pfcolorlabel112-132+pfres*pfwidth)
   8448  33d7					      else
   8449  33d7		       a9 04		      lda	#<(pfcolorlabel112-84)
   8450  33d9					      endif
   8451  33d9		       85 f0		      sta	pfcolortable
   8452  33db				   .
   8453  33db							; 
   8454  33db
   8455  33db				   .L0335		;  COLUP0  =  $CC  :  COLUP1  =  $CC
   8456  33db
   8457  33db		       a9 cc		      LDA	#$CC
   8458  33dd		       85 06		      STA	COLUP0
   8459  33df		       85 07		      STA	COLUP1
   8460  33e1				   .
   8461  33e1							; 
   8462  33e1
   8463  33e1				   .L0336		;  COLUBK  =  $CA
   8464  33e1
   8465  33e1		       a9 ca		      LDA	#$CA
   8466  33e3		       85 09		      STA	COLUBK
   8467  33e5				   .
   8468  33e5							; 
   8469  33e5
   8470  33e5				   .L0337		;  scorecolor	=  $CC
   8471  33e5
   8472  33e5		       a9 cc		      LDA	#$CC
   8473  33e7		       85 a3		      STA	scorecolor
   8474  33e9				   .
   8475  33e9							; 
   8476  33e9
   8477  33e9				   .L0338		;  goto __Got_Pause_Colors
   8478  33e9
   8479  33e9		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8480  33ec
   8481  33ec				   .
   8482  33ec							; 
   8483  33ec
   8484  33ec				   .
   8485  33ec							; 
   8486  33ec
   8487  33ec				   .
   8488  33ec							; 
   8489  33ec
   8490  33ec				   .
   8491  33ec							; 
   8492  33ec
   8493  33ec				   .
   8494  33ec							; 
   8495  33ec
   8496  33ec				   .
   8497  33ec							; 
   8498  33ec
   8499  33ec				   .
   8500  33ec							; 
   8501  33ec
   8502  33ec				   .__Ps4B
   8503  33ec							; __Ps4B
   8504  33ec
   8505  33ec				   .
   8506  33ec							; 
   8507  33ec
   8508  33ec				   .L0339		;  pfcolors:
   8509  33ec
   8510  33ec		       a9 ca		      lda	# $CA
   8511  33ee		       85 08		      sta	COLUPF
   8512  33f0				  -	      ifconst	pfres
   8513  33f0				  -	      lda	#>(pfcolorlabel112-131+pfres*pfwidth)
   8514  33f0					      else
   8515  33f0		       a9 f6		      lda	#>(pfcolorlabel112-83)
   8516  33f2					      endif
   8517  33f2		       85 f1		      sta	pfcolortable+1
   8518  33f4				  -	      ifconst	pfres
   8519  33f4				  -	      lda	#<(pfcolorlabel112-131+pfres*pfwidth)
   8520  33f4					      else
   8521  33f4		       a9 05		      lda	#<(pfcolorlabel112-83)
   8522  33f6					      endif
   8523  33f6		       85 f0		      sta	pfcolortable
   8524  33f8				   .
   8525  33f8							; 
   8526  33f8
   8527  33f8				   .L0340		;  COLUP0  =  $CA  :  COLUP1  =  $CA
   8528  33f8
   8529  33f8		       a9 ca		      LDA	#$CA
   8530  33fa		       85 06		      STA	COLUP0
   8531  33fc		       85 07		      STA	COLUP1
   8532  33fe				   .
   8533  33fe							; 
   8534  33fe
   8535  33fe				   .L0341		;  COLUBK  =  $CC
   8536  33fe
   8537  33fe		       a9 cc		      LDA	#$CC
   8538  3400		       85 09		      STA	COLUBK
   8539  3402				   .
   8540  3402							; 
   8541  3402
   8542  3402				   .L0342		;  scorecolor	=  $CA
   8543  3402
   8544  3402		       a9 ca		      LDA	#$CA
   8545  3404		       85 a3		      STA	scorecolor
   8546  3406				   .
   8547  3406							; 
   8548  3406
   8549  3406				   .L0343		;  goto __Got_Pause_Colors
   8550  3406
   8551  3406		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8552  3409
   8553  3409				   .
   8554  3409							; 
   8555  3409
   8556  3409				   .
   8557  3409							; 
   8558  3409
   8559  3409				   .
   8560  3409							; 
   8561  3409
   8562  3409				   .
   8563  3409							; 
   8564  3409
   8565  3409				   .
   8566  3409							; 
   8567  3409
   8568  3409				   .
   8569  3409							; 
   8570  3409
   8571  3409				   .
   8572  3409							; 
   8573  3409
   8574  3409				   .__Ps5
   8575  3409							; __Ps5
   8576  3409
   8577  3409				   .
   8578  3409							; 
   8579  3409
   8580  3409				   .L0344		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps5B
   8581  3409
   8582  3409		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8583  340b		       29 04		      AND	#4
   8584  340d		       f0 03		      BEQ	.skipL0344
   8585  340f				   .condpart145
   8586  340f		       4c 2f 54 	      jmp	.__Ps5B
   8587  3412
   8588  3412				   .skipL0344
   8589  3412				   .
   8590  3412							; 
   8591  3412
   8592  3412				   .L0345		;  pfcolors:
   8593  3412
   8594  3412		       a9 fc		      lda	# $FC
   8595  3414		       85 08		      sta	COLUPF
   8596  3416				  -	      ifconst	pfres
   8597  3416				  -	      lda	#>(pfcolorlabel112-130+pfres*pfwidth)
   8598  3416					      else
   8599  3416		       a9 f6		      lda	#>(pfcolorlabel112-82)
   8600  3418					      endif
   8601  3418		       85 f1		      sta	pfcolortable+1
   8602  341a				  -	      ifconst	pfres
   8603  341a				  -	      lda	#<(pfcolorlabel112-130+pfres*pfwidth)
   8604  341a					      else
   8605  341a		       a9 06		      lda	#<(pfcolorlabel112-82)
   8606  341c					      endif
   8607  341c		       85 f0		      sta	pfcolortable
   8608  341e				   .
   8609  341e							; 
   8610  341e
   8611  341e				   .L0346		;  COLUP0  =  $FC  :  COLUP1  =  $FC
   8612  341e
   8613  341e		       a9 fc		      LDA	#$FC
   8614  3420		       85 06		      STA	COLUP0
   8615  3422		       85 07		      STA	COLUP1
   8616  3424				   .
   8617  3424							; 
   8618  3424
   8619  3424				   .L0347		;  COLUBK  =  $FA
   8620  3424
   8621  3424		       a9 fa		      LDA	#$FA
   8622  3426		       85 09		      STA	COLUBK
   8623  3428				   .
   8624  3428							; 
   8625  3428
   8626  3428				   .L0348		;  scorecolor	=  $FC
   8627  3428
   8628  3428		       a9 fc		      LDA	#$FC
   8629  342a		       85 a3		      STA	scorecolor
   8630  342c				   .
   8631  342c							; 
   8632  342c
   8633  342c				   .L0349		;  goto __Got_Pause_Colors
   8634  342c
   8635  342c		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8636  342f
   8637  342f				   .
   8638  342f							; 
   8639  342f
   8640  342f				   .
   8641  342f							; 
   8642  342f
   8643  342f				   .
   8644  342f							; 
   8645  342f
   8646  342f				   .
   8647  342f							; 
   8648  342f
   8649  342f				   .
   8650  342f							; 
   8651  342f
   8652  342f				   .
   8653  342f							; 
   8654  342f
   8655  342f				   .
   8656  342f							; 
   8657  342f
   8658  342f				   .__Ps5B
   8659  342f							; __Ps5B
   8660  342f
   8661  342f				   .
   8662  342f							; 
   8663  342f
   8664  342f				   .L0350		;  pfcolors:
   8665  342f
   8666  342f		       a9 fa		      lda	# $FA
   8667  3431		       85 08		      sta	COLUPF
   8668  3433				  -	      ifconst	pfres
   8669  3433				  -	      lda	#>(pfcolorlabel112-129+pfres*pfwidth)
   8670  3433					      else
   8671  3433		       a9 f6		      lda	#>(pfcolorlabel112-81)
   8672  3435					      endif
   8673  3435		       85 f1		      sta	pfcolortable+1
   8674  3437				  -	      ifconst	pfres
   8675  3437				  -	      lda	#<(pfcolorlabel112-129+pfres*pfwidth)
   8676  3437					      else
   8677  3437		       a9 07		      lda	#<(pfcolorlabel112-81)
   8678  3439					      endif
   8679  3439		       85 f0		      sta	pfcolortable
   8680  343b				   .
   8681  343b							; 
   8682  343b
   8683  343b				   .L0351		;  COLUP0  =  $FA  :  COLUP1  =  $FA
   8684  343b
   8685  343b		       a9 fa		      LDA	#$FA
   8686  343d		       85 06		      STA	COLUP0
   8687  343f		       85 07		      STA	COLUP1
   8688  3441				   .
   8689  3441							; 
   8690  3441
   8691  3441				   .L0352		;  COLUBK  =  $FC
   8692  3441
   8693  3441		       a9 fc		      LDA	#$FC
   8694  3443		       85 09		      STA	COLUBK
   8695  3445				   .
   8696  3445							; 
   8697  3445
   8698  3445				   .L0353		;  scorecolor	=  $FA
   8699  3445
   8700  3445		       a9 fa		      LDA	#$FA
   8701  3447		       85 a3		      STA	scorecolor
   8702  3449				   .
   8703  3449							; 
   8704  3449
   8705  3449				   .L0354		;  goto __Got_Pause_Colors
   8706  3449
   8707  3449		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8708  344c
   8709  344c				   .
   8710  344c							; 
   8711  344c
   8712  344c				   .
   8713  344c							; 
   8714  344c
   8715  344c				   .
   8716  344c							; 
   8717  344c
   8718  344c				   .
   8719  344c							; 
   8720  344c
   8721  344c				   .
   8722  344c							; 
   8723  344c
   8724  344c				   .
   8725  344c							; 
   8726  344c
   8727  344c				   .
   8728  344c							; 
   8729  344c
   8730  344c				   .__Ps6
   8731  344c							; __Ps6
   8732  344c
   8733  344c				   .
   8734  344c							; 
   8735  344c
   8736  344c				   .L0355		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps6B
   8737  344c
   8738  344c		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8739  344e		       29 04		      AND	#4
   8740  3450		       f0 03		      BEQ	.skipL0355
   8741  3452				   .condpart146
   8742  3452		       4c 72 54 	      jmp	.__Ps6B
   8743  3455
   8744  3455				   .skipL0355
   8745  3455				   .
   8746  3455							; 
   8747  3455
   8748  3455				   .L0356		;  pfcolors:
   8749  3455
   8750  3455		       a9 8c		      lda	# $8C
   8751  3457		       85 08		      sta	COLUPF
   8752  3459				  -	      ifconst	pfres
   8753  3459				  -	      lda	#>(pfcolorlabel137-132+pfres*pfwidth)
   8754  3459					      else
   8755  3459		       a9 f6		      lda	#>(pfcolorlabel137-84)
   8756  345b					      endif
   8757  345b		       85 f1		      sta	pfcolortable+1
   8758  345d				  -	      ifconst	pfres
   8759  345d				  -	      lda	#<(pfcolorlabel137-132+pfres*pfwidth)
   8760  345d					      else
   8761  345d		       a9 30		      lda	#<(pfcolorlabel137-84)
   8762  345f					      endif
   8763  345f		       85 f0		      sta	pfcolortable
   8764  3461				   .
   8765  3461							; 
   8766  3461
   8767  3461				   .L0357		;  COLUP0  =  $8C  :  COLUP1  =  $8C
   8768  3461
   8769  3461		       a9 8c		      LDA	#$8C
   8770  3463		       85 06		      STA	COLUP0
   8771  3465		       85 07		      STA	COLUP1
   8772  3467				   .
   8773  3467							; 
   8774  3467
   8775  3467				   .L0358		;  COLUBK  =  $8A
   8776  3467
   8777  3467		       a9 8a		      LDA	#$8A
   8778  3469		       85 09		      STA	COLUBK
   8779  346b				   .
   8780  346b							; 
   8781  346b
   8782  346b				   .L0359		;  scorecolor	=  $8C
   8783  346b
   8784  346b		       a9 8c		      LDA	#$8C
   8785  346d		       85 a3		      STA	scorecolor
   8786  346f				   .
   8787  346f							; 
   8788  346f
   8789  346f				   .L0360		;  goto __Got_Pause_Colors
   8790  346f
   8791  346f		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8792  3472
   8793  3472				   .
   8794  3472							; 
   8795  3472
   8796  3472				   .
   8797  3472							; 
   8798  3472
   8799  3472				   .
   8800  3472							; 
   8801  3472
   8802  3472				   .
   8803  3472							; 
   8804  3472
   8805  3472				   .
   8806  3472							; 
   8807  3472
   8808  3472				   .
   8809  3472							; 
   8810  3472
   8811  3472				   .
   8812  3472							; 
   8813  3472
   8814  3472				   .__Ps6B
   8815  3472							; __Ps6B
   8816  3472
   8817  3472				   .
   8818  3472							; 
   8819  3472
   8820  3472				   .L0361		;  pfcolors:
   8821  3472
   8822  3472		       a9 8a		      lda	# $8A
   8823  3474		       85 08		      sta	COLUPF
   8824  3476				  -	      ifconst	pfres
   8825  3476				  -	      lda	#>(pfcolorlabel137-131+pfres*pfwidth)
   8826  3476					      else
   8827  3476		       a9 f6		      lda	#>(pfcolorlabel137-83)
   8828  3478					      endif
   8829  3478		       85 f1		      sta	pfcolortable+1
   8830  347a				  -	      ifconst	pfres
   8831  347a				  -	      lda	#<(pfcolorlabel137-131+pfres*pfwidth)
   8832  347a					      else
   8833  347a		       a9 31		      lda	#<(pfcolorlabel137-83)
   8834  347c					      endif
   8835  347c		       85 f0		      sta	pfcolortable
   8836  347e				   .
   8837  347e							; 
   8838  347e
   8839  347e				   .L0362		;  COLUP0  =  $8A  :  COLUP1  =  $8A
   8840  347e
   8841  347e		       a9 8a		      LDA	#$8A
   8842  3480		       85 06		      STA	COLUP0
   8843  3482		       85 07		      STA	COLUP1
   8844  3484				   .
   8845  3484							; 
   8846  3484
   8847  3484				   .L0363		;  COLUBK  =  $8C
   8848  3484
   8849  3484		       a9 8c		      LDA	#$8C
   8850  3486		       85 09		      STA	COLUBK
   8851  3488				   .
   8852  3488							; 
   8853  3488
   8854  3488				   .L0364		;  scorecolor	=  $8A
   8855  3488
   8856  3488		       a9 8a		      LDA	#$8A
   8857  348a		       85 a3		      STA	scorecolor
   8858  348c				   .
   8859  348c							; 
   8860  348c
   8861  348c				   .L0365		;  goto __Got_Pause_Colors
   8862  348c
   8863  348c		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8864  348f
   8865  348f				   .
   8866  348f							; 
   8867  348f
   8868  348f				   .
   8869  348f							; 
   8870  348f
   8871  348f				   .
   8872  348f							; 
   8873  348f
   8874  348f				   .
   8875  348f							; 
   8876  348f
   8877  348f				   .
   8878  348f							; 
   8879  348f
   8880  348f				   .
   8881  348f							; 
   8882  348f
   8883  348f				   .
   8884  348f							; 
   8885  348f
   8886  348f				   .__Ps7
   8887  348f							; __Ps7
   8888  348f
   8889  348f				   .
   8890  348f							; 
   8891  348f
   8892  348f				   .L0366		;  if _Bit2_Pause_Clr_Scheme{2} then goto __Ps7B
   8893  348f
   8894  348f		       a5 e5		      LDA	_Bit2_Pause_Clr_Scheme
   8895  3491		       29 04		      AND	#4
   8896  3493		       f0 03		      BEQ	.skipL0366
   8897  3495				   .condpart147
   8898  3495		       4c b5 54 	      jmp	.__Ps7B
   8899  3498
   8900  3498				   .skipL0366
   8901  3498				   .
   8902  3498							; 
   8903  3498
   8904  3498				   .L0367		;  pfcolors:
   8905  3498
   8906  3498		       a9 2c		      lda	# $2C
   8907  349a		       85 08		      sta	COLUPF
   8908  349c				  -	      ifconst	pfres
   8909  349c				  -	      lda	#>(pfcolorlabel137-130+pfres*pfwidth)
   8910  349c					      else
   8911  349c		       a9 f6		      lda	#>(pfcolorlabel137-82)
   8912  349e					      endif
   8913  349e		       85 f1		      sta	pfcolortable+1
   8914  34a0				  -	      ifconst	pfres
   8915  34a0				  -	      lda	#<(pfcolorlabel137-130+pfres*pfwidth)
   8916  34a0					      else
   8917  34a0		       a9 32		      lda	#<(pfcolorlabel137-82)
   8918  34a2					      endif
   8919  34a2		       85 f0		      sta	pfcolortable
   8920  34a4				   .
   8921  34a4							; 
   8922  34a4
   8923  34a4				   .L0368		;  COLUP0  =  $2C  :  COLUP1  =  $2C
   8924  34a4
   8925  34a4		       a9 2c		      LDA	#$2C
   8926  34a6		       85 06		      STA	COLUP0
   8927  34a8		       85 07		      STA	COLUP1
   8928  34aa				   .
   8929  34aa							; 
   8930  34aa
   8931  34aa				   .L0369		;  COLUBK  =  $2A
   8932  34aa
   8933  34aa		       a9 2a		      LDA	#$2A
   8934  34ac		       85 09		      STA	COLUBK
   8935  34ae				   .
   8936  34ae							; 
   8937  34ae
   8938  34ae				   .L0370		;  scorecolor	=  $2C
   8939  34ae
   8940  34ae		       a9 2c		      LDA	#$2C
   8941  34b0		       85 a3		      STA	scorecolor
   8942  34b2				   .
   8943  34b2							; 
   8944  34b2
   8945  34b2				   .L0371		;  goto __Got_Pause_Colors
   8946  34b2
   8947  34b2		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   8948  34b5
   8949  34b5				   .
   8950  34b5							; 
   8951  34b5
   8952  34b5				   .
   8953  34b5							; 
   8954  34b5
   8955  34b5				   .
   8956  34b5							; 
   8957  34b5
   8958  34b5				   .
   8959  34b5							; 
   8960  34b5
   8961  34b5				   .
   8962  34b5							; 
   8963  34b5
   8964  34b5				   .
   8965  34b5							; 
   8966  34b5
   8967  34b5				   .
   8968  34b5							; 
   8969  34b5
   8970  34b5				   .__Ps7B
   8971  34b5							; __Ps7B
   8972  34b5
   8973  34b5				   .
   8974  34b5							; 
   8975  34b5
   8976  34b5				   .L0372		;  pfcolors:
   8977  34b5
   8978  34b5		       a9 2a		      lda	# $2A
   8979  34b7		       85 08		      sta	COLUPF
   8980  34b9				  -	      ifconst	pfres
   8981  34b9				  -	      lda	#>(pfcolorlabel137-129+pfres*pfwidth)
   8982  34b9					      else
   8983  34b9		       a9 f6		      lda	#>(pfcolorlabel137-81)
   8984  34bb					      endif
   8985  34bb		       85 f1		      sta	pfcolortable+1
   8986  34bd				  -	      ifconst	pfres
   8987  34bd				  -	      lda	#<(pfcolorlabel137-129+pfres*pfwidth)
   8988  34bd					      else
   8989  34bd		       a9 33		      lda	#<(pfcolorlabel137-81)
   8990  34bf					      endif
   8991  34bf		       85 f0		      sta	pfcolortable
   8992  34c1				   .
   8993  34c1							; 
   8994  34c1
   8995  34c1				   .L0373		;  COLUP0  =  $2A  :  COLUP1  =  $2A
   8996  34c1
   8997  34c1		       a9 2a		      LDA	#$2A
   8998  34c3		       85 06		      STA	COLUP0
   8999  34c5		       85 07		      STA	COLUP1
   9000  34c7				   .
   9001  34c7							; 
   9002  34c7
   9003  34c7				   .L0374		;  COLUBK  =  $2C
   9004  34c7
   9005  34c7		       a9 2c		      LDA	#$2C
   9006  34c9		       85 09		      STA	COLUBK
   9007  34cb				   .
   9008  34cb							; 
   9009  34cb
   9010  34cb				   .L0375		;  scorecolor	=  $2A
   9011  34cb
   9012  34cb		       a9 2a		      LDA	#$2A
   9013  34cd		       85 a3		      STA	scorecolor
   9014  34cf				   .
   9015  34cf							; 
   9016  34cf
   9017  34cf				   .L0376		;  goto __Got_Pause_Colors
   9018  34cf
   9019  34cf		       4c 5d 52 	      jmp	.__Got_Pause_Colors
   9020  34d2
   9021  34d2				   .
   9022  34d2							; 
   9023  34d2
   9024  34d2				   .
   9025  34d2							; 
   9026  34d2
   9027  34d2				   .
   9028  34d2							; 
   9029  34d2
   9030  34d2				   .L0377		;  bank 4
   9031  34d2
   9032  34d2					      if	ECHO3
      2818 bytes of ROM space left in bank 3
   9033  34d2					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   9034  34d2					      endif
   9035  34d2		       00 01	   ECHO3      =	1
   9036  3fd4					      ORG	$3FF4-bscode_length
   9037  3fd4					      RORG	$5FF4-bscode_length
   9038  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   9039  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9040  3fd6				  -	      stx	FASTFETCH
   9041  3fd6					      endif
   9042  3fd6		       9a		      txs
   9043  3fd7				  -	      if	bankswitch == 64
   9044  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9045  3fd7					      else
   9046  3fd7		       a9 f2		      lda	#>(start-1)
   9047  3fd9					      endif
   9048  3fd9		       48		      pha
   9049  3fda		       a9 4f		      lda	#<(start-1)
   9050  3fdc		       48		      pha
   9051  3fdd		       48		      pha
   9052  3fde		       8a		      txa
   9053  3fdf		       48		      pha
   9054  3fe0		       ba		      tsx
   9055  3fe1					      if	bankswitch != 64
   9056  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   9057  3fe3		       2a		      rol
   9058  3fe4		       2a		      rol
   9059  3fe5		       2a		      rol
   9060  3fe6		       2a		      rol
   9061  3fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9062  3fe9		       aa		      tax
   9063  3fea		       e8		      inx
   9064  3feb				  -	      else
   9065  3feb				  -	      lda	4,x	; get high byte of return address
   9066  3feb				  -	      tay
   9067  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9068  3feb				  -	      sta	4,x
   9069  3feb				  -	      tya
   9070  3feb				  -	      lsr
   9071  3feb				  -	      lsr
   9072  3feb				  -	      lsr
   9073  3feb				  -	      lsr
   9074  3feb				  -	      tax
   9075  3feb				  -	      inx
   9076  3feb					      endif
   9077  3feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9078  3fee		       68		      pla
   9079  3fef		       aa		      tax
   9080  3ff0		       68		      pla
   9081  3ff1		       60		      rts
   9082  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9083  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9084  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9085  3ff2					      endif
   9086  3ffc					      ORG	$3FFC
   9087  3ffc					      RORG	$5FFC
   9088  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   9089  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   9090  4000					      ORG	$4000
   9091  4000					      RORG	$7000
   9092  4000				   .
   9093  4000							; 
   9094  4000
   9095  4000				   .
   9096  4000							; 
   9097  4000
   9098  4000				   .
   9099  4000							; 
   9100  4000
   9101  4000				   .L0378		;  bank 5
   9102  4000
   9103  4000					      if	ECHO4
      4052 bytes of ROM space left in bank 4
   9104  4000					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   9105  4000					      endif
   9106  4000		       00 01	   ECHO4      =	1
   9107  4fd4					      ORG	$4FF4-bscode_length
   9108  4fd4					      RORG	$7FF4-bscode_length
   9109  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   9110  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9111  4fd6				  -	      stx	FASTFETCH
   9112  4fd6					      endif
   9113  4fd6		       9a		      txs
   9114  4fd7				  -	      if	bankswitch == 64
   9115  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9116  4fd7					      else
   9117  4fd7		       a9 f2		      lda	#>(start-1)
   9118  4fd9					      endif
   9119  4fd9		       48		      pha
   9120  4fda		       a9 4f		      lda	#<(start-1)
   9121  4fdc		       48		      pha
   9122  4fdd		       48		      pha
   9123  4fde		       8a		      txa
   9124  4fdf		       48		      pha
   9125  4fe0		       ba		      tsx
   9126  4fe1					      if	bankswitch != 64
   9127  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   9128  4fe3		       2a		      rol
   9129  4fe4		       2a		      rol
   9130  4fe5		       2a		      rol
   9131  4fe6		       2a		      rol
   9132  4fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9133  4fe9		       aa		      tax
   9134  4fea		       e8		      inx
   9135  4feb				  -	      else
   9136  4feb				  -	      lda	4,x	; get high byte of return address
   9137  4feb				  -	      tay
   9138  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9139  4feb				  -	      sta	4,x
   9140  4feb				  -	      tya
   9141  4feb				  -	      lsr
   9142  4feb				  -	      lsr
   9143  4feb				  -	      lsr
   9144  4feb				  -	      lsr
   9145  4feb				  -	      tax
   9146  4feb				  -	      inx
   9147  4feb					      endif
   9148  4feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9149  4fee		       68		      pla
   9150  4fef		       aa		      tax
   9151  4ff0		       68		      pla
   9152  4ff1		       60		      rts
   9153  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9154  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9155  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9156  4ff2					      endif
   9157  4ffc					      ORG	$4FFC
   9158  4ffc					      RORG	$7FFC
   9159  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   9160  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   9161  5000					      ORG	$5000
   9162  5000					      RORG	$9000
   9163  5000				   .
   9164  5000							; 
   9165  5000
   9166  5000				   .
   9167  5000							; 
   9168  5000
   9169  5000				   .
   9170  5000							; 
   9171  5000
   9172  5000				   .L0379		;  bank 6
   9173  5000
   9174  5000					      if	ECHO5
      4052 bytes of ROM space left in bank 5
   9175  5000					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   9176  5000					      endif
   9177  5000		       00 01	   ECHO5      =	1
   9178  5fd4					      ORG	$5FF4-bscode_length
   9179  5fd4					      RORG	$9FF4-bscode_length
   9180  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   9181  5fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9182  5fd6				  -	      stx	FASTFETCH
   9183  5fd6					      endif
   9184  5fd6		       9a		      txs
   9185  5fd7				  -	      if	bankswitch == 64
   9186  5fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9187  5fd7					      else
   9188  5fd7		       a9 f2		      lda	#>(start-1)
   9189  5fd9					      endif
   9190  5fd9		       48		      pha
   9191  5fda		       a9 4f		      lda	#<(start-1)
   9192  5fdc		       48		      pha
   9193  5fdd		       48		      pha
   9194  5fde		       8a		      txa
   9195  5fdf		       48		      pha
   9196  5fe0		       ba		      tsx
   9197  5fe1					      if	bankswitch != 64
   9198  5fe1		       b5 04		      lda	4,x	; get high byte of return address
   9199  5fe3		       2a		      rol
   9200  5fe4		       2a		      rol
   9201  5fe5		       2a		      rol
   9202  5fe6		       2a		      rol
   9203  5fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9204  5fe9		       aa		      tax
   9205  5fea		       e8		      inx
   9206  5feb				  -	      else
   9207  5feb				  -	      lda	4,x	; get high byte of return address
   9208  5feb				  -	      tay
   9209  5feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9210  5feb				  -	      sta	4,x
   9211  5feb				  -	      tya
   9212  5feb				  -	      lsr
   9213  5feb				  -	      lsr
   9214  5feb				  -	      lsr
   9215  5feb				  -	      lsr
   9216  5feb				  -	      tax
   9217  5feb				  -	      inx
   9218  5feb					      endif
   9219  5feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9220  5fee		       68		      pla
   9221  5fef		       aa		      tax
   9222  5ff0		       68		      pla
   9223  5ff1		       60		      rts
   9224  5ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9225  5ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9226  5ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9227  5ff2					      endif
   9228  5ffc					      ORG	$5FFC
   9229  5ffc					      RORG	$9FFC
   9230  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   9231  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   9232  6000					      ORG	$6000
   9233  6000					      RORG	$B000
   9234  6000				   .
   9235  6000							; 
   9236  6000
   9237  6000				   .
   9238  6000							; 
   9239  6000
   9240  6000				   .
   9241  6000							; 
   9242  6000
   9243  6000				   .L0380		;  bank 7
   9244  6000
   9245  6000					      if	ECHO6
      4052 bytes of ROM space left in bank 6
   9246  6000					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   9247  6000					      endif
   9248  6000		       00 01	   ECHO6      =	1
   9249  6fd4					      ORG	$6FF4-bscode_length
   9250  6fd4					      RORG	$BFF4-bscode_length
   9251  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   9252  6fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9253  6fd6				  -	      stx	FASTFETCH
   9254  6fd6					      endif
   9255  6fd6		       9a		      txs
   9256  6fd7				  -	      if	bankswitch == 64
   9257  6fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9258  6fd7					      else
   9259  6fd7		       a9 f2		      lda	#>(start-1)
   9260  6fd9					      endif
   9261  6fd9		       48		      pha
   9262  6fda		       a9 4f		      lda	#<(start-1)
   9263  6fdc		       48		      pha
   9264  6fdd		       48		      pha
   9265  6fde		       8a		      txa
   9266  6fdf		       48		      pha
   9267  6fe0		       ba		      tsx
   9268  6fe1					      if	bankswitch != 64
   9269  6fe1		       b5 04		      lda	4,x	; get high byte of return address
   9270  6fe3		       2a		      rol
   9271  6fe4		       2a		      rol
   9272  6fe5		       2a		      rol
   9273  6fe6		       2a		      rol
   9274  6fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9275  6fe9		       aa		      tax
   9276  6fea		       e8		      inx
   9277  6feb				  -	      else
   9278  6feb				  -	      lda	4,x	; get high byte of return address
   9279  6feb				  -	      tay
   9280  6feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9281  6feb				  -	      sta	4,x
   9282  6feb				  -	      tya
   9283  6feb				  -	      lsr
   9284  6feb				  -	      lsr
   9285  6feb				  -	      lsr
   9286  6feb				  -	      lsr
   9287  6feb				  -	      tax
   9288  6feb				  -	      inx
   9289  6feb					      endif
   9290  6feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9291  6fee		       68		      pla
   9292  6fef		       aa		      tax
   9293  6ff0		       68		      pla
   9294  6ff1		       60		      rts
   9295  6ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9296  6ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9297  6ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9298  6ff2					      endif
   9299  6ffc					      ORG	$6FFC
   9300  6ffc					      RORG	$BFFC
   9301  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   9302  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   9303  7000					      ORG	$7000
   9304  7000					      RORG	$D000
   9305  7000				   .
   9306  7000							; 
   9307  7000
   9308  7000				   .
   9309  7000							; 
   9310  7000
   9311  7000				   .
   9312  7000							; 
   9313  7000
   9314  7000				   .L0381		;  bank 8
   9315  7000
   9316  7000					      if	ECHO7
      4052 bytes of ROM space left in bank 7
   9317  7000					      echo	"    ",[(start_bank7 - *)]d , "bytes of ROM space left in bank 7")
   9318  7000					      endif
   9319  7000		       00 01	   ECHO7      =	1
   9320  7fd4					      ORG	$7FF4-bscode_length
   9321  7fd4					      RORG	$DFF4-bscode_length
   9322  7fd4		       a2 ff	   start_bank7 ldx	#$ff
   9323  7fd6				  -	      ifconst	FASTFETCH	; using DPC+
   9324  7fd6				  -	      stx	FASTFETCH
   9325  7fd6					      endif
   9326  7fd6		       9a		      txs
   9327  7fd7				  -	      if	bankswitch == 64
   9328  7fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   9329  7fd7					      else
   9330  7fd7		       a9 f2		      lda	#>(start-1)
   9331  7fd9					      endif
   9332  7fd9		       48		      pha
   9333  7fda		       a9 4f		      lda	#<(start-1)
   9334  7fdc		       48		      pha
   9335  7fdd		       48		      pha
   9336  7fde		       8a		      txa
   9337  7fdf		       48		      pha
   9338  7fe0		       ba		      tsx
   9339  7fe1					      if	bankswitch != 64
   9340  7fe1		       b5 04		      lda	4,x	; get high byte of return address
   9341  7fe3		       2a		      rol
   9342  7fe4		       2a		      rol
   9343  7fe5		       2a		      rol
   9344  7fe6		       2a		      rol
   9345  7fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   9346  7fe9		       aa		      tax
   9347  7fea		       e8		      inx
   9348  7feb				  -	      else
   9349  7feb				  -	      lda	4,x	; get high byte of return address
   9350  7feb				  -	      tay
   9351  7feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   9352  7feb				  -	      sta	4,x
   9353  7feb				  -	      tya
   9354  7feb				  -	      lsr
   9355  7feb				  -	      lsr
   9356  7feb				  -	      lsr
   9357  7feb				  -	      lsr
   9358  7feb				  -	      tax
   9359  7feb				  -	      inx
   9360  7feb					      endif
   9361  7feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   9362  7fee		       68		      pla
   9363  7fef		       aa		      tax
   9364  7ff0		       68		      pla
   9365  7ff1		       60		      rts
   9366  7ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   9367  7ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   9368  7ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   9369  7ff2					      endif
   9370  7ffc					      ORG	$7FFC
   9371  7ffc					      RORG	$DFFC
   9372  7ffc		       d4 df		      .word.w	(start_bank7 & $ffff)
   9373  7ffe		       d4 df		      .word.w	(start_bank7 & $ffff)
   9374  8000					      ORG	$8000
   9375  8000					      RORG	$F000
   9376  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   9377  8000
   9378  8000							; This is a 2-line kernel!
   9379  8000					      ifnconst	vertical_reflect
   9380  8000				   kernel
   9381  8000					      endif
   9382  8000		       85 02		      sta	WSYNC
   9383  8002		       a9 ff		      lda	#255
   9384  8004		       8d 96 02 	      sta	TIM64T
   9385  8007
   9386  8007		       a9 01		      lda	#1
   9387  8009		       85 27		      sta	VDELBL
   9388  800b		       85 25		      sta	VDELP0
   9389  800d		       a6 92		      ldx	ballheight
   9390  800f		       e8		      inx
   9391  8010		       e8		      inx
   9392  8011		       86 9f		      stx	temp4
   9393  8013		       a5 86		      lda	player1y
   9394  8015		       85 9e		      sta	temp3
   9395  8017
   9396  8017				  -	      ifconst	shakescreen
   9397  8017				  -	      jsr	doshakescreen
   9398  8017					      else
   9399  8017		       a6 90		      ldx	missile0height
   9400  8019		       e8		      inx
   9401  801a					      endif
   9402  801a
   9403  801a		       e8		      inx
   9404  801b		       86 f6		      stx	stack1
   9405  801d
   9406  801d		       a5 89		      lda	bally
   9407  801f		       85 f7		      sta	stack2
   9408  8021
   9409  8021		       a5 85		      lda	player0y
   9410  8023		       a2 00		      ldx	#0
   9411  8025		       85 02		      sta	WSYNC
   9412  8027		       86 1b		      stx	GRP0
   9413  8029		       86 1c		      stx	GRP1
   9414  802b		       86 0e		      stx	PF1L
   9415  802d		       86 0f		      stx	PF2
   9416  802f		       86 2c		      stx	CXCLR
   9417  8031				  -	      ifconst	readpaddle
   9418  8031				  -	      stx	paddle
   9419  8031					      else
      0  8031					      sleep	3
      1  8031				   .CYCLES    SET	3
      2  8031
      3  8031				  -	      IF	.CYCLES < 2
      4  8031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8031				  -	      ERR
      6  8031					      ENDIF
      7  8031
      8  8031					      IF	.CYCLES & 1
      9  8031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8031		       04 00		      nop	0
     11  8033				  -	      ELSE
     12  8033				  -	      bit	VSYNC
     13  8033					      ENDIF
     14  8033				   .CYCLES    SET	.CYCLES - 3
     15  8033					      ENDIF
     16  8033
     17  8033				  -	      REPEAT	.CYCLES / 2
     18  8033				  -	      nop
     19  8033					      REPEND
   9421  8033					      endif
   9422  8033
   9423  8033		       95 9d		      sta	temp2,x
   9424  8035
   9425  8035							;store these so they can be retrieved later
   9426  8035					      ifnconst	pfres
   9427  8035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   9428  8037				  -	      else
   9429  8037				  -	      ldx	#132-pfres*pfwidth
   9430  8037					      endif
   9431  8037
   9432  8037		       c6 85		      dec	player0y
   9433  8039
   9434  8039		       a5 91		      lda	missile0y
   9435  803b		       85 a0		      sta	temp5
   9436  803d		       a5 88		      lda	missile1y
   9437  803f		       85 a1		      sta	temp6
   9438  8041
   9439  8041		       a5 ef		      lda	playfieldpos
   9440  8043		       85 9c		      sta	temp1
   9441  8045
   9442  8045				  -	      ifconst	pfrowheight
   9443  8045				  -	      lda	#pfrowheight+2
   9444  8045					      else
   9445  8045					      ifnconst	pfres
   9446  8045		       a9 0a		      lda	#10
   9447  8047				  -	      else
   9448  8047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   9449  8047					      endif
   9450  8047					      endif
   9451  8047		       18		      clc
   9452  8048		       e5 ef		      sbc	playfieldpos
   9453  804a		       85 ef		      sta	playfieldpos
   9454  804c		       4c 74 f0 	      jmp	.startkernel
   9455  804f
   9456  804f				   .skipDrawP0
   9457  804f		       a9 00		      lda	#0
   9458  8051		       a8		      tay
   9459  8052		       4c a2 f0 	      jmp	.continueP0
   9460  8055
   9461  8055				   .skipDrawP1
   9462  8055		       a9 00		      lda	#0
   9463  8057		       a8		      tay
   9464  8058		       4c 7e f0 	      jmp	.continueP1
   9465  805b
   9466  805b				   .kerloop		; enter at cycle 59??
   9467  805b
   9468  805b				   continuekernel
      0  805b					      sleep	2
      1  805b				   .CYCLES    SET	2
      2  805b
      3  805b				  -	      IF	.CYCLES < 2
      4  805b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  805b				  -	      ERR
      6  805b					      ENDIF
      7  805b
      8  805b				  -	      IF	.CYCLES & 1
      9  805b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  805b				  -	      nop	0
     11  805b				  -	      ELSE
     12  805b				  -	      bit	VSYNC
     13  805b				  -	      ENDIF
     14  805b				  -.CYCLES    SET	.CYCLES - 3
     15  805b					      ENDIF
     16  805b
     17  805b					      REPEAT	.CYCLES / 2
     18  805b		       ea		      nop
     19  805c					      REPEND
   9470  805c				   continuekernel2
   9471  805c		       a5 92		      lda	ballheight
   9472  805e
   9473  805e				  -	      ifconst	pfres
   9474  805e				  -	      ldy	playfield+pfres*pfwidth-132,x
   9475  805e				  -	      sty	PF1L	;3
   9476  805e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   9477  805e				  -	      sty	PF2L	;3
   9478  805e				  -	      ldy	playfield+pfres*pfwidth-129,x
   9479  805e				  -	      sty	PF1R	; 3 too early?
   9480  805e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   9481  805e				  -	      sty	PF2R	;3
   9482  805e					      else
   9483  805e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   9484  8060		       84 0e		      sty	PF1L	;3
   9485  8062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   9486  8064		       84 0f		      sty	PF2L	;3
   9487  8066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   9488  8068		       84 0e		      sty	PF1R	; 3 too early?
   9489  806a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   9490  806c		       84 0f		      sty	PF2R	;3
   9491  806e					      endif
   9492  806e
   9493  806e							; should be playfield+$38 for width=2
   9494  806e
   9495  806e		       c7 89		      dcp	bally
   9496  8070		       2a		      rol
   9497  8071		       2a		      rol
   9498  8072							; rol
   9499  8072							; rol
   9500  8072				   goback
   9501  8072		       85 1f		      sta	ENABL
   9502  8074				   .startkernel
   9503  8074		       a5 8f		      lda	player1height	;3
   9504  8076		       c7 86		      dcp	player1y	;5
   9505  8078		       90 db		      bcc	.skipDrawP1	;2
   9506  807a		       a4 86		      ldy	player1y	;3
   9507  807c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   9508  807e							; so it doesn't cross a page boundary!
   9509  807e
   9510  807e				   .continueP1
   9511  807e		       85 1c		      sta	GRP1	;3
   9512  8080
   9513  8080					      ifnconst	player1colors
   9514  8080		       a5 87		      lda	missile1height	;3
   9515  8082		       c7 88		      dcp	missile1y	;5
   9516  8084		       2a		      rol		;2
   9517  8085		       2a		      rol		;2
   9518  8086		       85 1e		      sta	ENAM1	;3
   9519  8088				  -	      else
   9520  8088				  -	      lda	(player1color),y
   9521  8088				  -	      sta	COLUP1
   9522  8088				  -	      ifnconst	playercolors
   9523  8088				  -	      sleep	7
   9524  8088				  -	      else
   9525  8088				  -	      lda.w	player0colorstore
   9526  8088				  -	      sta	COLUP0
   9527  8088				  -	      endif
   9528  8088					      endif
   9529  8088
   9530  8088				  -	      ifconst	pfres
   9531  8088				  -	      lda	playfield+pfres*pfwidth-132,x
   9532  8088				  -	      sta	PF1L	;3
   9533  8088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   9534  8088				  -	      sta	PF2L	;3
   9535  8088				  -	      lda	playfield+pfres*pfwidth-129,x
   9536  8088				  -	      sta	PF1R	; 3 too early?
   9537  8088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   9538  8088				  -	      sta	PF2R	;3
   9539  8088					      else
   9540  8088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   9541  808a		       85 0e		      sta	PF1L	;3
   9542  808c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   9543  808e		       85 0f		      sta	PF2L	;3
   9544  8090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   9545  8092		       85 0e		      sta	PF1R	; 3 too early?
   9546  8094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   9547  8096		       85 0f		      sta	PF2R	;3
   9548  8098					      endif
   9549  8098							; sleep 3
   9550  8098
   9551  8098		       a5 8e		      lda	player0height
   9552  809a		       c7 85		      dcp	player0y
   9553  809c		       90 b1		      bcc	.skipDrawP0
   9554  809e		       a4 85		      ldy	player0y
   9555  80a0		       b1 8a		      lda	(player0pointer),y
   9556  80a2				   .continueP0
   9557  80a2		       85 1b		      sta	GRP0
   9558  80a4
   9559  80a4				  -	      ifnconst	no_blank_lines
   9560  80a4				  -	      ifnconst	playercolors
   9561  80a4				  -	      lda	missile0height	;3
   9562  80a4				  -	      dcp	missile0y	;5
   9563  80a4				  -	      sbc	stack1
   9564  80a4				  -	      sta	ENAM0	;3
   9565  80a4				  -	      else
   9566  80a4				  -	      lda	(player0color),y
   9567  80a4				  -	      sta	player0colorstore
   9568  80a4				  -	      sleep	6
   9569  80a4				  -	      endif
   9570  80a4				  -	      dec	temp1
   9571  80a4				  -	      bne	continuekernel
   9572  80a4					      else
   9573  80a4		       c6 9c		      dec	temp1
   9574  80a6		       f0 0c		      beq	altkernel2
   9575  80a8				  -	      ifconst	readpaddle
   9576  80a8				  -	      ldy	currentpaddle
   9577  80a8				  -	      lda	INPT0,y
   9578  80a8				  -	      bpl	noreadpaddle
   9579  80a8				  -	      inc	paddle
   9580  80a8				  -	      jmp	continuekernel2
   9581  80a8				  -noreadpaddle
   9582  80a8				  -	      sleep	2
   9583  80a8				  -	      jmp	continuekernel
   9584  80a8					      else
   9585  80a8					      ifnconst	playercolors
   9586  80a8					      ifconst	PFcolors
   9587  80a8		       8a		      txa
   9588  80a9		       a8		      tay
   9589  80aa		       b1 f0		      lda	(pfcolortable),y
   9590  80ac					      ifnconst	backgroundchange
   9591  80ac		       85 08		      sta	COLUPF
   9592  80ae				  -	      else
   9593  80ae				  -	      sta	COLUBK
   9594  80ae					      endif
   9595  80ae		       4c 5b f0 	      jmp	continuekernel
   9596  80b1				  -	      else
   9597  80b1				  -	      ifconst	kernelmacrodef
   9598  80b1				  -	      kernelmacro
   9599  80b1				  -	      else
   9600  80b1				  -	      sleep	12
   9601  80b1				  -	      endif
   9602  80b1					      endif
   9603  80b1				  -	      else
   9604  80b1				  -	      lda	(player0color),y
   9605  80b1				  -	      sta	player0colorstore
   9606  80b1				  -	      sleep	4
   9607  80b1					      endif
   9608  80b1		       4c 5b f0 	      jmp	continuekernel
   9609  80b4					      endif
   9610  80b4				   altkernel2
   9611  80b4		       8a		      txa
   9612  80b5					      ifnconst	vertical_reflect
   9613  80b5		       cb fc		      sbx	#256-pfwidth
   9614  80b7				  -	      else
   9615  80b7				  -	      sbx	#256-pfwidth/2
   9616  80b7					      endif
   9617  80b7		       30 24		      bmi	lastkernelline
   9618  80b9				  -	      ifconst	pfrowheight
   9619  80b9				  -	      lda	#pfrowheight
   9620  80b9					      else
   9621  80b9					      ifnconst	pfres
   9622  80b9		       a9 08		      lda	#8
   9623  80bb				  -	      else
   9624  80bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   9625  80bb					      endif
   9626  80bb					      endif
   9627  80bb		       85 9c		      sta	temp1
   9628  80bd		       4c 5b f0 	      jmp	continuekernel
   9629  80c0					      endif
   9630  80c0
   9631  80c0				   altkernel
   9632  80c0
   9633  80c0				  -	      ifconst	PFmaskvalue
   9634  80c0				  -	      lda	#PFmaskvalue
   9635  80c0					      else
   9636  80c0		       a9 00		      lda	#0
   9637  80c2					      endif
   9638  80c2		       85 0e		      sta	PF1L
   9639  80c4		       85 0f		      sta	PF2
   9640  80c6
   9641  80c6
   9642  80c6							;sleep 3
   9643  80c6
   9644  80c6							;28 cycles to fix things
   9645  80c6							;minus 11=17
   9646  80c6
   9647  80c6							; lax temp4
   9648  80c6							; clc
   9649  80c6		       8a		      txa
   9650  80c7					      ifnconst	vertical_reflect
   9651  80c7		       cb fc		      sbx	#256-pfwidth
   9652  80c9				  -	      else
   9653  80c9				  -	      sbx	#256-pfwidth/2
   9654  80c9					      endif
   9655  80c9
   9656  80c9		       30 12		      bmi	lastkernelline
   9657  80cb
   9658  80cb				  -	      ifconst	PFcolorandheight
   9659  80cb				  -	      ifconst	pfres
   9660  80cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   9661  80cb				  -	      else
   9662  80cb				  -	      ldy	playfieldcolorandheight-87,x
   9663  80cb				  -	      endif
   9664  80cb				  -	      ifnconst	backgroundchange
   9665  80cb				  -	      sty	COLUPF
   9666  80cb				  -	      else
   9667  80cb				  -	      sty	COLUBK
   9668  80cb				  -	      endif
   9669  80cb				  -	      ifconst	pfres
   9670  80cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   9671  80cb				  -	      else
   9672  80cb				  -	      lda	playfieldcolorandheight-88,x
   9673  80cb				  -	      endif
   9674  80cb				  -	      sta.w	temp1
   9675  80cb					      endif
   9676  80cb				  -	      ifconst	PFheights
   9677  80cb				  -	      lsr
   9678  80cb				  -	      lsr
   9679  80cb				  -	      tay
   9680  80cb				  -	      lda	(pfheighttable),y
   9681  80cb				  -	      sta.w	temp1
   9682  80cb					      endif
   9683  80cb					      ifconst	PFcolors
   9684  80cb		       a8		      tay
   9685  80cc		       b1 f0		      lda	(pfcolortable),y
   9686  80ce					      ifnconst	backgroundchange
   9687  80ce		       85 08		      sta	COLUPF
   9688  80d0				  -	      else
   9689  80d0				  -	      sta	COLUBK
   9690  80d0					      endif
   9691  80d0				  -	      ifconst	pfrowheight
   9692  80d0				  -	      lda	#pfrowheight
   9693  80d0					      else
   9694  80d0					      ifnconst	pfres
   9695  80d0		       a9 08		      lda	#8
   9696  80d2				  -	      else
   9697  80d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   9698  80d2					      endif
   9699  80d2					      endif
   9700  80d2		       85 9c		      sta	temp1
   9701  80d4					      endif
   9702  80d4					      ifnconst	PFcolorandheight
   9703  80d4				  -	      ifnconst	PFcolors
   9704  80d4				  -	      ifnconst	PFheights
   9705  80d4				  -	      ifnconst	no_blank_lines
   9706  80d4				  -			; read paddle 0
   9707  80d4				  -			; lo-res paddle read
   9708  80d4				  -			; bit INPT0
   9709  80d4				  -			; bmi paddleskipread
   9710  80d4				  -			; inc paddle0
   9711  80d4				  -			;donepaddleskip
   9712  80d4				  -	      sleep	10
   9713  80d4				  -	      ifconst	pfrowheight
   9714  80d4				  -	      lda	#pfrowheight
   9715  80d4				  -	      else
   9716  80d4				  -	      ifnconst	pfres
   9717  80d4				  -	      lda	#8
   9718  80d4				  -	      else
   9719  80d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   9720  80d4				  -	      endif
   9721  80d4				  -	      endif
   9722  80d4				  -	      sta	temp1
   9723  80d4				  -	      endif
   9724  80d4				  -	      endif
   9725  80d4					      endif
   9726  80d4					      endif
   9727  80d4
   9728  80d4
   9729  80d4		       a5 92		      lda	ballheight
   9730  80d6		       c7 89		      dcp	bally
   9731  80d8		       e5 9f		      sbc	temp4
   9732  80da
   9733  80da
   9734  80da		       4c 72 f0 	      jmp	goback
   9735  80dd
   9736  80dd
   9737  80dd				  -	      ifnconst	no_blank_lines
   9738  80dd				  -lastkernelline
   9739  80dd				  -	      ifnconst	PFcolors
   9740  80dd				  -	      sleep	10
   9741  80dd				  -	      else
   9742  80dd				  -	      ldy	#124
   9743  80dd				  -	      lda	(pfcolortable),y
   9744  80dd				  -	      sta	COLUPF
   9745  80dd				  -	      endif
   9746  80dd				  -
   9747  80dd				  -	      ifconst	PFheights
   9748  80dd				  -	      ldx	#1
   9749  80dd				  -			;sleep 4
   9750  80dd				  -	      sleep	3	; this was over 1 cycle
   9751  80dd				  -	      else
   9752  80dd				  -	      ldx	playfieldpos
   9753  80dd				  -			;sleep 3
   9754  80dd				  -	      sleep	2	; this was over 1 cycle
   9755  80dd				  -	      endif
   9756  80dd				  -
   9757  80dd				  -	      jmp	enterlastkernel
   9758  80dd				  -
   9759  80dd					      else
   9760  80dd				   lastkernelline
   9761  80dd
   9762  80dd				  -	      ifconst	PFheights
   9763  80dd				  -	      ldx	#1
   9764  80dd				  -			;sleep 5
   9765  80dd				  -	      sleep	4	; this was over 1 cycle
   9766  80dd					      else
   9767  80dd		       a6 ef		      ldx	playfieldpos
   9768  80df							;sleep 4
      0  80df					      sleep	3	; this was over 1 cycle
      1  80df				   .CYCLES    SET	3
      2  80df
      3  80df				  -	      IF	.CYCLES < 2
      4  80df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80df				  -	      ERR
      6  80df					      ENDIF
      7  80df
      8  80df					      IF	.CYCLES & 1
      9  80df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  80df		       04 00		      nop	0
     11  80e1				  -	      ELSE
     12  80e1				  -	      bit	VSYNC
     13  80e1					      ENDIF
     14  80e1				   .CYCLES    SET	.CYCLES - 3
     15  80e1					      ENDIF
     16  80e1
     17  80e1				  -	      REPEAT	.CYCLES / 2
     18  80e1				  -	      nop
     19  80e1					      REPEND
   9770  80e1					      endif
   9771  80e1
   9772  80e1		       e0 00		      cpx	#0
   9773  80e3		       d0 22		      bne	.enterfromNBL
   9774  80e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   9775  80e8					      endif
   9776  80e8
   9777  80e8					      if	((<*)>$d5)
   9778  8100		       00 00 00 00*	      align	256
   9779  8100					      endif
   9780  8100							; this is a kludge to prevent page wrapping - fix!!!
   9781  8100
   9782  8100				   .skipDrawlastP1
   9783  8100		       a9 00		      lda	#0
   9784  8102		       a8		      tay		; added so we don't cross a page
   9785  8103		       4c 2d f1 	      jmp	.continuelastP1
   9786  8106
   9787  8106				   .endkerloop		; enter at cycle 59??
   9788  8106
   9789  8106		       ea		      nop
   9790  8107
   9791  8107				   .enterfromNBL
   9792  8107				  -	      ifconst	pfres
   9793  8107				  -	      ldy.w	playfield+pfres*pfwidth-4
   9794  8107				  -	      sty	PF1L	;3
   9795  8107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   9796  8107				  -	      sty	PF2L	;3
   9797  8107				  -	      ldy.w	playfield+pfres*pfwidth-1
   9798  8107				  -	      sty	PF1R	; possibly too early?
   9799  8107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   9800  8107				  -	      sty	PF2R	;3
   9801  8107					      else
   9802  8107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   9803  810a		       84 0e		      sty	PF1L	;3
   9804  810c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   9805  810f		       84 0f		      sty	PF2L	;3
   9806  8111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   9807  8114		       84 0e		      sty	PF1R	; possibly too early?
   9808  8116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   9809  8119		       84 0f		      sty	PF2R	;3
   9810  811b					      endif
   9811  811b
   9812  811b				   enterlastkernel
   9813  811b		       a5 92		      lda	ballheight
   9814  811d
   9815  811d							; tya
   9816  811d		       c7 89		      dcp	bally
   9817  811f							; sleep 4
   9818  811f
   9819  811f							; sbc stack3
   9820  811f		       2a		      rol
   9821  8120		       2a		      rol
   9822  8121		       85 1f		      sta	ENABL
   9823  8123
   9824  8123		       a5 8f		      lda	player1height	;3
   9825  8125		       c7 86		      dcp	player1y	;5
   9826  8127		       90 d7		      bcc	.skipDrawlastP1
   9827  8129		       a4 86		      ldy	player1y	;3
   9828  812b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   9829  812d							; so it doesn't cross a page boundary!
   9830  812d
   9831  812d				   .continuelastP1
   9832  812d		       85 1c		      sta	GRP1	;3
   9833  812f
   9834  812f					      ifnconst	player1colors
   9835  812f		       a5 87		      lda	missile1height	;3
   9836  8131		       c7 88		      dcp	missile1y	;5
   9837  8133				  -	      else
   9838  8133				  -	      lda	(player1color),y
   9839  8133				  -	      sta	COLUP1
   9840  8133					      endif
   9841  8133
   9842  8133		       ca		      dex
   9843  8134							;dec temp4 ; might try putting this above PF writes
   9844  8134		       f0 34		      beq	endkernel
   9845  8136
   9846  8136
   9847  8136				  -	      ifconst	pfres
   9848  8136				  -	      ldy.w	playfield+pfres*pfwidth-4
   9849  8136				  -	      sty	PF1L	;3
   9850  8136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   9851  8136				  -	      sty	PF2L	;3
   9852  8136				  -	      ldy.w	playfield+pfres*pfwidth-1
   9853  8136				  -	      sty	PF1R	; possibly too early?
   9854  8136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   9855  8136				  -	      sty	PF2R	;3
   9856  8136					      else
   9857  8136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   9858  8139		       84 0e		      sty	PF1L	;3
   9859  813b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   9860  813e		       84 0f		      sty	PF2L	;3
   9861  8140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   9862  8143		       84 0e		      sty	PF1R	; possibly too early?
   9863  8145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   9864  8148		       84 0f		      sty	PF2R	;3
   9865  814a					      endif
   9866  814a
   9867  814a					      ifnconst	player1colors
   9868  814a		       2a		      rol		;2
   9869  814b		       2a		      rol		;2
   9870  814c		       85 1e		      sta	ENAM1	;3
   9871  814e				  -	      else
   9872  814e				  -	      ifnconst	playercolors
   9873  814e				  -	      sleep	7
   9874  814e				  -	      else
   9875  814e				  -	      lda.w	player0colorstore
   9876  814e				  -	      sta	COLUP0
   9877  814e				  -	      endif
   9878  814e					      endif
   9879  814e
   9880  814e		       ad 8e 00 	      lda.w	player0height
   9881  8151		       c7 85		      dcp	player0y
   9882  8153		       90 0d		      bcc	.skipDrawlastP0
   9883  8155		       a4 85		      ldy	player0y
   9884  8157		       b1 8a		      lda	(player0pointer),y
   9885  8159				   .continuelastP0
   9886  8159		       85 1b		      sta	GRP0
   9887  815b
   9888  815b
   9889  815b
   9890  815b				  -	      ifnconst	no_blank_lines
   9891  815b				  -	      lda	missile0height	;3
   9892  815b				  -	      dcp	missile0y	;5
   9893  815b				  -	      sbc	stack1
   9894  815b				  -	      sta	ENAM0	;3
   9895  815b				  -	      jmp	.endkerloop
   9896  815b					      else
   9897  815b				  -	      ifconst	readpaddle
   9898  815b				  -	      ldy	currentpaddle
   9899  815b				  -	      lda	INPT0,y
   9900  815b				  -	      bpl	noreadpaddle2
   9901  815b				  -	      inc	paddle
   9902  815b				  -	      jmp	.endkerloop
   9903  815b				  -noreadpaddle2
   9904  815b				  -	      sleep	4
   9905  815b				  -	      jmp	.endkerloop
   9906  815b					      else		; no_blank_lines and no paddle reading
   9907  815b		       68		      pla
   9908  815c		       48		      pha		; 14 cycles in 4 bytes
   9909  815d		       68		      pla
   9910  815e		       48		      pha
   9911  815f							; sleep 14
   9912  815f		       4c 06 f1 	      jmp	.endkerloop
   9913  8162					      endif
   9914  8162					      endif
   9915  8162
   9916  8162
   9917  8162							; ifconst donepaddleskip
   9918  8162							;paddleskipread
   9919  8162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   9920  8162							; plus we get a lo-res paddle read
   9921  8162							; bmi donepaddleskip
   9922  8162							; endif
   9923  8162
   9924  8162				   .skipDrawlastP0
   9925  8162		       a9 00		      lda	#0
   9926  8164		       a8		      tay
   9927  8165		       4c 59 f1 	      jmp	.continuelastP0
   9928  8168
   9929  8168					      ifconst	no_blank_lines
   9930  8168				   no_blank_lines_bailout
   9931  8168		       a2 00		      ldx	#0
   9932  816a					      endif
   9933  816a
   9934  816a				   endkernel
   9935  816a							; 6 digit score routine
   9936  816a		       86 0e		      stx	PF1
   9937  816c		       86 0f		      stx	PF2
   9938  816e		       86 0d		      stx	PF0
   9939  8170		       18		      clc
   9940  8171
   9941  8171				  -	      ifconst	pfrowheight
   9942  8171				  -	      lda	#pfrowheight+2
   9943  8171					      else
   9944  8171					      ifnconst	pfres
   9945  8171		       a9 0a		      lda	#10
   9946  8173				  -	      else
   9947  8173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   9948  8173					      endif
   9949  8173					      endif
   9950  8173
   9951  8173		       e5 ef		      sbc	playfieldpos
   9952  8175		       85 ef		      sta	playfieldpos
   9953  8177		       8a		      txa
   9954  8178
   9955  8178				  -	      ifconst	shakescreen
   9956  8178				  -	      bit	shakescreen
   9957  8178				  -	      bmi	noshakescreen2
   9958  8178				  -	      ldx	#$3D
   9959  8178				  -noshakescreen2
   9960  8178					      endif
   9961  8178
   9962  8178		       95 02		      sta	WSYNC,x
   9963  817a
   9964  817a							; STA WSYNC ;first one, need one more
   9965  817a		       85 0b		      sta	REFP0
   9966  817c		       85 0c		      sta	REFP1
   9967  817e		       85 1b		      STA	GRP0
   9968  8180		       85 1c		      STA	GRP1
   9969  8182							; STA PF1
   9970  8182							; STA PF2
   9971  8182		       85 2b		      sta	HMCLR
   9972  8184		       85 1d		      sta	ENAM0
   9973  8186		       85 1e		      sta	ENAM1
   9974  8188		       85 1f		      sta	ENABL
   9975  818a
   9976  818a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   9977  818c		       85 85		      sta	player0y
   9978  818e		       a5 9e		      lda	temp3
   9979  8190		       85 86		      sta	player1y
   9980  8192					      ifnconst	player1colors
   9981  8192		       a5 a1		      lda	temp6
   9982  8194		       85 88		      sta	missile1y
   9983  8196					      endif
   9984  8196					      ifnconst	playercolors
   9985  8196					      ifnconst	readpaddle
   9986  8196		       a5 a0		      lda	temp5
   9987  8198		       85 91		      sta	missile0y
   9988  819a					      endif
   9989  819a					      endif
   9990  819a		       a5 f7		      lda	stack2
   9991  819c		       85 89		      sta	bally
   9992  819e
   9993  819e							; strangely, this isn't required any more. might have
   9994  819e							; resulted from the no_blank_lines score bounce fix
   9995  819e							;ifconst no_blank_lines
   9996  819e							;sta WSYNC
   9997  819e							;endif
   9998  819e
   9999  819e		       ad 84 02 	      lda	INTIM
  10000  81a1		       18		      clc
  10001  81a2					      ifnconst	vblank_time
  10002  81a2		       69 8e		      adc	#43+12+87
  10003  81a4				  -	      else
  10004  81a4				  -	      adc	#vblank_time+12+87
  10005  81a4				  -
  10006  81a4					      endif
  10007  81a4							; sta WSYNC
  10008  81a4		       8d 96 02 	      sta	TIM64T
  10009  81a7
  10010  81a7				  -	      ifconst	minikernel
  10011  81a7				  -	      jsr	minikernel
  10012  81a7					      endif
  10013  81a7
  10014  81a7							; now reassign temp vars for score pointers
  10015  81a7
  10016  81a7							; score pointers contain:
  10017  81a7							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
  10018  81a7							; swap lo2->temp1
  10019  81a7							; swap lo4->temp3
  10020  81a7							; swap lo6->temp5
  10021  81a7					      ifnconst	noscore
  10022  81a7		       a5 97		      lda	scorepointers+1
  10023  81a9							; ldy temp1
  10024  81a9		       85 9c		      sta	temp1
  10025  81ab							; sty scorepointers+1
  10026  81ab
  10027  81ab		       a5 99		      lda	scorepointers+3
  10028  81ad							; ldy temp3
  10029  81ad		       85 9e		      sta	temp3
  10030  81af							; sty scorepointers+3
  10031  81af
  10032  81af
  10033  81af		       85 2b		      sta	HMCLR
  10034  81b1		       ba		      tsx
  10035  81b2		       86 f6		      stx	stack1
  10036  81b4		       a2 e0		      ldx	#$E0
  10037  81b6		       86 20		      stx	HMP0
  10038  81b8
  10039  81b8		       a5 a3		      LDA	scorecolor
  10040  81ba		       85 06		      STA	COLUP0
  10041  81bc		       85 07		      STA	COLUP1
  10042  81be				  -	      ifconst	scorefade
  10043  81be				  -	      STA	stack2
  10044  81be					      endif
  10045  81be				  -	      ifconst	pfscore
  10046  81be				  -	      lda	pfscorecolor
  10047  81be				  -	      sta	COLUPF
  10048  81be					      endif
  10049  81be		       85 02		      sta	WSYNC
  10050  81c0		       a2 00		      ldx	#0
  10051  81c2		       86 1b		      STx	GRP0
  10052  81c4		       86 1c		      STx	GRP1	; seems to be needed because of vdel
  10053  81c6
  10054  81c6		       a5 9b		      lda	scorepointers+5
  10055  81c8							; ldy temp5
  10056  81c8		       95 a0		      sta	temp5,x
  10057  81ca							; sty scorepointers+5
  10058  81ca		       a9 ff		      lda	#>scoretable
  10059  81cc		       85 97		      sta	scorepointers+1
  10060  81ce		       85 99		      sta	scorepointers+3
  10061  81d0		       85 9b		      sta	scorepointers+5
  10062  81d2		       85 9d		      sta	temp2
  10063  81d4		       85 9f		      sta	temp4
  10064  81d6		       85 a1		      sta	temp6
  10065  81d8		       a0 07		      LDY	#7
  10066  81da		       84 25		      STY	VDELP0
  10067  81dc		       85 10		      STA	RESP0
  10068  81de		       85 11		      STA	RESP1
  10069  81e0
  10070  81e0
  10071  81e0		       a9 03		      LDA	#$03
  10072  81e2		       85 04		      STA	NUSIZ0
  10073  81e4		       85 05		      STA	NUSIZ1
  10074  81e6		       85 26		      STA	VDELP1
  10075  81e8		       a9 f0		      LDA	#$F0
  10076  81ea		       85 21		      STA	HMP1
  10077  81ec		       b1 96		      lda	(scorepointers),y
  10078  81ee		       85 1b		      sta	GRP0
  10079  81f0		       85 2a		      STA	HMOVE	; cycle 73 ?
  10080  81f2		       4c 08 f2 	      jmp	beginscore
  10081  81f5
  10082  81f5
  10083  81f5					      if	((<*)>$d4)
  10084  8200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
  10085  8200					      endif
  10086  8200
  10087  8200				   loop2
  10088  8200		       b1 96		      lda	(scorepointers),y	;+5 68 204
  10089  8202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
  10090  8204				  -	      ifconst	pfscore
  10091  8204				  -	      lda.w	pfscore1
  10092  8204				  -	      sta	PF1
  10093  8204					      else
  10094  8204				  -	      ifconst	scorefade
  10095  8204				  -	      sleep	2
  10096  8204				  -	      dec	stack2	; decrement the temporary scorecolor
  10097  8204					      else
      0  8204					      sleep	7
      1  8204				   .CYCLES    SET	7
      2  8204
      3  8204				  -	      IF	.CYCLES < 2
      4  8204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8204				  -	      ERR
      6  8204					      ENDIF
      7  8204
      8  8204					      IF	.CYCLES & 1
      9  8204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8204		       04 00		      nop	0
     11  8206				  -	      ELSE
     12  8206				  -	      bit	VSYNC
     13  8206					      ENDIF
     14  8206				   .CYCLES    SET	.CYCLES - 3
     15  8206					      ENDIF
     16  8206
     17  8206					      REPEAT	.CYCLES / 2
     18  8206		       ea		      nop
     17  8206					      REPEND
     18  8207		       ea		      nop
     19  8208					      REPEND
  10099  8208					      endif
  10100  8208					      endif
  10101  8208							; cycle 0
  10102  8208				   beginscore
  10103  8208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
  10104  820a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
  10105  820c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
  10106  820e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
  10107  8210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
  10108  8212		       9a		      txs
  10109  8213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
  10110  8215				  -	      ifconst	scorefade
  10111  8215				  -	      lda	stack2
  10112  8215					      else
      0  8215					      sleep	3
      1  8215				   .CYCLES    SET	3
      2  8215
      3  8215				  -	      IF	.CYCLES < 2
      4  8215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8215				  -	      ERR
      6  8215					      ENDIF
      7  8215
      8  8215					      IF	.CYCLES & 1
      9  8215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8215		       04 00		      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217					      ENDIF
     14  8217				   .CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217				  -	      REPEAT	.CYCLES / 2
     18  8217				  -	      nop
     19  8217					      REPEND
  10114  8217					      endif
  10115  8217
  10116  8217				  -	      ifconst	pfscore
  10117  8217				  -	      lda	pfscore2
  10118  8217				  -	      sta	PF1
  10119  8217					      else
  10120  8217				  -	      ifconst	scorefade
  10121  8217				  -	      sta	COLUP0
  10122  8217				  -	      sta	COLUP1
  10123  8217					      else
      0  8217					      sleep	6
      1  8217				   .CYCLES    SET	6
      2  8217
      3  8217				  -	      IF	.CYCLES < 2
      4  8217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8217				  -	      ERR
      6  8217					      ENDIF
      7  8217
      8  8217				  -	      IF	.CYCLES & 1
      9  8217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  8217				  -	      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217				  -	      ENDIF
     14  8217				  -.CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217					      REPEAT	.CYCLES / 2
     18  8217		       ea		      nop
     17  8217					      REPEND
     18  8218		       ea		      nop
     17  8218					      REPEND
     18  8219		       ea		      nop
     19  821a					      REPEND
  10125  821a					      endif
  10126  821a					      endif
  10127  821a
  10128  821a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
  10129  821c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
  10130  821e		       ba		      tsx
  10131  821f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
  10132  8221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
  10133  8223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
  10134  8225		       88		      dey
  10135  8226		       10 d8		      bpl	loop2	;+2 60 180
  10136  8228
  10137  8228		       a6 f6		      ldx	stack1
  10138  822a		       9a		      txs
  10139  822b							; lda scorepointers+1
  10140  822b		       a4 9c		      ldy	temp1
  10141  822d							; sta temp1
  10142  822d		       84 97		      sty	scorepointers+1
  10143  822f
  10144  822f		       a9 00		      LDA	#0
  10145  8231		       85 0e		      sta	PF1
  10146  8233		       85 1b		      STA	GRP0
  10147  8235		       85 1c		      STA	GRP1
  10148  8237		       85 25		      STA	VDELP0
  10149  8239		       85 26		      STA	VDELP1	;do we need these
  10150  823b		       85 04		      STA	NUSIZ0
  10151  823d		       85 05		      STA	NUSIZ1
  10152  823f
  10153  823f							; lda scorepointers+3
  10154  823f		       a4 9e		      ldy	temp3
  10155  8241							; sta temp3
  10156  8241		       84 99		      sty	scorepointers+3
  10157  8243
  10158  8243							; lda scorepointers+5
  10159  8243		       a4 a0		      ldy	temp5
  10160  8245							; sta temp5
  10161  8245		       84 9b		      sty	scorepointers+5
  10162  8247					      endif		;noscore
  10163  8247				  -	      ifconst	readpaddle
  10164  8247				  -	      lda	#%11000010
  10165  8247					      else
  10166  8247				  -	      ifconst	qtcontroller
  10167  8247				  -	      lda	qtcontroller
  10168  8247				  -	      lsr		; bit 0 in carry
  10169  8247				  -	      lda	#4
  10170  8247				  -	      ror		; carry into top of A
  10171  8247					      else
  10172  8247		       a9 02		      lda	#2
  10173  8249					      endif		; qtcontroller
  10174  8249					      endif		; readpaddle
  10175  8249		       85 02		      sta	WSYNC
  10176  824b		       85 01		      sta	VBLANK
      0  824d					      RETURN
      1  824d				  -	      ifnconst	bankswitch
      2  824d				  -	      rts
      3  824d					      else
      4  824d		       4c dd ff 	      jmp	BS_return
      5  8250					      endif
  10178  8250				  -	      ifconst	shakescreen
  10179  8250				  -doshakescreen
  10180  8250				  -	      bit	shakescreen
  10181  8250				  -	      bmi	noshakescreen
  10182  8250				  -	      sta	WSYNC
  10183  8250				  -noshakescreen
  10184  8250				  -	      ldx	missile0height
  10185  8250				  -	      inx
  10186  8250				  -	      rts
  10187  8250					      endif
  10188  8250
  10189  8250							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10190  8250
  10191  8250				   start
  10192  8250		       78		      sei
  10193  8251		       d8		      cld
  10194  8252		       a0 00		      ldy	#0
  10195  8254		       a5 d0		      lda	$D0
  10196  8256		       c9 2c		      cmp	#$2C	;check RAM location #1
  10197  8258		       d0 07		      bne	MachineIs2600
  10198  825a		       a5 d1		      lda	$D1
  10199  825c		       c9 a9		      cmp	#$A9	;check RAM location #2
  10200  825e		       d0 01		      bne	MachineIs2600
  10201  8260		       88		      dey
  10202  8261				   MachineIs2600
  10203  8261		       a2 00		      ldx	#0
  10204  8263		       8a		      txa
  10205  8264				   clearmem
  10206  8264		       e8		      inx
  10207  8265		       9a		      txs
  10208  8266		       48		      pha
  10209  8267		       d0 fb		      bne	clearmem
  10210  8269		       84 9c		      sty	temp1
  10211  826b					      ifnconst	multisprite
  10212  826b				  -	      ifconst	pfrowheight
  10213  826b				  -	      lda	#pfrowheight
  10214  826b					      else
  10215  826b				  -	      ifconst	pfres
  10216  826b				  -	      lda	#(96/pfres)
  10217  826b					      else
  10218  826b		       a9 08		      lda	#8
  10219  826d					      endif
  10220  826d					      endif
  10221  826d		       85 ef		      sta	playfieldpos
  10222  826f					      endif
  10223  826f		       a2 05		      ldx	#5
  10224  8271				   initscore
  10225  8271		       a9 74		      lda	#<scoretable
  10226  8273		       95 96		      sta	scorepointers,x
  10227  8275		       ca		      dex
  10228  8276		       10 f9		      bpl	initscore
  10229  8278		       a9 01		      lda	#1
  10230  827a		       85 0a		      sta	CTRLPF
  10231  827c		       0d 84 02 	      ora	INTIM
  10232  827f		       85 a2		      sta	rand
  10233  8281
  10234  8281				  -	      ifconst	multisprite
  10235  8281				  -	      jsr	multisprite_setup
  10236  8281					      endif
  10237  8281
  10238  8281				  -	      ifnconst	bankswitch
  10239  8281				  -	      jmp	game
  10240  8281					      else
  10241  8281		       a9 0f		      lda	#>(game-1)
  10242  8283		       48		      pha
  10243  8284		       a9 ff		      lda	#<(game-1)
  10244  8286		       48		      pha
  10245  8287		       48		      pha
  10246  8288		       48		      pha
  10247  8289		       a2 01		      ldx	#1
  10248  828b		       4c eb ff 	      jmp	BS_jsr
  10249  828e					      endif
  10250  828e							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10251  828e
  10252  828e							; playfield drawing routines
  10253  828e							; you get a 32x12 bitmapped display in a single color :)
  10254  828e							; 0-31 and 0-11
  10255  828e
  10256  828e				   pfclear		; clears playfield - or fill with pattern
  10257  828e				  -	      ifconst	pfres
  10258  828e				  -	      ldx	#pfres*pfwidth-1
  10259  828e					      else
  10260  828e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
  10261  8290					      endif
  10262  8290				   pfclear_loop
  10263  8290					      ifnconst	superchip
  10264  8290		       95 a4		      sta	playfield,x
  10265  8292				  -	      else
  10266  8292				  -	      sta	playfield-128,x
  10267  8292					      endif
  10268  8292		       ca		      dex
  10269  8293		       10 fb		      bpl	pfclear_loop
      0  8295					      RETURN
      1  8295				  -	      ifnconst	bankswitch
      2  8295				  -	      rts
      3  8295					      else
      4  8295		       4c dd ff 	      jmp	BS_return
      5  8298					      endif
  10271  8298
  10272  8298				   setuppointers
  10273  8298		       86 9d		      stx	temp2	; store on.off.flip value
  10274  829a		       aa		      tax		; put x-value in x 
  10275  829b		       4a		      lsr
  10276  829c		       4a		      lsr
  10277  829d		       4a		      lsr		; divide x pos by 8 
  10278  829e		       85 9c		      sta	temp1
  10279  82a0		       98		      tya
  10280  82a1		       0a		      asl
  10281  82a2					      if	pfwidth=4
  10282  82a2		       0a		      asl		; multiply y pos by 4
  10283  82a3					      endif		; else multiply by 2
  10284  82a3		       18		      clc
  10285  82a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
  10286  82a6		       a8		      tay		; put the value in y
  10287  82a7		       a5 9d		      lda	temp2	; restore on.off.flip value
  10288  82a9		       60		      rts
  10289  82aa
  10290  82aa				   pfread
  10291  82aa							;x=xvalue, y=yvalue
  10292  82aa		       20 98 f2 	      jsr	setuppointers
  10293  82ad		       bd 42 f3 	      lda	setbyte,x
  10294  82b0		       39 a4 00 	      and	playfield,y
  10295  82b3		       5d 42 f3 	      eor	setbyte,x
  10296  82b6							; beq readzero
  10297  82b6							; lda #1
  10298  82b6							; readzero
      0  82b6					      RETURN
      1  82b6				  -	      ifnconst	bankswitch
      2  82b6				  -	      rts
      3  82b6					      else
      4  82b6		       4c dd ff 	      jmp	BS_return
      5  82b9					      endif
  10300  82b9
  10301  82b9				   pfpixel
  10302  82b9							;x=xvalue, y=yvalue, a=0,1,2
  10303  82b9		       20 98 f2 	      jsr	setuppointers
  10304  82bc
  10305  82bc					      ifconst	bankswitch
  10306  82bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
  10307  82be		       f0 0f		      beq	pixelon_r	; if "on" go to on
  10308  82c0		       4a		      lsr
  10309  82c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
  10310  82c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
  10311  82c6		       5d 42 f3 	      eor	setbyte,x
  10312  82c9				  -	      ifconst	superchip
  10313  82c9				  -	      sta	playfield-128,y
  10314  82c9					      else
  10315  82c9		       99 a4 00 	      sta	playfield,y
  10316  82cc					      endif
      0  82cc					      RETURN
      1  82cc				  -	      ifnconst	bankswitch
      2  82cc				  -	      rts
      3  82cc					      else
      4  82cc		       4c dd ff 	      jmp	BS_return
      5  82cf					      endif
  10318  82cf				   pixelon_r
  10319  82cf		       b9 a4 00 	      lda	playfield,y
  10320  82d2		       1d 42 f3 	      ora	setbyte,x
  10321  82d5				  -	      ifconst	superchip
  10322  82d5				  -	      sta	playfield-128,y
  10323  82d5					      else
  10324  82d5		       99 a4 00 	      sta	playfield,y
  10325  82d8					      endif
      0  82d8					      RETURN
      1  82d8				  -	      ifnconst	bankswitch
      2  82d8				  -	      rts
      3  82d8					      else
      4  82d8		       4c dd ff 	      jmp	BS_return
      5  82db					      endif
  10327  82db				   pixeloff_r
  10328  82db		       bd 42 f3 	      lda	setbyte,x
  10329  82de		       49 ff		      eor	#$ff
  10330  82e0		       39 a4 00 	      and	playfield,y
  10331  82e3				  -	      ifconst	superchip
  10332  82e3				  -	      sta	playfield-128,y
  10333  82e3					      else
  10334  82e3		       99 a4 00 	      sta	playfield,y
  10335  82e6					      endif
      0  82e6					      RETURN
      1  82e6				  -	      ifnconst	bankswitch
      2  82e6				  -	      rts
      3  82e6					      else
      4  82e6		       4c dd ff 	      jmp	BS_return
      5  82e9					      endif
  10337  82e9
  10338  82e9				  -	      else
  10339  82e9				  -	      jmp	plotpoint
  10340  82e9					      endif
  10341  82e9
  10342  82e9				   pfhline
  10343  82e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
  10344  82e9		       20 98 f2 	      jsr	setuppointers
  10345  82ec		       4c f6 f2 	      jmp	noinc
  10346  82ef				   keepgoing
  10347  82ef		       e8		      inx
  10348  82f0		       8a		      txa
  10349  82f1		       29 07		      and	#7
  10350  82f3		       d0 01		      bne	noinc
  10351  82f5		       c8		      iny
  10352  82f6				   noinc
  10353  82f6		       20 1b f3 	      jsr	plotpoint
  10354  82f9		       e4 9e		      cpx	temp3
  10355  82fb		       30 f2		      bmi	keepgoing
      0  82fd					      RETURN
      1  82fd				  -	      ifnconst	bankswitch
      2  82fd				  -	      rts
      3  82fd					      else
      4  82fd		       4c dd ff 	      jmp	BS_return
      5  8300					      endif
  10357  8300
  10358  8300				   pfvline
  10359  8300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
  10360  8300		       20 98 f2 	      jsr	setuppointers
  10361  8303		       84 9c		      sty	temp1	; store memory location offset
  10362  8305		       e6 9e		      inc	temp3	; increase final x by 1 
  10363  8307		       a5 9e		      lda	temp3
  10364  8309		       0a		      asl
  10365  830a					      if	pfwidth=4
  10366  830a		       0a		      asl		; multiply by 4
  10367  830b					      endif		; else multiply by 2
  10368  830b		       85 9e		      sta	temp3	; store it
  10369  830d							; Thanks to Michael Rideout for fixing a bug in this code
  10370  830d							; right now, temp1=y=starting memory location, temp3=final
  10371  830d							; x should equal original x value
  10372  830d				   keepgoingy
  10373  830d		       20 1b f3 	      jsr	plotpoint
  10374  8310		       c8		      iny
  10375  8311		       c8		      iny
  10376  8312					      if	pfwidth=4
  10377  8312		       c8		      iny
  10378  8313		       c8		      iny
  10379  8314					      endif
  10380  8314		       c4 9e		      cpy	temp3
  10381  8316		       30 f5		      bmi	keepgoingy
      0  8318					      RETURN
      1  8318				  -	      ifnconst	bankswitch
      2  8318				  -	      rts
      3  8318					      else
      4  8318		       4c dd ff 	      jmp	BS_return
      5  831b					      endif
  10383  831b
  10384  831b				   plotpoint
  10385  831b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
  10386  831d		       f0 0d		      beq	pixelon	; if "on" go to on
  10387  831f		       4a		      lsr
  10388  8320		       b0 14		      bcs	pixeloff	; value is 1 if true
  10389  8322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
  10390  8325		       5d 42 f3 	      eor	setbyte,x
  10391  8328				  -	      ifconst	superchip
  10392  8328				  -	      sta	playfield-128,y
  10393  8328					      else
  10394  8328		       99 a4 00 	      sta	playfield,y
  10395  832b					      endif
  10396  832b		       60		      rts
  10397  832c				   pixelon
  10398  832c		       b9 a4 00 	      lda	playfield,y
  10399  832f		       1d 42 f3 	      ora	setbyte,x
  10400  8332				  -	      ifconst	superchip
  10401  8332				  -	      sta	playfield-128,y
  10402  8332					      else
  10403  8332		       99 a4 00 	      sta	playfield,y
  10404  8335					      endif
  10405  8335		       60		      rts
  10406  8336				   pixeloff
  10407  8336		       bd 42 f3 	      lda	setbyte,x
  10408  8339		       49 ff		      eor	#$ff
  10409  833b		       39 a4 00 	      and	playfield,y
  10410  833e				  -	      ifconst	superchip
  10411  833e				  -	      sta	playfield-128,y
  10412  833e					      else
  10413  833e		       99 a4 00 	      sta	playfield,y
  10414  8341					      endif
  10415  8341		       60		      rts
  10416  8342
  10417  8342				   setbyte
  10418  8342					      ifnconst	pfcenter
  10419  8342		       80		      .byte.b	$80
  10420  8343		       40		      .byte.b	$40
  10421  8344		       20		      .byte.b	$20
  10422  8345		       10		      .byte.b	$10
  10423  8346		       08		      .byte.b	$08
  10424  8347		       04		      .byte.b	$04
  10425  8348		       02		      .byte.b	$02
  10426  8349		       01		      .byte.b	$01
  10427  834a					      endif
  10428  834a		       01		      .byte.b	$01
  10429  834b		       02		      .byte.b	$02
  10430  834c		       04		      .byte.b	$04
  10431  834d		       08		      .byte.b	$08
  10432  834e		       10		      .byte.b	$10
  10433  834f		       20		      .byte.b	$20
  10434  8350		       40		      .byte.b	$40
  10435  8351		       80		      .byte.b	$80
  10436  8352		       80		      .byte.b	$80
  10437  8353		       40		      .byte.b	$40
  10438  8354		       20		      .byte.b	$20
  10439  8355		       10		      .byte.b	$10
  10440  8356		       08		      .byte.b	$08
  10441  8357		       04		      .byte.b	$04
  10442  8358		       02		      .byte.b	$02
  10443  8359		       01		      .byte.b	$01
  10444  835a		       01		      .byte.b	$01
  10445  835b		       02		      .byte.b	$02
  10446  835c		       04		      .byte.b	$04
  10447  835d		       08		      .byte.b	$08
  10448  835e		       10		      .byte.b	$10
  10449  835f		       20		      .byte.b	$20
  10450  8360		       40		      .byte.b	$40
  10451  8361		       80		      .byte.b	$80
  10452  8362							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10453  8362
  10454  8362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
  10455  8362		       d0 15		      bne	notleft
  10456  8364							;left
  10457  8364				  -	      ifconst	pfres
  10458  8364				  -	      ldx	#pfres*4
  10459  8364					      else
  10460  8364		       a2 30		      ldx	#48
  10461  8366					      endif
  10462  8366				   leftloop
  10463  8366		       b5 a3		      lda	playfield-1,x
  10464  8368		       4a		      lsr
  10465  8369
  10466  8369				  -	      ifconst	superchip
  10467  8369				  -	      lda	playfield-2,x
  10468  8369				  -	      rol
  10469  8369				  -	      sta	playfield-130,x
  10470  8369				  -	      lda	playfield-3,x
  10471  8369				  -	      ror
  10472  8369				  -	      sta	playfield-131,x
  10473  8369				  -	      lda	playfield-4,x
  10474  8369				  -	      rol
  10475  8369				  -	      sta	playfield-132,x
  10476  8369				  -	      lda	playfield-1,x
  10477  8369				  -	      ror
  10478  8369				  -	      sta	playfield-129,x
  10479  8369					      else
  10480  8369		       36 a2		      rol	playfield-2,x
  10481  836b		       76 a1		      ror	playfield-3,x
  10482  836d		       36 a0		      rol	playfield-4,x
  10483  836f		       76 a3		      ror	playfield-1,x
  10484  8371					      endif
  10485  8371
  10486  8371		       8a		      txa
  10487  8372		       cb 04		      sbx	#4
  10488  8374		       d0 f0		      bne	leftloop
      0  8376					      RETURN
      1  8376				  -	      ifnconst	bankswitch
      2  8376				  -	      rts
      3  8376					      else
      4  8376		       4c dd ff 	      jmp	BS_return
      5  8379					      endif
  10490  8379
  10491  8379				   notleft
  10492  8379		       4a		      lsr
  10493  837a		       90 15		      bcc	notright
  10494  837c							;right
  10495  837c
  10496  837c				  -	      ifconst	pfres
  10497  837c				  -	      ldx	#pfres*4
  10498  837c					      else
  10499  837c		       a2 30		      ldx	#48
  10500  837e					      endif
  10501  837e				   rightloop
  10502  837e		       b5 a0		      lda	playfield-4,x
  10503  8380		       4a		      lsr
  10504  8381				  -	      ifconst	superchip
  10505  8381				  -	      lda	playfield-3,x
  10506  8381				  -	      rol
  10507  8381				  -	      sta	playfield-131,x
  10508  8381				  -	      lda	playfield-2,x
  10509  8381				  -	      ror
  10510  8381				  -	      sta	playfield-130,x
  10511  8381				  -	      lda	playfield-1,x
  10512  8381				  -	      rol
  10513  8381				  -	      sta	playfield-129,x
  10514  8381				  -	      lda	playfield-4,x
  10515  8381				  -	      ror
  10516  8381				  -	      sta	playfield-132,x
  10517  8381					      else
  10518  8381		       36 a1		      rol	playfield-3,x
  10519  8383		       76 a2		      ror	playfield-2,x
  10520  8385		       36 a3		      rol	playfield-1,x
  10521  8387		       76 a0		      ror	playfield-4,x
  10522  8389					      endif
  10523  8389		       8a		      txa
  10524  838a		       cb 04		      sbx	#4
  10525  838c		       d0 f0		      bne	rightloop
      0  838e					      RETURN
      1  838e				  -	      ifnconst	bankswitch
      2  838e				  -	      rts
      3  838e					      else
      4  838e		       4c dd ff 	      jmp	BS_return
      5  8391					      endif
  10527  8391
  10528  8391				   notright
  10529  8391		       4a		      lsr
  10530  8392		       90 4b		      bcc	notup
  10531  8394							;up
  10532  8394		       4a		      lsr
  10533  8395		       90 02		      bcc	onedecup
  10534  8397		       c6 ef		      dec	playfieldpos
  10535  8399				   onedecup
  10536  8399		       c6 ef		      dec	playfieldpos
  10537  839b		       f0 02		      beq	shiftdown
  10538  839d		       10 3d		      bpl	noshiftdown2
  10539  839f				   shiftdown
  10540  839f				  -	      ifconst	pfrowheight
  10541  839f				  -	      lda	#pfrowheight
  10542  839f					      else
  10543  839f					      ifnconst	pfres
  10544  839f		       a9 08		      lda	#8
  10545  83a1				  -	      else
  10546  83a1				  -	      lda	#(96/pfres)	; try to come close to the real size
  10547  83a1					      endif
  10548  83a1					      endif
  10549  83a1
  10550  83a1		       85 ef		      sta	playfieldpos
  10551  83a3		       a5 a7		      lda	playfield+3
  10552  83a5		       85 9f		      sta	temp4
  10553  83a7		       a5 a6		      lda	playfield+2
  10554  83a9		       85 9e		      sta	temp3
  10555  83ab		       a5 a5		      lda	playfield+1
  10556  83ad		       85 9d		      sta	temp2
  10557  83af		       a5 a4		      lda	playfield
  10558  83b1		       85 9c		      sta	temp1
  10559  83b3		       a2 00		      ldx	#0
  10560  83b5				   up2
  10561  83b5		       b5 a8		      lda	playfield+4,x
  10562  83b7				  -	      ifconst	superchip
  10563  83b7				  -	      sta	playfield-128,x
  10564  83b7				  -	      lda	playfield+5,x
  10565  83b7				  -	      sta	playfield-127,x
  10566  83b7				  -	      lda	playfield+6,x
  10567  83b7				  -	      sta	playfield-126,x
  10568  83b7				  -	      lda	playfield+7,x
  10569  83b7				  -	      sta	playfield-125,x
  10570  83b7					      else
  10571  83b7		       95 a4		      sta	playfield,x
  10572  83b9		       b5 a9		      lda	playfield+5,x
  10573  83bb		       95 a5		      sta	playfield+1,x
  10574  83bd		       b5 aa		      lda	playfield+6,x
  10575  83bf		       95 a6		      sta	playfield+2,x
  10576  83c1		       b5 ab		      lda	playfield+7,x
  10577  83c3		       95 a7		      sta	playfield+3,x
  10578  83c5					      endif
  10579  83c5		       8a		      txa
  10580  83c6		       cb fc		      sbx	#252
  10581  83c8				  -	      ifconst	pfres
  10582  83c8				  -	      cpx	#(pfres-1)*4
  10583  83c8					      else
  10584  83c8		       e0 2c		      cpx	#44
  10585  83ca					      endif
  10586  83ca		       d0 e9		      bne	up2
  10587  83cc
  10588  83cc		       a5 9f		      lda	temp4
  10589  83ce
  10590  83ce				  -	      ifconst	superchip
  10591  83ce				  -	      ifconst	pfres
  10592  83ce				  -	      sta	playfield+pfres*4-129
  10593  83ce				  -	      lda	temp3
  10594  83ce				  -	      sta	playfield+pfres*4-130
  10595  83ce				  -	      lda	temp2
  10596  83ce				  -	      sta	playfield+pfres*4-131
  10597  83ce				  -	      lda	temp1
  10598  83ce				  -	      sta	playfield+pfres*4-132
  10599  83ce				  -	      else
  10600  83ce				  -	      sta	playfield+47-128
  10601  83ce				  -	      lda	temp3
  10602  83ce				  -	      sta	playfield+46-128
  10603  83ce				  -	      lda	temp2
  10604  83ce				  -	      sta	playfield+45-128
  10605  83ce				  -	      lda	temp1
  10606  83ce				  -	      sta	playfield+44-128
  10607  83ce				  -	      endif
  10608  83ce					      else
  10609  83ce				  -	      ifconst	pfres
  10610  83ce				  -	      sta	playfield+pfres*4-1
  10611  83ce				  -	      lda	temp3
  10612  83ce				  -	      sta	playfield+pfres*4-2
  10613  83ce				  -	      lda	temp2
  10614  83ce				  -	      sta	playfield+pfres*4-3
  10615  83ce				  -	      lda	temp1
  10616  83ce				  -	      sta	playfield+pfres*4-4
  10617  83ce					      else
  10618  83ce		       85 d3		      sta	playfield+47
  10619  83d0		       a5 9e		      lda	temp3
  10620  83d2		       85 d2		      sta	playfield+46
  10621  83d4		       a5 9d		      lda	temp2
  10622  83d6		       85 d1		      sta	playfield+45
  10623  83d8		       a5 9c		      lda	temp1
  10624  83da		       85 d0		      sta	playfield+44
  10625  83dc					      endif
  10626  83dc					      endif
  10627  83dc				   noshiftdown2
      0  83dc					      RETURN
      1  83dc				  -	      ifnconst	bankswitch
      2  83dc				  -	      rts
      3  83dc					      else
      4  83dc		       4c dd ff 	      jmp	BS_return
      5  83df					      endif
  10629  83df
  10630  83df
  10631  83df				   notup
  10632  83df							;down
  10633  83df		       4a		      lsr
  10634  83e0		       b0 02		      bcs	oneincup
  10635  83e2		       e6 ef		      inc	playfieldpos
  10636  83e4				   oneincup
  10637  83e4		       e6 ef		      inc	playfieldpos
  10638  83e6		       a5 ef		      lda	playfieldpos
  10639  83e8
  10640  83e8				  -	      ifconst	pfrowheight
  10641  83e8				  -	      cmp	#pfrowheight+1
  10642  83e8					      else
  10643  83e8					      ifnconst	pfres
  10644  83e8		       c9 09		      cmp	#9
  10645  83ea				  -	      else
  10646  83ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
  10647  83ea					      endif
  10648  83ea					      endif
  10649  83ea
  10650  83ea		       90 3b		      bcc	noshiftdown
  10651  83ec		       a9 01		      lda	#1
  10652  83ee		       85 ef		      sta	playfieldpos
  10653  83f0
  10654  83f0				  -	      ifconst	pfres
  10655  83f0				  -	      lda	playfield+pfres*4-1
  10656  83f0				  -	      sta	temp4
  10657  83f0				  -	      lda	playfield+pfres*4-2
  10658  83f0				  -	      sta	temp3
  10659  83f0				  -	      lda	playfield+pfres*4-3
  10660  83f0				  -	      sta	temp2
  10661  83f0				  -	      lda	playfield+pfres*4-4
  10662  83f0					      else
  10663  83f0		       a5 d3		      lda	playfield+47
  10664  83f2		       85 9f		      sta	temp4
  10665  83f4		       a5 d2		      lda	playfield+46
  10666  83f6		       85 9e		      sta	temp3
  10667  83f8		       a5 d1		      lda	playfield+45
  10668  83fa		       85 9d		      sta	temp2
  10669  83fc		       a5 d0		      lda	playfield+44
  10670  83fe					      endif
  10671  83fe
  10672  83fe		       85 9c		      sta	temp1
  10673  8400
  10674  8400				  -	      ifconst	pfres
  10675  8400				  -	      ldx	#(pfres-1)*4
  10676  8400					      else
  10677  8400		       a2 2c		      ldx	#44
  10678  8402					      endif
  10679  8402				   down2
  10680  8402		       b5 a3		      lda	playfield-1,x
  10681  8404				  -	      ifconst	superchip
  10682  8404				  -	      sta	playfield-125,x
  10683  8404				  -	      lda	playfield-2,x
  10684  8404				  -	      sta	playfield-126,x
  10685  8404				  -	      lda	playfield-3,x
  10686  8404				  -	      sta	playfield-127,x
  10687  8404				  -	      lda	playfield-4,x
  10688  8404				  -	      sta	playfield-128,x
  10689  8404					      else
  10690  8404		       95 a7		      sta	playfield+3,x
  10691  8406		       b5 a2		      lda	playfield-2,x
  10692  8408		       95 a6		      sta	playfield+2,x
  10693  840a		       b5 a1		      lda	playfield-3,x
  10694  840c		       95 a5		      sta	playfield+1,x
  10695  840e		       b5 a0		      lda	playfield-4,x
  10696  8410		       95 a4		      sta	playfield,x
  10697  8412					      endif
  10698  8412		       8a		      txa
  10699  8413		       cb 04		      sbx	#4
  10700  8415		       d0 eb		      bne	down2
  10701  8417
  10702  8417		       a5 9f		      lda	temp4
  10703  8419				  -	      ifconst	superchip
  10704  8419				  -	      sta	playfield-125
  10705  8419				  -	      lda	temp3
  10706  8419				  -	      sta	playfield-126
  10707  8419				  -	      lda	temp2
  10708  8419				  -	      sta	playfield-127
  10709  8419				  -	      lda	temp1
  10710  8419				  -	      sta	playfield-128
  10711  8419					      else
  10712  8419		       85 a7		      sta	playfield+3
  10713  841b		       a5 9e		      lda	temp3
  10714  841d		       85 a6		      sta	playfield+2
  10715  841f		       a5 9d		      lda	temp2
  10716  8421		       85 a5		      sta	playfield+1
  10717  8423		       a5 9c		      lda	temp1
  10718  8425		       85 a4		      sta	playfield
  10719  8427					      endif
  10720  8427				   noshiftdown
      0  8427					      RETURN
      1  8427				  -	      ifnconst	bankswitch
      2  8427				  -	      rts
      3  8427					      else
      4  8427		       4c dd ff 	      jmp	BS_return
      5  842a					      endif
  10722  842a							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10723  842a
  10724  842a							;standard routines needed for pretty much all games
  10725  842a							; just the random number generator is left - maybe we should remove this asm file altogether?
  10726  842a							; repositioning code and score pointer setup moved to overscan
  10727  842a							; read switches, joysticks now compiler generated (more efficient)
  10728  842a
  10729  842a				   randomize
  10730  842a		       a5 a2		      lda	rand
  10731  842c		       4a		      lsr
  10732  842d					      ifconst	rand16
  10733  842d		       26 ed		      rol	rand16
  10734  842f					      endif
  10735  842f		       90 02		      bcc	noeor
  10736  8431		       49 b4		      eor	#$B4
  10737  8433				   noeor
  10738  8433		       85 a2		      sta	rand
  10739  8435					      ifconst	rand16
  10740  8435		       45 ed		      eor	rand16
  10741  8437					      endif
      0  8437					      RETURN
      1  8437				  -	      ifnconst	bankswitch
      2  8437				  -	      rts
      3  8437					      else
      4  8437		       4c dd ff 	      jmp	BS_return
      5  843a					      endif
  10743  843a							; Provided under the CC0 license. See the included LICENSE.txt for details.
  10744  843a
  10745  843a				   drawscreen
  10746  843a				  -	      ifconst	debugscore
  10747  843a				  -	      ldx	#14
  10748  843a				  -	      lda	INTIM	; display # cycles left in the score
  10749  843a				  -
  10750  843a				  -	      ifconst	mincycles
  10751  843a				  -	      lda	mincycles
  10752  843a				  -	      cmp	INTIM
  10753  843a				  -	      lda	mincycles
  10754  843a				  -	      bcc	nochange
  10755  843a				  -	      lda	INTIM
  10756  843a				  -	      sta	mincycles
  10757  843a				  -nochange
  10758  843a				  -	      endif
  10759  843a				  -
  10760  843a				  -			; cmp #$2B
  10761  843a				  -			; bcs no_cycles_left
  10762  843a				  -	      bmi	cycles_left
  10763  843a				  -	      ldx	#64
  10764  843a				  -	      eor	#$ff	;make negative
  10765  843a				  -cycles_left
  10766  843a				  -	      stx	scorecolor
  10767  843a				  -	      and	#$7f	; clear sign bit
  10768  843a				  -	      tax
  10769  843a				  -	      lda	scorebcd,x
  10770  843a				  -	      sta	score+2
  10771  843a				  -	      lda	scorebcd1,x
  10772  843a				  -	      sta	score+1
  10773  843a				  -	      jmp	done_debugscore
  10774  843a				  -scorebcd
  10775  843a				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
  10776  843a				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
  10777  843a				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
  10778  843a				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
  10779  843a				  -scorebcd1
  10780  843a				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
  10781  843a				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
  10782  843a				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
  10783  843a				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
  10784  843a				  -done_debugscore
  10785  843a					      endif
  10786  843a
  10787  843a				  -	      ifconst	debugcycles
  10788  843a				  -	      lda	INTIM	; if we go over, it mucks up the background color
  10789  843a				  -			; cmp #$2B
  10790  843a				  -			; BCC overscan
  10791  843a				  -	      bmi	overscan
  10792  843a				  -	      sta	COLUBK
  10793  843a				  -	      bcs	doneoverscan
  10794  843a					      endif
  10795  843a
  10796  843a				   overscan
  10797  843a				  -	      ifconst	interlaced
  10798  843a				  -	      PHP
  10799  843a				  -	      PLA
  10800  843a				  -	      EOR	#4	; flip interrupt bit
  10801  843a				  -	      PHA
  10802  843a				  -	      PLP
  10803  843a				  -	      AND	#4	; isolate the interrupt bit
  10804  843a				  -	      TAX		; save it for later
  10805  843a					      endif
  10806  843a
  10807  843a				   overscanloop
  10808  843a		       ad 84 02 	      lda	INTIM	;wait for sync
  10809  843d		       30 fb		      bmi	overscanloop
  10810  843f				   doneoverscan
  10811  843f
  10812  843f							;do VSYNC
  10813  843f
  10814  843f				  -	      ifconst	interlaced
  10815  843f				  -	      CPX	#4
  10816  843f				  -	      BNE	oddframevsync
  10817  843f					      endif
  10818  843f
  10819  843f		       a9 02		      lda	#2
  10820  8441		       85 02		      sta	WSYNC
  10821  8443		       85 00		      sta	VSYNC
  10822  8445		       85 02		      STA	WSYNC
  10823  8447		       85 02		      STA	WSYNC
  10824  8449		       4a		      lsr
  10825  844a		       85 02		      STA	WSYNC
  10826  844c		       85 00		      STA	VSYNC
  10827  844e		       85 01		      sta	VBLANK
  10828  8450					      ifnconst	overscan_time
  10829  8450		       a9 a5		      lda	#37+128
  10830  8452				  -	      else
  10831  8452				  -	      lda	#overscan_time+128
  10832  8452					      endif
  10833  8452		       8d 96 02 	      sta	TIM64T
  10834  8455
  10835  8455				  -	      ifconst	interlaced
  10836  8455				  -	      jmp	postsync
  10837  8455				  -
  10838  8455				  -oddframevsync
  10839  8455				  -	      sta	WSYNC
  10840  8455				  -
  10841  8455				  -	      LDA	($80,X)	; 11 waste
  10842  8455				  -	      LDA	($80,X)	; 11 waste
  10843  8455				  -	      LDA	($80,X)	; 11 waste
  10844  8455				  -
  10845  8455				  -	      lda	#2
  10846  8455				  -	      sta	VSYNC
  10847  8455				  -	      sta	WSYNC
  10848  8455				  -	      sta	WSYNC
  10849  8455				  -	      sta	WSYNC
  10850  8455				  -
  10851  8455				  -	      LDA	($80,X)	; 11 waste
  10852  8455				  -	      LDA	($80,X)	; 11 waste
  10853  8455				  -	      LDA	($80,X)	; 11 waste
  10854  8455				  -
  10855  8455				  -	      lda	#0
  10856  8455				  -	      sta	VSYNC
  10857  8455				  -	      sta	VBLANK
  10858  8455				  -	      ifnconst	overscan_time
  10859  8455				  -	      lda	#37+128
  10860  8455				  -	      else
  10861  8455				  -	      lda	#overscan_time+128
  10862  8455				  -	      endif
  10863  8455				  -	      sta	TIM64T
  10864  8455				  -
  10865  8455				  -postsync
  10866  8455					      endif
  10867  8455
  10868  8455				  -	      ifconst	legacy
  10869  8455				  -	      if	legacy < 100
  10870  8455				  -	      ldx	#4
  10871  8455				  -adjustloop
  10872  8455				  -	      lda	player0x,x
  10873  8455				  -	      sec
  10874  8455				  -	      sbc	#14	;?
  10875  8455				  -	      sta	player0x,x
  10876  8455				  -	      dex
  10877  8455				  -	      bpl	adjustloop
  10878  8455				  -	      endif
  10879  8455					      endif
  10880  8455				  -	      if	((<*)>$e9)&&((<*)<$fa)
  10881  8455				  -	      repeat	($fa-(<*))
  10882  8455				  -	      nop
  10883  8455				  -	      repend
  10884  8455					      endif
  10885  8455		       85 02		      sta	WSYNC
  10886  8457		       a2 04		      ldx	#4
      0  8459					      SLEEP	3
      1  8459				   .CYCLES    SET	3
      2  8459
      3  8459				  -	      IF	.CYCLES < 2
      4  8459				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8459				  -	      ERR
      6  8459					      ENDIF
      7  8459
      8  8459					      IF	.CYCLES & 1
      9  8459					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8459		       04 00		      nop	0
     11  845b				  -	      ELSE
     12  845b				  -	      bit	VSYNC
     13  845b					      ENDIF
     14  845b				   .CYCLES    SET	.CYCLES - 3
     15  845b					      ENDIF
     16  845b
     17  845b				  -	      REPEAT	.CYCLES / 2
     18  845b				  -	      nop
     19  845b					      REPEND
  10888  845b				   HorPosLoop		; 5
  10889  845b		       b5 80		      lda	player0x,X	;+4 9
  10890  845d		       38		      sec		;+2 11
  10891  845e				   DivideLoop
  10892  845e		       e9 0f		      sbc	#15
  10893  8460		       b0 fc		      bcs	DivideLoop	;+4 15
  10894  8462		       95 9c		      sta	temp1,X	;+4 19
  10895  8464		       95 10		      sta	RESP0,X	;+4 23
  10896  8466		       85 02		      sta	WSYNC
  10897  8468		       ca		      dex
  10898  8469		       10 f0		      bpl	HorPosLoop	;+5 5
  10899  846b							; 4
  10900  846b
  10901  846b		       a2 04		      ldx	#4
  10902  846d		       b4 9c		      ldy	temp1,X
  10903  846f		       b9 cb f3 	      lda	repostable-256,Y
  10904  8472		       95 20		      sta	HMP0,X	;+14 18
  10905  8474
  10906  8474		       ca		      dex
  10907  8475		       b4 9c		      ldy	temp1,X
  10908  8477		       b9 cb f3 	      lda	repostable-256,Y
  10909  847a		       95 20		      sta	HMP0,X	;+14 32
  10910  847c
  10911  847c		       ca		      dex
  10912  847d		       b4 9c		      ldy	temp1,X
  10913  847f		       b9 cb f3 	      lda	repostable-256,Y
  10914  8482		       95 20		      sta	HMP0,X	;+14 46
  10915  8484
  10916  8484		       ca		      dex
  10917  8485		       b4 9c		      ldy	temp1,X
  10918  8487		       b9 cb f3 	      lda	repostable-256,Y
  10919  848a		       95 20		      sta	HMP0,X	;+14 60
  10920  848c
  10921  848c		       ca		      dex
  10922  848d		       b4 9c		      ldy	temp1,X
  10923  848f		       b9 cb f3 	      lda	repostable-256,Y
  10924  8492		       95 20		      sta	HMP0,X	;+14 74
  10925  8494
  10926  8494		       85 02		      sta	WSYNC
  10927  8496
  10928  8496		       85 2a		      sta	HMOVE	;+3 3
  10929  8498
  10930  8498
  10931  8498				  -	      ifconst	legacy
  10932  8498				  -	      if	legacy < 100
  10933  8498				  -	      ldx	#4
  10934  8498				  -adjustloop2
  10935  8498				  -	      lda	player0x,x
  10936  8498				  -	      clc
  10937  8498				  -	      adc	#14	;?
  10938  8498				  -	      sta	player0x,x
  10939  8498				  -	      dex
  10940  8498				  -	      bpl	adjustloop2
  10941  8498				  -	      endif
  10942  8498					      endif
  10943  8498
  10944  8498
  10945  8498
  10946  8498
  10947  8498							;set score pointers
  10948  8498		       a7 95		      lax	score+2
  10949  849a		       20 cb f4 	      jsr	scorepointerset
  10950  849d		       84 9b		      sty	scorepointers+5
  10951  849f		       86 98		      stx	scorepointers+2
  10952  84a1		       a7 94		      lax	score+1
  10953  84a3		       20 cb f4 	      jsr	scorepointerset
  10954  84a6		       84 9a		      sty	scorepointers+4
  10955  84a8		       86 97		      stx	scorepointers+1
  10956  84aa		       a7 93		      lax	score
  10957  84ac		       20 cb f4 	      jsr	scorepointerset
  10958  84af		       84 99		      sty	scorepointers+3
  10959  84b1		       86 96		      stx	scorepointers
  10960  84b3
  10961  84b3				   vblk
  10962  84b3							; run possible vblank bB code
  10963  84b3				  -	      ifconst	vblank_bB_code
  10964  84b3				  -	      jsr	vblank_bB_code
  10965  84b3					      endif
  10966  84b3				   vblk2
  10967  84b3		       ad 84 02 	      LDA	INTIM
  10968  84b6		       30 fb		      bmi	vblk2
  10969  84b8		       4c 00 f0 	      jmp	kernel
  10970  84bb
  10971  84bb
  10972  84bb		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
  10973  84c4		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
  10974  84cb				   repostable
  10975  84cb
  10976  84cb				   scorepointerset
  10977  84cb		       29 0f		      and	#$0F
  10978  84cd		       0a		      asl
  10979  84ce		       0a		      asl
  10980  84cf		       0a		      asl
  10981  84d0		       69 74		      adc	#<scoretable
  10982  84d2		       a8		      tay
  10983  84d3		       8a		      txa
  10984  84d4							; and #$F0
  10985  84d4							; lsr
  10986  84d4		       4b f0		      asr	#$F0
  10987  84d6		       69 74		      adc	#<scoretable
  10988  84d8		       aa		      tax
  10989  84d9		       60		      rts
  10990  84da							;bB.asm
  10991  84da							; bB.asm file is split here
  10992  84da				   .
  10993  84da							; 
  10994  84da
  10995  84da				   .
  10996  84da							; 
  10997  84da
  10998  84da				   .
  10999  84da							; 
  11000  84da
  11001  84da				   .
  11002  84da							; 
  11003  84da
  11004  84da				   .
  11005  84da							; 
  11006  84da
  11007  84da				   .
  11008  84da							; 
  11009  84da
  11010  84da				   .
  11011  84da							; 
  11012  84da
  11013  84da				   .
  11014  84da							; 
  11015  84da
  11016  84da				   .
  11017  84da							; 
  11018  84da
  11019  84da				   .
  11020  84da							; 
  11021  84da
  11022  84da				   .
  11023  84da							; 
  11024  84da
  11025  84da				   .
  11026  84da							; 
  11027  84da
  11028  84da				  -	      ifconst	pfres
  11029  84da				  -	      if	(<*) > (254-pfres*pfwidth)
  11030  84da				  -	      align	256
  11031  84da				  -	      endif
  11032  84da				  -	      if	(<*) < (136-pfres*pfwidth)
  11033  84da				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11034  84da				  -	      .byte	0
  11035  84da				  -	      repend
  11036  84da				  -	      endif
  11037  84da					      else
  11038  84da					      if	(<*) > 206
  11039  8500		       00 00 00 00*	      align	256
  11040  8500					      endif
  11041  8500					      if	(<*) < 88
  11042  8500					      repeat	(88-(<*))
  11043  8500		       00		      .byte.b	0
  11042  8500					      repend
  11043  8501		       00		      .byte.b	0
  11042  8501					      repend
  11043  8502		       00		      .byte.b	0
  11042  8502					      repend
  11043  8503		       00		      .byte.b	0
  11042  8503					      repend
  11043  8504		       00		      .byte.b	0
  11042  8504					      repend
  11043  8505		       00		      .byte.b	0
  11042  8505					      repend
  11043  8506		       00		      .byte.b	0
  11042  8506					      repend
  11043  8507		       00		      .byte.b	0
  11042  8507					      repend
  11043  8508		       00		      .byte.b	0
  11042  8508					      repend
  11043  8509		       00		      .byte.b	0
  11042  8509					      repend
  11043  850a		       00		      .byte.b	0
  11042  850a					      repend
  11043  850b		       00		      .byte.b	0
  11042  850b					      repend
  11043  850c		       00		      .byte.b	0
  11042  850c					      repend
  11043  850d		       00		      .byte.b	0
  11042  850d					      repend
  11043  850e		       00		      .byte.b	0
  11042  850e					      repend
  11043  850f		       00		      .byte.b	0
  11042  850f					      repend
  11043  8510		       00		      .byte.b	0
  11042  8510					      repend
  11043  8511		       00		      .byte.b	0
  11042  8511					      repend
  11043  8512		       00		      .byte.b	0
  11042  8512					      repend
  11043  8513		       00		      .byte.b	0
  11042  8513					      repend
  11043  8514		       00		      .byte.b	0
  11042  8514					      repend
  11043  8515		       00		      .byte.b	0
  11042  8515					      repend
  11043  8516		       00		      .byte.b	0
  11042  8516					      repend
  11043  8517		       00		      .byte.b	0
  11042  8517					      repend
  11043  8518		       00		      .byte.b	0
  11042  8518					      repend
  11043  8519		       00		      .byte.b	0
  11042  8519					      repend
  11043  851a		       00		      .byte.b	0
  11042  851a					      repend
  11043  851b		       00		      .byte.b	0
  11042  851b					      repend
  11043  851c		       00		      .byte.b	0
  11042  851c					      repend
  11043  851d		       00		      .byte.b	0
  11042  851d					      repend
  11043  851e		       00		      .byte.b	0
  11042  851e					      repend
  11043  851f		       00		      .byte.b	0
  11042  851f					      repend
  11043  8520		       00		      .byte.b	0
  11042  8520					      repend
  11043  8521		       00		      .byte.b	0
  11042  8521					      repend
  11043  8522		       00		      .byte.b	0
  11042  8522					      repend
  11043  8523		       00		      .byte.b	0
  11042  8523					      repend
  11043  8524		       00		      .byte.b	0
  11042  8524					      repend
  11043  8525		       00		      .byte.b	0
  11042  8525					      repend
  11043  8526		       00		      .byte.b	0
  11042  8526					      repend
  11043  8527		       00		      .byte.b	0
  11042  8527					      repend
  11043  8528		       00		      .byte.b	0
  11042  8528					      repend
  11043  8529		       00		      .byte.b	0
  11042  8529					      repend
  11043  852a		       00		      .byte.b	0
  11042  852a					      repend
  11043  852b		       00		      .byte.b	0
  11042  852b					      repend
  11043  852c		       00		      .byte.b	0
  11042  852c					      repend
  11043  852d		       00		      .byte.b	0
  11042  852d					      repend
  11043  852e		       00		      .byte.b	0
  11042  852e					      repend
  11043  852f		       00		      .byte.b	0
  11042  852f					      repend
  11043  8530		       00		      .byte.b	0
  11042  8530					      repend
  11043  8531		       00		      .byte.b	0
  11042  8531					      repend
  11043  8532		       00		      .byte.b	0
  11042  8532					      repend
  11043  8533		       00		      .byte.b	0
  11042  8533					      repend
  11043  8534		       00		      .byte.b	0
  11042  8534					      repend
  11043  8535		       00		      .byte.b	0
  11042  8535					      repend
  11043  8536		       00		      .byte.b	0
  11042  8536					      repend
  11043  8537		       00		      .byte.b	0
  11042  8537					      repend
  11043  8538		       00		      .byte.b	0
  11042  8538					      repend
  11043  8539		       00		      .byte.b	0
  11042  8539					      repend
  11043  853a		       00		      .byte.b	0
  11042  853a					      repend
  11043  853b		       00		      .byte.b	0
  11042  853b					      repend
  11043  853c		       00		      .byte.b	0
  11042  853c					      repend
  11043  853d		       00		      .byte.b	0
  11042  853d					      repend
  11043  853e		       00		      .byte.b	0
  11042  853e					      repend
  11043  853f		       00		      .byte.b	0
  11042  853f					      repend
  11043  8540		       00		      .byte.b	0
  11042  8540					      repend
  11043  8541		       00		      .byte.b	0
  11042  8541					      repend
  11043  8542		       00		      .byte.b	0
  11042  8542					      repend
  11043  8543		       00		      .byte.b	0
  11042  8543					      repend
  11043  8544		       00		      .byte.b	0
  11042  8544					      repend
  11043  8545		       00		      .byte.b	0
  11042  8545					      repend
  11043  8546		       00		      .byte.b	0
  11042  8546					      repend
  11043  8547		       00		      .byte.b	0
  11042  8547					      repend
  11043  8548		       00		      .byte.b	0
  11042  8548					      repend
  11043  8549		       00		      .byte.b	0
  11042  8549					      repend
  11043  854a		       00		      .byte.b	0
  11042  854a					      repend
  11043  854b		       00		      .byte.b	0
  11042  854b					      repend
  11043  854c		       00		      .byte.b	0
  11042  854c					      repend
  11043  854d		       00		      .byte.b	0
  11042  854d					      repend
  11043  854e		       00		      .byte.b	0
  11042  854e					      repend
  11043  854f		       00		      .byte.b	0
  11042  854f					      repend
  11043  8550		       00		      .byte.b	0
  11042  8550					      repend
  11043  8551		       00		      .byte.b	0
  11042  8551					      repend
  11043  8552		       00		      .byte.b	0
  11042  8552					      repend
  11043  8553		       00		      .byte.b	0
  11042  8553					      repend
  11043  8554		       00		      .byte.b	0
  11042  8554					      repend
  11043  8555		       00		      .byte.b	0
  11042  8555					      repend
  11043  8556		       00		      .byte.b	0
  11042  8556					      repend
  11043  8557		       00		      .byte.b	0
  11044  8558					      repend
  11045  8558					      endif
  11046  8558					      endif
  11047  8558				   pfcolorlabel13
  11048  8558		       6e 2c 2e de	      .byte.b	$6E, $2C, $2E, $DE
  11049  855c		       6c 2c 2c dc	      .byte.b	$6C, $2C, $2C, $DC
  11050  8560		       6a 2c 2a da	      .byte.b	$6A, $2C, $2A, $DA
  11051  8564		       68 2a 28 d8	      .byte.b	$68, $2A, $28, $D8
  11052  8568		       66 28 26 d6	      .byte.b	$66, $28, $26, $D6
  11053  856c		       6e 26 2e de	      .byte.b	$6E, $26, $2E, $DE
  11054  8570		       6e 2c 2e de	      .byte.b	$6E, $2C, $2E, $DE
  11055  8574		       6c 2c 2c dc	      .byte.b	$6C, $2C, $2C, $DC
  11056  8578		       6a 2c 2a da	      .byte.b	$6A, $2C, $2A, $DA
  11057  857c		       68 2c 28 d8	      .byte.b	$68, $2C, $28, $D8
  11058  8580		       66 00 26 d6	      .byte.b	$66,0, $26, $D6
  11059  8584				  -	      if	(<*) > (<(*+7))
  11060  8584				  -	      repeat	($100-<*)
  11061  8584				  -	      .byte	0
  11062  8584				  -	      repend
  11063  8584					      endif
  11064  8584				   playerL081_0
  11065  8584		       3c		      .byte.b	%00111100
  11066  8585		       7e		      .byte.b	%01111110
  11067  8586		       c3		      .byte.b	%11000011
  11068  8587		       bd		      .byte.b	%10111101
  11069  8588		       ff		      .byte.b	%11111111
  11070  8589		       db		      .byte.b	%11011011
  11071  858a		       7e		      .byte.b	%01111110
  11072  858b		       3c		      .byte.b	%00111100
  11073  858c				  -	      if	(<*) > (<(*+7))
  11074  858c				  -	      repeat	($100-<*)
  11075  858c				  -	      .byte	0
  11076  858c				  -	      repend
  11077  858c					      endif
  11078  858c				   playerL082_1
  11079  858c		       3c		      .byte.b	%00111100
  11080  858d		       7e		      .byte.b	%01111110
  11081  858e		       c3		      .byte.b	%11000011
  11082  858f		       ff		      .byte.b	%11111111
  11083  8590		       ff		      .byte.b	%11111111
  11084  8591		       db		      .byte.b	%11011011
  11085  8592		       7e		      .byte.b	%01111110
  11086  8593		       3c		      .byte.b	%00111100
  11087  8594				  -	      ifconst	pfres
  11088  8594				  -	      if	(<*) > (254-pfres*pfwidth)
  11089  8594				  -	      align	256
  11090  8594				  -	      endif
  11091  8594				  -	      if	(<*) < (136-pfres*pfwidth)
  11092  8594				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11093  8594				  -	      .byte	0
  11094  8594				  -	      repend
  11095  8594				  -	      endif
  11096  8594					      else
  11097  8594				  -	      if	(<*) > 206
  11098  8594				  -	      align	256
  11099  8594					      endif
  11100  8594				  -	      if	(<*) < 88
  11101  8594				  -	      repeat	(88-(<*))
  11102  8594				  -	      .byte	0
  11103  8594				  -	      repend
  11104  8594					      endif
  11105  8594					      endif
  11106  8594				   pfcolorlabel62
  11107  8594		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11108  8598		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11109  859c		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11110  85a0		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11111  85a4		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11112  85a8		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11113  85ac		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11114  85b0		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11115  85b4		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11116  85b8		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11117  85bc		       0c 0a 3c 3a	      .byte.b	$0C, $0A, $3C, $3A
  11118  85c0				  -	      ifconst	pfres
  11119  85c0				  -	      if	(<*) > (254-pfres*pfwidth)
  11120  85c0				  -	      align	256
  11121  85c0				  -	      endif
  11122  85c0				  -	      if	(<*) < (136-pfres*pfwidth)
  11123  85c0				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11124  85c0				  -	      .byte	0
  11125  85c0				  -	      repend
  11126  85c0				  -	      endif
  11127  85c0					      else
  11128  85c0				  -	      if	(<*) > 206
  11129  85c0				  -	      align	256
  11130  85c0					      endif
  11131  85c0				  -	      if	(<*) < 88
  11132  85c0				  -	      repeat	(88-(<*))
  11133  85c0				  -	      .byte	0
  11134  85c0				  -	      repend
  11135  85c0					      endif
  11136  85c0					      endif
  11137  85c0				   pfcolorlabel87
  11138  85c0		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11139  85c4		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11140  85c8		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11141  85cc		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11142  85d0		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11143  85d4		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11144  85d8		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11145  85dc		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11146  85e0		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11147  85e4		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11148  85e8		       6c 6a 9c 9a	      .byte.b	$6C, $6A, $9C, $9A
  11149  85ec				  -	      ifconst	pfres
  11150  85ec				  -	      if	(<*) > (254-pfres*pfwidth)
  11151  85ec				  -	      align	256
  11152  85ec				  -	      endif
  11153  85ec				  -	      if	(<*) < (136-pfres*pfwidth)
  11154  85ec				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11155  85ec				  -	      .byte	0
  11156  85ec				  -	      repend
  11157  85ec				  -	      endif
  11158  85ec					      else
  11159  85ec					      if	(<*) > 206
  11160  8600		       00 00 00 00*	      align	256
  11161  8600					      endif
  11162  8600					      if	(<*) < 88
  11163  8600					      repeat	(88-(<*))
  11164  8600		       00		      .byte.b	0
  11163  8600					      repend
  11164  8601		       00		      .byte.b	0
  11163  8601					      repend
  11164  8602		       00		      .byte.b	0
  11163  8602					      repend
  11164  8603		       00		      .byte.b	0
  11163  8603					      repend
  11164  8604		       00		      .byte.b	0
  11163  8604					      repend
  11164  8605		       00		      .byte.b	0
  11163  8605					      repend
  11164  8606		       00		      .byte.b	0
  11163  8606					      repend
  11164  8607		       00		      .byte.b	0
  11163  8607					      repend
  11164  8608		       00		      .byte.b	0
  11163  8608					      repend
  11164  8609		       00		      .byte.b	0
  11163  8609					      repend
  11164  860a		       00		      .byte.b	0
  11163  860a					      repend
  11164  860b		       00		      .byte.b	0
  11163  860b					      repend
  11164  860c		       00		      .byte.b	0
  11163  860c					      repend
  11164  860d		       00		      .byte.b	0
  11163  860d					      repend
  11164  860e		       00		      .byte.b	0
  11163  860e					      repend
  11164  860f		       00		      .byte.b	0
  11163  860f					      repend
  11164  8610		       00		      .byte.b	0
  11163  8610					      repend
  11164  8611		       00		      .byte.b	0
  11163  8611					      repend
  11164  8612		       00		      .byte.b	0
  11163  8612					      repend
  11164  8613		       00		      .byte.b	0
  11163  8613					      repend
  11164  8614		       00		      .byte.b	0
  11163  8614					      repend
  11164  8615		       00		      .byte.b	0
  11163  8615					      repend
  11164  8616		       00		      .byte.b	0
  11163  8616					      repend
  11164  8617		       00		      .byte.b	0
  11163  8617					      repend
  11164  8618		       00		      .byte.b	0
  11163  8618					      repend
  11164  8619		       00		      .byte.b	0
  11163  8619					      repend
  11164  861a		       00		      .byte.b	0
  11163  861a					      repend
  11164  861b		       00		      .byte.b	0
  11163  861b					      repend
  11164  861c		       00		      .byte.b	0
  11163  861c					      repend
  11164  861d		       00		      .byte.b	0
  11163  861d					      repend
  11164  861e		       00		      .byte.b	0
  11163  861e					      repend
  11164  861f		       00		      .byte.b	0
  11163  861f					      repend
  11164  8620		       00		      .byte.b	0
  11163  8620					      repend
  11164  8621		       00		      .byte.b	0
  11163  8621					      repend
  11164  8622		       00		      .byte.b	0
  11163  8622					      repend
  11164  8623		       00		      .byte.b	0
  11163  8623					      repend
  11164  8624		       00		      .byte.b	0
  11163  8624					      repend
  11164  8625		       00		      .byte.b	0
  11163  8625					      repend
  11164  8626		       00		      .byte.b	0
  11163  8626					      repend
  11164  8627		       00		      .byte.b	0
  11163  8627					      repend
  11164  8628		       00		      .byte.b	0
  11163  8628					      repend
  11164  8629		       00		      .byte.b	0
  11163  8629					      repend
  11164  862a		       00		      .byte.b	0
  11163  862a					      repend
  11164  862b		       00		      .byte.b	0
  11163  862b					      repend
  11164  862c		       00		      .byte.b	0
  11163  862c					      repend
  11164  862d		       00		      .byte.b	0
  11163  862d					      repend
  11164  862e		       00		      .byte.b	0
  11163  862e					      repend
  11164  862f		       00		      .byte.b	0
  11163  862f					      repend
  11164  8630		       00		      .byte.b	0
  11163  8630					      repend
  11164  8631		       00		      .byte.b	0
  11163  8631					      repend
  11164  8632		       00		      .byte.b	0
  11163  8632					      repend
  11164  8633		       00		      .byte.b	0
  11163  8633					      repend
  11164  8634		       00		      .byte.b	0
  11163  8634					      repend
  11164  8635		       00		      .byte.b	0
  11163  8635					      repend
  11164  8636		       00		      .byte.b	0
  11163  8636					      repend
  11164  8637		       00		      .byte.b	0
  11163  8637					      repend
  11164  8638		       00		      .byte.b	0
  11163  8638					      repend
  11164  8639		       00		      .byte.b	0
  11163  8639					      repend
  11164  863a		       00		      .byte.b	0
  11163  863a					      repend
  11164  863b		       00		      .byte.b	0
  11163  863b					      repend
  11164  863c		       00		      .byte.b	0
  11163  863c					      repend
  11164  863d		       00		      .byte.b	0
  11163  863d					      repend
  11164  863e		       00		      .byte.b	0
  11163  863e					      repend
  11164  863f		       00		      .byte.b	0
  11163  863f					      repend
  11164  8640		       00		      .byte.b	0
  11163  8640					      repend
  11164  8641		       00		      .byte.b	0
  11163  8641					      repend
  11164  8642		       00		      .byte.b	0
  11163  8642					      repend
  11164  8643		       00		      .byte.b	0
  11163  8643					      repend
  11164  8644		       00		      .byte.b	0
  11163  8644					      repend
  11164  8645		       00		      .byte.b	0
  11163  8645					      repend
  11164  8646		       00		      .byte.b	0
  11163  8646					      repend
  11164  8647		       00		      .byte.b	0
  11163  8647					      repend
  11164  8648		       00		      .byte.b	0
  11163  8648					      repend
  11164  8649		       00		      .byte.b	0
  11163  8649					      repend
  11164  864a		       00		      .byte.b	0
  11163  864a					      repend
  11164  864b		       00		      .byte.b	0
  11163  864b					      repend
  11164  864c		       00		      .byte.b	0
  11163  864c					      repend
  11164  864d		       00		      .byte.b	0
  11163  864d					      repend
  11164  864e		       00		      .byte.b	0
  11163  864e					      repend
  11164  864f		       00		      .byte.b	0
  11163  864f					      repend
  11164  8650		       00		      .byte.b	0
  11163  8650					      repend
  11164  8651		       00		      .byte.b	0
  11163  8651					      repend
  11164  8652		       00		      .byte.b	0
  11163  8652					      repend
  11164  8653		       00		      .byte.b	0
  11163  8653					      repend
  11164  8654		       00		      .byte.b	0
  11163  8654					      repend
  11164  8655		       00		      .byte.b	0
  11163  8655					      repend
  11164  8656		       00		      .byte.b	0
  11163  8656					      repend
  11164  8657		       00		      .byte.b	0
  11165  8658					      repend
  11166  8658					      endif
  11167  8658					      endif
  11168  8658				   pfcolorlabel112
  11169  8658		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11170  865c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11171  8660		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11172  8664		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11173  8668		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11174  866c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11175  8670		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11176  8674		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11177  8678		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11178  867c		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11179  8680		       cc ca fc fa	      .byte.b	$CC, $CA, $FC, $FA
  11180  8684				  -	      ifconst	pfres
  11181  8684				  -	      if	(<*) > (254-pfres*pfwidth)
  11182  8684				  -	      align	256
  11183  8684				  -	      endif
  11184  8684				  -	      if	(<*) < (136-pfres*pfwidth)
  11185  8684				  -	      repeat	((136-pfres*pfwidth)-(<*))
  11186  8684				  -	      .byte	0
  11187  8684				  -	      repend
  11188  8684				  -	      endif
  11189  8684					      else
  11190  8684				  -	      if	(<*) > 206
  11191  8684				  -	      align	256
  11192  8684					      endif
  11193  8684				  -	      if	(<*) < 88
  11194  8684				  -	      repeat	(88-(<*))
  11195  8684				  -	      .byte	0
  11196  8684				  -	      repend
  11197  8684					      endif
  11198  8684					      endif
  11199  8684				   pfcolorlabel137
  11200  8684		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11201  8688		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11202  868c		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11203  8690		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11204  8694		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11205  8698		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11206  869c		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11207  86a0		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11208  86a4		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11209  86a8		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11210  86ac		       8c 8a 2c 2a	      .byte.b	$8C, $8A, $2C, $2A
  11211  86b0					      if	ECHOFIRST
      2244 bytes of ROM space left in bank 8
  11212  86b0					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 8")
  11213  86b0					      endif
  11214  86b0		       00 01	   ECHOFIRST  =	1
  11215  86b0
  11216  86b0
  11217  86b0							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11218  86b0
  11219  86b0							; feel free to modify the score graphics - just keep each digit 8 high
  11220  86b0							; and keep the conditional compilation stuff intact
  11221  86b0				  -	      ifconst	ROM2k
  11222  86b0				  -	      ORG	$F7AC-8
  11223  86b0					      else
  11224  86b0					      ifconst	bankswitch
  11225  86b0				  -	      if	bankswitch == 8
  11226  86b0				  -	      ORG	$2F94-bscode_length
  11227  86b0				  -	      RORG	$FF94-bscode_length
  11228  86b0					      endif
  11229  86b0				  -	      if	bankswitch == 16
  11230  86b0				  -	      ORG	$4F94-bscode_length
  11231  86b0				  -	      RORG	$FF94-bscode_length
  11232  86b0					      endif
  11233  86b0					      if	bankswitch == 32
  11234  8f74					      ORG	$8F94-bscode_length
  11235  8f74					      RORG	$FF94-bscode_length
  11236  8f74					      endif
  11237  8f74				  -	      if	bankswitch == 64
  11238  8f74				  -	      ORG	$10F80-bscode_length
  11239  8f74				  -	      RORG	$1FF80-bscode_length
  11240  8f74					      endif
  11241  8f74				  -	      else
  11242  8f74				  -	      ORG	$FF9C
  11243  8f74					      endif
  11244  8f74					      endif
  11245  8f74
  11246  8f74							; font equates
  11247  8f74		       00 01	   .21stcentury =	1
  11248  8f74		       00 02	   alarmclock =	2
  11249  8f74		       00 03	   handwritten =	3
  11250  8f74		       00 04	   interrupted =	4
  11251  8f74		       00 05	   retroputer =	5
  11252  8f74		       00 06	   whimsey    =	6
  11253  8f74		       00 07	   tiny       =	7
  11254  8f74		       00 08	   hex	      =	8
  11255  8f74
  11256  8f74				  -	      ifconst	font
  11257  8f74				  -	      if	font == hex
  11258  8f74				  -	      ORG	. - 48
  11259  8f74				  -	      endif
  11260  8f74					      endif
  11261  8f74
  11262  8f74				   scoretable
  11263  8f74
  11264  8f74				  -	      ifconst	font
  11265  8f74				  -	      if	font == .21stcentury
  11266  8f74				  -	      include	"score_graphics.asm.21stcentury"
  11267  8f74				  -	      endif
  11268  8f74				  -	      if	font == alarmclock
  11269  8f74				  -	      include	"score_graphics.asm.alarmclock"
  11270  8f74				  -	      endif
  11271  8f74				  -	      if	font == handwritten
  11272  8f74				  -	      include	"score_graphics.asm.handwritten"
  11273  8f74				  -	      endif
  11274  8f74				  -	      if	font == interrupted
  11275  8f74				  -	      include	"score_graphics.asm.interrupted"
  11276  8f74				  -	      endif
  11277  8f74				  -	      if	font == retroputer
  11278  8f74				  -	      include	"score_graphics.asm.retroputer"
  11279  8f74				  -	      endif
  11280  8f74				  -	      if	font == whimsey
  11281  8f74				  -	      include	"score_graphics.asm.whimsey"
  11282  8f74				  -	      endif
  11283  8f74				  -	      if	font == tiny
  11284  8f74				  -	      include	"score_graphics.asm.tiny"
  11285  8f74				  -	      endif
  11286  8f74				  -	      if	font == hex
  11287  8f74				  -	      include	"score_graphics.asm.hex"
  11288  8f74				  -	      endif
  11289  8f74					      else		; default font
  11290  8f74
  11291  8f74		       3c		      .byte.b	%00111100
  11292  8f75		       66		      .byte.b	%01100110
  11293  8f76		       66		      .byte.b	%01100110
  11294  8f77		       66		      .byte.b	%01100110
  11295  8f78		       66		      .byte.b	%01100110
  11296  8f79		       66		      .byte.b	%01100110
  11297  8f7a		       66		      .byte.b	%01100110
  11298  8f7b		       3c		      .byte.b	%00111100
  11299  8f7c
  11300  8f7c		       7e		      .byte.b	%01111110
  11301  8f7d		       18		      .byte.b	%00011000
  11302  8f7e		       18		      .byte.b	%00011000
  11303  8f7f		       18		      .byte.b	%00011000
  11304  8f80		       18		      .byte.b	%00011000
  11305  8f81		       38		      .byte.b	%00111000
  11306  8f82		       18		      .byte.b	%00011000
  11307  8f83		       08		      .byte.b	%00001000
  11308  8f84
  11309  8f84		       7e		      .byte.b	%01111110
  11310  8f85		       60		      .byte.b	%01100000
  11311  8f86		       60		      .byte.b	%01100000
  11312  8f87		       3c		      .byte.b	%00111100
  11313  8f88		       06		      .byte.b	%00000110
  11314  8f89		       06		      .byte.b	%00000110
  11315  8f8a		       46		      .byte.b	%01000110
  11316  8f8b		       3c		      .byte.b	%00111100
  11317  8f8c
  11318  8f8c		       3c		      .byte.b	%00111100
  11319  8f8d		       46		      .byte.b	%01000110
  11320  8f8e		       06		      .byte.b	%00000110
  11321  8f8f		       06		      .byte.b	%00000110
  11322  8f90		       1c		      .byte.b	%00011100
  11323  8f91		       06		      .byte.b	%00000110
  11324  8f92		       46		      .byte.b	%01000110
  11325  8f93		       3c		      .byte.b	%00111100
  11326  8f94
  11327  8f94		       0c		      .byte.b	%00001100
  11328  8f95		       0c		      .byte.b	%00001100
  11329  8f96		       7e		      .byte.b	%01111110
  11330  8f97		       4c		      .byte.b	%01001100
  11331  8f98		       4c		      .byte.b	%01001100
  11332  8f99		       2c		      .byte.b	%00101100
  11333  8f9a		       1c		      .byte.b	%00011100
  11334  8f9b		       0c		      .byte.b	%00001100
  11335  8f9c
  11336  8f9c		       3c		      .byte.b	%00111100
  11337  8f9d		       46		      .byte.b	%01000110
  11338  8f9e		       06		      .byte.b	%00000110
  11339  8f9f		       06		      .byte.b	%00000110
  11340  8fa0		       3c		      .byte.b	%00111100
  11341  8fa1		       60		      .byte.b	%01100000
  11342  8fa2		       60		      .byte.b	%01100000
  11343  8fa3		       7e		      .byte.b	%01111110
  11344  8fa4
  11345  8fa4		       3c		      .byte.b	%00111100
  11346  8fa5		       66		      .byte.b	%01100110
  11347  8fa6		       66		      .byte.b	%01100110
  11348  8fa7		       66		      .byte.b	%01100110
  11349  8fa8		       7c		      .byte.b	%01111100
  11350  8fa9		       60		      .byte.b	%01100000
  11351  8faa		       62		      .byte.b	%01100010
  11352  8fab		       3c		      .byte.b	%00111100
  11353  8fac
  11354  8fac		       30		      .byte.b	%00110000
  11355  8fad		       30		      .byte.b	%00110000
  11356  8fae		       30		      .byte.b	%00110000
  11357  8faf		       18		      .byte.b	%00011000
  11358  8fb0		       0c		      .byte.b	%00001100
  11359  8fb1		       06		      .byte.b	%00000110
  11360  8fb2		       42		      .byte.b	%01000010
  11361  8fb3		       3e		      .byte.b	%00111110
  11362  8fb4
  11363  8fb4		       3c		      .byte.b	%00111100
  11364  8fb5		       66		      .byte.b	%01100110
  11365  8fb6		       66		      .byte.b	%01100110
  11366  8fb7		       66		      .byte.b	%01100110
  11367  8fb8		       3c		      .byte.b	%00111100
  11368  8fb9		       66		      .byte.b	%01100110
  11369  8fba		       66		      .byte.b	%01100110
  11370  8fbb		       3c		      .byte.b	%00111100
  11371  8fbc
  11372  8fbc		       3c		      .byte.b	%00111100
  11373  8fbd		       46		      .byte.b	%01000110
  11374  8fbe		       06		      .byte.b	%00000110
  11375  8fbf		       3e		      .byte.b	%00111110
  11376  8fc0		       66		      .byte.b	%01100110
  11377  8fc1		       66		      .byte.b	%01100110
  11378  8fc2		       66		      .byte.b	%01100110
  11379  8fc3		       3c		      .byte.b	%00111100
  11380  8fc4
  11381  8fc4					      ifnconst	DPC_kernel_options
  11382  8fc4
  11383  8fc4		       00		      .byte.b	%00000000
  11384  8fc5		       00		      .byte.b	%00000000
  11385  8fc6		       00		      .byte.b	%00000000
  11386  8fc7		       00		      .byte.b	%00000000
  11387  8fc8		       00		      .byte.b	%00000000
  11388  8fc9		       00		      .byte.b	%00000000
  11389  8fca		       00		      .byte.b	%00000000
  11390  8fcb		       00		      .byte.b	%00000000
  11391  8fcc
  11392  8fcc					      endif
  11393  8fcc
  11394  8fcc					      endif
  11395  8fcc
  11396  8fcc				  -	      ifconst	ROM2k
  11397  8fcc				  -	      ORG	$F7FC
  11398  8fcc					      else
  11399  8fcc					      ifconst	bankswitch
  11400  8fcc				  -	      if	bankswitch == 8
  11401  8fcc				  -	      ORG	$2FF4-bscode_length
  11402  8fcc				  -	      RORG	$FFF4-bscode_length
  11403  8fcc					      endif
  11404  8fcc				  -	      if	bankswitch == 16
  11405  8fcc				  -	      ORG	$4FF4-bscode_length
  11406  8fcc				  -	      RORG	$FFF4-bscode_length
  11407  8fcc					      endif
  11408  8fcc					      if	bankswitch == 32
  11409  8fd4					      ORG	$8FF4-bscode_length
  11410  8fd4					      RORG	$FFF4-bscode_length
  11411  8fd4					      endif
  11412  8fd4				  -	      if	bankswitch == 64
  11413  8fd4				  -	      ORG	$10FE0-bscode_length
  11414  8fd4				  -	      RORG	$1FFE0-bscode_length
  11415  8fd4					      endif
  11416  8fd4				  -	      else
  11417  8fd4				  -	      ORG	$FFFC
  11418  8fd4					      endif
  11419  8fd4					      endif
  11420  8fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11421  8fd4
  11422  8fd4							; every bank has this stuff at the same place
  11423  8fd4							; this code can switch to/from any bank at any entry point
  11424  8fd4							; and can preserve register values
  11425  8fd4							; note: lines not starting with a space are not placed in all banks
  11426  8fd4							;
  11427  8fd4							; line below tells the compiler how long this is - do not remove
  11428  8fd4							;size=32
  11429  8fd4
  11430  8fd4				   begin_bscode
  11431  8fd4		       a2 ff		      ldx	#$ff
  11432  8fd6				  -	      ifconst	FASTFETCH	; using DPC+
  11433  8fd6				  -	      stx	FASTFETCH
  11434  8fd6					      endif
  11435  8fd6		       9a		      txs
  11436  8fd7				  -	      if	bankswitch == 64
  11437  8fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
  11438  8fd7					      else
  11439  8fd7		       a9 f2		      lda	#>(start-1)
  11440  8fd9					      endif
  11441  8fd9		       48		      pha
  11442  8fda		       a9 4f		      lda	#<(start-1)
  11443  8fdc		       48		      pha
  11444  8fdd
  11445  8fdd				   BS_return
  11446  8fdd		       48		      pha
  11447  8fde		       8a		      txa
  11448  8fdf		       48		      pha
  11449  8fe0		       ba		      tsx
  11450  8fe1
  11451  8fe1					      if	bankswitch != 64
  11452  8fe1		       b5 04		      lda	4,x	; get high byte of return address
  11453  8fe3
  11454  8fe3		       2a		      rol
  11455  8fe4		       2a		      rol
  11456  8fe5		       2a		      rol
  11457  8fe6		       2a		      rol
  11458  8fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
  11459  8fe9		       aa		      tax
  11460  8fea		       e8		      inx
  11461  8feb				  -	      else
  11462  8feb				  -	      lda	4,x	; get high byte of return address
  11463  8feb				  -	      tay
  11464  8feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
  11465  8feb				  -	      sta	4,x
  11466  8feb				  -	      tya
  11467  8feb				  -	      lsr
  11468  8feb				  -	      lsr
  11469  8feb				  -	      lsr
  11470  8feb				  -	      lsr
  11471  8feb				  -	      tax
  11472  8feb				  -	      inx
  11473  8feb					      endif
  11474  8feb
  11475  8feb				   BS_jsr
  11476  8feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
  11477  8fee		       68		      pla
  11478  8fef		       aa		      tax
  11479  8ff0		       68		      pla
  11480  8ff1		       60		      rts
  11481  8ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
  11482  8ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
  11483  8ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
  11484  8ff2					      endif
  11485  8ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
  11486  8ff2
  11487  8ff2					      ifconst	bankswitch
  11488  8ff2				  -	      if	bankswitch == 8
  11489  8ff2				  -	      ORG	$2FFC
  11490  8ff2				  -	      RORG	$FFFC
  11491  8ff2					      endif
  11492  8ff2				  -	      if	bankswitch == 16
  11493  8ff2				  -	      ORG	$4FFC
  11494  8ff2				  -	      RORG	$FFFC
  11495  8ff2					      endif
  11496  8ff2					      if	bankswitch == 32
  11497  8ffc					      ORG	$8FFC
  11498  8ffc					      RORG	$FFFC
  11499  8ffc					      endif
  11500  8ffc				  -	      if	bankswitch == 64
  11501  8ffc				  -	      ORG	$10FF0
  11502  8ffc				  -	      RORG	$1FFF0
  11503  8ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
  11504  8ffc				  -	      ORG	$10FF8
  11505  8ffc				  -	      RORG	$1FFF8
  11506  8ffc				  -	      ifconst	superchip
  11507  8ffc				  -	      .byte	"E","F","S","C"
  11508  8ffc				  -	      else
  11509  8ffc				  -	      .byte	"E","F","E","F"
  11510  8ffc				  -	      endif
  11511  8ffc				  -	      ORG	$10FFC
  11512  8ffc				  -	      RORG	$1FFFC
  11513  8ffc					      endif
  11514  8ffc				  -	      else
  11515  8ffc				  -	      ifconst	ROM2k
  11516  8ffc				  -	      ORG	$F7FC
  11517  8ffc				  -	      else
  11518  8ffc				  -	      ORG	$FFFC
  11519  8ffc				  -	      endif
  11520  8ffc					      endif
  11521  8ffc		       50 f2		      .word.w	(start & $ffff)
  11522  8ffe		       50 f2		      .word.w	(start & $ffff)
