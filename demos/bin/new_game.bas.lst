------- FILE e:\Documents\bB\demos\new_game.bas.asm LEVEL 1 PASS 2
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE e:\Documents\bB\demos\new_game.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE e:\Documents\bB\demos\new_game.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 3d	   _SD_Shot_length =	.skipL0232-_SD_Shot
      5  9000 ????
      6  9000 ????	       00 55	   _SD_Slide_length =	.skipL0231-_SD_Slide
      7  9000 ????
      8  9000 ????	       00 81	   _SD_Fall_length =	.skipL0230-_SD_Fall
      9  9000 ????
     10  9000 ????	       00 51	   _SD_Jump_length =	.skipL0229-_SD_Jump
     11  9000 ????
     12  9000 ????	       00 ed	   rand16     =	z
     13  9000 ????
     14  9000 ????	       00 04	   _c_Shot_Sound =	4
     15  9000 ????
     16  9000 ????	       00 03	   _c_Slide_Sound =	3
     17  9000 ????
     18  9000 ????	       00 02	   _c_Fall_Sound =	2
     19  9000 ????
     20  9000 ????	       00 01	   _c_Jump_Sound =	1
     21  9000 ????
     22  9000 ????	       00 ec	   _Bit7_Reset_Restrainer =	y
     23  9000 ????
     24  9000 ????	       00 ec	   _Bit6_Duck_in_Progress =	y
     25  9000 ????
     26  9000 ????	       00 ec	   _Bit5_Ground_Slide_in_Progress =	y
     27  9000 ????
     28  9000 ????	       00 ec	   _Bit4_Flip_P1 =	y
     29  9000 ????
     30  9000 ????	       00 ec	   _Bit3_FireB_Restrainer =	y
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit2_Slide_Right_in_Progress =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit1_Slide_Left_in_Progress =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit0_Fall_in_Progress =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _BitOp_01  =	y
     39  9000 ????
     40  9000 ????	       00 eb	   _Bit6_LR_Joy_Movement =	x
     41  9000 ????
     42  9000 ????	       00 eb	   _Bit5_Slide_Fire_Restrainer =	x
     43  9000 ????
     44  9000 ????	       00 eb	   _Bit4_Mem_Right =	x
     45  9000 ????
     46  9000 ????	       00 eb	   _Bit3_Mem_Left =	x
     47  9000 ????
     48  9000 ????	       00 eb	   _Bit2_Shot_Moving =	x
     49  9000 ????
     50  9000 ????	       00 eb	   _Bit1_Shoot_Right =	x
     51  9000 ????
     52  9000 ????	       00 eb	   _Bit0_Shoot_Left =	x
     53  9000 ????
     54  9000 ????	       00 eb	   _BitOp_02  =	x
     55  9000 ????
     56  9000 ????	       00 e5	   _Shot_Stand_Counter =	r
     57  9000 ????
     58  9000 ????	       00 e2	   _Generic_Counter =	o
     59  9000 ????
     60  9000 ????	       00 e0	   _Ch0_Counter =	m
     61  9000 ????
     62  9000 ????	       00 df	   _Ch0_Duration =	l
     63  9000 ????
     64  9000 ????	       00 de	   _Ch0_Sound =	k
     65  9000 ????
     66  9000 ????	       00 dd	   _Frame_Counter =	j
     67  9000 ????
     68  9000 ????	       00 dc	   _Master_Counter =	i
     69  9000 ????
     70  9000 ????	       00 db	   _Slide_Limit =	h
     71  9000 ????
     72  9000 ????	       00 da	   _Slide_Speed =	g
     73  9000 ????
     74  9000 ????	       00 d9	   _Slide_Counter =	f
     75  9000 ????
     76  9000 ????	       00 d8	   _Fall_Gravity_Counter =	e
     77  9000 ????
     78  9000 ????	       00 d7	   _Jump_Gravity_Counter =	d
     79  9000 ????
     80  9000 ????	       00 d6	   _Convert_Y =	c
     81  9000 ????
     82  9000 ????	       00 d5	   _Convert_X =	b
     83  9000 ????
     84  9000 ????	       00 81	   _P1_Left_Right =	player1x
     85  9000 ????	       00 01	   PFcolors   =	1
     86  9000 ????	       00 01	   player1colors =	1
     87  9000 ????	       00 01	   playercolors =	1
     88  9000 ????	       00 01	   player1colors =	1
     89  9000 ????	       00 07	   bs_mask    =	7
     90  9000 ????	       00 20	   bankswitch =	32
     91  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
     92  9000 ????	       00 2b	   vblank_time =	43
     93  9000 ????	       00 25	   overscan_time =	37
------- FILE 2600basic.h
      7  9000 ????
      8  9000 ????	       00 80	   player0x   =	$80
      9  9000 ????	       00 81	   player1x   =	$81
     10  9000 ????	       00 82	   missile0x  =	$82
     11  9000 ????	       00 83	   missile1x  =	$83
     12  9000 ????	       00 84	   ballx      =	$84
     13  9000 ????
     14  9000 ????	       00 85	   objecty    =	$85
     15  9000 ????	       00 85	   player0y   =	$85
     16  9000 ????	       00 86	   player1y   =	$86
     17  9000 ????	       00 87	   missile1height =	$87
     18  9000 ????	       00 88	   missile1y  =	$88
     19  9000 ????	       00 89	   bally      =	$89
     20  9000 ????
     21  9000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  9000 ????
     23  9000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  9000 ????	       00 8a	   player0pointerlo =	$8A
     25  9000 ????	       00 8b	   player0pointerhi =	$8B
     26  9000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  9000 ????	       00 8c	   player1pointerlo =	$8C
     28  9000 ????	       00 8d	   player1pointerhi =	$8D
     29  9000 ????
     30  9000 ????	       00 8e	   player0height =	$8E
     31  9000 ????	       00 8f	   player1height =	$8F
     32  9000 ????	       00 90	   missile0height =	$90
     33  9000 ????	       00 91	   missile0y  =	$91
     34  9000 ????	       00 92	   ballheight =	$92
     35  9000 ????
     36  9000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  9000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  9000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  9000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  9000 ????
     41  9000 ????	       00 93	   score      =	$93	; $93-$95
     42  9000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  9000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  9000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  9000 ????	       00 9e	   temp3      =	$9E
     46  9000 ????	       00 9f	   temp4      =	$9F
     47  9000 ????	       00 a0	   temp5      =	$A0
     48  9000 ????	       00 a1	   temp6      =	$A1
     49  9000 ????
     50  9000 ????	       00 a2	   rand       =	$A2
     51  9000 ????	       00 a3	   scorecolor =	$A3
     52  9000 ????
     53  9000 ????	       00 a4	   var0       =	$A4
     54  9000 ????	       00 a5	   var1       =	$A5
     55  9000 ????	       00 a6	   var2       =	$A6
     56  9000 ????	       00 a7	   var3       =	$A7
     57  9000 ????	       00 a8	   var4       =	$A8
     58  9000 ????	       00 a9	   var5       =	$A9
     59  9000 ????	       00 aa	   var6       =	$AA
     60  9000 ????	       00 ab	   var7       =	$AB
     61  9000 ????	       00 ac	   var8       =	$AC
     62  9000 ????	       00 ad	   var9       =	$AD
     63  9000 ????	       00 ae	   var10      =	$AE
     64  9000 ????	       00 af	   var11      =	$AF
     65  9000 ????	       00 b0	   var12      =	$B0
     66  9000 ????	       00 b1	   var13      =	$B1
     67  9000 ????	       00 b2	   var14      =	$B2
     68  9000 ????	       00 b3	   var15      =	$B3
     69  9000 ????	       00 b4	   var16      =	$B4
     70  9000 ????	       00 b5	   var17      =	$B5
     71  9000 ????	       00 b6	   var18      =	$B6
     72  9000 ????	       00 b7	   var19      =	$B7
     73  9000 ????	       00 b8	   var20      =	$B8
     74  9000 ????	       00 b9	   var21      =	$B9
     75  9000 ????	       00 ba	   var22      =	$BA
     76  9000 ????	       00 bb	   var23      =	$BB
     77  9000 ????	       00 bc	   var24      =	$BC
     78  9000 ????	       00 bd	   var25      =	$BD
     79  9000 ????	       00 be	   var26      =	$BE
     80  9000 ????	       00 bf	   var27      =	$BF
     81  9000 ????	       00 c0	   var28      =	$C0
     82  9000 ????	       00 c1	   var29      =	$C1
     83  9000 ????	       00 c2	   var30      =	$C2
     84  9000 ????	       00 c3	   var31      =	$C3
     85  9000 ????	       00 c4	   var32      =	$C4
     86  9000 ????	       00 c5	   var33      =	$C5
     87  9000 ????	       00 c6	   var34      =	$C6
     88  9000 ????	       00 c7	   var35      =	$C7
     89  9000 ????	       00 c8	   var36      =	$C8
     90  9000 ????	       00 c9	   var37      =	$C9
     91  9000 ????	       00 ca	   var38      =	$CA
     92  9000 ????	       00 cb	   var39      =	$CB
     93  9000 ????	       00 cc	   var40      =	$CC
     94  9000 ????	       00 cd	   var41      =	$CD
     95  9000 ????	       00 ce	   var42      =	$CE
     96  9000 ????	       00 cf	   var43      =	$CF
     97  9000 ????	       00 d0	   var44      =	$D0
     98  9000 ????	       00 d1	   var45      =	$D1
     99  9000 ????	       00 d2	   var46      =	$D2
    100  9000 ????	       00 d3	   var47      =	$D3
    101  9000 ????
    102  9000 ????	       00 d4	   A	      =	$d4
    103  9000 ????	       00 d4	   a	      =	$d4
    104  9000 ????	       00 d5	   B	      =	$d5
    105  9000 ????	       00 d5	   b	      =	$d5
    106  9000 ????	       00 d6	   C	      =	$d6
    107  9000 ????	       00 d6	   c	      =	$d6
    108  9000 ????	       00 d7	   D	      =	$d7
    109  9000 ????	       00 d7	   d	      =	$d7
    110  9000 ????	       00 d8	   E	      =	$d8
    111  9000 ????	       00 d8	   e	      =	$d8
    112  9000 ????	       00 d9	   F	      =	$d9
    113  9000 ????	       00 d9	   f	      =	$d9
    114  9000 ????	       00 da	   G	      =	$da
    115  9000 ????	       00 da	   g	      =	$da
    116  9000 ????	       00 db	   H	      =	$db
    117  9000 ????	       00 db	   h	      =	$db
    118  9000 ????	       00 dc	   I	      =	$dc
    119  9000 ????	       00 dc	   i	      =	$dc
    120  9000 ????	       00 dd	   J	      =	$dd
    121  9000 ????	       00 dd	   j	      =	$dd
    122  9000 ????	       00 de	   K	      =	$de
    123  9000 ????	       00 de	   k	      =	$de
    124  9000 ????	       00 df	   L	      =	$df
    125  9000 ????	       00 df	   l	      =	$df
    126  9000 ????	       00 e0	   M	      =	$e0
    127  9000 ????	       00 e0	   m	      =	$e0
    128  9000 ????	       00 e1	   N	      =	$e1
    129  9000 ????	       00 e1	   n	      =	$e1
    130  9000 ????	       00 e2	   O	      =	$e2
    131  9000 ????	       00 e2	   o	      =	$e2
    132  9000 ????	       00 e3	   P	      =	$e3
    133  9000 ????	       00 e3	   p	      =	$e3
    134  9000 ????	       00 e4	   Q	      =	$e4
    135  9000 ????	       00 e4	   q	      =	$e4
    136  9000 ????	       00 e5	   R	      =	$e5
    137  9000 ????	       00 e5	   r	      =	$e5
    138  9000 ????	       00 e6	   S	      =	$e6
    139  9000 ????	       00 e6	   s	      =	$e6
    140  9000 ????	       00 e7	   T	      =	$e7
    141  9000 ????	       00 e7	   t	      =	$e7
    142  9000 ????	       00 e8	   U	      =	$e8
    143  9000 ????	       00 e8	   u	      =	$e8
    144  9000 ????	       00 e9	   V	      =	$e9
    145  9000 ????	       00 e9	   v	      =	$e9
    146  9000 ????	       00 ea	   W	      =	$ea
    147  9000 ????	       00 ea	   w	      =	$ea
    148  9000 ????	       00 eb	   X	      =	$eb
    149  9000 ????	       00 eb	   x	      =	$eb
    150  9000 ????	       00 ec	   Y	      =	$ec
    151  9000 ????	       00 ec	   y	      =	$ec
    152  9000 ????	       00 ed	   Z	      =	$ed
    153  9000 ????	       00 ed	   z	      =	$ed
    154  9000 ????
    155  9000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  9000 ????	       00 ef	   playfieldpos =	$ef
    157  9000 ????
    158  9000 ????						; available for other uses, or if unused, provide more stack space
    159  9000 ????
    160  9000 ????	       00 f0	   aux1       =	$f0
    161  9000 ????	       00 f1	   aux2       =	$f1
    162  9000 ????	       00 f2	   aux3       =	$f2
    163  9000 ????	       00 f3	   aux4       =	$f3
    164  9000 ????	       00 f4	   aux5       =	$f4
    165  9000 ????	       00 f5	   aux6       =	$f5
    166  9000 ????
    167  9000 ????						; playfield color/height pointers
    168  9000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  9000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  9000 ????						; the above pointers are the same because if color and height are both used together,
    171  9000 ????						; they must used absolute indexed and cannot use pointers
    172  9000 ????
    173  9000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  9000 ????						; upper 3 bits of $f2 contain the number of lives
    175  9000 ????	       00 f4	   lifecolor  =	$f4
    176  9000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  9000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  9000 ????
    179  9000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  9000 ????	       00 f3	   pfscore2   =	$f3
    181  9000 ????	       00 f4	   pfscorecolor =	$f4
    182  9000 ????
    183  9000 ????	       00 f6	   stack1     =	$f6
    184  9000 ????	       00 f7	   stack2     =	$f7
    185  9000 ????	       00 f8	   stack3     =	$f8
    186  9000 ????	       00 f9	   stack4     =	$f9
    187  9000 ????						; the stack bytes above may be used in the kernel
    188  9000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  9000 ????
    190  9000 ????				      MAC	return
    191  9000 ????				      ifnconst	bankswitch
    192  9000 ????				      rts
    193  9000 ????				      else
    194  9000 ????				      jmp	BS_return
    195  9000 ????				      endif
    196  9000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  9000 ????
    198  9000 ????			  -	      ifconst	superchip
    199  9000 ????			  -playfieldbase =	$10D0
    200  9000 ????			  -	      include	superchip.h
    201  9000 ????				      else
    202  9000 ????	       00 a4	   playfieldbase =	$A4
    203  9000 ????				      endif
    204  9000 ????
    205  9000 ????				      ifnconst	pfhalfwidth
    206  9000 ????	       00 04	   pfwidth    =	4
    207  9000 ????	       00 0e	   PF1L       =	PF1
    208  9000 ????	       00 0f	   PF2L       =	PF2
    209  9000 ????	       00 0e	   PF1R       =	PF1
    210  9000 ????	       00 0f	   PF2R       =	PF2
    211  9000 ????	       00 00	   pfadjust   =	0
    212  9000 ????			  -	      else
    213  9000 ????			  -pfwidth    =	2
    214  9000 ????			  -	      ifconst	pfcenter
    215  9000 ????			  -PF1L       =	$3F	; no effect
    216  9000 ????			  -PF2L       =	PF2
    217  9000 ????			  -PF1R       =	$3F
    218  9000 ????			  -PF2R       =	PF2	; no effect
    219  9000 ????			  -pfadjust   =	1
    220  9000 ????			  -	      else
    221  9000 ????			  -PF1L       =	PF1
    222  9000 ????			  -PF2L       =	PF2
    223  9000 ????			  -PF1R       =	$3F	; no effect
    224  9000 ????			  -PF2R       =	$3F	; no effect
    225  9000 ????			  -pfadjust   =	0
    226  9000 ????			  -	      endif
    227  9000 ????				      endif
    228  9000 ????
    229  9000 ????						; define playfield start based on height
    230  9000 ????				      ifnconst	pfres
    231  9000 ????	       00 a4	   playfield  =	playfieldbase
    232  9000 ????			  -	      else
    233  9000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  9000 ????				      endif
------- FILE e:\Documents\bB\demos\new_game.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 3d	   _SD_Shot_length =	.skipL0232-_SD_Shot
      5  9000 ????
      6  9000 ????	       00 55	   _SD_Slide_length =	.skipL0231-_SD_Slide
      7  9000 ????
      8  9000 ????	       00 81	   _SD_Fall_length =	.skipL0230-_SD_Fall
      9  9000 ????
     10  9000 ????	       00 51	   _SD_Jump_length =	.skipL0229-_SD_Jump
     11  9000 ????
     12  9000 ????	       00 ed	   rand16     =	z
     13  9000 ????
     14  9000 ????	       00 04	   _c_Shot_Sound =	4
     15  9000 ????
     16  9000 ????	       00 03	   _c_Slide_Sound =	3
     17  9000 ????
     18  9000 ????	       00 02	   _c_Fall_Sound =	2
     19  9000 ????
     20  9000 ????	       00 01	   _c_Jump_Sound =	1
     21  9000 ????
     22  9000 ????	       00 ec	   _Bit7_Reset_Restrainer =	y
     23  9000 ????
     24  9000 ????	       00 ec	   _Bit6_Duck_in_Progress =	y
     25  9000 ????
     26  9000 ????	       00 ec	   _Bit5_Ground_Slide_in_Progress =	y
     27  9000 ????
     28  9000 ????	       00 ec	   _Bit4_Flip_P1 =	y
     29  9000 ????
     30  9000 ????	       00 ec	   _Bit3_FireB_Restrainer =	y
     31  9000 ????
     32  9000 ????	       00 ec	   _Bit2_Slide_Right_in_Progress =	y
     33  9000 ????
     34  9000 ????	       00 ec	   _Bit1_Slide_Left_in_Progress =	y
     35  9000 ????
     36  9000 ????	       00 ec	   _Bit0_Fall_in_Progress =	y
     37  9000 ????
     38  9000 ????	       00 ec	   _BitOp_01  =	y
     39  9000 ????
     40  9000 ????	       00 eb	   _Bit6_LR_Joy_Movement =	x
     41  9000 ????
     42  9000 ????	       00 eb	   _Bit5_Slide_Fire_Restrainer =	x
     43  9000 ????
     44  9000 ????	       00 eb	   _Bit4_Mem_Right =	x
     45  9000 ????
     46  9000 ????	       00 eb	   _Bit3_Mem_Left =	x
     47  9000 ????
     48  9000 ????	       00 eb	   _Bit2_Shot_Moving =	x
     49  9000 ????
     50  9000 ????	       00 eb	   _Bit1_Shoot_Right =	x
     51  9000 ????
     52  9000 ????	       00 eb	   _Bit0_Shoot_Left =	x
     53  9000 ????
     54  9000 ????	       00 eb	   _BitOp_02  =	x
     55  9000 ????
     56  9000 ????	       00 e5	   _Shot_Stand_Counter =	r
     57  9000 ????
     58  9000 ????	       00 e2	   _Generic_Counter =	o
     59  9000 ????
     60  9000 ????	       00 e0	   _Ch0_Counter =	m
     61  9000 ????
     62  9000 ????	       00 df	   _Ch0_Duration =	l
     63  9000 ????
     64  9000 ????	       00 de	   _Ch0_Sound =	k
     65  9000 ????
     66  9000 ????	       00 dd	   _Frame_Counter =	j
     67  9000 ????
     68  9000 ????	       00 dc	   _Master_Counter =	i
     69  9000 ????
     70  9000 ????	       00 db	   _Slide_Limit =	h
     71  9000 ????
     72  9000 ????	       00 da	   _Slide_Speed =	g
     73  9000 ????
     74  9000 ????	       00 d9	   _Slide_Counter =	f
     75  9000 ????
     76  9000 ????	       00 d8	   _Fall_Gravity_Counter =	e
     77  9000 ????
     78  9000 ????	       00 d7	   _Jump_Gravity_Counter =	d
     79  9000 ????
     80  9000 ????	       00 d6	   _Convert_Y =	c
     81  9000 ????
     82  9000 ????	       00 d5	   _Convert_X =	b
     83  9000 ????
     84  9000 ????	       00 81	   _P1_Left_Right =	player1x
     85  9000 ????	       00 01	   PFcolors   =	1
     86  9000 ????	       00 01	   player1colors =	1
     87  9000 ????	       00 01	   playercolors =	1
     88  9000 ????	       00 01	   player1colors =	1
     89  9000 ????	       00 07	   bs_mask    =	7
     90  9000 ????	       00 20	   bankswitch =	32
     91  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
     92  9000 ????	       00 2b	   vblank_time =	43
     93  9000 ????	       00 25	   overscan_time =	37
------- FILE e:\Documents\bB\demos\new_game.bas.asm
      8  9000 ????				      ifconst	bankswitch
      9  9000 ????			  -	      if	bankswitch == 8
     10  9000 ????			  -	      ORG	$1000
     11  9000 ????			  -	      RORG	$D000
     12  9000 ????				      endif
     13  9000 ????			  -	      if	bankswitch == 16
     14  9000 ????			  -	      ORG	$1000
     15  9000 ????			  -	      RORG	$9000
     16  9000 ????				      endif
     17  9000 ????				      if	bankswitch == 32
     18  1000					      ORG	$1000
     19  1000					      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .
     45  1000							; 
     46  1000
     47  1000				   .
     48  1000							; 
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .
     57  1000							; 
     58  1000
     59  1000				   .
     60  1000							; 
     61  1000
     62  1000				   .
     63  1000							; 
     64  1000
     65  1000				   .
     66  1000							; 
     67  1000
     68  1000				   .
     69  1000							; 
     70  1000
     71  1000				   .
     72  1000							; 
     73  1000
     74  1000				   .
     75  1000							; 
     76  1000
     77  1000				   .
     78  1000							; 
     79  1000
     80  1000				   .
     81  1000							; 
     82  1000
     83  1000				   .
     84  1000							; 
     85  1000
     86  1000				   .L00 		;  set smartbranching on
     87  1000
     88  1000				   .L01 		;  set tv ntsc
     89  1000
     90  1000				   .L02 		;  set romsize 32k
     91  1000
     92  1000				   .L03 		;  set kernel_options player1colors playercolors pfcolors
     93  1000
     94  1000				   .
     95  1000							; 
     96  1000
     97  1000				   .
     98  1000							; 
     99  1000
    100  1000				   .
    101  1000							; 
    102  1000
    103  1000				   .
    104  1000							; 
    105  1000
    106  1000				   .
    107  1000							; 
    108  1000
    109  1000				   .
    110  1000							; 
    111  1000
    112  1000				   .
    113  1000							; 
    114  1000
    115  1000				   .
    116  1000							; 
    117  1000
    118  1000				   .
    119  1000							; 
    120  1000
    121  1000				   .
    122  1000							; 
    123  1000
    124  1000				   .
    125  1000							; 
    126  1000
    127  1000				   .
    128  1000							; 
    129  1000
    130  1000				   .
    131  1000							; 
    132  1000
    133  1000				   .
    134  1000							; 
    135  1000
    136  1000				   .
    137  1000							; 
    138  1000
    139  1000				   .
    140  1000							; 
    141  1000
    142  1000				   .
    143  1000							; 
    144  1000
    145  1000				   .
    146  1000							; 
    147  1000
    148  1000				   .
    149  1000							; 
    150  1000
    151  1000				   .
    152  1000							; 
    153  1000
    154  1000				   .
    155  1000							; 
    156  1000
    157  1000				   .
    158  1000							; 
    159  1000
    160  1000				   .
    161  1000							; 
    162  1000
    163  1000				   .
    164  1000							; 
    165  1000
    166  1000				   .
    167  1000							; 
    168  1000
    169  1000				   .
    170  1000							; 
    171  1000
    172  1000				   .
    173  1000							; 
    174  1000
    175  1000				   .
    176  1000							; 
    177  1000
    178  1000				   .
    179  1000							; 
    180  1000
    181  1000				   .L04 		;  dim _P1_Left_Right	=  player1x.a
    182  1000
    183  1000				   .
    184  1000							; 
    185  1000
    186  1000				   .
    187  1000							; 
    188  1000
    189  1000				   .
    190  1000							; 
    191  1000
    192  1000				   .
    193  1000							; 
    194  1000
    195  1000				   .L05 		;  dim _Convert_X  =  b
    196  1000
    197  1000				   .
    198  1000							; 
    199  1000
    200  1000				   .
    201  1000							; 
    202  1000
    203  1000				   .
    204  1000							; 
    205  1000
    206  1000				   .
    207  1000							; 
    208  1000
    209  1000				   .L06 		;  dim _Convert_Y  =  c
    210  1000
    211  1000				   .
    212  1000							; 
    213  1000
    214  1000				   .
    215  1000							; 
    216  1000
    217  1000				   .
    218  1000							; 
    219  1000
    220  1000				   .
    221  1000							; 
    222  1000
    223  1000				   .L07 		;  dim _Jump_Gravity_Counter  =  d
    224  1000
    225  1000				   .
    226  1000							; 
    227  1000
    228  1000				   .
    229  1000							; 
    230  1000
    231  1000				   .
    232  1000							; 
    233  1000
    234  1000				   .
    235  1000							; 
    236  1000
    237  1000				   .L08 		;  dim _Fall_Gravity_Counter  =  e
    238  1000
    239  1000				   .
    240  1000							; 
    241  1000
    242  1000				   .
    243  1000							; 
    244  1000
    245  1000				   .
    246  1000							; 
    247  1000
    248  1000				   .
    249  1000							; 
    250  1000
    251  1000				   .L09 		;  dim _Slide_Counter	=  f
    252  1000
    253  1000				   .
    254  1000							; 
    255  1000
    256  1000				   .
    257  1000							; 
    258  1000
    259  1000				   .
    260  1000							; 
    261  1000
    262  1000				   .
    263  1000							; 
    264  1000
    265  1000				   .L010		;  dim _Slide_Speed  =  g
    266  1000
    267  1000				   .
    268  1000							; 
    269  1000
    270  1000				   .
    271  1000							; 
    272  1000
    273  1000				   .
    274  1000							; 
    275  1000
    276  1000				   .
    277  1000							; 
    278  1000
    279  1000				   .L011		;  dim _Slide_Limit  =  h
    280  1000
    281  1000				   .
    282  1000							; 
    283  1000
    284  1000				   .
    285  1000							; 
    286  1000
    287  1000				   .
    288  1000							; 
    289  1000
    290  1000				   .
    291  1000							; 
    292  1000
    293  1000				   .L012		;  dim _Master_Counter  =  i
    294  1000
    295  1000				   .
    296  1000							; 
    297  1000
    298  1000				   .
    299  1000							; 
    300  1000
    301  1000				   .
    302  1000							; 
    303  1000
    304  1000				   .
    305  1000							; 
    306  1000
    307  1000				   .L013		;  dim _Frame_Counter	=  j
    308  1000
    309  1000				   .
    310  1000							; 
    311  1000
    312  1000				   .
    313  1000							; 
    314  1000
    315  1000				   .
    316  1000							; 
    317  1000
    318  1000				   .
    319  1000							; 
    320  1000
    321  1000				   .L014		;  dim _Ch0_Sound  =  k
    322  1000
    323  1000				   .L015		;  dim _Ch0_Duration  =  l
    324  1000
    325  1000				   .L016		;  dim _Ch0_Counter  =  m
    326  1000
    327  1000				   .
    328  1000							; 
    329  1000
    330  1000				   .L017		;  dim _Generic_Counter  =  o
    331  1000
    332  1000				   .
    333  1000							; 
    334  1000
    335  1000				   .
    336  1000							; 
    337  1000
    338  1000				   .
    339  1000							; 
    340  1000
    341  1000				   .
    342  1000							; 
    343  1000
    344  1000				   .L018		;  dim _Shot_Stand_Counter  =	r
    345  1000
    346  1000				   .
    347  1000							; 
    348  1000
    349  1000				   .
    350  1000							; 
    351  1000
    352  1000				   .
    353  1000							; 
    354  1000
    355  1000				   .
    356  1000							; 
    357  1000
    358  1000				   .
    359  1000							; 
    360  1000
    361  1000				   .L019		;  dim _BitOp_02  =  x
    362  1000
    363  1000				   .L020		;  dim _Bit0_Shoot_Left  =  x
    364  1000
    365  1000				   .L021		;  dim _Bit1_Shoot_Right  =  x
    366  1000
    367  1000				   .L022		;  dim _Bit2_Shot_Moving  =  x
    368  1000
    369  1000				   .L023		;  dim _Bit3_Mem_Left	=  x
    370  1000
    371  1000				   .L024		;  dim _Bit4_Mem_Right  =  x
    372  1000
    373  1000				   .L025		;  dim _Bit5_Slide_Fire_Restrainer  =	x
    374  1000
    375  1000				   .L026		;  dim _Bit6_LR_Joy_Movement  =  x
    376  1000
    377  1000				   .
    378  1000							; 
    379  1000
    380  1000				   .
    381  1000							; 
    382  1000
    383  1000				   .
    384  1000							; 
    385  1000
    386  1000				   .
    387  1000							; 
    388  1000
    389  1000				   .
    390  1000							; 
    391  1000
    392  1000				   .L027		;  dim _BitOp_01  =  y
    393  1000
    394  1000				   .L028		;  dim _Bit0_Fall_in_Progress	=  y
    395  1000
    396  1000				   .L029		;  dim _Bit1_Slide_Left_in_Progress  =  y
    397  1000
    398  1000				   .L030		;  dim _Bit2_Slide_Right_in_Progress  =  y
    399  1000
    400  1000				   .L031		;  dim _Bit3_FireB_Restrainer	=  y
    401  1000
    402  1000				   .L032		;  dim _Bit4_Flip_P1  =  y
    403  1000
    404  1000				   .L033		;  dim _Bit5_Ground_Slide_in_Progress	=  y
    405  1000
    406  1000				   .L034		;  dim _Bit6_Duck_in_Progress	=  y
    407  1000
    408  1000				   .L035		;  dim _Bit7_Reset_Restrainer	=  y
    409  1000
    410  1000				   .
    411  1000							; 
    412  1000
    413  1000				   .
    414  1000							; 
    415  1000
    416  1000				   .
    417  1000							; 
    418  1000
    419  1000				   .
    420  1000							; 
    421  1000
    422  1000				   .
    423  1000							; 
    424  1000
    425  1000				   .
    426  1000							; 
    427  1000
    428  1000				   .
    429  1000							; 
    430  1000
    431  1000				   .
    432  1000							; 
    433  1000
    434  1000				   .L036		;  const _c_Jump_Sound  =  1
    435  1000
    436  1000				   .L037		;  const _c_Fall_Sound  =  2
    437  1000
    438  1000				   .L038		;  const _c_Slide_Sound  =  3
    439  1000
    440  1000				   .L039		;  const _c_Shot_Sound  =  4
    441  1000
    442  1000				   .
    443  1000							; 
    444  1000
    445  1000				   .
    446  1000							; 
    447  1000
    448  1000				   .
    449  1000							; 
    450  1000
    451  1000				   .
    452  1000							; 
    453  1000
    454  1000				   .L040		;  dim rand16	=  z
    455  1000
    456  1000				   .
    457  1000							; 
    458  1000
    459  1000				   .
    460  1000							; 
    461  1000
    462  1000				   .
    463  1000							; 
    464  1000
    465  1000				   .
    466  1000							; 
    467  1000
    468  1000				   .
    469  1000							; 
    470  1000
    471  1000				   .
    472  1000							; 
    473  1000
    474  1000				   .
    475  1000							; 
    476  1000
    477  1000				   .
    478  1000							; 
    479  1000
    480  1000				   .
    481  1000							; 
    482  1000
    483  1000				   .
    484  1000							; 
    485  1000
    486  1000				   .
    487  1000							; 
    488  1000
    489  1000				   .__Start_Restart
    490  1000							; __Start_Restart
    491  1000
    492  1000				   .
    493  1000							; 
    494  1000
    495  1000				   .
    496  1000							; 
    497  1000
    498  1000				   .
    499  1000							; 
    500  1000
    501  1000				   .
    502  1000							; 
    503  1000
    504  1000				   .
    505  1000							; 
    506  1000
    507  1000				   .
    508  1000							; 
    509  1000
    510  1000				   .L041		;  AUDV0  =  0  :  AUDV1  =  0
    511  1000
    512  1000		       a9 00		      LDA	#0
    513  1002		       85 19		      STA	AUDV0
    514  1004		       85 1a		      STA	AUDV1
    515  1006				   .
    516  1006							; 
    517  1006
    518  1006				   .
    519  1006							; 
    520  1006
    521  1006				   .
    522  1006							; 
    523  1006
    524  1006				   .
    525  1006							; 
    526  1006
    527  1006				   .
    528  1006							; 
    529  1006
    530  1006				   .
    531  1006							; 
    532  1006
    533  1006				   .L042		;  a  =  0  :	b  =  0  :  c  =  0  :	d  =  0  :  e  =  0  :	f  =  0  :  g  =  0  :	h  =  0  :  i  =  0
    534  1006
    535  1006		       a9 00		      LDA	#0
    536  1008		       85 d4		      STA	a
    537  100a		       85 d5		      STA	b
    538  100c		       85 d6		      STA	c
    539  100e		       85 d7		      STA	d
    540  1010		       85 d8		      STA	e
    541  1012		       85 d9		      STA	f
    542  1014		       85 da		      STA	g
    543  1016		       85 db		      STA	h
    544  1018		       85 dc		      STA	i
    545  101a				   .L043		;  j  =  0  :	k  =  0  :  l  =  0  :	m  =  0  :  n  =  0  :	o  =  0  :  p  =  0  :	q  =  0  :  r  =  0
    546  101a
    547  101a		       a9 00		      LDA	#0
    548  101c		       85 dd		      STA	j
    549  101e		       85 de		      STA	k
    550  1020		       85 df		      STA	l
    551  1022		       85 e0		      STA	m
    552  1024		       85 e1		      STA	n
    553  1026		       85 e2		      STA	o
    554  1028		       85 e3		      STA	p
    555  102a		       85 e4		      STA	q
    556  102c		       85 e5		      STA	r
    557  102e				   .L044		;  s  =  0  :	t  =  0  :  u  =  0  :	v  =  0  :  w  =  0  :	x  =  0  :  y  =  0  :	z  =  0
    558  102e
    559  102e		       a9 00		      LDA	#0
    560  1030		       85 e6		      STA	s
    561  1032		       85 e7		      STA	t
    562  1034		       85 e8		      STA	u
    563  1036		       85 e9		      STA	v
    564  1038		       85 ea		      STA	w
    565  103a		       85 eb		      STA	x
    566  103c		       85 ec		      STA	y
    567  103e		       85 ed		      STA	z
    568  1040				   .
    569  1040							; 
    570  1040
    571  1040				   .
    572  1040							; 
    573  1040
    574  1040				   .
    575  1040							; 
    576  1040
    577  1040				   .
    578  1040							; 
    579  1040
    580  1040				   .
    581  1040							; 
    582  1040
    583  1040				   .
    584  1040							; 
    585  1040
    586  1040				   .L045		;  _Slide_Speed  =  1
    587  1040
    588  1040		       a9 01		      LDA	#1
    589  1042		       85 da		      STA	_Slide_Speed
    590  1044				   .
    591  1044							; 
    592  1044
    593  1044				   .
    594  1044							; 
    595  1044
    596  1044				   .
    597  1044							; 
    598  1044
    599  1044				   .
    600  1044							; 
    601  1044
    602  1044				   .
    603  1044							; 
    604  1044
    605  1044				   .
    606  1044							; 
    607  1044
    608  1044				   .L046		;  player1x  =  79  :	player1y  =  79
    609  1044
    610  1044		       a9 4f		      LDA	#79
    611  1046		       85 81		      STA	player1x
    612  1048		       85 86		      STA	player1y
    613  104a				   .
    614  104a							; 
    615  104a
    616  104a				   .
    617  104a							; 
    618  104a
    619  104a				   .
    620  104a							; 
    621  104a
    622  104a				   .
    623  104a							; 
    624  104a
    625  104a				   .L047		;  playfieldpos  =  8
    626  104a
    627  104a		       a9 08		      LDA	#8
    628  104c		       85 ef		      STA	playfieldpos
    629  104e				   .
    630  104e							; 
    631  104e
    632  104e				   .
    633  104e							; 
    634  104e
    635  104e				   .
    636  104e							; 
    637  104e
    638  104e				   .
    639  104e							; 
    640  104e
    641  104e				   .
    642  104e							; 
    643  104e
    644  104e				   .
    645  104e							; 
    646  104e
    647  104e				   .L048		;  _Bit3_Mem_Left{3}  =  1
    648  104e
    649  104e		       a5 eb		      LDA	_Bit3_Mem_Left
    650  1050		       09 08		      ORA	#8
    651  1052		       85 eb		      STA	_Bit3_Mem_Left
    652  1054				   .
    653  1054							; 
    654  1054
    655  1054				   .
    656  1054							; 
    657  1054
    658  1054				   .
    659  1054							; 
    660  1054
    661  1054				   .
    662  1054							; 
    663  1054
    664  1054				   .
    665  1054							; 
    666  1054
    667  1054				   .
    668  1054							; 
    669  1054
    670  1054				   .L049		;  ballx  =  250  :  bally  =	250
    671  1054
    672  1054		       a9 fa		      LDA	#250
    673  1056		       85 84		      STA	ballx
    674  1058		       85 89		      STA	bally
    675  105a				   .
    676  105a							; 
    677  105a
    678  105a				   .
    679  105a							; 
    680  105a
    681  105a				   .
    682  105a							; 
    683  105a
    684  105a				   .
    685  105a							; 
    686  105a
    687  105a				   .
    688  105a							; 
    689  105a
    690  105a				   .
    691  105a							; 
    692  105a
    693  105a				   .L050		;  ballheight	=  0  :  CTRLPF  =  $01
    694  105a
    695  105a		       a9 00		      LDA	#0
    696  105c		       85 92		      STA	ballheight
    697  105e		       a9 01		      LDA	#$01
    698  1060		       85 0a		      STA	CTRLPF
    699  1062				   .
    700  1062							; 
    701  1062
    702  1062				   .
    703  1062							; 
    704  1062
    705  1062				   .
    706  1062							; 
    707  1062
    708  1062				   .
    709  1062							; 
    710  1062
    711  1062				   .
    712  1062							; 
    713  1062
    714  1062				   .
    715  1062							; 
    716  1062
    717  1062				   .
    718  1062							; 
    719  1062
    720  1062				   .
    721  1062							; 
    722  1062
    723  1062				   .
    724  1062							; 
    725  1062
    726  1062				   .L051		;  _Bit7_Reset_Restrainer{7}  =  1
    727  1062
    728  1062		       a5 ec		      LDA	_Bit7_Reset_Restrainer
    729  1064		       09 80		      ORA	#128
    730  1066		       85 ec		      STA	_Bit7_Reset_Restrainer
    731  1068				   .
    732  1068							; 
    733  1068
    734  1068				   .
    735  1068							; 
    736  1068
    737  1068				   .
    738  1068							; 
    739  1068
    740  1068				   .
    741  1068							; 
    742  1068
    743  1068				   .
    744  1068							; 
    745  1068
    746  1068				   .
    747  1068							; 
    748  1068
    749  1068				   .L052		;  playfield:
    750  1068
    751  1068				  -	      ifconst	pfres
    752  1068				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    753  1068					      else
    754  1068		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    755  106a					      endif
    756  106a		       4c 99 10 	      jmp	pflabel0
    757  106d				   PF_data0
    758  106d		       00 00		      .byte.b	%00000000, %00000000
    759  106f					      if	(pfwidth>2)
    760  106f		       00 00		      .byte.b	%00000000, %00000000
    761  1071					      endif
    762  1071		       00 00		      .byte.b	%00000000, %00000000
    763  1073					      if	(pfwidth>2)
    764  1073		       00 00		      .byte.b	%00000000, %00000000
    765  1075					      endif
    766  1075		       00 00		      .byte.b	%00000000, %00000000
    767  1077					      if	(pfwidth>2)
    768  1077		       00 00		      .byte.b	%00000000, %00000000
    769  1079					      endif
    770  1079		       00 00		      .byte.b	%00000000, %00000000
    771  107b					      if	(pfwidth>2)
    772  107b		       00 00		      .byte.b	%00000000, %00000000
    773  107d					      endif
    774  107d		       03 1f		      .byte.b	%00000011, %00011111
    775  107f					      if	(pfwidth>2)
    776  107f		       1f 03		      .byte.b	%00011111, %00000011
    777  1081					      endif
    778  1081		       00 00		      .byte.b	%00000000, %00000000
    779  1083					      if	(pfwidth>2)
    780  1083		       00 00		      .byte.b	%00000000, %00000000
    781  1085					      endif
    782  1085		       00 00		      .byte.b	%00000000, %00000000
    783  1087					      if	(pfwidth>2)
    784  1087		       00 00		      .byte.b	%00000000, %00000000
    785  1089					      endif
    786  1089		       00 fc		      .byte.b	%00000000, %11111100
    787  108b					      if	(pfwidth>2)
    788  108b		       fc 00		      .byte.b	%11111100, %00000000
    789  108d					      endif
    790  108d		       00 00		      .byte.b	%00000000, %00000000
    791  108f					      if	(pfwidth>2)
    792  108f		       00 00		      .byte.b	%00000000, %00000000
    793  1091					      endif
    794  1091		       00 00		      .byte.b	%00000000, %00000000
    795  1093					      if	(pfwidth>2)
    796  1093		       00 00		      .byte.b	%00000000, %00000000
    797  1095					      endif
    798  1095		       ff ff		      .byte.b	%11111111, %11111111
    799  1097					      if	(pfwidth>2)
    800  1097		       ff ff		      .byte.b	%11111111, %11111111
    801  1099					      endif
    802  1099				   pflabel0
    803  1099		       bd 6d 10 	      lda	PF_data0,x
    804  109c		       95 a4		      sta	playfield,x
    805  109e		       ca		      dex
    806  109f		       10 f8		      bpl	pflabel0
    807  10a1				   .
    808  10a1							; 
    809  10a1
    810  10a1				   .
    811  10a1							; 
    812  10a1
    813  10a1				   .
    814  10a1							; 
    815  10a1
    816  10a1				   .
    817  10a1							; 
    818  10a1
    819  10a1				   .
    820  10a1							; 
    821  10a1
    822  10a1				   .
    823  10a1							; 
    824  10a1
    825  10a1				   .
    826  10a1							; 
    827  10a1
    828  10a1				   .
    829  10a1							; 
    830  10a1
    831  10a1				   .
    832  10a1							; 
    833  10a1
    834  10a1				   .
    835  10a1							; 
    836  10a1
    837  10a1				   .
    838  10a1							; 
    839  10a1
    840  10a1				   .__Main_Loop
    841  10a1							; __Main_Loop
    842  10a1
    843  10a1				   .
    844  10a1							; 
    845  10a1
    846  10a1				   .
    847  10a1							; 
    848  10a1
    849  10a1				   .
    850  10a1							; 
    851  10a1
    852  10a1				   .
    853  10a1							; 
    854  10a1
    855  10a1				   .
    856  10a1							; 
    857  10a1
    858  10a1				   .
    859  10a1							; 
    860  10a1
    861  10a1				   .
    862  10a1							; 
    863  10a1
    864  10a1				   .L053		;  COLUPF  =  $96  :  COLUBK  =  $9E  :  COLUP1  =  $42
    865  10a1
    866  10a1		       a9 96		      LDA	#$96
    867  10a3		       85 08		      STA	COLUPF
    868  10a5		       a9 9e		      LDA	#$9E
    869  10a7		       85 09		      STA	COLUBK
    870  10a9		       a9 42		      LDA	#$42
    871  10ab		       85 07		      STA	COLUP1
    872  10ad				   .
    873  10ad							; 
    874  10ad
    875  10ad				   .
    876  10ad							; 
    877  10ad
    878  10ad				   .
    879  10ad							; 
    880  10ad
    881  10ad				   .
    882  10ad							; 
    883  10ad
    884  10ad				   .
    885  10ad							; 
    886  10ad
    887  10ad				   .
    888  10ad							; 
    889  10ad
    890  10ad				   .
    891  10ad							; 
    892  10ad
    893  10ad				   .L054		;  pfcolors:
    894  10ad
    895  10ad		       a9 0c		      lda	# $0C
    896  10af		       85 08		      sta	COLUPF
    897  10b1				  -	      ifconst	pfres
    898  10b1				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
    899  10b1					      else
    900  10b1		       a9 f5		      lda	#>(pfcolorlabel13-84)
    901  10b3					      endif
    902  10b3		       85 f1		      sta	pfcolortable+1
    903  10b5				  -	      ifconst	pfres
    904  10b5				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
    905  10b5					      else
    906  10b5		       a9 04		      lda	#<(pfcolorlabel13-84)
    907  10b7					      endif
    908  10b7		       85 f0		      sta	pfcolortable
    909  10b9				   .
    910  10b9							; 
    911  10b9
    912  10b9				   .
    913  10b9							; 
    914  10b9
    915  10b9				   .
    916  10b9							; 
    917  10b9
    918  10b9				   .
    919  10b9							; 
    920  10b9
    921  10b9				   .
    922  10b9							; 
    923  10b9
    924  10b9				   .
    925  10b9							; 
    926  10b9
    927  10b9				   .
    928  10b9							; 
    929  10b9
    930  10b9				   .L055		;  _Convert_X	=   ( player1x - 14 )  / 4
    931  10b9
    932  10b9							; complex statement detected
    933  10b9		       a5 81		      LDA	player1x
    934  10bb		       38		      SEC
    935  10bc		       e9 0e		      SBC	#14
    936  10be		       4a		      lsr
    937  10bf		       4a		      lsr
    938  10c0		       85 d5		      STA	_Convert_X
    939  10c2				   .L056		;  _Convert_Y	=  player1y / 8
    940  10c2
    941  10c2		       a5 86		      LDA	player1y
    942  10c4		       4a		      lsr
    943  10c5		       4a		      lsr
    944  10c6		       4a		      lsr
    945  10c7		       85 d6		      STA	_Convert_Y
    946  10c9				   .
    947  10c9							; 
    948  10c9
    949  10c9				   .
    950  10c9							; 
    951  10c9
    952  10c9				   .
    953  10c9							; 
    954  10c9
    955  10c9				   .
    956  10c9							; 
    957  10c9
    958  10c9				   .
    959  10c9							; 
    960  10c9
    961  10c9				   .
    962  10c9							; 
    963  10c9
    964  10c9				   .
    965  10c9							; 
    966  10c9
    967  10c9				   .L057		;  _Master_Counter  =	_Master_Counter  +  1
    968  10c9
    969  10c9		       e6 dc		      INC	_Master_Counter
    970  10cb				   .
    971  10cb							; 
    972  10cb
    973  10cb				   .L058		;  if _Master_Counter	<  4 then goto __Skip_Frame_Counter
    974  10cb
    975  10cb		       a5 dc		      LDA	_Master_Counter
    976  10cd		       c9 04		      CMP	#4
    977  10cf		       b0 03		      BCS	.skipL058
    978  10d1				   .condpart0
    979  10d1		       4c e4 10 	      jmp	.__Skip_Frame_Counter
    980  10d4
    981  10d4				   .skipL058
    982  10d4				   .
    983  10d4							; 
    984  10d4
    985  10d4				   .L059		;  _Frame_Counter  =  _Frame_Counter  +  1  :	_Master_Counter  =  0
    986  10d4
    987  10d4		       e6 dd		      INC	_Frame_Counter
    988  10d6		       a9 00		      LDA	#0
    989  10d8		       85 dc		      STA	_Master_Counter
    990  10da				   .
    991  10da							; 
    992  10da
    993  10da				   .L060		;  if _Frame_Counter  =  4 then _Frame_Counter  =  0
    994  10da
    995  10da		       a5 dd		      LDA	_Frame_Counter
    996  10dc		       c9 04		      CMP	#4
    997  10de		       d0 04		      BNE	.skipL060
    998  10e0				   .condpart1
    999  10e0		       a9 00		      LDA	#0
   1000  10e2		       85 dd		      STA	_Frame_Counter
   1001  10e4				   .skipL060
   1002  10e4				   .
   1003  10e4							; 
   1004  10e4
   1005  10e4				   .__Skip_Frame_Counter
   1006  10e4							; __Skip_Frame_Counter
   1007  10e4
   1008  10e4				   .
   1009  10e4							; 
   1010  10e4
   1011  10e4				   .
   1012  10e4							; 
   1013  10e4
   1014  10e4				   .
   1015  10e4							; 
   1016  10e4
   1017  10e4				   .
   1018  10e4							; 
   1019  10e4
   1020  10e4				   .
   1021  10e4							; 
   1022  10e4
   1023  10e4				   .
   1024  10e4							; 
   1025  10e4
   1026  10e4				   .
   1027  10e4							; 
   1028  10e4
   1029  10e4				   .L061		;  player1color:
   1030  10e4
   1031  10e4		       a2 84		      LDX	#<playercolorL061_1
   1032  10e6		       86 87		      STX	player1color
   1033  10e8		       a9 f5		      LDA	#>playercolorL061_1
   1034  10ea		       85 88		      STA	player1color+1
   1035  10ec				   .
   1036  10ec							; 
   1037  10ec
   1038  10ec				   .L062		;  player1:
   1039  10ec
   1040  10ec		       a2 8e		      LDX	#<playerL062_1
   1041  10ee		       86 8c		      STX	player1pointerlo
   1042  10f0		       a9 f5		      LDA	#>playerL062_1
   1043  10f2		       85 8d		      STA	player1pointerhi
   1044  10f4		       a9 09		      LDA	#9
   1045  10f6		       85 8f		      STA	player1height
   1046  10f8				   .
   1047  10f8							; 
   1048  10f8
   1049  10f8				   .
   1050  10f8							; 
   1051  10f8
   1052  10f8				   .
   1053  10f8							; 
   1054  10f8
   1055  10f8				   .
   1056  10f8							; 
   1057  10f8
   1058  10f8				   .
   1059  10f8							; 
   1060  10f8
   1061  10f8				   .
   1062  10f8							; 
   1063  10f8
   1064  10f8				   .
   1065  10f8							; 
   1066  10f8
   1067  10f8				   .
   1068  10f8							; 
   1069  10f8
   1070  10f8				   .
   1071  10f8							; 
   1072  10f8
   1073  10f8				   .
   1074  10f8							; 
   1075  10f8
   1076  10f8				   .L063		;  if !joy0fire then _Jump_Gravity_Counter  =	0  :  _Bit3_FireB_Restrainer{3}  =  0  :  goto __Skip_Jump
   1077  10f8
   1078  10f8		       24 0c		      bit	INPT4
   1079  10fa		       10 0d		      BPL	.skipL063
   1080  10fc				   .condpart2
   1081  10fc		       a9 00		      LDA	#0
   1082  10fe		       85 d7		      STA	_Jump_Gravity_Counter
   1083  1100		       a5 ec		      LDA	_Bit3_FireB_Restrainer
   1084  1102		       29 f7		      AND	#247
   1085  1104		       85 ec		      STA	_Bit3_FireB_Restrainer
   1086  1106		       4c f6 11 	      jmp	.__Skip_Jump
   1087  1109
   1088  1109				   .skipL063
   1089  1109				   .
   1090  1109							; 
   1091  1109
   1092  1109				   .
   1093  1109							; 
   1094  1109
   1095  1109				   .
   1096  1109							; 
   1097  1109
   1098  1109				   .
   1099  1109							; 
   1100  1109
   1101  1109				   .
   1102  1109							; 
   1103  1109
   1104  1109				   .L064		;  if !_Jump_Gravity_Counter  &&  _Bit6_Duck_in_Progress{6} then goto __Skip_Jump
   1105  1109
   1106  1109		       a5 d7		      LDA	_Jump_Gravity_Counter
   1107  110b		       d0 07		      BNE	.skipL064
   1108  110d				   .condpart3
   1109  110d		       24 ec		      BIT	_Bit6_Duck_in_Progress
   1110  110f		       50 03		      BVC	.skip3then
   1111  1111				   .condpart4
   1112  1111		       4c f6 11 	      jmp	.__Skip_Jump
   1113  1114
   1114  1114				   .skip3then
   1115  1114				   .skipL064
   1116  1114				   .
   1117  1114							; 
   1118  1114
   1119  1114				   .
   1120  1114							; 
   1121  1114
   1122  1114				   .
   1123  1114							; 
   1124  1114
   1125  1114				   .
   1126  1114							; 
   1127  1114
   1128  1114				   .L065		;  _Bit5_Ground_Slide_in_Progress{5}  =  0
   1129  1114
   1130  1114		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   1131  1116		       29 df		      AND	#223
   1132  1118		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   1133  111a				   .
   1134  111a							; 
   1135  111a
   1136  111a				   .
   1137  111a							; 
   1138  111a
   1139  111a				   .
   1140  111a							; 
   1141  111a
   1142  111a				   .
   1143  111a							; 
   1144  111a
   1145  111a				   .L066		;  if !_Bit3_FireB_Restrainer{3} then player1:
   1146  111a
   1147  111a		       a5 ec		      LDA	_Bit3_FireB_Restrainer
   1148  111c		       29 08		      AND	#8
   1149  111e		       d0 0c		      BNE	.skipL066
   1150  1120				   .condpart5
   1151  1120		       a2 98		      LDX	#<player5then_1
   1152  1122		       86 8c		      STX	player1pointerlo
   1153  1124		       a9 f5		      LDA	#>player5then_1
   1154  1126		       85 8d		      STA	player1pointerhi
   1155  1128		       a9 09		      LDA	#9
   1156  112a		       85 8f		      STA	player1height
   1157  112c				   .skipL066
   1158  112c				   .
   1159  112c							; 
   1160  112c
   1161  112c				   .
   1162  112c							; 
   1163  112c
   1164  112c				   .
   1165  112c							; 
   1166  112c
   1167  112c				   .
   1168  112c							; 
   1169  112c
   1170  112c				   .L067		;  if !joy0left  &&  !joy0right  &&  !_Bit3_FireB_Restrainer{3} then player1:
   1171  112c
   1172  112c		       2c 80 02 	      bit	SWCHA
   1173  112f		       50 17		      BVC	.skipL067
   1174  1131				   .condpart6
   1175  1131		       2c 80 02 	      bit	SWCHA
   1176  1134		       10 12		      BPL	.skip6then
   1177  1136				   .condpart7
   1178  1136		       a5 ec		      LDA	_Bit3_FireB_Restrainer
   1179  1138		       29 08		      AND	#8
   1180  113a		       d0 0c		      BNE	.skip7then
   1181  113c				   .condpart8
   1182  113c		       a2 a2		      LDX	#<player8then_1
   1183  113e		       86 8c		      STX	player1pointerlo
   1184  1140		       a9 f5		      LDA	#>player8then_1
   1185  1142		       85 8d		      STA	player1pointerhi
   1186  1144		       a9 09		      LDA	#9
   1187  1146		       85 8f		      STA	player1height
   1188  1148				   .skip7then
   1189  1148				   .skip6then
   1190  1148				   .skipL067
   1191  1148				   .
   1192  1148							; 
   1193  1148
   1194  1148				   .
   1195  1148							; 
   1196  1148
   1197  1148				   .
   1198  1148							; 
   1199  1148
   1200  1148				   .
   1201  1148							; 
   1202  1148
   1203  1148				   .L068		;  if _Bit0_Fall_in_Progress{0} then goto __Skip_Jump
   1204  1148
   1205  1148		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1206  114a		       4a		      LSR
   1207  114b		       90 03		      BCC	.skipL068
   1208  114d				   .condpart9
   1209  114d		       4c f6 11 	      jmp	.__Skip_Jump
   1210  1150
   1211  1150				   .skipL068
   1212  1150				   .
   1213  1150							; 
   1214  1150
   1215  1150				   .
   1216  1150							; 
   1217  1150
   1218  1150				   .
   1219  1150							; 
   1220  1150
   1221  1150				   .
   1222  1150							; 
   1223  1150
   1224  1150				   .
   1225  1150							; 
   1226  1150
   1227  1150				   .
   1228  1150							; 
   1229  1150
   1230  1150				   .L069		;  if _Bit3_FireB_Restrainer{3}  &&  !_Bit0_Fall_in_Progress{0}  &&  !_Jump_Gravity_Counter then goto __Skip_Jump
   1231  1150
   1232  1150		       a5 ec		      LDA	_Bit3_FireB_Restrainer
   1233  1152		       29 08		      AND	#8
   1234  1154		       f0 0c		      BEQ	.skipL069
   1235  1156				   .condpart10
   1236  1156		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1237  1158		       4a		      LSR
   1238  1159		       b0 07		      BCS	.skip10then
   1239  115b				   .condpart11
   1240  115b		       a5 d7		      LDA	_Jump_Gravity_Counter
   1241  115d		       d0 03		      BNE	.skip11then
   1242  115f				   .condpart12
   1243  115f		       4c f6 11 	      jmp	.__Skip_Jump
   1244  1162
   1245  1162				   .skip11then
   1246  1162				   .skip10then
   1247  1162				   .skipL069
   1248  1162				   .
   1249  1162							; 
   1250  1162
   1251  1162				   .
   1252  1162							; 
   1253  1162
   1254  1162				   .
   1255  1162							; 
   1256  1162
   1257  1162				   .
   1258  1162							; 
   1259  1162
   1260  1162				   .L070		;  if !_Jump_Gravity_Counter then _Ch0_Sound  =  _c_Jump_Sound  :  _Ch0_Duration  =  1  :  _Ch0_Counter  =  0
   1261  1162
   1262  1162		       a5 d7		      LDA	_Jump_Gravity_Counter
   1263  1164		       d0 0c		      BNE	.skipL070
   1264  1166				   .condpart13
   1265  1166		       a9 01		      LDA	#_c_Jump_Sound
   1266  1168		       85 de		      STA	_Ch0_Sound
   1267  116a		       a9 01		      LDA	#1
   1268  116c		       85 df		      STA	_Ch0_Duration
   1269  116e		       a9 00		      LDA	#0
   1270  1170		       85 e0		      STA	_Ch0_Counter
   1271  1172				   .skipL070
   1272  1172				   .
   1273  1172							; 
   1274  1172
   1275  1172				   .
   1276  1172							; 
   1277  1172
   1278  1172				   .
   1279  1172							; 
   1280  1172
   1281  1172				   .
   1282  1172							; 
   1283  1172
   1284  1172				   .L071		;  _Bit3_FireB_Restrainer{3}  =  1
   1285  1172
   1286  1172		       a5 ec		      LDA	_Bit3_FireB_Restrainer
   1287  1174		       09 08		      ORA	#8
   1288  1176		       85 ec		      STA	_Bit3_FireB_Restrainer
   1289  1178				   .
   1290  1178							; 
   1291  1178
   1292  1178				   .
   1293  1178							; 
   1294  1178
   1295  1178				   .
   1296  1178							; 
   1297  1178
   1298  1178				   .
   1299  1178							; 
   1300  1178
   1301  1178				   .L072		;  _Jump_Gravity_Counter  =  _Jump_Gravity_Counter  +	1
   1302  1178
   1303  1178		       e6 d7		      INC	_Jump_Gravity_Counter
   1304  117a				   .
   1305  117a							; 
   1306  117a
   1307  117a				   .
   1308  117a							; 
   1309  117a
   1310  117a				   .
   1311  117a							; 
   1312  117a
   1313  117a				   .
   1314  117a							; 
   1315  117a
   1316  117a				   .L073		;  if _Jump_Gravity_Counter  >  12 then _Jump_Gravity_Counter	=  0  :  _Bit0_Fall_in_Progress{0}  =  1  :  goto __Skip_Jump
   1317  117a
   1318  117a		       a9 0c		      LDA	#12
   1319  117c		       c5 d7		      CMP	_Jump_Gravity_Counter
   1320  117e		       b0 0d		      BCS	.skipL073
   1321  1180				   .condpart14
   1322  1180		       a9 00		      LDA	#0
   1323  1182		       85 d7		      STA	_Jump_Gravity_Counter
   1324  1184		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1325  1186		       09 01		      ORA	#1
   1326  1188		       85 ec		      STA	_Bit0_Fall_in_Progress
   1327  118a		       4c f6 11 	      jmp	.__Skip_Jump
   1328  118d
   1329  118d				   .skipL073
   1330  118d				   .
   1331  118d							; 
   1332  118d
   1333  118d				   .
   1334  118d							; 
   1335  118d
   1336  118d				   .
   1337  118d							; 
   1338  118d
   1339  118d				   .
   1340  118d							; 
   1341  118d
   1342  118d				   .
   1343  118d							; 
   1344  118d
   1345  118d				   .
   1346  118d							; 
   1347  118d
   1348  118d				   .L074		;  if player1y  <  13 then goto __Skip_Jump
   1349  118d
   1350  118d		       a5 86		      LDA	player1y
   1351  118f		       c9 0d		      CMP	#13
   1352  1191		       b0 03		      BCS	.skipL074
   1353  1193				   .condpart15
   1354  1193		       4c f6 11 	      jmp	.__Skip_Jump
   1355  1196
   1356  1196				   .skipL074
   1357  1196				   .
   1358  1196							; 
   1359  1196
   1360  1196				   .
   1361  1196							; 
   1362  1196
   1363  1196				   .
   1364  1196							; 
   1365  1196
   1366  1196				   .
   1367  1196							; 
   1368  1196
   1369  1196				   .
   1370  1196							; 
   1371  1196
   1372  1196				   .L075		;  if _Jump_Gravity_Counter  <=  7 then temp6	=  3
   1373  1196
   1374  1196		       a9 07		      LDA	#7
   1375  1198		       c5 d7		      CMP	_Jump_Gravity_Counter
   1376  119a		       90 04		      BCC	.skipL075
   1377  119c				   .condpart16
   1378  119c		       a9 03		      LDA	#3
   1379  119e		       85 a1		      STA	temp6
   1380  11a0				   .skipL075
   1381  11a0				   .L076		;  if _Jump_Gravity_Counter  >  7  &&	_Jump_Gravity_Counter  <=  10 then temp6  =  2
   1382  11a0
   1383  11a0		       a9 07		      LDA	#7
   1384  11a2		       c5 d7		      CMP	_Jump_Gravity_Counter
   1385  11a4		       b0 0a		      BCS	.skipL076
   1386  11a6				   .condpart17
   1387  11a6		       a9 0a		      LDA	#10
   1388  11a8		       c5 d7		      CMP	_Jump_Gravity_Counter
   1389  11aa		       90 04		      BCC	.skip17then
   1390  11ac				   .condpart18
   1391  11ac		       a9 02		      LDA	#2
   1392  11ae		       85 a1		      STA	temp6
   1393  11b0				   .skip17then
   1394  11b0				   .skipL076
   1395  11b0				   .L077		;  if _Jump_Gravity_Counter  >  10 then temp6	=  1
   1396  11b0
   1397  11b0		       a9 0a		      LDA	#10
   1398  11b2		       c5 d7		      CMP	_Jump_Gravity_Counter
   1399  11b4		       b0 04		      BCS	.skipL077
   1400  11b6				   .condpart19
   1401  11b6		       a9 01		      LDA	#1
   1402  11b8		       85 a1		      STA	temp6
   1403  11ba				   .skipL077
   1404  11ba				   .
   1405  11ba							; 
   1406  11ba
   1407  11ba				   .
   1408  11ba							; 
   1409  11ba
   1410  11ba				   .
   1411  11ba							; 
   1412  11ba
   1413  11ba				   .
   1414  11ba							; 
   1415  11ba
   1416  11ba				   .L078		;  player1y  =  player1y  -  temp6
   1417  11ba
   1418  11ba		       a5 86		      LDA	player1y
   1419  11bc		       38		      SEC
   1420  11bd		       e5 a1		      SBC	temp6
   1421  11bf		       85 86		      STA	player1y
   1422  11c1				   .
   1423  11c1							; 
   1424  11c1
   1425  11c1				   .
   1426  11c1							; 
   1427  11c1
   1428  11c1				   .
   1429  11c1							; 
   1430  11c1
   1431  11c1				   .
   1432  11c1							; 
   1433  11c1
   1434  11c1				   .L079		;  temp5  =   ( player1y - 5 )  / 8
   1435  11c1
   1436  11c1							; complex statement detected
   1437  11c1		       a5 86		      LDA	player1y
   1438  11c3		       38		      SEC
   1439  11c4		       e9 05		      SBC	#5
   1440  11c6		       4a		      lsr
   1441  11c7		       4a		      lsr
   1442  11c8		       4a		      lsr
   1443  11c9		       85 a0		      STA	temp5
   1444  11cb				   .
   1445  11cb							; 
   1446  11cb
   1447  11cb				   .
   1448  11cb							; 
   1449  11cb
   1450  11cb				   .
   1451  11cb							; 
   1452  11cb
   1453  11cb				   .
   1454  11cb							; 
   1455  11cb
   1456  11cb				   .L080		;  if pfread ( _Convert_X , temp5 )  then _Jump_Gravity_Counter  =  0	:  _Bit0_Fall_in_Progress{0}  =  1  :  goto __Skip_Jump
   1457  11cb
   1458  11cb		       a5 d5		      LDA	_Convert_X
   1459  11cd		       a4 a0		      LDY	temp5
   1460  11cf		       85 ee		      sta	temp7
   1461  11d1		       a9 11		      lda	#>(ret_point1-1)
   1462  11d3		       48		      pha
   1463  11d4		       a9 e6		      lda	#<(ret_point1-1)
   1464  11d6		       48		      pha
   1465  11d7		       a9 f2		      lda	#>(pfread-1)
   1466  11d9		       48		      pha
   1467  11da		       a9 a9		      lda	#<(pfread-1)
   1468  11dc		       48		      pha
   1469  11dd		       a5 ee		      lda	temp7
   1470  11df		       48		      pha
   1471  11e0		       8a		      txa
   1472  11e1		       48		      pha
   1473  11e2		       a2 08		      ldx	#8
   1474  11e4		       4c eb ff 	      jmp	BS_jsr
   1475  11e7				   ret_point1
   1476  11e7		       d0 0d		      BNE	.skipL080
   1477  11e9				   .condpart20
   1478  11e9		       a9 00		      LDA	#0
   1479  11eb		       85 d7		      STA	_Jump_Gravity_Counter
   1480  11ed		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1481  11ef		       09 01		      ORA	#1
   1482  11f1		       85 ec		      STA	_Bit0_Fall_in_Progress
   1483  11f3		       4c f6 11 	      jmp	.__Skip_Jump
   1484  11f6
   1485  11f6				   .skipL080
   1486  11f6				   .
   1487  11f6							; 
   1488  11f6
   1489  11f6				   .__Skip_Jump
   1490  11f6							; __Skip_Jump
   1491  11f6
   1492  11f6				   .
   1493  11f6							; 
   1494  11f6
   1495  11f6				   .
   1496  11f6							; 
   1497  11f6
   1498  11f6				   .
   1499  11f6							; 
   1500  11f6
   1501  11f6				   .
   1502  11f6							; 
   1503  11f6
   1504  11f6				   .
   1505  11f6							; 
   1506  11f6
   1507  11f6				   .
   1508  11f6							; 
   1509  11f6
   1510  11f6				   .
   1511  11f6							; 
   1512  11f6
   1513  11f6				   .
   1514  11f6							; 
   1515  11f6
   1516  11f6				   .
   1517  11f6							; 
   1518  11f6
   1519  11f6				   .
   1520  11f6							; 
   1521  11f6
   1522  11f6				   .L081		;  temp5  =   ( player1y + 1 )  / 8
   1523  11f6
   1524  11f6							; complex statement detected
   1525  11f6		       a5 86		      LDA	player1y
   1526  11f8		       18		      CLC
   1527  11f9		       69 01		      ADC	#1
   1528  11fb		       4a		      lsr
   1529  11fc		       4a		      lsr
   1530  11fd		       4a		      lsr
   1531  11fe		       85 a0		      STA	temp5
   1532  1200				   .
   1533  1200							; 
   1534  1200
   1535  1200				   .
   1536  1200							; 
   1537  1200
   1538  1200				   .
   1539  1200							; 
   1540  1200
   1541  1200				   .
   1542  1200							; 
   1543  1200
   1544  1200				   .L082		;  if _Jump_Gravity_Counter  ||  pfread ( _Convert_X , temp5 )  then goto __Skip_Fall_01
   1545  1200
   1546  1200		       a5 d7		      LDA	_Jump_Gravity_Counter
   1547  1202		       f0 03		      BEQ	.skipL082
   1548  1204				   .condpart21
   1549  1204		       4c 25 12 	      jmp	.condpart22
   1550  1207				   .skipL082
   1551  1207		       a5 d5		      LDA	_Convert_X
   1552  1209		       a4 a0		      LDY	temp5
   1553  120b		       85 ee		      sta	temp7
   1554  120d		       a9 12		      lda	#>(ret_point2-1)
   1555  120f		       48		      pha
   1556  1210		       a9 22		      lda	#<(ret_point2-1)
   1557  1212		       48		      pha
   1558  1213		       a9 f2		      lda	#>(pfread-1)
   1559  1215		       48		      pha
   1560  1216		       a9 a9		      lda	#<(pfread-1)
   1561  1218		       48		      pha
   1562  1219		       a5 ee		      lda	temp7
   1563  121b		       48		      pha
   1564  121c		       8a		      txa
   1565  121d		       48		      pha
   1566  121e		       a2 08		      ldx	#8
   1567  1220		       4c eb ff 	      jmp	BS_jsr
   1568  1223				   ret_point2
   1569  1223		       d0 03		      BNE	.skip6OR
   1570  1225				   .condpart22
   1571  1225		       4c cd 12 	      jmp	.__Skip_Fall_01
   1572  1228
   1573  1228				   .skip6OR
   1574  1228				   .
   1575  1228							; 
   1576  1228
   1577  1228				   .
   1578  1228							; 
   1579  1228
   1580  1228				   .
   1581  1228							; 
   1582  1228
   1583  1228				   .
   1584  1228							; 
   1585  1228
   1586  1228				   .L083		;  player1:
   1587  1228
   1588  1228		       a2 ac		      LDX	#<playerL083_1
   1589  122a		       86 8c		      STX	player1pointerlo
   1590  122c		       a9 f5		      LDA	#>playerL083_1
   1591  122e		       85 8d		      STA	player1pointerhi
   1592  1230		       a9 09		      LDA	#9
   1593  1232		       85 8f		      STA	player1height
   1594  1234				   .
   1595  1234							; 
   1596  1234
   1597  1234				   .
   1598  1234							; 
   1599  1234
   1600  1234				   .
   1601  1234							; 
   1602  1234
   1603  1234				   .
   1604  1234							; 
   1605  1234
   1606  1234				   .L084		;  if !joy0left  &&  !joy0right then player1:
   1607  1234
   1608  1234		       2c 80 02 	      bit	SWCHA
   1609  1237		       50 11		      BVC	.skipL084
   1610  1239				   .condpart23
   1611  1239		       2c 80 02 	      bit	SWCHA
   1612  123c		       10 0c		      BPL	.skip23then
   1613  123e				   .condpart24
   1614  123e		       a2 b6		      LDX	#<player24then_1
   1615  1240		       86 8c		      STX	player1pointerlo
   1616  1242		       a9 f5		      LDA	#>player24then_1
   1617  1244		       85 8d		      STA	player1pointerhi
   1618  1246		       a9 09		      LDA	#9
   1619  1248		       85 8f		      STA	player1height
   1620  124a				   .skip23then
   1621  124a				   .skipL084
   1622  124a				   .
   1623  124a							; 
   1624  124a
   1625  124a				   .
   1626  124a							; 
   1627  124a
   1628  124a				   .
   1629  124a							; 
   1630  124a
   1631  124a				   .
   1632  124a							; 
   1633  124a
   1634  124a				   .L085		;  _Fall_Gravity_Counter  =  _Fall_Gravity_Counter  +	1
   1635  124a
   1636  124a		       e6 d8		      INC	_Fall_Gravity_Counter
   1637  124c				   .
   1638  124c							; 
   1639  124c
   1640  124c				   .
   1641  124c							; 
   1642  124c
   1643  124c				   .
   1644  124c							; 
   1645  124c
   1646  124c				   .
   1647  124c							; 
   1648  124c
   1649  124c				   .L086		;  temp6  =  0
   1650  124c
   1651  124c		       a9 00		      LDA	#0
   1652  124e		       85 a1		      STA	temp6
   1653  1250				   .L087		;  if _Fall_Gravity_Counter  >  8  &&	_Jump_Gravity_Counter  <=  16 then temp6  =  1
   1654  1250
   1655  1250		       a9 08		      LDA	#8
   1656  1252		       c5 d8		      CMP	_Fall_Gravity_Counter
   1657  1254		       b0 0a		      BCS	.skipL087
   1658  1256				   .condpart25
   1659  1256		       a9 10		      LDA	#16
   1660  1258		       c5 d7		      CMP	_Jump_Gravity_Counter
   1661  125a		       90 04		      BCC	.skip25then
   1662  125c				   .condpart26
   1663  125c		       a9 01		      LDA	#1
   1664  125e		       85 a1		      STA	temp6
   1665  1260				   .skip25then
   1666  1260				   .skipL087
   1667  1260				   .L088		;  if _Fall_Gravity_Counter  >  16  &&  _Jump_Gravity_Counter	<=  24 then temp6  =  2
   1668  1260
   1669  1260		       a9 10		      LDA	#16
   1670  1262		       c5 d8		      CMP	_Fall_Gravity_Counter
   1671  1264		       b0 0a		      BCS	.skipL088
   1672  1266				   .condpart27
   1673  1266		       a9 18		      LDA	#24
   1674  1268		       c5 d7		      CMP	_Jump_Gravity_Counter
   1675  126a		       90 04		      BCC	.skip27then
   1676  126c				   .condpart28
   1677  126c		       a9 02		      LDA	#2
   1678  126e		       85 a1		      STA	temp6
   1679  1270				   .skip27then
   1680  1270				   .skipL088
   1681  1270				   .L089		;  if _Fall_Gravity_Counter  >  24  &&  _Jump_Gravity_Counter	<=  32 then temp6  =  3
   1682  1270
   1683  1270		       a9 18		      LDA	#24
   1684  1272		       c5 d8		      CMP	_Fall_Gravity_Counter
   1685  1274		       b0 0a		      BCS	.skipL089
   1686  1276				   .condpart29
   1687  1276		       a9 20		      LDA	#32
   1688  1278		       c5 d7		      CMP	_Jump_Gravity_Counter
   1689  127a		       90 04		      BCC	.skip29then
   1690  127c				   .condpart30
   1691  127c		       a9 03		      LDA	#3
   1692  127e		       85 a1		      STA	temp6
   1693  1280				   .skip29then
   1694  1280				   .skipL089
   1695  1280				   .L090		;  if _Fall_Gravity_Counter  >  32 then temp6	=  4
   1696  1280
   1697  1280		       a9 20		      LDA	#32
   1698  1282		       c5 d8		      CMP	_Fall_Gravity_Counter
   1699  1284		       b0 04		      BCS	.skipL090
   1700  1286				   .condpart31
   1701  1286		       a9 04		      LDA	#4
   1702  1288		       85 a1		      STA	temp6
   1703  128a				   .skipL090
   1704  128a				   .
   1705  128a							; 
   1706  128a
   1707  128a				   .
   1708  128a							; 
   1709  128a
   1710  128a				   .
   1711  128a							; 
   1712  128a
   1713  128a				   .
   1714  128a							; 
   1715  128a
   1716  128a				   .L091		;  player1y  =  player1y  +  temp6
   1717  128a
   1718  128a		       a5 86		      LDA	player1y
   1719  128c		       18		      CLC
   1720  128d		       65 a1		      ADC	temp6
   1721  128f		       85 86		      STA	player1y
   1722  1291				   .
   1723  1291							; 
   1724  1291
   1725  1291				   .
   1726  1291							; 
   1727  1291
   1728  1291				   .
   1729  1291							; 
   1730  1291
   1731  1291				   .
   1732  1291							; 
   1733  1291
   1734  1291				   .L092		;  if _Ch0_Sound  =  _c_Jump_Sound  ||  _Ch0_Sound  =	_c_Fall_Sound then goto __Skip_Fall_Sound_Check
   1735  1291
   1736  1291		       a5 de		      LDA	_Ch0_Sound
   1737  1293		       c9 01		      CMP	#_c_Jump_Sound
   1738  1295		       d0 03		      BNE	.skipL092
   1739  1297				   .condpart32
   1740  1297		       4c a0 12 	      jmp	.condpart33
   1741  129a				   .skipL092
   1742  129a		       a5 de		      LDA	_Ch0_Sound
   1743  129c		       c9 02		      CMP	#_c_Fall_Sound
   1744  129e		       d0 03		      BNE	.skip11OR
   1745  12a0				   .condpart33
   1746  12a0		       4c be 12 	      jmp	.__Skip_Fall_Sound_Check
   1747  12a3
   1748  12a3				   .skip11OR
   1749  12a3				   .
   1750  12a3							; 
   1751  12a3
   1752  12a3				   .
   1753  12a3							; 
   1754  12a3
   1755  12a3				   .
   1756  12a3							; 
   1757  12a3
   1758  12a3				   .
   1759  12a3							; 
   1760  12a3
   1761  12a3				   .L093		;  if _Fall_Gravity_Counter  =  17  ||  _Fall_Gravity_Counter	=  27 then _Ch0_Sound  =  _c_Fall_Sound  :  _Ch0_Duration  =  1  :  _Ch0_Counter  =  0
   1762  12a3
   1763  12a3		       a5 d8		      LDA	_Fall_Gravity_Counter
   1764  12a5		       c9 11		      CMP	#17
   1765  12a7		       d0 03		      BNE	.skipL093
   1766  12a9				   .condpart34
   1767  12a9		       4c b2 12 	      jmp	.condpart35
   1768  12ac				   .skipL093
   1769  12ac		       a5 d8		      LDA	_Fall_Gravity_Counter
   1770  12ae		       c9 1b		      CMP	#27
   1771  12b0		       d0 0c		      BNE	.skip12OR
   1772  12b2				   .condpart35
   1773  12b2		       a9 02		      LDA	#_c_Fall_Sound
   1774  12b4		       85 de		      STA	_Ch0_Sound
   1775  12b6		       a9 01		      LDA	#1
   1776  12b8		       85 df		      STA	_Ch0_Duration
   1777  12ba		       a9 00		      LDA	#0
   1778  12bc		       85 e0		      STA	_Ch0_Counter
   1779  12be				   .skip12OR
   1780  12be				   .
   1781  12be							; 
   1782  12be
   1783  12be				   .__Skip_Fall_Sound_Check
   1784  12be							; __Skip_Fall_Sound_Check
   1785  12be
   1786  12be				   .
   1787  12be							; 
   1788  12be
   1789  12be				   .
   1790  12be							; 
   1791  12be
   1792  12be				   .
   1793  12be							; 
   1794  12be
   1795  12be				   .
   1796  12be							; 
   1797  12be
   1798  12be				   .L094		;  _Bit0_Fall_in_Progress{0}  =  1
   1799  12be
   1800  12be		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1801  12c0		       09 01		      ORA	#1
   1802  12c2		       85 ec		      STA	_Bit0_Fall_in_Progress
   1803  12c4				   .
   1804  12c4							; 
   1805  12c4
   1806  12c4				   .
   1807  12c4							; 
   1808  12c4
   1809  12c4				   .
   1810  12c4							; 
   1811  12c4
   1812  12c4				   .
   1813  12c4							; 
   1814  12c4
   1815  12c4				   .L095		;  _Bit5_Ground_Slide_in_Progress{5}  =  0
   1816  12c4
   1817  12c4		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   1818  12c6		       29 df		      AND	#223
   1819  12c8		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   1820  12ca				   .
   1821  12ca							; 
   1822  12ca
   1823  12ca				   .L096		;  goto __Skip_Fall_02
   1824  12ca
   1825  12ca		       4c fe 12 	      jmp	.__Skip_Fall_02
   1826  12cd
   1827  12cd				   .
   1828  12cd							; 
   1829  12cd
   1830  12cd				   .__Skip_Fall_01
   1831  12cd							; __Skip_Fall_01
   1832  12cd
   1833  12cd				   .
   1834  12cd							; 
   1835  12cd
   1836  12cd				   .
   1837  12cd							; 
   1838  12cd
   1839  12cd				   .
   1840  12cd							; 
   1841  12cd
   1842  12cd				   .
   1843  12cd							; 
   1844  12cd
   1845  12cd				   .L097		;  _Bit0_Fall_in_Progress{0}  =  0  :	_Fall_Gravity_Counter  =  0
   1846  12cd
   1847  12cd		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1848  12cf		       29 fe		      AND	#254
   1849  12d1		       85 ec		      STA	_Bit0_Fall_in_Progress
   1850  12d3		       a9 00		      LDA	#0
   1851  12d5		       85 d8		      STA	_Fall_Gravity_Counter
   1852  12d7				   .
   1853  12d7							; 
   1854  12d7
   1855  12d7				   .
   1856  12d7							; 
   1857  12d7
   1858  12d7				   .
   1859  12d7							; 
   1860  12d7
   1861  12d7				   .
   1862  12d7							; 
   1863  12d7
   1864  12d7				   .L098		;  temp5  =   ( player1y )  / 8
   1865  12d7
   1866  12d7							; complex statement detected
   1867  12d7		       a5 86		      LDA	player1y
   1868  12d9		       4a		      lsr
   1869  12da		       4a		      lsr
   1870  12db		       4a		      lsr
   1871  12dc		       85 a0		      STA	temp5
   1872  12de				   .
   1873  12de							; 
   1874  12de
   1875  12de				   .
   1876  12de							; 
   1877  12de
   1878  12de				   .
   1879  12de							; 
   1880  12de
   1881  12de				   .
   1882  12de							; 
   1883  12de
   1884  12de				   .L099		;  if pfread ( _Convert_X , temp5 )  then player1y  =	player1y  -  1
   1885  12de
   1886  12de		       a5 d5		      LDA	_Convert_X
   1887  12e0		       a4 a0		      LDY	temp5
   1888  12e2		       85 ee		      sta	temp7
   1889  12e4		       a9 12		      lda	#>(ret_point3-1)
   1890  12e6		       48		      pha
   1891  12e7		       a9 f9		      lda	#<(ret_point3-1)
   1892  12e9		       48		      pha
   1893  12ea		       a9 f2		      lda	#>(pfread-1)
   1894  12ec		       48		      pha
   1895  12ed		       a9 a9		      lda	#<(pfread-1)
   1896  12ef		       48		      pha
   1897  12f0		       a5 ee		      lda	temp7
   1898  12f2		       48		      pha
   1899  12f3		       8a		      txa
   1900  12f4		       48		      pha
   1901  12f5		       a2 08		      ldx	#8
   1902  12f7		       4c eb ff 	      jmp	BS_jsr
   1903  12fa				   ret_point3
   1904  12fa		       d0 02		      BNE	.skipL099
   1905  12fc				   .condpart36
   1906  12fc		       c6 86		      DEC	player1y
   1907  12fe				   .skipL099
   1908  12fe				   .
   1909  12fe							; 
   1910  12fe
   1911  12fe				   .__Skip_Fall_02
   1912  12fe							; __Skip_Fall_02
   1913  12fe
   1914  12fe				   .
   1915  12fe							; 
   1916  12fe
   1917  12fe				   .
   1918  12fe							; 
   1919  12fe
   1920  12fe				   .
   1921  12fe							; 
   1922  12fe
   1923  12fe				   .
   1924  12fe							; 
   1925  12fe
   1926  12fe				   .L0100		;  _Bit6_Duck_in_Progress{6}  =  0
   1927  12fe
   1928  12fe		       a5 ec		      LDA	_Bit6_Duck_in_Progress
   1929  1300		       29 bf		      AND	#191
   1930  1302		       85 ec		      STA	_Bit6_Duck_in_Progress
   1931  1304				   .
   1932  1304							; 
   1933  1304
   1934  1304				   .
   1935  1304							; 
   1936  1304
   1937  1304				   .
   1938  1304							; 
   1939  1304
   1940  1304				   .
   1941  1304							; 
   1942  1304
   1943  1304				   .
   1944  1304							; 
   1945  1304
   1946  1304				   .
   1947  1304							; 
   1948  1304
   1949  1304				   .
   1950  1304							; 
   1951  1304
   1952  1304				   .
   1953  1304							; 
   1954  1304
   1955  1304				   .
   1956  1304							; 
   1957  1304
   1958  1304				   .
   1959  1304							; 
   1960  1304
   1961  1304				   .L0101		;  if !joy0down then goto __Skip_Duck
   1962  1304
   1963  1304		       a9 20		      lda	#$20
   1964  1306		       2c 80 02 	      bit	SWCHA
   1965  1309		       f0 03		      BEQ	.skipL0101
   1966  130b				   .condpart37
   1967  130b		       4c fe 13 	      jmp	.__Skip_Duck
   1968  130e
   1969  130e				   .skipL0101
   1970  130e				   .
   1971  130e							; 
   1972  130e
   1973  130e				   .
   1974  130e							; 
   1975  130e
   1976  130e				   .
   1977  130e							; 
   1978  130e
   1979  130e				   .
   1980  130e							; 
   1981  130e
   1982  130e				   .L0102		;  if _Bit0_Fall_in_Progress{0}  ||  _Jump_Gravity_Counter then goto __Skip_Duck
   1983  130e
   1984  130e		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   1985  1310		       4a		      LSR
   1986  1311		       90 03		      BCC	.skipL0102
   1987  1313				   .condpart38
   1988  1313		       4c 1a 13 	      jmp	.condpart39
   1989  1316				   .skipL0102
   1990  1316		       a5 d7		      LDA	_Jump_Gravity_Counter
   1991  1318		       f0 03		      BEQ	.skip13OR
   1992  131a				   .condpart39
   1993  131a		       4c fe 13 	      jmp	.__Skip_Duck
   1994  131d
   1995  131d				   .skip13OR
   1996  131d				   .
   1997  131d							; 
   1998  131d
   1999  131d				   .
   2000  131d							; 
   2001  131d
   2002  131d				   .
   2003  131d							; 
   2004  131d
   2005  131d				   .
   2006  131d							; 
   2007  131d
   2008  131d				   .L0103		;  _Bit6_Duck_in_Progress{6}  =  1
   2009  131d
   2010  131d		       a5 ec		      LDA	_Bit6_Duck_in_Progress
   2011  131f		       09 40		      ORA	#64
   2012  1321		       85 ec		      STA	_Bit6_Duck_in_Progress
   2013  1323				   .
   2014  1323							; 
   2015  1323
   2016  1323				   .
   2017  1323							; 
   2018  1323
   2019  1323				   .
   2020  1323							; 
   2021  1323
   2022  1323				   .
   2023  1323							; 
   2024  1323
   2025  1323				   .L0104		;  player1color:
   2026  1323
   2027  1323		       a2 c0		      LDX	#<playercolorL0104_1
   2028  1325		       86 87		      STX	player1color
   2029  1327		       a9 f5		      LDA	#>playercolorL0104_1
   2030  1329		       85 88		      STA	player1color+1
   2031  132b				   .
   2032  132b							; 
   2033  132b
   2034  132b				   .L0105		;  player1:
   2035  132b
   2036  132b		       a2 c8		      LDX	#<playerL0105_1
   2037  132d		       86 8c		      STX	player1pointerlo
   2038  132f		       a9 f5		      LDA	#>playerL0105_1
   2039  1331		       85 8d		      STA	player1pointerhi
   2040  1333		       a9 07		      LDA	#7
   2041  1335		       85 8f		      STA	player1height
   2042  1337				   .
   2043  1337							; 
   2044  1337
   2045  1337				   .
   2046  1337							; 
   2047  1337
   2048  1337				   .
   2049  1337							; 
   2050  1337
   2051  1337				   .
   2052  1337							; 
   2053  1337
   2054  1337				   .L0106		;  if !_Bit2_Shot_Moving{2} then goto __Skip_Duck_Shot_Moving
   2055  1337
   2056  1337		       a5 eb		      LDA	_Bit2_Shot_Moving
   2057  1339		       29 04		      AND	#4
   2058  133b		       d0 03		      BNE	.skipL0106
   2059  133d				   .condpart40
   2060  133d		       4c 4c 13 	      jmp	.__Skip_Duck_Shot_Moving
   2061  1340
   2062  1340				   .skipL0106
   2063  1340				   .
   2064  1340							; 
   2065  1340
   2066  1340				   .
   2067  1340							; 
   2068  1340
   2069  1340				   .
   2070  1340							; 
   2071  1340
   2072  1340				   .
   2073  1340							; 
   2074  1340
   2075  1340				   .L0107		;  if _Shot_Stand_Counter  <  13 then goto __Skip_Duck_Fire
   2076  1340
   2077  1340		       a5 e5		      LDA	_Shot_Stand_Counter
   2078  1342		       c9 0d		      CMP	#13
   2079  1344		       b0 03		      BCS	.skipL0107
   2080  1346				   .condpart41
   2081  1346		       4c 92 13 	      jmp	.__Skip_Duck_Fire
   2082  1349
   2083  1349				   .skipL0107
   2084  1349				   .
   2085  1349							; 
   2086  1349
   2087  1349				   .L0108		;  goto __Skip_Duck
   2088  1349
   2089  1349		       4c fe 13 	      jmp	.__Skip_Duck
   2090  134c
   2091  134c				   .
   2092  134c							; 
   2093  134c
   2094  134c				   .__Skip_Duck_Shot_Moving
   2095  134c							; __Skip_Duck_Shot_Moving
   2096  134c
   2097  134c				   .
   2098  134c							; 
   2099  134c
   2100  134c				   .
   2101  134c							; 
   2102  134c
   2103  134c				   .
   2104  134c							; 
   2105  134c
   2106  134c				   .
   2107  134c							; 
   2108  134c
   2109  134c				   .L0109		;  _Bit0_Shoot_Left{0}  =  _Bit3_Mem_Left{3}  :  _Bit1_Shoot_Right{1}	=  _Bit4_Mem_Right{4}
   2110  134c
   2111  134c		       a5 eb		      LDA	_Bit3_Mem_Left
   2112  134e		       29 08		      AND	#8
   2113  1350		       08		      PHP
   2114  1351		       a5 eb		      LDA	_Bit0_Shoot_Left
   2115  1353		       29 fe		      AND	#254
   2116  1355		       28		      PLP
   2117  1356		       f0 02		      .byte.b	$F0, $02
   2118  1358		       09 01		      ORA	#1
   2119  135a		       85 eb		      STA	_Bit0_Shoot_Left
   2120  135c		       a5 eb		      LDA	_Bit4_Mem_Right
   2121  135e		       29 10		      AND	#16
   2122  1360		       08		      PHP
   2123  1361		       a5 eb		      LDA	_Bit1_Shoot_Right
   2124  1363		       29 fd		      AND	#253
   2125  1365		       28		      PLP
   2126  1366		       f0 02		      .byte.b	$F0, $02
   2127  1368		       09 02		      ORA	#2
   2128  136a		       85 eb		      STA	_Bit1_Shoot_Right
   2129  136c				   .
   2130  136c							; 
   2131  136c
   2132  136c				   .
   2133  136c							; 
   2134  136c
   2135  136c				   .
   2136  136c							; 
   2137  136c
   2138  136c				   .
   2139  136c							; 
   2140  136c
   2141  136c				   .L0110		;  if !joy0fire then _Bit5_Slide_Fire_Restrainer{5}  =  0  :  goto __Skip_Duck
   2142  136c
   2143  136c		       24 0c		      bit	INPT4
   2144  136e		       10 09		      BPL	.skipL0110
   2145  1370				   .condpart42
   2146  1370		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   2147  1372		       29 df		      AND	#223
   2148  1374		       85 eb		      STA	_Bit5_Slide_Fire_Restrainer
   2149  1376		       4c fe 13 	      jmp	.__Skip_Duck
   2150  1379
   2151  1379				   .skipL0110
   2152  1379				   .
   2153  1379							; 
   2154  1379
   2155  1379				   .
   2156  1379							; 
   2157  1379
   2158  1379				   .
   2159  1379							; 
   2160  1379
   2161  1379				   .
   2162  1379							; 
   2163  1379
   2164  1379				   .L0111		;  if _Bit5_Slide_Fire_Restrainer{5} then goto __Skip_Duck
   2165  1379
   2166  1379		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   2167  137b		       29 20		      AND	#32
   2168  137d		       f0 03		      BEQ	.skipL0111
   2169  137f				   .condpart43
   2170  137f		       4c fe 13 	      jmp	.__Skip_Duck
   2171  1382
   2172  1382				   .skipL0111
   2173  1382				   .
   2174  1382							; 
   2175  1382
   2176  1382				   .
   2177  1382							; 
   2178  1382
   2179  1382				   .
   2180  1382							; 
   2181  1382
   2182  1382				   .
   2183  1382							; 
   2184  1382
   2185  1382				   .L0112		;  _Bit2_Shot_Moving{2}  =  1	:  _Shot_Stand_Counter	=  0  :  _Bit5_Slide_Fire_Restrainer{5}  =  1
   2186  1382
   2187  1382		       a5 eb		      LDA	_Bit2_Shot_Moving
   2188  1384		       09 04		      ORA	#4
   2189  1386		       85 eb		      STA	_Bit2_Shot_Moving
   2190  1388		       a9 00		      LDA	#0
   2191  138a		       85 e5		      STA	_Shot_Stand_Counter
   2192  138c		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   2193  138e		       09 20		      ORA	#32
   2194  1390		       85 eb		      STA	_Bit5_Slide_Fire_Restrainer
   2195  1392				   .
   2196  1392							; 
   2197  1392
   2198  1392				   .__Skip_Duck_Fire
   2199  1392							; __Skip_Duck_Fire
   2200  1392
   2201  1392				   .
   2202  1392							; 
   2203  1392
   2204  1392				   .
   2205  1392							; 
   2206  1392
   2207  1392				   .
   2208  1392							; 
   2209  1392
   2210  1392				   .
   2211  1392							; 
   2212  1392
   2213  1392				   .L0113		;  if joy0left  ||  joy0right then goto __Skip_Duck
   2214  1392
   2215  1392		       2c 80 02 	      bit	SWCHA
   2216  1395		       70 03		      BVS	.skipL0113
   2217  1397				   .condpart44
   2218  1397		       4c 9f 13 	      jmp	.condpart45
   2219  139a				   .skipL0113
   2220  139a		       2c 80 02 	      bit	SWCHA
   2221  139d		       30 03		      BMI	.skip14OR
   2222  139f				   .condpart45
   2223  139f		       4c fe 13 	      jmp	.__Skip_Duck
   2224  13a2
   2225  13a2				   .skip14OR
   2226  13a2				   .
   2227  13a2							; 
   2228  13a2
   2229  13a2				   .
   2230  13a2							; 
   2231  13a2
   2232  13a2				   .
   2233  13a2							; 
   2234  13a2
   2235  13a2				   .
   2236  13a2							; 
   2237  13a2
   2238  13a2				   .L0114		;  player1color:
   2239  13a2
   2240  13a2		       a2 d0		      LDX	#<playercolorL0114_1
   2241  13a4		       86 87		      STX	player1color
   2242  13a6		       a9 f5		      LDA	#>playercolorL0114_1
   2243  13a8		       85 88		      STA	player1color+1
   2244  13aa				   .
   2245  13aa							; 
   2246  13aa
   2247  13aa				   .L0115		;  player1:
   2248  13aa
   2249  13aa		       a2 da		      LDX	#<playerL0115_1
   2250  13ac		       86 8c		      STX	player1pointerlo
   2251  13ae		       a9 f5		      LDA	#>playerL0115_1
   2252  13b0		       85 8d		      STA	player1pointerhi
   2253  13b2		       a9 09		      LDA	#9
   2254  13b4		       85 8f		      STA	player1height
   2255  13b6				   .
   2256  13b6							; 
   2257  13b6
   2258  13b6				   .
   2259  13b6							; 
   2260  13b6
   2261  13b6				   .
   2262  13b6							; 
   2263  13b6
   2264  13b6				   .
   2265  13b6							; 
   2266  13b6
   2267  13b6				   .L0116		;  if _Shot_Stand_Counter  >  0 then goto __Skip_Duck
   2268  13b6
   2269  13b6		       a9 00		      LDA	#0
   2270  13b8		       c5 e5		      CMP	_Shot_Stand_Counter
   2271  13ba		       b0 03		      BCS	.skipL0116
   2272  13bc				   .condpart46
   2273  13bc		       4c fe 13 	      jmp	.__Skip_Duck
   2274  13bf
   2275  13bf				   .skipL0116
   2276  13bf				   .
   2277  13bf							; 
   2278  13bf
   2279  13bf				   .
   2280  13bf							; 
   2281  13bf
   2282  13bf				   .
   2283  13bf							; 
   2284  13bf
   2285  13bf				   .
   2286  13bf							; 
   2287  13bf
   2288  13bf				   .L0117		;  _Ch0_Sound	=  _c_Shot_Sound  :  _Ch0_Duration  =  1  :  _Ch0_Counter  =  0
   2289  13bf
   2290  13bf		       a9 04		      LDA	#_c_Shot_Sound
   2291  13c1		       85 de		      STA	_Ch0_Sound
   2292  13c3		       a9 01		      LDA	#1
   2293  13c5		       85 df		      STA	_Ch0_Duration
   2294  13c7		       a9 00		      LDA	#0
   2295  13c9		       85 e0		      STA	_Ch0_Counter
   2296  13cb				   .
   2297  13cb							; 
   2298  13cb
   2299  13cb				   .
   2300  13cb							; 
   2301  13cb
   2302  13cb				   .
   2303  13cb							; 
   2304  13cb
   2305  13cb				   .
   2306  13cb							; 
   2307  13cb
   2308  13cb				   .L0118		;  if _Bit0_Shoot_Left{0} then ballx  =  player1x  +  3  :  bally  =  player1y - 8  :	_Bit4_Flip_P1{4}  =  0
   2309  13cb
   2310  13cb		       a5 eb		      LDA	_Bit0_Shoot_Left
   2311  13cd		       4a		      LSR
   2312  13ce		       90 14		      BCC	.skipL0118
   2313  13d0				   .condpart47
   2314  13d0		       a5 81		      LDA	player1x
   2315  13d2		       18		      CLC
   2316  13d3		       69 03		      ADC	#3
   2317  13d5		       85 84		      STA	ballx
   2318  13d7		       a5 86		      LDA	player1y
   2319  13d9		       38		      SEC
   2320  13da		       e9 08		      SBC	#8
   2321  13dc		       85 89		      STA	bally
   2322  13de		       a5 ec		      LDA	_Bit4_Flip_P1
   2323  13e0		       29 ef		      AND	#239
   2324  13e2		       85 ec		      STA	_Bit4_Flip_P1
   2325  13e4				   .skipL0118
   2326  13e4				   .
   2327  13e4							; 
   2328  13e4
   2329  13e4				   .
   2330  13e4							; 
   2331  13e4
   2332  13e4				   .
   2333  13e4							; 
   2334  13e4
   2335  13e4				   .
   2336  13e4							; 
   2337  13e4
   2338  13e4				   .L0119		;  if _Bit1_Shoot_Right{1} then ballx	=  player1x  +	6  :  bally  =	player1y - 8  :  _Bit4_Flip_P1{4}  =  1
   2339  13e4
   2340  13e4		       a5 eb		      LDA	_Bit1_Shoot_Right
   2341  13e6		       29 02		      AND	#2
   2342  13e8		       f0 14		      BEQ	.skipL0119
   2343  13ea				   .condpart48
   2344  13ea		       a5 81		      LDA	player1x
   2345  13ec		       18		      CLC
   2346  13ed		       69 06		      ADC	#6
   2347  13ef		       85 84		      STA	ballx
   2348  13f1		       a5 86		      LDA	player1y
   2349  13f3		       38		      SEC
   2350  13f4		       e9 08		      SBC	#8
   2351  13f6		       85 89		      STA	bally
   2352  13f8		       a5 ec		      LDA	_Bit4_Flip_P1
   2353  13fa		       09 10		      ORA	#16
   2354  13fc		       85 ec		      STA	_Bit4_Flip_P1
   2355  13fe				   .skipL0119
   2356  13fe				   .
   2357  13fe							; 
   2358  13fe
   2359  13fe				   .__Skip_Duck
   2360  13fe							; __Skip_Duck
   2361  13fe
   2362  13fe				   .
   2363  13fe							; 
   2364  13fe
   2365  13fe				   .
   2366  13fe							; 
   2367  13fe
   2368  13fe				   .
   2369  13fe							; 
   2370  13fe
   2371  13fe				   .
   2372  13fe							; 
   2373  13fe
   2374  13fe				   .
   2375  13fe							; 
   2376  13fe
   2377  13fe				   .
   2378  13fe							; 
   2379  13fe
   2380  13fe				   .
   2381  13fe							; 
   2382  13fe
   2383  13fe				   .
   2384  13fe							; 
   2385  13fe
   2386  13fe				   .
   2387  13fe							; 
   2388  13fe
   2389  13fe				   .
   2390  13fe							; 
   2391  13fe
   2392  13fe				   .L0120		;  if !_Bit2_Shot_Moving{2} then goto __Shot_Not_Moving
   2393  13fe
   2394  13fe		       a5 eb		      LDA	_Bit2_Shot_Moving
   2395  1400		       29 04		      AND	#4
   2396  1402		       d0 03		      BNE	.skipL0120
   2397  1404				   .condpart49
   2398  1404		       4c 41 14 	      jmp	.__Shot_Not_Moving
   2399  1407
   2400  1407				   .skipL0120
   2401  1407				   .
   2402  1407							; 
   2403  1407
   2404  1407				   .
   2405  1407							; 
   2406  1407
   2407  1407				   .
   2408  1407							; 
   2409  1407
   2410  1407				   .
   2411  1407							; 
   2412  1407
   2413  1407				   .L0121		;  if _Shot_Stand_Counter  <  14 then _Shot_Stand_Counter  =  _Shot_Stand_Counter  +  1
   2414  1407
   2415  1407		       a5 e5		      LDA	_Shot_Stand_Counter
   2416  1409		       c9 0e		      CMP	#14
   2417  140b		       b0 02		      BCS	.skipL0121
   2418  140d				   .condpart50
   2419  140d		       e6 e5		      INC	_Shot_Stand_Counter
   2420  140f				   .skipL0121
   2421  140f				   .
   2422  140f							; 
   2423  140f
   2424  140f				   .
   2425  140f							; 
   2426  140f
   2427  140f				   .
   2428  140f							; 
   2429  140f
   2430  140f				   .
   2431  140f							; 
   2432  140f
   2433  140f				   .L0122		;  if _Bit0_Shoot_Left{0} then ballx  =  ballx  -  2
   2434  140f
   2435  140f		       a5 eb		      LDA	_Bit0_Shoot_Left
   2436  1411		       4a		      LSR
   2437  1412		       90 07		      BCC	.skipL0122
   2438  1414				   .condpart51
   2439  1414		       a5 84		      LDA	ballx
   2440  1416		       38		      SEC
   2441  1417		       e9 02		      SBC	#2
   2442  1419		       85 84		      STA	ballx
   2443  141b				   .skipL0122
   2444  141b				   .
   2445  141b							; 
   2446  141b
   2447  141b				   .
   2448  141b							; 
   2449  141b
   2450  141b				   .
   2451  141b							; 
   2452  141b
   2453  141b				   .
   2454  141b							; 
   2455  141b
   2456  141b				   .L0123		;  if _Bit1_Shoot_Right{1} then ballx	=  ballx  +  2
   2457  141b
   2458  141b		       a5 eb		      LDA	_Bit1_Shoot_Right
   2459  141d		       29 02		      AND	#2
   2460  141f		       f0 07		      BEQ	.skipL0123
   2461  1421				   .condpart52
   2462  1421		       a5 84		      LDA	ballx
   2463  1423		       18		      CLC
   2464  1424		       69 02		      ADC	#2
   2465  1426		       85 84		      STA	ballx
   2466  1428				   .skipL0123
   2467  1428				   .
   2468  1428							; 
   2469  1428
   2470  1428				   .
   2471  1428							; 
   2472  1428
   2473  1428				   .
   2474  1428							; 
   2475  1428
   2476  1428				   .
   2477  1428							; 
   2478  1428
   2479  1428				   .L0124		;  if ballx  <  3  ||	ballx  >  159 then bally  =  250  :  _Bit2_Shot_Moving{2}  =  0
   2480  1428
   2481  1428		       a5 84		      LDA	ballx
   2482  142a		       c9 03		      CMP	#3
   2483  142c		       b0 03		      BCS	.skipL0124
   2484  142e				   .condpart53
   2485  142e		       4c 37 14 	      jmp	.condpart54
   2486  1431				   .skipL0124
   2487  1431		       a9 9f		      LDA	#159
   2488  1433		       c5 84		      CMP	ballx
   2489  1435		       b0 0a		      BCS	.skip15OR
   2490  1437				   .condpart54
   2491  1437		       a9 fa		      LDA	#250
   2492  1439		       85 89		      STA	bally
   2493  143b		       a5 eb		      LDA	_Bit2_Shot_Moving
   2494  143d		       29 fb		      AND	#251
   2495  143f		       85 eb		      STA	_Bit2_Shot_Moving
   2496  1441				   .skip15OR
   2497  1441				   .
   2498  1441							; 
   2499  1441
   2500  1441				   .__Shot_Not_Moving
   2501  1441							; __Shot_Not_Moving
   2502  1441
   2503  1441				   .
   2504  1441							; 
   2505  1441
   2506  1441				   .
   2507  1441							; 
   2508  1441
   2509  1441				   .
   2510  1441							; 
   2511  1441
   2512  1441				   .
   2513  1441							; 
   2514  1441
   2515  1441				   .
   2516  1441							; 
   2517  1441
   2518  1441				   .
   2519  1441							; 
   2520  1441
   2521  1441				   .
   2522  1441							; 
   2523  1441
   2524  1441				   .L0125		;  _Bit6_LR_Joy_Movement{6}  =  0
   2525  1441
   2526  1441		       a5 eb		      LDA	_Bit6_LR_Joy_Movement
   2527  1443		       29 bf		      AND	#191
   2528  1445		       85 eb		      STA	_Bit6_LR_Joy_Movement
   2529  1447				   .
   2530  1447							; 
   2531  1447
   2532  1447				   .
   2533  1447							; 
   2534  1447
   2535  1447				   .
   2536  1447							; 
   2537  1447
   2538  1447				   .
   2539  1447							; 
   2540  1447
   2541  1447				   .
   2542  1447							; 
   2543  1447
   2544  1447				   .
   2545  1447							; 
   2546  1447
   2547  1447				   .
   2548  1447							; 
   2549  1447
   2550  1447				   .
   2551  1447							; 
   2552  1447
   2553  1447				   .
   2554  1447							; 
   2555  1447
   2556  1447				   .
   2557  1447							; 
   2558  1447
   2559  1447				   .L0126		;  if !joy0left then goto __Skip_Joy0Left
   2560  1447
   2561  1447		       2c 80 02 	      bit	SWCHA
   2562  144a		       50 03		      BVC	.skipL0126
   2563  144c				   .condpart55
   2564  144c		       4c 1e 15 	      jmp	.__Skip_Joy0Left
   2565  144f
   2566  144f				   .skipL0126
   2567  144f				   .L0127		;  if joy0left then gosub __Slow_Scroll_right bank2
   2568  144f
   2569  144f		       2c 80 02 	      bit	SWCHA
   2570  1452		       70 18		      BVS	.skipL0127
   2571  1454				   .condpart56
   2572  1454		       85 ee		      sta	temp7
   2573  1456		       a9 14		      lda	#>(ret_point4-1)
   2574  1458		       48		      pha
   2575  1459		       a9 6b		      lda	#<(ret_point4-1)
   2576  145b		       48		      pha
   2577  145c		       a9 30		      lda	#>(.__Slow_Scroll_right-1)
   2578  145e		       48		      pha
   2579  145f		       a9 2a		      lda	#<(.__Slow_Scroll_right-1)
   2580  1461		       48		      pha
   2581  1462		       a5 ee		      lda	temp7
   2582  1464		       48		      pha
   2583  1465		       8a		      txa
   2584  1466		       48		      pha
   2585  1467		       a2 02		      ldx	#2
   2586  1469		       4c eb ff 	      jmp	BS_jsr
   2587  146c				   ret_point4
   2588  146c				   .skipL0127
   2589  146c				   .
   2590  146c							; 
   2591  146c
   2592  146c				   .
   2593  146c							; 
   2594  146c
   2595  146c				   .
   2596  146c							; 
   2597  146c
   2598  146c				   .
   2599  146c							; 
   2600  146c
   2601  146c				   .
   2602  146c							; 
   2603  146c
   2604  146c				   .
   2605  146c							; 
   2606  146c
   2607  146c				   .
   2608  146c							; 
   2609  146c
   2610  146c				   .L0128		;  if _Bit0_Fall_in_Progress{0}  ||  _Jump_Gravity_Counter then _Bit5_Ground_Slide_in_Progress{5}  =  0  :  _Bit1_Slide_Left_in_Progress{1}  =  1  :  _Bit2_Slide_Right_in_Progress{2}  =  0  :  goto __Skip_Slide_Check_Left
   2611  146c
   2612  146c		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   2613  146e		       4a		      LSR
   2614  146f		       90 03		      BCC	.skipL0128
   2615  1471				   .condpart57
   2616  1471		       4c 78 14 	      jmp	.condpart58
   2617  1474				   .skipL0128
   2618  1474		       a5 d7		      LDA	_Jump_Gravity_Counter
   2619  1476		       f0 15		      BEQ	.skip16OR
   2620  1478				   .condpart58
   2621  1478		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2622  147a		       29 df		      AND	#223
   2623  147c		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   2624  147e		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   2625  1480		       09 02		      ORA	#2
   2626  1482		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   2627  1484		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   2628  1486		       29 fb		      AND	#251
   2629  1488		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   2630  148a		       4c bd 14 	      jmp	.__Skip_Slide_Check_Left
   2631  148d
   2632  148d				   .skip16OR
   2633  148d				   .
   2634  148d							; 
   2635  148d
   2636  148d				   .
   2637  148d							; 
   2638  148d
   2639  148d				   .
   2640  148d							; 
   2641  148d
   2642  148d				   .
   2643  148d							; 
   2644  148d
   2645  148d				   .
   2646  148d							; 
   2647  148d
   2648  148d				   .L0129		;  if _Bit5_Ground_Slide_in_Progress{5} then _Bit5_Ground_Slide_in_Progress{5}  =  1  :  _Bit1_Slide_Left_in_Progress{1}  =  0  :  _Bit2_Slide_Right_in_Progress{2}  =  1  :  goto __Skip_Joy0Left
   2649  148d
   2650  148d		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2651  148f		       29 20		      AND	#32
   2652  1491		       f0 15		      BEQ	.skipL0129
   2653  1493				   .condpart59
   2654  1493		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2655  1495		       09 20		      ORA	#32
   2656  1497		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   2657  1499		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   2658  149b		       29 fd		      AND	#253
   2659  149d		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   2660  149f		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   2661  14a1		       09 04		      ORA	#4
   2662  14a3		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   2663  14a5		       4c 1e 15 	      jmp	.__Skip_Joy0Left
   2664  14a8
   2665  14a8				   .skipL0129
   2666  14a8				   .
   2667  14a8							; 
   2668  14a8
   2669  14a8				   .
   2670  14a8							; 
   2671  14a8
   2672  14a8				   .
   2673  14a8							; 
   2674  14a8
   2675  14a8				   .
   2676  14a8							; 
   2677  14a8
   2678  14a8				   .
   2679  14a8							; 
   2680  14a8
   2681  14a8				   .
   2682  14a8							; 
   2683  14a8
   2684  14a8				   .L0130		;  if _Bit2_Slide_Right_in_Progress{2} then _Bit5_Ground_Slide_in_Progress{5}	=  1  :  _Bit1_Slide_Left_in_Progress{1}  =  0	:  goto __Skip_Joy0Left
   2685  14a8
   2686  14a8		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   2687  14aa		       29 04		      AND	#4
   2688  14ac		       f0 0f		      BEQ	.skipL0130
   2689  14ae				   .condpart60
   2690  14ae		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2691  14b0		       09 20		      ORA	#32
   2692  14b2		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   2693  14b4		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   2694  14b6		       29 fd		      AND	#253
   2695  14b8		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   2696  14ba		       4c 1e 15 	      jmp	.__Skip_Joy0Left
   2697  14bd
   2698  14bd				   .skipL0130
   2699  14bd				   .
   2700  14bd							; 
   2701  14bd
   2702  14bd				   .__Skip_Slide_Check_Left
   2703  14bd							; __Skip_Slide_Check_Left
   2704  14bd
   2705  14bd				   .
   2706  14bd							; 
   2707  14bd
   2708  14bd				   .
   2709  14bd							; 
   2710  14bd
   2711  14bd				   .
   2712  14bd							; 
   2713  14bd
   2714  14bd				   .
   2715  14bd							; 
   2716  14bd
   2717  14bd				   .L0131		;  temp5  =   ( player1x - 18 )  / 4
   2718  14bd
   2719  14bd							; complex statement detected
   2720  14bd		       a5 81		      LDA	player1x
   2721  14bf		       38		      SEC
   2722  14c0		       e9 12		      SBC	#18
   2723  14c2		       4a		      lsr
   2724  14c3		       4a		      lsr
   2725  14c4		       85 a0		      STA	temp5
   2726  14c6				   .
   2727  14c6							; 
   2728  14c6
   2729  14c6				   .
   2730  14c6							; 
   2731  14c6
   2732  14c6				   .
   2733  14c6							; 
   2734  14c6
   2735  14c6				   .
   2736  14c6							; 
   2737  14c6
   2738  14c6				   .L0132		;  if pfread ( temp5 , _Convert_Y )  then goto __Skip_Joy0Left
   2739  14c6
   2740  14c6		       a5 a0		      LDA	temp5
   2741  14c8		       a4 d6		      LDY	_Convert_Y
   2742  14ca		       85 ee		      sta	temp7
   2743  14cc		       a9 14		      lda	#>(ret_point5-1)
   2744  14ce		       48		      pha
   2745  14cf		       a9 e1		      lda	#<(ret_point5-1)
   2746  14d1		       48		      pha
   2747  14d2		       a9 f2		      lda	#>(pfread-1)
   2748  14d4		       48		      pha
   2749  14d5		       a9 a9		      lda	#<(pfread-1)
   2750  14d7		       48		      pha
   2751  14d8		       a5 ee		      lda	temp7
   2752  14da		       48		      pha
   2753  14db		       8a		      txa
   2754  14dc		       48		      pha
   2755  14dd		       a2 08		      ldx	#8
   2756  14df		       4c eb ff 	      jmp	BS_jsr
   2757  14e2				   ret_point5
   2758  14e2		       d0 03		      BNE	.skipL0132
   2759  14e4				   .condpart61
   2760  14e4		       4c 1e 15 	      jmp	.__Skip_Joy0Left
   2761  14e7
   2762  14e7				   .skipL0132
   2763  14e7				   .
   2764  14e7							; 
   2765  14e7
   2766  14e7				   .
   2767  14e7							; 
   2768  14e7
   2769  14e7				   .
   2770  14e7							; 
   2771  14e7
   2772  14e7				   .
   2773  14e7							; 
   2774  14e7
   2775  14e7				   .L0133		;  _Bit1_Slide_Left_in_Progress{1}  =	1  :  _Bit6_LR_Joy_Movement{6}	=  1
   2776  14e7
   2777  14e7		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   2778  14e9		       09 02		      ORA	#2
   2779  14eb		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   2780  14ed		       a5 eb		      LDA	_Bit6_LR_Joy_Movement
   2781  14ef		       09 40		      ORA	#64
   2782  14f1		       85 eb		      STA	_Bit6_LR_Joy_Movement
   2783  14f3				   .
   2784  14f3							; 
   2785  14f3
   2786  14f3				   .
   2787  14f3							; 
   2788  14f3
   2789  14f3				   .
   2790  14f3							; 
   2791  14f3
   2792  14f3				   .
   2793  14f3							; 
   2794  14f3
   2795  14f3				   .L0134		;  if player1x  >  17 then _P1_Left_Right  =  _P1_Left_Right  -  1.38
   2796  14f3
   2797  14f3		       a9 11		      LDA	#17
   2798  14f5		       c5 81		      CMP	player1x
   2799  14f7		       b0 0d		      BCS	.skipL0134
   2800  14f9				   .condpart62
   2801  14f9		       a5 d4		      LDA	a
   2802  14fb		       38		      SEC
   2803  14fc		       e9 61		      SBC	#97
   2804  14fe		       85 d4		      STA	a
   2805  1500		       a5 81		      LDA	_P1_Left_Right
   2806  1502		       e9 01		      SBC	#1
   2807  1504		       85 81		      STA	_P1_Left_Right
   2808  1506				   .skipL0134
   2809  1506				   .
   2810  1506							; 
   2811  1506
   2812  1506				   .
   2813  1506							; 
   2814  1506
   2815  1506				   .
   2816  1506							; 
   2817  1506
   2818  1506				   .
   2819  1506							; 
   2820  1506
   2821  1506				   .L0135		;  _Bit5_Slide_Fire_Restrainer{5}  =  1
   2822  1506
   2823  1506		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   2824  1508		       09 20		      ORA	#32
   2825  150a		       85 eb		      STA	_Bit5_Slide_Fire_Restrainer
   2826  150c				   .
   2827  150c							; 
   2828  150c
   2829  150c				   .
   2830  150c							; 
   2831  150c
   2832  150c				   .
   2833  150c							; 
   2834  150c
   2835  150c				   .
   2836  150c							; 
   2837  150c
   2838  150c				   .L0136		;  _Bit3_Mem_Left{3}  =  1  :	_Bit4_Mem_Right{4}  =  0
   2839  150c
   2840  150c		       a5 eb		      LDA	_Bit3_Mem_Left
   2841  150e		       09 08		      ORA	#8
   2842  1510		       85 eb		      STA	_Bit3_Mem_Left
   2843  1512		       a5 eb		      LDA	_Bit4_Mem_Right
   2844  1514		       29 ef		      AND	#239
   2845  1516		       85 eb		      STA	_Bit4_Mem_Right
   2846  1518				   .
   2847  1518							; 
   2848  1518
   2849  1518				   .
   2850  1518							; 
   2851  1518
   2852  1518				   .
   2853  1518							; 
   2854  1518
   2855  1518				   .
   2856  1518							; 
   2857  1518
   2858  1518				   .L0137		;  _Bit4_Flip_P1{4}  =  0
   2859  1518
   2860  1518		       a5 ec		      LDA	_Bit4_Flip_P1
   2861  151a		       29 ef		      AND	#239
   2862  151c		       85 ec		      STA	_Bit4_Flip_P1
   2863  151e				   .
   2864  151e							; 
   2865  151e
   2866  151e				   .__Skip_Joy0Left
   2867  151e							; __Skip_Joy0Left
   2868  151e
   2869  151e				   .
   2870  151e							; 
   2871  151e
   2872  151e				   .
   2873  151e							; 
   2874  151e
   2875  151e				   .
   2876  151e							; 
   2877  151e
   2878  151e				   .
   2879  151e							; 
   2880  151e
   2881  151e				   .
   2882  151e							; 
   2883  151e
   2884  151e				   .
   2885  151e							; 
   2886  151e
   2887  151e				   .
   2888  151e							; 
   2889  151e
   2890  151e				   .
   2891  151e							; 
   2892  151e
   2893  151e				   .
   2894  151e							; 
   2895  151e
   2896  151e				   .
   2897  151e							; 
   2898  151e
   2899  151e				   .L0138		;  if !joy0right then goto __Skip_Joy0Right
   2900  151e
   2901  151e		       2c 80 02 	      bit	SWCHA
   2902  1521		       10 03		      BPL	.skipL0138
   2903  1523				   .condpart63
   2904  1523		       4c f5 15 	      jmp	.__Skip_Joy0Right
   2905  1526
   2906  1526				   .skipL0138
   2907  1526				   .
   2908  1526							; 
   2909  1526
   2910  1526				   .L0139		;  if joy0right then gosub __Slow_Scroll_left bank2
   2911  1526
   2912  1526		       2c 80 02 	      bit	SWCHA
   2913  1529		       30 18		      BMI	.skipL0139
   2914  152b				   .condpart64
   2915  152b		       85 ee		      sta	temp7
   2916  152d		       a9 15		      lda	#>(ret_point6-1)
   2917  152f		       48		      pha
   2918  1530		       a9 42		      lda	#<(ret_point6-1)
   2919  1532		       48		      pha
   2920  1533		       a9 2f		      lda	#>(.__Slow_Scroll_left-1)
   2921  1535		       48		      pha
   2922  1536		       a9 ff		      lda	#<(.__Slow_Scroll_left-1)
   2923  1538		       48		      pha
   2924  1539		       a5 ee		      lda	temp7
   2925  153b		       48		      pha
   2926  153c		       8a		      txa
   2927  153d		       48		      pha
   2928  153e		       a2 02		      ldx	#2
   2929  1540		       4c eb ff 	      jmp	BS_jsr
   2930  1543				   ret_point6
   2931  1543				   .skipL0139
   2932  1543				   .
   2933  1543							; 
   2934  1543
   2935  1543				   .
   2936  1543							; 
   2937  1543
   2938  1543				   .
   2939  1543							; 
   2940  1543
   2941  1543				   .
   2942  1543							; 
   2943  1543
   2944  1543				   .
   2945  1543							; 
   2946  1543
   2947  1543				   .
   2948  1543							; 
   2949  1543
   2950  1543				   .L0140		;  if _Bit0_Fall_in_Progress{0}  ||  _Jump_Gravity_Counter then _Bit5_Ground_Slide_in_Progress{5}  =  0  :  _Bit2_Slide_Right_in_Progress{2}  =  1  :	_Bit1_Slide_Left_in_Progress{1}  =  0  :  goto __Skip_Slide_Check_Right
   2951  1543
   2952  1543		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   2953  1545		       4a		      LSR
   2954  1546		       90 03		      BCC	.skipL0140
   2955  1548				   .condpart65
   2956  1548		       4c 4f 15 	      jmp	.condpart66
   2957  154b				   .skipL0140
   2958  154b		       a5 d7		      LDA	_Jump_Gravity_Counter
   2959  154d		       f0 15		      BEQ	.skip17OR
   2960  154f				   .condpart66
   2961  154f		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2962  1551		       29 df		      AND	#223
   2963  1553		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   2964  1555		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   2965  1557		       09 04		      ORA	#4
   2966  1559		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   2967  155b		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   2968  155d		       29 fd		      AND	#253
   2969  155f		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   2970  1561		       4c 94 15 	      jmp	.__Skip_Slide_Check_Right
   2971  1564
   2972  1564				   .skip17OR
   2973  1564				   .
   2974  1564							; 
   2975  1564
   2976  1564				   .
   2977  1564							; 
   2978  1564
   2979  1564				   .
   2980  1564							; 
   2981  1564
   2982  1564				   .
   2983  1564							; 
   2984  1564
   2985  1564				   .
   2986  1564							; 
   2987  1564
   2988  1564				   .L0141		;  if _Bit5_Ground_Slide_in_Progress{5} then _Bit5_Ground_Slide_in_Progress{5}  =  1  :  _Bit2_Slide_Right_in_Progress{2}  =  0  :  _Bit1_Slide_Left_in_Progress{1}  =  1  :  goto __Skip_Joy0Right
   2989  1564
   2990  1564		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2991  1566		       29 20		      AND	#32
   2992  1568		       f0 15		      BEQ	.skipL0141
   2993  156a				   .condpart67
   2994  156a		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   2995  156c		       09 20		      ORA	#32
   2996  156e		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   2997  1570		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   2998  1572		       29 fb		      AND	#251
   2999  1574		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3000  1576		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3001  1578		       09 02		      ORA	#2
   3002  157a		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   3003  157c		       4c f5 15 	      jmp	.__Skip_Joy0Right
   3004  157f
   3005  157f				   .skipL0141
   3006  157f				   .
   3007  157f							; 
   3008  157f
   3009  157f				   .
   3010  157f							; 
   3011  157f
   3012  157f				   .
   3013  157f							; 
   3014  157f
   3015  157f				   .
   3016  157f							; 
   3017  157f
   3018  157f				   .
   3019  157f							; 
   3020  157f
   3021  157f				   .
   3022  157f							; 
   3023  157f
   3024  157f				   .L0142		;  if _Bit1_Slide_Left_in_Progress{1} then _Bit5_Ground_Slide_in_Progress{5}  =  1  :	_Bit2_Slide_Right_in_Progress{2}  =  0	:  goto __Skip_Joy0Right
   3025  157f
   3026  157f		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3027  1581		       29 02		      AND	#2
   3028  1583		       f0 0f		      BEQ	.skipL0142
   3029  1585				   .condpart68
   3030  1585		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3031  1587		       09 20		      ORA	#32
   3032  1589		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3033  158b		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3034  158d		       29 fb		      AND	#251
   3035  158f		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3036  1591		       4c f5 15 	      jmp	.__Skip_Joy0Right
   3037  1594
   3038  1594				   .skipL0142
   3039  1594				   .
   3040  1594							; 
   3041  1594
   3042  1594				   .__Skip_Slide_Check_Right
   3043  1594							; __Skip_Slide_Check_Right
   3044  1594
   3045  1594				   .
   3046  1594							; 
   3047  1594
   3048  1594				   .
   3049  1594							; 
   3050  1594
   3051  1594				   .
   3052  1594							; 
   3053  1594
   3054  1594				   .
   3055  1594							; 
   3056  1594
   3057  1594				   .L0143		;  temp5  =   ( player1x - 10 )  / 4
   3058  1594
   3059  1594							; complex statement detected
   3060  1594		       a5 81		      LDA	player1x
   3061  1596		       38		      SEC
   3062  1597		       e9 0a		      SBC	#10
   3063  1599		       4a		      lsr
   3064  159a		       4a		      lsr
   3065  159b		       85 a0		      STA	temp5
   3066  159d				   .
   3067  159d							; 
   3068  159d
   3069  159d				   .
   3070  159d							; 
   3071  159d
   3072  159d				   .
   3073  159d							; 
   3074  159d
   3075  159d				   .
   3076  159d							; 
   3077  159d
   3078  159d				   .L0144		;  if pfread ( temp5 , _Convert_Y )  then goto __Skip_Joy0Right
   3079  159d
   3080  159d		       a5 a0		      LDA	temp5
   3081  159f		       a4 d6		      LDY	_Convert_Y
   3082  15a1		       85 ee		      sta	temp7
   3083  15a3		       a9 15		      lda	#>(ret_point7-1)
   3084  15a5		       48		      pha
   3085  15a6		       a9 b8		      lda	#<(ret_point7-1)
   3086  15a8		       48		      pha
   3087  15a9		       a9 f2		      lda	#>(pfread-1)
   3088  15ab		       48		      pha
   3089  15ac		       a9 a9		      lda	#<(pfread-1)
   3090  15ae		       48		      pha
   3091  15af		       a5 ee		      lda	temp7
   3092  15b1		       48		      pha
   3093  15b2		       8a		      txa
   3094  15b3		       48		      pha
   3095  15b4		       a2 08		      ldx	#8
   3096  15b6		       4c eb ff 	      jmp	BS_jsr
   3097  15b9				   ret_point7
   3098  15b9		       d0 03		      BNE	.skipL0144
   3099  15bb				   .condpart69
   3100  15bb		       4c f5 15 	      jmp	.__Skip_Joy0Right
   3101  15be
   3102  15be				   .skipL0144
   3103  15be				   .
   3104  15be							; 
   3105  15be
   3106  15be				   .
   3107  15be							; 
   3108  15be
   3109  15be				   .
   3110  15be							; 
   3111  15be
   3112  15be				   .
   3113  15be							; 
   3114  15be
   3115  15be				   .L0145		;  _Bit2_Slide_Right_in_Progress{2}  =  1  :  _Bit6_LR_Joy_Movement{6}  =  1
   3116  15be
   3117  15be		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3118  15c0		       09 04		      ORA	#4
   3119  15c2		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3120  15c4		       a5 eb		      LDA	_Bit6_LR_Joy_Movement
   3121  15c6		       09 40		      ORA	#64
   3122  15c8		       85 eb		      STA	_Bit6_LR_Joy_Movement
   3123  15ca				   .
   3124  15ca							; 
   3125  15ca
   3126  15ca				   .
   3127  15ca							; 
   3128  15ca
   3129  15ca				   .
   3130  15ca							; 
   3131  15ca
   3132  15ca				   .
   3133  15ca							; 
   3134  15ca
   3135  15ca				   .L0146		;  if player1x  <  137 then _P1_Left_Right  =	_P1_Left_Right	+  1.38
   3136  15ca
   3137  15ca		       a5 81		      LDA	player1x
   3138  15cc		       c9 89		      CMP	#137
   3139  15ce		       b0 0d		      BCS	.skipL0146
   3140  15d0				   .condpart70
   3141  15d0		       a5 d4		      LDA	a
   3142  15d2		       18		      CLC
   3143  15d3		       69 61		      ADC	#97
   3144  15d5		       85 d4		      STA	a
   3145  15d7		       a5 81		      LDA	_P1_Left_Right
   3146  15d9		       69 01		      ADC	#1
   3147  15db		       85 81		      STA	_P1_Left_Right
   3148  15dd				   .skipL0146
   3149  15dd				   .
   3150  15dd							; 
   3151  15dd
   3152  15dd				   .
   3153  15dd							; 
   3154  15dd
   3155  15dd				   .
   3156  15dd							; 
   3157  15dd
   3158  15dd				   .
   3159  15dd							; 
   3160  15dd
   3161  15dd				   .L0147		;  _Bit5_Slide_Fire_Restrainer{5}  =  1
   3162  15dd
   3163  15dd		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   3164  15df		       09 20		      ORA	#32
   3165  15e1		       85 eb		      STA	_Bit5_Slide_Fire_Restrainer
   3166  15e3				   .
   3167  15e3							; 
   3168  15e3
   3169  15e3				   .
   3170  15e3							; 
   3171  15e3
   3172  15e3				   .
   3173  15e3							; 
   3174  15e3
   3175  15e3				   .
   3176  15e3							; 
   3177  15e3
   3178  15e3				   .L0148		;  _Bit3_Mem_Left{3}  =  0  :	_Bit4_Mem_Right{4}  =  1
   3179  15e3
   3180  15e3		       a5 eb		      LDA	_Bit3_Mem_Left
   3181  15e5		       29 f7		      AND	#247
   3182  15e7		       85 eb		      STA	_Bit3_Mem_Left
   3183  15e9		       a5 eb		      LDA	_Bit4_Mem_Right
   3184  15eb		       09 10		      ORA	#16
   3185  15ed		       85 eb		      STA	_Bit4_Mem_Right
   3186  15ef				   .
   3187  15ef							; 
   3188  15ef
   3189  15ef				   .
   3190  15ef							; 
   3191  15ef
   3192  15ef				   .
   3193  15ef							; 
   3194  15ef
   3195  15ef				   .
   3196  15ef							; 
   3197  15ef
   3198  15ef				   .L0149		;  _Bit4_Flip_P1{4}  =  1
   3199  15ef
   3200  15ef		       a5 ec		      LDA	_Bit4_Flip_P1
   3201  15f1		       09 10		      ORA	#16
   3202  15f3		       85 ec		      STA	_Bit4_Flip_P1
   3203  15f5				   .
   3204  15f5							; 
   3205  15f5
   3206  15f5				   .__Skip_Joy0Right
   3207  15f5							; __Skip_Joy0Right
   3208  15f5
   3209  15f5				   .
   3210  15f5							; 
   3211  15f5
   3212  15f5				   .
   3213  15f5							; 
   3214  15f5
   3215  15f5				   .
   3216  15f5							; 
   3217  15f5
   3218  15f5				   .
   3219  15f5							; 
   3220  15f5
   3221  15f5				   .
   3222  15f5							; 
   3223  15f5
   3224  15f5				   .
   3225  15f5							; 
   3226  15f5
   3227  15f5				   .
   3228  15f5							; 
   3229  15f5
   3230  15f5				   .
   3231  15f5							; 
   3232  15f5
   3233  15f5				   .
   3234  15f5							; 
   3235  15f5
   3236  15f5				   .
   3237  15f5							; 
   3238  15f5
   3239  15f5				   .L0150		;  if !_Bit6_LR_Joy_Movement{6} then goto __Done_Anim_jump
   3240  15f5
   3241  15f5		       24 eb		      BIT	_Bit6_LR_Joy_Movement
   3242  15f7		       70 03		      BVS	.skipL0150
   3243  15f9				   .condpart71
   3244  15f9		       4c 38 16 	      jmp	.__Done_Anim_jump
   3245  15fc
   3246  15fc				   .skipL0150
   3247  15fc				   .
   3248  15fc							; 
   3249  15fc
   3250  15fc				   .
   3251  15fc							; 
   3252  15fc
   3253  15fc				   .
   3254  15fc							; 
   3255  15fc
   3256  15fc				   .
   3257  15fc							; 
   3258  15fc
   3259  15fc				   .L0151		;  if _Jump_Gravity_Counter  ||  _Bit0_Fall_in_Progress{0} then goto __Done_Anim_jump
   3260  15fc
   3261  15fc		       a5 d7		      LDA	_Jump_Gravity_Counter
   3262  15fe		       f0 03		      BEQ	.skipL0151
   3263  1600				   .condpart72
   3264  1600		       4c 08 16 	      jmp	.condpart73
   3265  1603				   .skipL0151
   3266  1603		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   3267  1605		       4a		      LSR
   3268  1606		       90 03		      BCC	.skip18OR
   3269  1608				   .condpart73
   3270  1608		       4c 38 16 	      jmp	.__Done_Anim_jump
   3271  160b
   3272  160b				   .skip18OR
   3273  160b				   .
   3274  160b							; 
   3275  160b
   3276  160b				   .
   3277  160b							; 
   3278  160b
   3279  160b				   .
   3280  160b							; 
   3281  160b
   3282  160b				   .
   3283  160b							; 
   3284  160b
   3285  160b				   .L0152		;  if player1x  <  18	||  player1x  >  136 then goto __Done_Anim_jump
   3286  160b
   3287  160b		       a5 81		      LDA	player1x
   3288  160d		       c9 12		      CMP	#18
   3289  160f		       b0 03		      BCS	.skipL0152
   3290  1611				   .condpart74
   3291  1611		       4c 1a 16 	      jmp	.condpart75
   3292  1614				   .skipL0152
   3293  1614		       a9 88		      LDA	#136
   3294  1616		       c5 81		      CMP	player1x
   3295  1618		       b0 03		      BCS	.skip19OR
   3296  161a				   .condpart75
   3297  161a		       4c 38 16 	      jmp	.__Done_Anim_jump
   3298  161d
   3299  161d				   .skip19OR
   3300  161d				   .
   3301  161d							; 
   3302  161d
   3303  161d				   .
   3304  161d							; 
   3305  161d
   3306  161d				   .
   3307  161d							; 
   3308  161d
   3309  161d				   .
   3310  161d							; 
   3311  161d
   3312  161d				   .L0153		;  player1color:
   3313  161d
   3314  161d		       a2 e4		      LDX	#<playercolorL0153_1
   3315  161f		       86 87		      STX	player1color
   3316  1621		       a9 f5		      LDA	#>playercolorL0153_1
   3317  1623		       85 88		      STA	player1color+1
   3318  1625				   .
   3319  1625							; 
   3320  1625
   3321  1625				   .
   3322  1625							; 
   3323  1625
   3324  1625				   .
   3325  1625							; 
   3326  1625
   3327  1625				   .
   3328  1625							; 
   3329  1625
   3330  1625				   .L0154		;  on _Frame_Counter goto __Frame0 __Frame1 __Frame0 __Frame2
   3331  1625
   3332  1625		       a6 dd		      LDX	_Frame_Counter
   3333  1627		       bd 30 16 	      LDA	.L0154jumptablehi,x
   3334  162a		       48		      PHA
   3335  162b		       bd 34 16 	      LDA	.L0154jumptablelo,x
   3336  162e		       48		      PHA
   3337  162f		       60		      RTS
   3338  1630				   .L0154jumptablehi
   3339  1630		       1a		      .byte.b	>(.__Frame0-1)
   3340  1631		       1a		      .byte.b	>(.__Frame1-1)
   3341  1632		       1a		      .byte.b	>(.__Frame0-1)
   3342  1633		       1a		      .byte.b	>(.__Frame2-1)
   3343  1634				   .L0154jumptablelo
   3344  1634		       52		      .byte.b	<(.__Frame0-1)
   3345  1635		       61		      .byte.b	<(.__Frame1-1)
   3346  1636		       52		      .byte.b	<(.__Frame0-1)
   3347  1637		       70		      .byte.b	<(.__Frame2-1)
   3348  1638				   .
   3349  1638							; 
   3350  1638
   3351  1638				   .__Done_Anim_jump
   3352  1638							; __Done_Anim_jump
   3353  1638
   3354  1638				   .
   3355  1638							; 
   3356  1638
   3357  1638				   .
   3358  1638							; 
   3359  1638
   3360  1638				   .
   3361  1638							; 
   3362  1638
   3363  1638				   .
   3364  1638							; 
   3365  1638
   3366  1638				   .
   3367  1638							; 
   3368  1638
   3369  1638				   .
   3370  1638							; 
   3371  1638
   3372  1638				   .
   3373  1638							; 
   3374  1638
   3375  1638				   .
   3376  1638							; 
   3377  1638
   3378  1638				   .
   3379  1638							; 
   3380  1638
   3381  1638				   .
   3382  1638							; 
   3383  1638
   3384  1638				   .L0155		;  if _Bit5_Ground_Slide_in_Progress{5} then goto __Skip_Joy0_Slide_Check
   3385  1638
   3386  1638		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3387  163a		       29 20		      AND	#32
   3388  163c		       f0 03		      BEQ	.skipL0155
   3389  163e				   .condpart76
   3390  163e		       4c 59 16 	      jmp	.__Skip_Joy0_Slide_Check
   3391  1641
   3392  1641				   .skipL0155
   3393  1641				   .
   3394  1641							; 
   3395  1641
   3396  1641				   .
   3397  1641							; 
   3398  1641
   3399  1641				   .
   3400  1641							; 
   3401  1641
   3402  1641				   .
   3403  1641							; 
   3404  1641
   3405  1641				   .L0156		;  if joy0right  ||  joy0left then _Slide_Counter  =  0  :  _Slide_Speed  =  1  :  goto __Check_Shot_in_Slide
   3406  1641
   3407  1641		       2c 80 02 	      bit	SWCHA
   3408  1644		       30 03		      BMI	.skipL0156
   3409  1646				   .condpart77
   3410  1646		       4c 4e 16 	      jmp	.condpart78
   3411  1649				   .skipL0156
   3412  1649		       2c 80 02 	      bit	SWCHA
   3413  164c		       70 0b		      BVS	.skip20OR
   3414  164e				   .condpart78
   3415  164e		       a9 00		      LDA	#0
   3416  1650		       85 d9		      STA	_Slide_Counter
   3417  1652		       a9 01		      LDA	#1
   3418  1654		       85 da		      STA	_Slide_Speed
   3419  1656		       4c 6e 17 	      jmp	.__Check_Shot_in_Slide
   3420  1659
   3421  1659				   .skip20OR
   3422  1659				   .
   3423  1659							; 
   3424  1659
   3425  1659				   .__Skip_Joy0_Slide_Check
   3426  1659							; __Skip_Joy0_Slide_Check
   3427  1659
   3428  1659				   .
   3429  1659							; 
   3430  1659
   3431  1659				   .
   3432  1659							; 
   3433  1659
   3434  1659				   .
   3435  1659							; 
   3436  1659
   3437  1659				   .
   3438  1659							; 
   3439  1659
   3440  1659				   .L0157		;  if player1x  <  17 then _Slide_Counter  =  0  :  _Bit5_Ground_Slide_in_Progress{5}	=  0  :  _Bit1_Slide_Left_in_Progress{1}  =  0	:  _Slide_Speed  =  1  :  _Bit2_Slide_Right_in_Progress{2}  =  1  :  goto __Skip_Slide
   3441  1659
   3442  1659		       a5 81		      LDA	player1x
   3443  165b		       c9 11		      CMP	#17
   3444  165d		       b0 1d		      BCS	.skipL0157
   3445  165f				   .condpart79
   3446  165f		       a9 00		      LDA	#0
   3447  1661		       85 d9		      STA	_Slide_Counter
   3448  1663		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3449  1665		       29 df		      AND	#223
   3450  1667		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3451  1669		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3452  166b		       29 fd		      AND	#253
   3453  166d		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   3454  166f		       a9 01		      LDA	#1
   3455  1671		       85 da		      STA	_Slide_Speed
   3456  1673		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3457  1675		       09 04		      ORA	#4
   3458  1677		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3459  1679		       4c 7a 17 	      jmp	.__Skip_Slide
   3460  167c
   3461  167c				   .skipL0157
   3462  167c				   .L0158		;  if player1x  >  137 then _Slide_Counter  =	0  :  _Bit5_Ground_Slide_in_Progress{5}  =  0  :  _Bit2_Slide_Right_in_Progress{2}  =  0  :  _Slide_Speed  =  1  :  _Bit1_Slide_Left_in_Progress{1}  =	1  :  goto __Skip_Slide
   3463  167c
   3464  167c		       a9 89		      LDA	#137
   3465  167e		       c5 81		      CMP	player1x
   3466  1680		       b0 1d		      BCS	.skipL0158
   3467  1682				   .condpart80
   3468  1682		       a9 00		      LDA	#0
   3469  1684		       85 d9		      STA	_Slide_Counter
   3470  1686		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3471  1688		       29 df		      AND	#223
   3472  168a		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3473  168c		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3474  168e		       29 fb		      AND	#251
   3475  1690		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3476  1692		       a9 01		      LDA	#1
   3477  1694		       85 da		      STA	_Slide_Speed
   3478  1696		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3479  1698		       09 02		      ORA	#2
   3480  169a		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   3481  169c		       4c 7a 17 	      jmp	.__Skip_Slide
   3482  169f
   3483  169f				   .skipL0158
   3484  169f				   .
   3485  169f							; 
   3486  169f
   3487  169f				   .
   3488  169f							; 
   3489  169f
   3490  169f				   .
   3491  169f							; 
   3492  169f
   3493  169f				   .
   3494  169f							; 
   3495  169f
   3496  169f				   .L0159		;  if !_Bit1_Slide_Left_in_Progress{1}  &&  !_Bit2_Slide_Right_in_Progress{2} then goto __Skip_Slide
   3497  169f
   3498  169f		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3499  16a1		       29 02		      AND	#2
   3500  16a3		       d0 09		      BNE	.skipL0159
   3501  16a5				   .condpart81
   3502  16a5		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3503  16a7		       29 04		      AND	#4
   3504  16a9		       d0 03		      BNE	.skip81then
   3505  16ab				   .condpart82
   3506  16ab		       4c 7a 17 	      jmp	.__Skip_Slide
   3507  16ae
   3508  16ae				   .skip81then
   3509  16ae				   .skipL0159
   3510  16ae				   .
   3511  16ae							; 
   3512  16ae
   3513  16ae				   .
   3514  16ae							; 
   3515  16ae
   3516  16ae				   .
   3517  16ae							; 
   3518  16ae
   3519  16ae				   .
   3520  16ae							; 
   3521  16ae
   3522  16ae				   .L0160		;  _Slide_Limit  =  31  :  _Bit5_Ground_Slide_in_Progress{5}  =  1
   3523  16ae
   3524  16ae		       a9 1f		      LDA	#31
   3525  16b0		       85 db		      STA	_Slide_Limit
   3526  16b2		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3527  16b4		       09 20		      ORA	#32
   3528  16b6		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3529  16b8				   .
   3530  16b8							; 
   3531  16b8
   3532  16b8				   .
   3533  16b8							; 
   3534  16b8
   3535  16b8				   .
   3536  16b8							; 
   3537  16b8
   3538  16b8				   .
   3539  16b8							; 
   3540  16b8
   3541  16b8				   .
   3542  16b8							; 
   3543  16b8
   3544  16b8				   .L0161		;  if _Bit0_Fall_in_Progress{0}  ||  _Jump_Gravity_Counter then _Slide_Limit  =  127  :  _Bit5_Ground_Slide_in_Progress{5}  =	0
   3545  16b8
   3546  16b8		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   3547  16ba		       4a		      LSR
   3548  16bb		       90 03		      BCC	.skipL0161
   3549  16bd				   .condpart83
   3550  16bd		       4c c4 16 	      jmp	.condpart84
   3551  16c0				   .skipL0161
   3552  16c0		       a5 d7		      LDA	_Jump_Gravity_Counter
   3553  16c2		       f0 0a		      BEQ	.skip22OR
   3554  16c4				   .condpart84
   3555  16c4		       a9 7f		      LDA	#127
   3556  16c6		       85 db		      STA	_Slide_Limit
   3557  16c8		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3558  16ca		       29 df		      AND	#223
   3559  16cc		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3560  16ce				   .skip22OR
   3561  16ce				   .
   3562  16ce							; 
   3563  16ce
   3564  16ce				   .
   3565  16ce							; 
   3566  16ce
   3567  16ce				   .
   3568  16ce							; 
   3569  16ce
   3570  16ce				   .
   3571  16ce							; 
   3572  16ce
   3573  16ce				   .L0162		;  if _Bit6_Duck_in_Progress{6} then goto __Skip_Slide_Sprite
   3574  16ce
   3575  16ce		       24 ec		      BIT	_Bit6_Duck_in_Progress
   3576  16d0		       50 03		      BVC	.skipL0162
   3577  16d2				   .condpart85
   3578  16d2		       4c f8 16 	      jmp	.__Skip_Slide_Sprite
   3579  16d5
   3580  16d5				   .skipL0162
   3581  16d5				   .
   3582  16d5							; 
   3583  16d5
   3584  16d5				   .
   3585  16d5							; 
   3586  16d5
   3587  16d5				   .
   3588  16d5							; 
   3589  16d5
   3590  16d5				   .
   3591  16d5							; 
   3592  16d5
   3593  16d5				   .L0163		;  if _Jump_Gravity_Counter  ||  _Bit0_Fall_in_Progress{0} then goto __Skip_Slide_Sprite
   3594  16d5
   3595  16d5		       a5 d7		      LDA	_Jump_Gravity_Counter
   3596  16d7		       f0 03		      BEQ	.skipL0163
   3597  16d9				   .condpart86
   3598  16d9		       4c e1 16 	      jmp	.condpart87
   3599  16dc				   .skipL0163
   3600  16dc		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   3601  16de		       4a		      LSR
   3602  16df		       90 03		      BCC	.skip23OR
   3603  16e1				   .condpart87
   3604  16e1		       4c f8 16 	      jmp	.__Skip_Slide_Sprite
   3605  16e4
   3606  16e4				   .skip23OR
   3607  16e4				   .
   3608  16e4							; 
   3609  16e4
   3610  16e4				   .
   3611  16e4							; 
   3612  16e4
   3613  16e4				   .
   3614  16e4							; 
   3615  16e4
   3616  16e4				   .
   3617  16e4							; 
   3618  16e4
   3619  16e4				   .L0164		;  player1:
   3620  16e4
   3621  16e4		       a2 ee		      LDX	#<playerL0164_1
   3622  16e6		       86 8c		      STX	player1pointerlo
   3623  16e8		       a9 f5		      LDA	#>playerL0164_1
   3624  16ea		       85 8d		      STA	player1pointerhi
   3625  16ec		       a9 09		      LDA	#9
   3626  16ee		       85 8f		      STA	player1height
   3627  16f0				   .
   3628  16f0							; 
   3629  16f0
   3630  16f0				   .L0165		;  player1color:
   3631  16f0
   3632  16f0		       a2 00		      LDX	#<playercolorL0165_1
   3633  16f2		       86 87		      STX	player1color
   3634  16f4		       a9 f6		      LDA	#>playercolorL0165_1
   3635  16f6		       85 88		      STA	player1color+1
   3636  16f8				   .
   3637  16f8							; 
   3638  16f8
   3639  16f8				   .__Skip_Slide_Sprite
   3640  16f8							; __Skip_Slide_Sprite
   3641  16f8
   3642  16f8				   .
   3643  16f8							; 
   3644  16f8
   3645  16f8				   .
   3646  16f8							; 
   3647  16f8
   3648  16f8				   .
   3649  16f8							; 
   3650  16f8
   3651  16f8				   .
   3652  16f8							; 
   3653  16f8
   3654  16f8				   .
   3655  16f8							; 
   3656  16f8
   3657  16f8				   .L0166		;  if _Slide_Counter  =  0  &&  _Ch0_Sound  =	0 then if !_Bit0_Fall_in_Progress{0} then _Ch0_Sound  =  _c_Slide_Sound  :  _Ch0_Duration  =  1  :  _Ch0_Counter  =  0
   3658  16f8
   3659  16f8		       a5 d9		      LDA	_Slide_Counter
   3660  16fa		       c9 00		      CMP	#0
   3661  16fc		       d0 17		      BNE	.skipL0166
   3662  16fe				   .condpart88
   3663  16fe		       a5 de		      LDA	_Ch0_Sound
   3664  1700		       c9 00		      CMP	#0
   3665  1702		       d0 11		      BNE	.skip88then
   3666  1704				   .condpart89
   3667  1704		       a5 ec		      LDA	_Bit0_Fall_in_Progress
   3668  1706		       4a		      LSR
   3669  1707		       b0 0c		      BCS	.skip89then
   3670  1709				   .condpart90
   3671  1709		       a9 03		      LDA	#_c_Slide_Sound
   3672  170b		       85 de		      STA	_Ch0_Sound
   3673  170d		       a9 01		      LDA	#1
   3674  170f		       85 df		      STA	_Ch0_Duration
   3675  1711		       a9 00		      LDA	#0
   3676  1713		       85 e0		      STA	_Ch0_Counter
   3677  1715				   .skip89then
   3678  1715				   .skip88then
   3679  1715				   .skipL0166
   3680  1715				   .
   3681  1715							; 
   3682  1715
   3683  1715				   .
   3684  1715							; 
   3685  1715
   3686  1715				   .
   3687  1715							; 
   3688  1715
   3689  1715				   .
   3690  1715							; 
   3691  1715
   3692  1715				   .L0167		;  _Slide_Counter  =  _Slide_Counter  +  1
   3693  1715
   3694  1715		       e6 d9		      INC	_Slide_Counter
   3695  1717				   .
   3696  1717							; 
   3697  1717
   3698  1717				   .
   3699  1717							; 
   3700  1717
   3701  1717				   .
   3702  1717							; 
   3703  1717
   3704  1717				   .
   3705  1717							; 
   3706  1717
   3707  1717				   .L0168		;  if _Slide_Counter  <  _Slide_Speed then goto __Skip_Slide
   3708  1717
   3709  1717		       a5 d9		      LDA	_Slide_Counter
   3710  1719		       c5 da		      CMP	_Slide_Speed
   3711  171b		       b0 03		      BCS	.skipL0168
   3712  171d				   .condpart91
   3713  171d		       4c 7a 17 	      jmp	.__Skip_Slide
   3714  1720
   3715  1720				   .skipL0168
   3716  1720				   .
   3717  1720							; 
   3718  1720
   3719  1720				   .
   3720  1720							; 
   3721  1720
   3722  1720				   .
   3723  1720							; 
   3724  1720
   3725  1720				   .
   3726  1720							; 
   3727  1720
   3728  1720				   .L0169		;  _Slide_Speed  =  _Slide_Speed  *  2
   3729  1720
   3730  1720		       a5 da		      LDA	_Slide_Speed
   3731  1722		       0a		      asl
   3732  1723		       85 da		      STA	_Slide_Speed
   3733  1725				   .
   3734  1725							; 
   3735  1725
   3736  1725				   .
   3737  1725							; 
   3738  1725
   3739  1725				   .
   3740  1725							; 
   3741  1725
   3742  1725				   .
   3743  1725							; 
   3744  1725
   3745  1725				   .L0170		;  if _Bit1_Slide_Left_in_Progress{1} then _P1_Left_Right  =  _P1_Left_Right  -  1.04
   3746  1725
   3747  1725		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3748  1727		       29 02		      AND	#2
   3749  1729		       f0 0d		      BEQ	.skipL0170
   3750  172b				   .condpart92
   3751  172b		       a5 d4		      LDA	a
   3752  172d		       38		      SEC
   3753  172e		       e9 0a		      SBC	#10
   3754  1730		       85 d4		      STA	a
   3755  1732		       a5 81		      LDA	_P1_Left_Right
   3756  1734		       e9 01		      SBC	#1
   3757  1736		       85 81		      STA	_P1_Left_Right
   3758  1738				   .skipL0170
   3759  1738				   .L0171		;  if _Bit2_Slide_Right_in_Progress{2} then _P1_Left_Right  =	_P1_Left_Right	+  1.04
   3760  1738
   3761  1738		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3762  173a		       29 04		      AND	#4
   3763  173c		       f0 0d		      BEQ	.skipL0171
   3764  173e				   .condpart93
   3765  173e		       a5 d4		      LDA	a
   3766  1740		       18		      CLC
   3767  1741		       69 0a		      ADC	#10
   3768  1743		       85 d4		      STA	a
   3769  1745		       a5 81		      LDA	_P1_Left_Right
   3770  1747		       69 01		      ADC	#1
   3771  1749		       85 81		      STA	_P1_Left_Right
   3772  174b				   .skipL0171
   3773  174b				   .
   3774  174b							; 
   3775  174b
   3776  174b				   .
   3777  174b							; 
   3778  174b
   3779  174b				   .
   3780  174b							; 
   3781  174b
   3782  174b				   .
   3783  174b							; 
   3784  174b
   3785  174b				   .L0172		;  if _Slide_Speed  >	_Slide_Limit then _Slide_Speed	=  1  :  _Slide_Counter  =  0  :  _Bit1_Slide_Left_in_Progress{1}  =  0  :  _Bit2_Slide_Right_in_Progress{2}  =  0  :  _Bit5_Ground_Slide_in_Progress{5}  =  0
   3786  174b
   3787  174b		       a5 db		      LDA	_Slide_Limit
   3788  174d		       c5 da		      CMP	_Slide_Speed
   3789  174f		       b0 1a		      BCS	.skipL0172
   3790  1751				   .condpart94
   3791  1751		       a9 01		      LDA	#1
   3792  1753		       85 da		      STA	_Slide_Speed
   3793  1755		       a9 00		      LDA	#0
   3794  1757		       85 d9		      STA	_Slide_Counter
   3795  1759		       a5 ec		      LDA	_Bit1_Slide_Left_in_Progress
   3796  175b		       29 fd		      AND	#253
   3797  175d		       85 ec		      STA	_Bit1_Slide_Left_in_Progress
   3798  175f		       a5 ec		      LDA	_Bit2_Slide_Right_in_Progress
   3799  1761		       29 fb		      AND	#251
   3800  1763		       85 ec		      STA	_Bit2_Slide_Right_in_Progress
   3801  1765		       a5 ec		      LDA	_Bit5_Ground_Slide_in_Progress
   3802  1767		       29 df		      AND	#223
   3803  1769		       85 ec		      STA	_Bit5_Ground_Slide_in_Progress
   3804  176b				   .skipL0172
   3805  176b				   .
   3806  176b							; 
   3807  176b
   3808  176b				   .L0173		;  goto __Skip_Slide
   3809  176b
   3810  176b		       4c 7a 17 	      jmp	.__Skip_Slide
   3811  176e
   3812  176e				   .
   3813  176e							; 
   3814  176e
   3815  176e				   .__Check_Shot_in_Slide
   3816  176e							; __Check_Shot_in_Slide
   3817  176e
   3818  176e				   .
   3819  176e							; 
   3820  176e
   3821  176e				   .
   3822  176e							; 
   3823  176e
   3824  176e				   .
   3825  176e							; 
   3826  176e
   3827  176e				   .
   3828  176e							; 
   3829  176e
   3830  176e				   .L0174		;  if !_Bit2_Shot_Moving{2} then _Bit5_Slide_Fire_Restrainer{5}  =  0
   3831  176e
   3832  176e		       a5 eb		      LDA	_Bit2_Shot_Moving
   3833  1770		       29 04		      AND	#4
   3834  1772		       d0 06		      BNE	.skipL0174
   3835  1774				   .condpart95
   3836  1774		       a5 eb		      LDA	_Bit5_Slide_Fire_Restrainer
   3837  1776		       29 df		      AND	#223
   3838  1778		       85 eb		      STA	_Bit5_Slide_Fire_Restrainer
   3839  177a				   .skipL0174
   3840  177a				   .
   3841  177a							; 
   3842  177a
   3843  177a				   .__Skip_Slide
   3844  177a							; __Skip_Slide
   3845  177a
   3846  177a				   .
   3847  177a							; 
   3848  177a
   3849  177a				   .
   3850  177a							; 
   3851  177a
   3852  177a				   .
   3853  177a							; 
   3854  177a
   3855  177a				   .
   3856  177a							; 
   3857  177a
   3858  177a				   .
   3859  177a							; 
   3860  177a
   3861  177a				   .
   3862  177a							; 
   3863  177a
   3864  177a				   .
   3865  177a							; 
   3866  177a
   3867  177a				   .L0175		;  if _Bit4_Flip_P1{4} then REFP1  =  8
   3868  177a
   3869  177a		       a5 ec		      LDA	_Bit4_Flip_P1
   3870  177c		       29 10		      AND	#16
   3871  177e		       f0 04		      BEQ	.skipL0175
   3872  1780				   .condpart96
   3873  1780		       a9 08		      LDA	#8
   3874  1782		       85 0c		      STA	REFP1
   3875  1784				   .skipL0175
   3876  1784				   .
   3877  1784							; 
   3878  1784
   3879  1784				   .
   3880  1784							; 
   3881  1784
   3882  1784				   .
   3883  1784							; 
   3884  1784
   3885  1784				   .
   3886  1784							; 
   3887  1784
   3888  1784				   .
   3889  1784							; 
   3890  1784
   3891  1784				   .
   3892  1784							; 
   3893  1784
   3894  1784				   .
   3895  1784							; 
   3896  1784
   3897  1784				   .
   3898  1784							; 
   3899  1784
   3900  1784				   .
   3901  1784							; 
   3902  1784
   3903  1784				   .
   3904  1784							; 
   3905  1784
   3906  1784				   .L0176		;  if !_Ch0_Sound then goto __Skip_Ch_0
   3907  1784
   3908  1784		       a5 de		      LDA	_Ch0_Sound
   3909  1786		       d0 03		      BNE	.skipL0176
   3910  1788				   .condpart97
   3911  1788		       4c b1 18 	      jmp	.__Skip_Ch_0
   3912  178b
   3913  178b				   .skipL0176
   3914  178b				   .
   3915  178b							; 
   3916  178b
   3917  178b				   .
   3918  178b							; 
   3919  178b
   3920  178b				   .
   3921  178b							; 
   3922  178b
   3923  178b				   .
   3924  178b							; 
   3925  178b
   3926  178b				   .L0177		;  _Ch0_Duration  =  _Ch0_Duration  -	1
   3927  178b
   3928  178b		       c6 df		      DEC	_Ch0_Duration
   3929  178d				   .
   3930  178d							; 
   3931  178d
   3932  178d				   .
   3933  178d							; 
   3934  178d
   3935  178d				   .
   3936  178d							; 
   3937  178d
   3938  178d				   .
   3939  178d							; 
   3940  178d
   3941  178d				   .
   3942  178d							; 
   3943  178d
   3944  178d				   .L0178		;  if _Ch0_Duration then goto __Skip_Ch_0
   3945  178d
   3946  178d		       a5 df		      LDA	_Ch0_Duration
   3947  178f		       f0 03		      BEQ	.skipL0178
   3948  1791				   .condpart98
   3949  1791		       4c b1 18 	      jmp	.__Skip_Ch_0
   3950  1794
   3951  1794				   .skipL0178
   3952  1794				   .
   3953  1794							; 
   3954  1794
   3955  1794				   .
   3956  1794							; 
   3957  1794
   3958  1794				   .
   3959  1794							; 
   3960  1794
   3961  1794				   .
   3962  1794							; 
   3963  1794
   3964  1794				   .
   3965  1794							; 
   3966  1794
   3967  1794				   .
   3968  1794							; 
   3969  1794
   3970  1794				   .
   3971  1794							; 
   3972  1794
   3973  1794				   .
   3974  1794							; 
   3975  1794
   3976  1794				   .
   3977  1794							; 
   3978  1794
   3979  1794				   .
   3980  1794							; 
   3981  1794
   3982  1794				   .
   3983  1794							; 
   3984  1794
   3985  1794				   .
   3986  1794							; 
   3987  1794
   3988  1794				   .L0179		;  if _Ch0_Sound  <>  _c_Jump_Sound then goto __Skip_Ch0_Sound_001
   3989  1794
   3990  1794		       a5 de		      LDA	_Ch0_Sound
   3991  1796		       c9 01		      CMP	#_c_Jump_Sound
   3992  1798		       f0 03		      BEQ	.skipL0179
   3993  179a				   .condpart99
   3994  179a		       4c d9 17 	      jmp	.__Skip_Ch0_Sound_001
   3995  179d
   3996  179d				   .skipL0179
   3997  179d				   .
   3998  179d							; 
   3999  179d
   4000  179d				   .
   4001  179d							; 
   4002  179d
   4003  179d				   .
   4004  179d							; 
   4005  179d
   4006  179d				   .
   4007  179d							; 
   4008  179d
   4009  179d				   .L0180		;  temp4  =  _SD_Jump[_Ch0_Counter]
   4010  179d
   4011  179d		       a6 e0		      LDX	_Ch0_Counter
   4012  179f		       bd e6 18 	      LDA	_SD_Jump,x
   4013  17a2		       85 9f		      STA	temp4
   4014  17a4				   .
   4015  17a4							; 
   4016  17a4
   4017  17a4				   .
   4018  17a4							; 
   4019  17a4
   4020  17a4				   .
   4021  17a4							; 
   4022  17a4
   4023  17a4				   .
   4024  17a4							; 
   4025  17a4
   4026  17a4				   .L0181		;  if temp4  =  255 then goto __Clear_Ch_0
   4027  17a4
   4028  17a4		       a5 9f		      LDA	temp4
   4029  17a6		       c9 ff		      CMP	#255
   4030  17a8		       d0 03		      BNE	.skipL0181
   4031  17aa				   .condpart100
   4032  17aa		       4c ab 18 	      jmp	.__Clear_Ch_0
   4033  17ad
   4034  17ad				   .skipL0181
   4035  17ad				   .
   4036  17ad							; 
   4037  17ad
   4038  17ad				   .
   4039  17ad							; 
   4040  17ad
   4041  17ad				   .
   4042  17ad							; 
   4043  17ad
   4044  17ad				   .
   4045  17ad							; 
   4046  17ad
   4047  17ad				   .L0182		;  _Ch0_Counter  =  _Ch0_Counter  +  1
   4048  17ad
   4049  17ad		       e6 e0		      INC	_Ch0_Counter
   4050  17af				   .L0183		;  temp5  =  _SD_Jump[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4051  17af
   4052  17af		       a6 e0		      LDX	_Ch0_Counter
   4053  17b1		       bd e6 18 	      LDA	_SD_Jump,x
   4054  17b4		       85 a0		      STA	temp5
   4055  17b6		       e6 e0		      INC	_Ch0_Counter
   4056  17b8				   .L0184		;  temp6  =  _SD_Jump[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4057  17b8
   4058  17b8		       a6 e0		      LDX	_Ch0_Counter
   4059  17ba		       bd e6 18 	      LDA	_SD_Jump,x
   4060  17bd		       85 a1		      STA	temp6
   4061  17bf		       e6 e0		      INC	_Ch0_Counter
   4062  17c1				   .
   4063  17c1							; 
   4064  17c1
   4065  17c1				   .
   4066  17c1							; 
   4067  17c1
   4068  17c1				   .
   4069  17c1							; 
   4070  17c1
   4071  17c1				   .
   4072  17c1							; 
   4073  17c1
   4074  17c1				   .L0185		;  AUDV0  =  temp4
   4075  17c1
   4076  17c1		       a5 9f		      LDA	temp4
   4077  17c3		       85 19		      STA	AUDV0
   4078  17c5				   .L0186		;  AUDC0  =  temp5
   4079  17c5
   4080  17c5		       a5 a0		      LDA	temp5
   4081  17c7		       85 15		      STA	AUDC0
   4082  17c9				   .L0187		;  AUDF0  =  temp6
   4083  17c9
   4084  17c9		       a5 a1		      LDA	temp6
   4085  17cb		       85 17		      STA	AUDF0
   4086  17cd				   .
   4087  17cd							; 
   4088  17cd
   4089  17cd				   .
   4090  17cd							; 
   4091  17cd
   4092  17cd				   .
   4093  17cd							; 
   4094  17cd
   4095  17cd				   .
   4096  17cd							; 
   4097  17cd
   4098  17cd				   .L0188		;  _Ch0_Duration  =  _SD_Jump[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4099  17cd
   4100  17cd		       a6 e0		      LDX	_Ch0_Counter
   4101  17cf		       bd e6 18 	      LDA	_SD_Jump,x
   4102  17d2		       85 df		      STA	_Ch0_Duration
   4103  17d4		       e6 e0		      INC	_Ch0_Counter
   4104  17d6				   .
   4105  17d6							; 
   4106  17d6
   4107  17d6				   .
   4108  17d6							; 
   4109  17d6
   4110  17d6				   .
   4111  17d6							; 
   4112  17d6
   4113  17d6				   .
   4114  17d6							; 
   4115  17d6
   4116  17d6				   .L0189		;  goto __Skip_Ch_0
   4117  17d6
   4118  17d6		       4c b1 18 	      jmp	.__Skip_Ch_0
   4119  17d9
   4120  17d9				   .
   4121  17d9							; 
   4122  17d9
   4123  17d9				   .__Skip_Ch0_Sound_001
   4124  17d9							; __Skip_Ch0_Sound_001
   4125  17d9
   4126  17d9				   .
   4127  17d9							; 
   4128  17d9
   4129  17d9				   .
   4130  17d9							; 
   4131  17d9
   4132  17d9				   .
   4133  17d9							; 
   4134  17d9
   4135  17d9				   .
   4136  17d9							; 
   4137  17d9
   4138  17d9				   .
   4139  17d9							; 
   4140  17d9
   4141  17d9				   .
   4142  17d9							; 
   4143  17d9
   4144  17d9				   .
   4145  17d9							; 
   4146  17d9
   4147  17d9				   .
   4148  17d9							; 
   4149  17d9
   4150  17d9				   .
   4151  17d9							; 
   4152  17d9
   4153  17d9				   .
   4154  17d9							; 
   4155  17d9
   4156  17d9				   .
   4157  17d9							; 
   4158  17d9
   4159  17d9				   .
   4160  17d9							; 
   4161  17d9
   4162  17d9				   .L0190		;  if _Ch0_Sound  <>  _c_Fall_Sound then goto __Skip_Ch0_Sound_002
   4163  17d9
   4164  17d9		       a5 de		      LDA	_Ch0_Sound
   4165  17db		       c9 02		      CMP	#_c_Fall_Sound
   4166  17dd		       f0 03		      BEQ	.skipL0190
   4167  17df				   .condpart101
   4168  17df		       4c 1e 18 	      jmp	.__Skip_Ch0_Sound_002
   4169  17e2
   4170  17e2				   .skipL0190
   4171  17e2				   .
   4172  17e2							; 
   4173  17e2
   4174  17e2				   .
   4175  17e2							; 
   4176  17e2
   4177  17e2				   .
   4178  17e2							; 
   4179  17e2
   4180  17e2				   .
   4181  17e2							; 
   4182  17e2
   4183  17e2				   .L0191		;  temp4  =  _SD_Fall[_Ch0_Counter]
   4184  17e2
   4185  17e2		       a6 e0		      LDX	_Ch0_Counter
   4186  17e4		       bd 3a 19 	      LDA	_SD_Fall,x
   4187  17e7		       85 9f		      STA	temp4
   4188  17e9				   .
   4189  17e9							; 
   4190  17e9
   4191  17e9				   .
   4192  17e9							; 
   4193  17e9
   4194  17e9				   .
   4195  17e9							; 
   4196  17e9
   4197  17e9				   .
   4198  17e9							; 
   4199  17e9
   4200  17e9				   .L0192		;  if temp4  =  255 then goto __Clear_Ch_0
   4201  17e9
   4202  17e9		       a5 9f		      LDA	temp4
   4203  17eb		       c9 ff		      CMP	#255
   4204  17ed		       d0 03		      BNE	.skipL0192
   4205  17ef				   .condpart102
   4206  17ef		       4c ab 18 	      jmp	.__Clear_Ch_0
   4207  17f2
   4208  17f2				   .skipL0192
   4209  17f2				   .
   4210  17f2							; 
   4211  17f2
   4212  17f2				   .
   4213  17f2							; 
   4214  17f2
   4215  17f2				   .
   4216  17f2							; 
   4217  17f2
   4218  17f2				   .
   4219  17f2							; 
   4220  17f2
   4221  17f2				   .L0193		;  _Ch0_Counter  =  _Ch0_Counter  +  1
   4222  17f2
   4223  17f2		       e6 e0		      INC	_Ch0_Counter
   4224  17f4				   .L0194		;  temp5  =  _SD_Fall[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4225  17f4
   4226  17f4		       a6 e0		      LDX	_Ch0_Counter
   4227  17f6		       bd 3a 19 	      LDA	_SD_Fall,x
   4228  17f9		       85 a0		      STA	temp5
   4229  17fb		       e6 e0		      INC	_Ch0_Counter
   4230  17fd				   .L0195		;  temp6  =  _SD_Fall[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4231  17fd
   4232  17fd		       a6 e0		      LDX	_Ch0_Counter
   4233  17ff		       bd 3a 19 	      LDA	_SD_Fall,x
   4234  1802		       85 a1		      STA	temp6
   4235  1804		       e6 e0		      INC	_Ch0_Counter
   4236  1806				   .
   4237  1806							; 
   4238  1806
   4239  1806				   .
   4240  1806							; 
   4241  1806
   4242  1806				   .
   4243  1806							; 
   4244  1806
   4245  1806				   .
   4246  1806							; 
   4247  1806
   4248  1806				   .L0196		;  AUDV0  =  temp4
   4249  1806
   4250  1806		       a5 9f		      LDA	temp4
   4251  1808		       85 19		      STA	AUDV0
   4252  180a				   .L0197		;  AUDC0  =  temp5
   4253  180a
   4254  180a		       a5 a0		      LDA	temp5
   4255  180c		       85 15		      STA	AUDC0
   4256  180e				   .L0198		;  AUDF0  =  temp6
   4257  180e
   4258  180e		       a5 a1		      LDA	temp6
   4259  1810		       85 17		      STA	AUDF0
   4260  1812				   .
   4261  1812							; 
   4262  1812
   4263  1812				   .
   4264  1812							; 
   4265  1812
   4266  1812				   .
   4267  1812							; 
   4268  1812
   4269  1812				   .
   4270  1812							; 
   4271  1812
   4272  1812				   .L0199		;  _Ch0_Duration  =  _SD_Fall[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4273  1812
   4274  1812		       a6 e0		      LDX	_Ch0_Counter
   4275  1814		       bd 3a 19 	      LDA	_SD_Fall,x
   4276  1817		       85 df		      STA	_Ch0_Duration
   4277  1819		       e6 e0		      INC	_Ch0_Counter
   4278  181b				   .
   4279  181b							; 
   4280  181b
   4281  181b				   .
   4282  181b							; 
   4283  181b
   4284  181b				   .
   4285  181b							; 
   4286  181b
   4287  181b				   .
   4288  181b							; 
   4289  181b
   4290  181b				   .L0200		;  goto __Skip_Ch_0
   4291  181b
   4292  181b		       4c b1 18 	      jmp	.__Skip_Ch_0
   4293  181e
   4294  181e				   .
   4295  181e							; 
   4296  181e
   4297  181e				   .__Skip_Ch0_Sound_002
   4298  181e							; __Skip_Ch0_Sound_002
   4299  181e
   4300  181e				   .
   4301  181e							; 
   4302  181e
   4303  181e				   .
   4304  181e							; 
   4305  181e
   4306  181e				   .
   4307  181e							; 
   4308  181e
   4309  181e				   .
   4310  181e							; 
   4311  181e
   4312  181e				   .
   4313  181e							; 
   4314  181e
   4315  181e				   .
   4316  181e							; 
   4317  181e
   4318  181e				   .
   4319  181e							; 
   4320  181e
   4321  181e				   .
   4322  181e							; 
   4323  181e
   4324  181e				   .
   4325  181e							; 
   4326  181e
   4327  181e				   .
   4328  181e							; 
   4329  181e
   4330  181e				   .
   4331  181e							; 
   4332  181e
   4333  181e				   .
   4334  181e							; 
   4335  181e
   4336  181e				   .L0201		;  if _Ch0_Sound  <>  _c_Slide_Sound then goto __Skip_Ch0_Sound_003
   4337  181e
   4338  181e		       a5 de		      LDA	_Ch0_Sound
   4339  1820		       c9 03		      CMP	#_c_Slide_Sound
   4340  1822		       f0 03		      BEQ	.skipL0201
   4341  1824				   .condpart103
   4342  1824		       4c 63 18 	      jmp	.__Skip_Ch0_Sound_003
   4343  1827
   4344  1827				   .skipL0201
   4345  1827				   .
   4346  1827							; 
   4347  1827
   4348  1827				   .
   4349  1827							; 
   4350  1827
   4351  1827				   .
   4352  1827							; 
   4353  1827
   4354  1827				   .
   4355  1827							; 
   4356  1827
   4357  1827				   .L0202		;  temp4  =  _SD_Slide[_Ch0_Counter]
   4358  1827
   4359  1827		       a6 e0		      LDX	_Ch0_Counter
   4360  1829		       bd be 19 	      LDA	_SD_Slide,x
   4361  182c		       85 9f		      STA	temp4
   4362  182e				   .
   4363  182e							; 
   4364  182e
   4365  182e				   .
   4366  182e							; 
   4367  182e
   4368  182e				   .
   4369  182e							; 
   4370  182e
   4371  182e				   .
   4372  182e							; 
   4373  182e
   4374  182e				   .L0203		;  if temp4  =  255 then goto __Clear_Ch_0
   4375  182e
   4376  182e		       a5 9f		      LDA	temp4
   4377  1830		       c9 ff		      CMP	#255
   4378  1832		       d0 03		      BNE	.skipL0203
   4379  1834				   .condpart104
   4380  1834		       4c ab 18 	      jmp	.__Clear_Ch_0
   4381  1837
   4382  1837				   .skipL0203
   4383  1837				   .
   4384  1837							; 
   4385  1837
   4386  1837				   .
   4387  1837							; 
   4388  1837
   4389  1837				   .
   4390  1837							; 
   4391  1837
   4392  1837				   .
   4393  1837							; 
   4394  1837
   4395  1837				   .L0204		;  _Ch0_Counter  =  _Ch0_Counter  +  1
   4396  1837
   4397  1837		       e6 e0		      INC	_Ch0_Counter
   4398  1839				   .L0205		;  temp5  =  _SD_Slide[_Ch0_Counter]  :  _Ch0_Counter	=  _Ch0_Counter  +  1
   4399  1839
   4400  1839		       a6 e0		      LDX	_Ch0_Counter
   4401  183b		       bd be 19 	      LDA	_SD_Slide,x
   4402  183e		       85 a0		      STA	temp5
   4403  1840		       e6 e0		      INC	_Ch0_Counter
   4404  1842				   .L0206		;  temp6  =  _SD_Slide[_Ch0_Counter]  :  _Ch0_Counter	=  _Ch0_Counter  +  1
   4405  1842
   4406  1842		       a6 e0		      LDX	_Ch0_Counter
   4407  1844		       bd be 19 	      LDA	_SD_Slide,x
   4408  1847		       85 a1		      STA	temp6
   4409  1849		       e6 e0		      INC	_Ch0_Counter
   4410  184b				   .
   4411  184b							; 
   4412  184b
   4413  184b				   .
   4414  184b							; 
   4415  184b
   4416  184b				   .
   4417  184b							; 
   4418  184b
   4419  184b				   .
   4420  184b							; 
   4421  184b
   4422  184b				   .L0207		;  AUDV0  =  temp4
   4423  184b
   4424  184b		       a5 9f		      LDA	temp4
   4425  184d		       85 19		      STA	AUDV0
   4426  184f				   .L0208		;  AUDC0  =  temp5
   4427  184f
   4428  184f		       a5 a0		      LDA	temp5
   4429  1851		       85 15		      STA	AUDC0
   4430  1853				   .L0209		;  AUDF0  =  temp6
   4431  1853
   4432  1853		       a5 a1		      LDA	temp6
   4433  1855		       85 17		      STA	AUDF0
   4434  1857				   .
   4435  1857							; 
   4436  1857
   4437  1857				   .
   4438  1857							; 
   4439  1857
   4440  1857				   .
   4441  1857							; 
   4442  1857
   4443  1857				   .
   4444  1857							; 
   4445  1857
   4446  1857				   .L0210		;  _Ch0_Duration  =  _SD_Slide[_Ch0_Counter]  :  _Ch0_Counter	=  _Ch0_Counter  +  1
   4447  1857
   4448  1857		       a6 e0		      LDX	_Ch0_Counter
   4449  1859		       bd be 19 	      LDA	_SD_Slide,x
   4450  185c		       85 df		      STA	_Ch0_Duration
   4451  185e		       e6 e0		      INC	_Ch0_Counter
   4452  1860				   .
   4453  1860							; 
   4454  1860
   4455  1860				   .
   4456  1860							; 
   4457  1860
   4458  1860				   .
   4459  1860							; 
   4460  1860
   4461  1860				   .
   4462  1860							; 
   4463  1860
   4464  1860				   .L0211		;  goto __Skip_Ch_0
   4465  1860
   4466  1860		       4c b1 18 	      jmp	.__Skip_Ch_0
   4467  1863
   4468  1863				   .
   4469  1863							; 
   4470  1863
   4471  1863				   .__Skip_Ch0_Sound_003
   4472  1863							; __Skip_Ch0_Sound_003
   4473  1863
   4474  1863				   .
   4475  1863							; 
   4476  1863
   4477  1863				   .
   4478  1863							; 
   4479  1863
   4480  1863				   .
   4481  1863							; 
   4482  1863
   4483  1863				   .
   4484  1863							; 
   4485  1863
   4486  1863				   .
   4487  1863							; 
   4488  1863
   4489  1863				   .
   4490  1863							; 
   4491  1863
   4492  1863				   .
   4493  1863							; 
   4494  1863
   4495  1863				   .
   4496  1863							; 
   4497  1863
   4498  1863				   .
   4499  1863							; 
   4500  1863
   4501  1863				   .
   4502  1863							; 
   4503  1863
   4504  1863				   .
   4505  1863							; 
   4506  1863
   4507  1863				   .
   4508  1863							; 
   4509  1863
   4510  1863				   .L0212		;  if _Ch0_Sound  <>  _c_Shot_Sound then goto __Skip_Ch0_Sound_004
   4511  1863
   4512  1863		       a5 de		      LDA	_Ch0_Sound
   4513  1865		       c9 04		      CMP	#_c_Shot_Sound
   4514  1867		       f0 03		      BEQ	.skipL0212
   4515  1869				   .condpart105
   4516  1869		       4c a8 18 	      jmp	.__Skip_Ch0_Sound_004
   4517  186c
   4518  186c				   .skipL0212
   4519  186c				   .
   4520  186c							; 
   4521  186c
   4522  186c				   .
   4523  186c							; 
   4524  186c
   4525  186c				   .
   4526  186c							; 
   4527  186c
   4528  186c				   .
   4529  186c							; 
   4530  186c
   4531  186c				   .L0213		;  temp4  =  _SD_Shot[_Ch0_Counter]
   4532  186c
   4533  186c		       a6 e0		      LDX	_Ch0_Counter
   4534  186e		       bd 16 1a 	      LDA	_SD_Shot,x
   4535  1871		       85 9f		      STA	temp4
   4536  1873				   .
   4537  1873							; 
   4538  1873
   4539  1873				   .
   4540  1873							; 
   4541  1873
   4542  1873				   .
   4543  1873							; 
   4544  1873
   4545  1873				   .
   4546  1873							; 
   4547  1873
   4548  1873				   .L0214		;  if temp4  =  255 then goto __Clear_Ch_0
   4549  1873
   4550  1873		       a5 9f		      LDA	temp4
   4551  1875		       c9 ff		      CMP	#255
   4552  1877		       d0 03		      BNE	.skipL0214
   4553  1879				   .condpart106
   4554  1879		       4c ab 18 	      jmp	.__Clear_Ch_0
   4555  187c
   4556  187c				   .skipL0214
   4557  187c				   .
   4558  187c							; 
   4559  187c
   4560  187c				   .
   4561  187c							; 
   4562  187c
   4563  187c				   .
   4564  187c							; 
   4565  187c
   4566  187c				   .
   4567  187c							; 
   4568  187c
   4569  187c				   .L0215		;  _Ch0_Counter  =  _Ch0_Counter  +  1
   4570  187c
   4571  187c		       e6 e0		      INC	_Ch0_Counter
   4572  187e				   .L0216		;  temp5  =  _SD_Shot[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4573  187e
   4574  187e		       a6 e0		      LDX	_Ch0_Counter
   4575  1880		       bd 16 1a 	      LDA	_SD_Shot,x
   4576  1883		       85 a0		      STA	temp5
   4577  1885		       e6 e0		      INC	_Ch0_Counter
   4578  1887				   .L0217		;  temp6  =  _SD_Shot[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4579  1887
   4580  1887		       a6 e0		      LDX	_Ch0_Counter
   4581  1889		       bd 16 1a 	      LDA	_SD_Shot,x
   4582  188c		       85 a1		      STA	temp6
   4583  188e		       e6 e0		      INC	_Ch0_Counter
   4584  1890				   .
   4585  1890							; 
   4586  1890
   4587  1890				   .
   4588  1890							; 
   4589  1890
   4590  1890				   .
   4591  1890							; 
   4592  1890
   4593  1890				   .
   4594  1890							; 
   4595  1890
   4596  1890				   .L0218		;  AUDV0  =  temp4
   4597  1890
   4598  1890		       a5 9f		      LDA	temp4
   4599  1892		       85 19		      STA	AUDV0
   4600  1894				   .L0219		;  AUDC0  =  temp5
   4601  1894
   4602  1894		       a5 a0		      LDA	temp5
   4603  1896		       85 15		      STA	AUDC0
   4604  1898				   .L0220		;  AUDF0  =  temp6
   4605  1898
   4606  1898		       a5 a1		      LDA	temp6
   4607  189a		       85 17		      STA	AUDF0
   4608  189c				   .
   4609  189c							; 
   4610  189c
   4611  189c				   .
   4612  189c							; 
   4613  189c
   4614  189c				   .
   4615  189c							; 
   4616  189c
   4617  189c				   .
   4618  189c							; 
   4619  189c
   4620  189c				   .L0221		;  _Ch0_Duration  =  _SD_Shot[_Ch0_Counter]  :  _Ch0_Counter  =  _Ch0_Counter	+  1
   4621  189c
   4622  189c		       a6 e0		      LDX	_Ch0_Counter
   4623  189e		       bd 16 1a 	      LDA	_SD_Shot,x
   4624  18a1		       85 df		      STA	_Ch0_Duration
   4625  18a3		       e6 e0		      INC	_Ch0_Counter
   4626  18a5				   .
   4627  18a5							; 
   4628  18a5
   4629  18a5				   .
   4630  18a5							; 
   4631  18a5
   4632  18a5				   .
   4633  18a5							; 
   4634  18a5
   4635  18a5				   .
   4636  18a5							; 
   4637  18a5
   4638  18a5				   .L0222		;  goto __Skip_Ch_0
   4639  18a5
   4640  18a5		       4c b1 18 	      jmp	.__Skip_Ch_0
   4641  18a8
   4642  18a8				   .
   4643  18a8							; 
   4644  18a8
   4645  18a8				   .__Skip_Ch0_Sound_004
   4646  18a8							; __Skip_Ch0_Sound_004
   4647  18a8
   4648  18a8				   .
   4649  18a8							; 
   4650  18a8
   4651  18a8				   .
   4652  18a8							; 
   4653  18a8
   4654  18a8				   .
   4655  18a8							; 
   4656  18a8
   4657  18a8				   .
   4658  18a8							; 
   4659  18a8
   4660  18a8				   .
   4661  18a8							; 
   4662  18a8
   4663  18a8				   .
   4664  18a8							; 
   4665  18a8
   4666  18a8				   .
   4667  18a8							; 
   4668  18a8
   4669  18a8				   .
   4670  18a8							; 
   4671  18a8
   4672  18a8				   .
   4673  18a8							; 
   4674  18a8
   4675  18a8				   .
   4676  18a8							; 
   4677  18a8
   4678  18a8				   .
   4679  18a8							; 
   4680  18a8
   4681  18a8				   .
   4682  18a8							; 
   4683  18a8
   4684  18a8				   .
   4685  18a8							; 
   4686  18a8
   4687  18a8				   .
   4688  18a8							; 
   4689  18a8
   4690  18a8				   .
   4691  18a8							; 
   4692  18a8
   4693  18a8				   .
   4694  18a8							; 
   4695  18a8
   4696  18a8				   .
   4697  18a8							; 
   4698  18a8
   4699  18a8				   .L0223		;  goto __Skip_Ch_0
   4700  18a8
   4701  18a8		       4c b1 18 	      jmp	.__Skip_Ch_0
   4702  18ab
   4703  18ab				   .
   4704  18ab							; 
   4705  18ab
   4706  18ab				   .
   4707  18ab							; 
   4708  18ab
   4709  18ab				   .
   4710  18ab							; 
   4711  18ab
   4712  18ab				   .
   4713  18ab							; 
   4714  18ab
   4715  18ab				   .
   4716  18ab							; 
   4717  18ab
   4718  18ab				   .
   4719  18ab							; 
   4720  18ab
   4721  18ab				   .
   4722  18ab							; 
   4723  18ab
   4724  18ab				   .__Clear_Ch_0
   4725  18ab							; __Clear_Ch_0
   4726  18ab
   4727  18ab				   .
   4728  18ab							; 
   4729  18ab
   4730  18ab				   .L0224		;  _Ch0_Sound	=  0  :  AUDV0	=  0
   4731  18ab
   4732  18ab		       a9 00		      LDA	#0
   4733  18ad		       85 de		      STA	_Ch0_Sound
   4734  18af		       85 19		      STA	AUDV0
   4735  18b1				   .
   4736  18b1							; 
   4737  18b1
   4738  18b1				   .
   4739  18b1							; 
   4740  18b1
   4741  18b1				   .
   4742  18b1							; 
   4743  18b1
   4744  18b1				   .
   4745  18b1							; 
   4746  18b1
   4747  18b1				   .
   4748  18b1							; 
   4749  18b1
   4750  18b1				   .
   4751  18b1							; 
   4752  18b1
   4753  18b1				   .
   4754  18b1							; 
   4755  18b1
   4756  18b1				   .__Skip_Ch_0
   4757  18b1							; __Skip_Ch_0
   4758  18b1
   4759  18b1				   .
   4760  18b1							; 
   4761  18b1
   4762  18b1				   .
   4763  18b1							; 
   4764  18b1
   4765  18b1				   .
   4766  18b1							; 
   4767  18b1
   4768  18b1				   .
   4769  18b1							; 
   4770  18b1
   4771  18b1				   .
   4772  18b1							; 
   4773  18b1
   4774  18b1				   .
   4775  18b1							; 
   4776  18b1
   4777  18b1				   .
   4778  18b1							; 
   4779  18b1
   4780  18b1				   .L0225		;  drawscreen
   4781  18b1
   4782  18b1		       85 ee		      sta	temp7
   4783  18b3		       a9 18		      lda	#>(ret_point8-1)
   4784  18b5		       48		      pha
   4785  18b6		       a9 c8		      lda	#<(ret_point8-1)
   4786  18b8		       48		      pha
   4787  18b9		       a9 f4		      lda	#>(drawscreen-1)
   4788  18bb		       48		      pha
   4789  18bc		       a9 39		      lda	#<(drawscreen-1)
   4790  18be		       48		      pha
   4791  18bf		       a5 ee		      lda	temp7
   4792  18c1		       48		      pha
   4793  18c2		       8a		      txa
   4794  18c3		       48		      pha
   4795  18c4		       a2 08		      ldx	#8
   4796  18c6		       4c eb ff 	      jmp	BS_jsr
   4797  18c9				   ret_point8
   4798  18c9				   .
   4799  18c9							; 
   4800  18c9
   4801  18c9				   .
   4802  18c9							; 
   4803  18c9
   4804  18c9				   .
   4805  18c9							; 
   4806  18c9
   4807  18c9				   .
   4808  18c9							; 
   4809  18c9
   4810  18c9				   .
   4811  18c9							; 
   4812  18c9
   4813  18c9				   .
   4814  18c9							; 
   4815  18c9
   4816  18c9				   .
   4817  18c9							; 
   4818  18c9
   4819  18c9				   .
   4820  18c9							; 
   4821  18c9
   4822  18c9				   .
   4823  18c9							; 
   4824  18c9
   4825  18c9				   .
   4826  18c9							; 
   4827  18c9
   4828  18c9				   .
   4829  18c9							; 
   4830  18c9
   4831  18c9				   .
   4832  18c9							; 
   4833  18c9
   4834  18c9				   .
   4835  18c9							; 
   4836  18c9
   4837  18c9				   .
   4838  18c9							; 
   4839  18c9
   4840  18c9				   .
   4841  18c9							; 
   4842  18c9
   4843  18c9				   .L0226		;  if !switchreset then _Bit7_Reset_Restrainer{7}  =  0  :  goto __Main_Loop
   4844  18c9
   4845  18c9		       a9 01		      lda	#1
   4846  18cb		       2c 82 02 	      bit	SWCHB
   4847  18ce		       f0 09		      BEQ	.skipL0226
   4848  18d0				   .condpart107
   4849  18d0		       a5 ec		      LDA	_Bit7_Reset_Restrainer
   4850  18d2		       29 7f		      AND	#127
   4851  18d4		       85 ec		      STA	_Bit7_Reset_Restrainer
   4852  18d6		       4c a1 10 	      jmp	.__Main_Loop
   4853  18d9
   4854  18d9				   .skipL0226
   4855  18d9				   .
   4856  18d9							; 
   4857  18d9
   4858  18d9				   .
   4859  18d9							; 
   4860  18d9
   4861  18d9				   .
   4862  18d9							; 
   4863  18d9
   4864  18d9				   .
   4865  18d9							; 
   4866  18d9
   4867  18d9				   .
   4868  18d9							; 
   4869  18d9
   4870  18d9				   .L0227		;  if _Bit7_Reset_Restrainer{7} then goto __Main_Loop
   4871  18d9
   4872  18d9		       24 ec		      BIT	_Bit7_Reset_Restrainer
   4873  18db		       10 03		      BPL	.skipL0227
   4874  18dd				   .condpart108
   4875  18dd		       4c a1 10 	      jmp	.__Main_Loop
   4876  18e0
   4877  18e0				   .skipL0227
   4878  18e0				   .
   4879  18e0							; 
   4880  18e0
   4881  18e0				   .
   4882  18e0							; 
   4883  18e0
   4884  18e0				   .
   4885  18e0							; 
   4886  18e0
   4887  18e0				   .
   4888  18e0							; 
   4889  18e0
   4890  18e0				   .L0228		;  goto __Start_Restart
   4891  18e0
   4892  18e0		       4c 00 10 	      jmp	.__Start_Restart
   4893  18e3
   4894  18e3				   .
   4895  18e3							; 
   4896  18e3
   4897  18e3				   .
   4898  18e3							; 
   4899  18e3
   4900  18e3				   .
   4901  18e3							; 
   4902  18e3
   4903  18e3				   .
   4904  18e3							; 
   4905  18e3
   4906  18e3				   .
   4907  18e3							; 
   4908  18e3
   4909  18e3				   .
   4910  18e3							; 
   4911  18e3
   4912  18e3				   .
   4913  18e3							; 
   4914  18e3
   4915  18e3				   .
   4916  18e3							; 
   4917  18e3
   4918  18e3				   .
   4919  18e3							; 
   4920  18e3
   4921  18e3				   .
   4922  18e3							; 
   4923  18e3
   4924  18e3				   .
   4925  18e3							; 
   4926  18e3
   4927  18e3				   .
   4928  18e3							; 
   4929  18e3
   4930  18e3				   .
   4931  18e3							; 
   4932  18e3
   4933  18e3				   .
   4934  18e3							; 
   4935  18e3
   4936  18e3				   .
   4937  18e3							; 
   4938  18e3
   4939  18e3				   .L0229		;  data _SD_Jump
   4940  18e3
   4941  18e3		       4c 37 19 	      JMP	.skipL0229
   4942  18e6				   _SD_Jump
   4943  18e6		       01 0c 1f 	      .byte.b	1,12,31
   4944  18e9
   4945  18e9		       01		      .byte.b	1
   4946  18ea
   4947  18ea		       08 0c 1f 	      .byte.b	8,12,31
   4948  18ed
   4949  18ed		       01		      .byte.b	1
   4950  18ee
   4951  18ee		       06 0c 1f 	      .byte.b	6,12,31
   4952  18f1
   4953  18f1		       01		      .byte.b	1
   4954  18f2
   4955  18f2		       08 0c 1f 	      .byte.b	8,12,31
   4956  18f5
   4957  18f5		       01		      .byte.b	1
   4958  18f6
   4959  18f6		       08 0c 1e 	      .byte.b	8,12,30
   4960  18f9
   4961  18f9		       01		      .byte.b	1
   4962  18fa
   4963  18fa		       08 0c 1d 	      .byte.b	8,12,29
   4964  18fd
   4965  18fd		       01		      .byte.b	1
   4966  18fe
   4967  18fe		       08 0c 1c 	      .byte.b	8,12,28
   4968  1901
   4969  1901		       01		      .byte.b	1
   4970  1902
   4971  1902		       08 0c 1b 	      .byte.b	8,12,27
   4972  1905
   4973  1905		       01		      .byte.b	1
   4974  1906
   4975  1906		       08 0c 1a 	      .byte.b	8,12,26
   4976  1909
   4977  1909		       01		      .byte.b	1
   4978  190a
   4979  190a		       08 0c 19 	      .byte.b	8,12,25
   4980  190d
   4981  190d		       01		      .byte.b	1
   4982  190e
   4983  190e		       08 0c 18 	      .byte.b	8,12,24
   4984  1911
   4985  1911		       01		      .byte.b	1
   4986  1912
   4987  1912		       08 0c 17 	      .byte.b	8,12,23
   4988  1915
   4989  1915		       01		      .byte.b	1
   4990  1916
   4991  1916		       08 0c 16 	      .byte.b	8,12,22
   4992  1919
   4993  1919		       01		      .byte.b	1
   4994  191a
   4995  191a		       08 0c 15 	      .byte.b	8,12,21
   4996  191d
   4997  191d		       01		      .byte.b	1
   4998  191e
   4999  191e		       08 0c 14 	      .byte.b	8,12,20
   5000  1921
   5001  1921		       01		      .byte.b	1
   5002  1922
   5003  1922		       08 0c 13 	      .byte.b	8,12,19
   5004  1925
   5005  1925		       01		      .byte.b	1
   5006  1926
   5007  1926		       06 0c 12 	      .byte.b	6,12,18
   5008  1929
   5009  1929		       01		      .byte.b	1
   5010  192a
   5011  192a		       04 0c 11 	      .byte.b	4,12,17
   5012  192d
   5013  192d		       01		      .byte.b	1
   5014  192e
   5015  192e		       02 0c 10 	      .byte.b	2,12,16
   5016  1931
   5017  1931		       02		      .byte.b	2
   5018  1932
   5019  1932		       00 00 00 	      .byte.b	0,0,0
   5020  1935
   5021  1935		       08		      .byte.b	8
   5022  1936
   5023  1936		       ff		      .byte.b	255
   5024  1937
   5025  1937				   .skipL0229
   5026  1937				   .
   5027  1937							; 
   5028  1937
   5029  1937				   .
   5030  1937							; 
   5031  1937
   5032  1937				   .
   5033  1937							; 
   5034  1937
   5035  1937				   .
   5036  1937							; 
   5037  1937
   5038  1937				   .
   5039  1937							; 
   5040  1937
   5041  1937				   .
   5042  1937							; 
   5043  1937
   5044  1937				   .
   5045  1937							; 
   5046  1937
   5047  1937				   .
   5048  1937							; 
   5049  1937
   5050  1937				   .L0230		;  data _SD_Fall
   5051  1937
   5052  1937		       4c bb 19 	      JMP	.skipL0230
   5053  193a				   _SD_Fall
   5054  193a		       06 0c 10 	      .byte.b	6,12,16
   5055  193d
   5056  193d		       01		      .byte.b	1
   5057  193e
   5058  193e		       08 0c 10 	      .byte.b	8,12,16
   5059  1941
   5060  1941		       01		      .byte.b	1
   5061  1942
   5062  1942		       06 0c 11 	      .byte.b	6,12,17
   5063  1945
   5064  1945		       01		      .byte.b	1
   5065  1946
   5066  1946		       08 0c 11 	      .byte.b	8,12,17
   5067  1949
   5068  1949		       01		      .byte.b	1
   5069  194a
   5070  194a		       06 0c 12 	      .byte.b	6,12,18
   5071  194d
   5072  194d		       01		      .byte.b	1
   5073  194e
   5074  194e		       08 0c 12 	      .byte.b	8,12,18
   5075  1951
   5076  1951		       01		      .byte.b	1
   5077  1952
   5078  1952		       06 0c 13 	      .byte.b	6,12,19
   5079  1955
   5080  1955		       01		      .byte.b	1
   5081  1956
   5082  1956		       08 0c 13 	      .byte.b	8,12,19
   5083  1959
   5084  1959		       01		      .byte.b	1
   5085  195a
   5086  195a		       06 0c 14 	      .byte.b	6,12,20
   5087  195d
   5088  195d		       01		      .byte.b	1
   5089  195e
   5090  195e		       08 0c 14 	      .byte.b	8,12,20
   5091  1961
   5092  1961		       01		      .byte.b	1
   5093  1962
   5094  1962		       06 0c 15 	      .byte.b	6,12,21
   5095  1965
   5096  1965		       01		      .byte.b	1
   5097  1966
   5098  1966		       08 0c 15 	      .byte.b	8,12,21
   5099  1969
   5100  1969		       01		      .byte.b	1
   5101  196a
   5102  196a		       06 0c 16 	      .byte.b	6,12,22
   5103  196d
   5104  196d		       01		      .byte.b	1
   5105  196e
   5106  196e		       08 0c 16 	      .byte.b	8,12,22
   5107  1971
   5108  1971		       01		      .byte.b	1
   5109  1972
   5110  1972		       06 0c 17 	      .byte.b	6,12,23
   5111  1975
   5112  1975		       01		      .byte.b	1
   5113  1976
   5114  1976		       08 0c 17 	      .byte.b	8,12,23
   5115  1979
   5116  1979		       01		      .byte.b	1
   5117  197a
   5118  197a		       06 0c 18 	      .byte.b	6,12,24
   5119  197d
   5120  197d		       01		      .byte.b	1
   5121  197e
   5122  197e		       08 0c 18 	      .byte.b	8,12,24
   5123  1981
   5124  1981		       01		      .byte.b	1
   5125  1982
   5126  1982		       06 0c 19 	      .byte.b	6,12,25
   5127  1985
   5128  1985		       01		      .byte.b	1
   5129  1986
   5130  1986		       08 0c 19 	      .byte.b	8,12,25
   5131  1989
   5132  1989		       01		      .byte.b	1
   5133  198a
   5134  198a		       06 0c 1a 	      .byte.b	6,12,26
   5135  198d
   5136  198d		       01		      .byte.b	1
   5137  198e
   5138  198e		       08 0c 1a 	      .byte.b	8,12,26
   5139  1991
   5140  1991		       01		      .byte.b	1
   5141  1992
   5142  1992		       06 0c 1b 	      .byte.b	6,12,27
   5143  1995
   5144  1995		       01		      .byte.b	1
   5145  1996
   5146  1996		       08 0c 1b 	      .byte.b	8,12,27
   5147  1999
   5148  1999		       01		      .byte.b	1
   5149  199a
   5150  199a		       06 0c 1c 	      .byte.b	6,12,28
   5151  199d
   5152  199d		       01		      .byte.b	1
   5153  199e
   5154  199e		       08 0c 1c 	      .byte.b	8,12,28
   5155  19a1
   5156  19a1		       01		      .byte.b	1
   5157  19a2
   5158  19a2		       06 0c 1d 	      .byte.b	6,12,29
   5159  19a5
   5160  19a5		       01		      .byte.b	1
   5161  19a6
   5162  19a6		       08 0c 1d 	      .byte.b	8,12,29
   5163  19a9
   5164  19a9		       01		      .byte.b	1
   5165  19aa
   5166  19aa		       06 0c 1e 	      .byte.b	6,12,30
   5167  19ad
   5168  19ad		       01		      .byte.b	1
   5169  19ae
   5170  19ae		       08 0c 1e 	      .byte.b	8,12,30
   5171  19b1
   5172  19b1		       01		      .byte.b	1
   5173  19b2
   5174  19b2		       06 0c 1f 	      .byte.b	6,12,31
   5175  19b5
   5176  19b5		       01		      .byte.b	1
   5177  19b6
   5178  19b6		       02 0c 1f 	      .byte.b	2,12,31
   5179  19b9
   5180  19b9		       02		      .byte.b	2
   5181  19ba
   5182  19ba		       ff		      .byte.b	255
   5183  19bb
   5184  19bb				   .skipL0230
   5185  19bb				   .
   5186  19bb							; 
   5187  19bb
   5188  19bb				   .
   5189  19bb							; 
   5190  19bb
   5191  19bb				   .
   5192  19bb							; 
   5193  19bb
   5194  19bb				   .
   5195  19bb							; 
   5196  19bb
   5197  19bb				   .
   5198  19bb							; 
   5199  19bb
   5200  19bb				   .
   5201  19bb							; 
   5202  19bb
   5203  19bb				   .
   5204  19bb							; 
   5205  19bb
   5206  19bb				   .
   5207  19bb							; 
   5208  19bb
   5209  19bb				   .L0231		;  data _SD_Slide
   5210  19bb
   5211  19bb		       4c 13 1a 	      JMP	.skipL0231
   5212  19be				   _SD_Slide
   5213  19be		       02 04 16 	      .byte.b	2,4,22
   5214  19c1
   5215  19c1		       01		      .byte.b	1
   5216  19c2
   5217  19c2		       01 04 15 	      .byte.b	1,4,21
   5218  19c5
   5219  19c5		       01		      .byte.b	1
   5220  19c6
   5221  19c6		       02 04 18 	      .byte.b	2,4,24
   5222  19c9
   5223  19c9		       01		      .byte.b	1
   5224  19ca
   5225  19ca		       01 04 14 	      .byte.b	1,4,20
   5226  19cd
   5227  19cd		       01		      .byte.b	1
   5228  19ce
   5229  19ce		       02 04 17 	      .byte.b	2,4,23
   5230  19d1
   5231  19d1		       01		      .byte.b	1
   5232  19d2
   5233  19d2		       01 04 19 	      .byte.b	1,4,25
   5234  19d5
   5235  19d5		       01		      .byte.b	1
   5236  19d6
   5237  19d6		       02 04 16 	      .byte.b	2,4,22
   5238  19d9
   5239  19d9		       01		      .byte.b	1
   5240  19da
   5241  19da		       01 04 14 	      .byte.b	1,4,20
   5242  19dd
   5243  19dd		       01		      .byte.b	1
   5244  19de
   5245  19de		       02 04 19 	      .byte.b	2,4,25
   5246  19e1
   5247  19e1		       01		      .byte.b	1
   5248  19e2
   5249  19e2		       01 04 15 	      .byte.b	1,4,21
   5250  19e5
   5251  19e5		       01		      .byte.b	1
   5252  19e6
   5253  19e6		       02 04 19 	      .byte.b	2,4,25
   5254  19e9
   5255  19e9		       01		      .byte.b	1
   5256  19ea
   5257  19ea		       01 04 16 	      .byte.b	1,4,22
   5258  19ed
   5259  19ed		       01		      .byte.b	1
   5260  19ee
   5261  19ee		       02 04 17 	      .byte.b	2,4,23
   5262  19f1
   5263  19f1		       01		      .byte.b	1
   5264  19f2
   5265  19f2		       01 04 16 	      .byte.b	1,4,22
   5266  19f5
   5267  19f5		       01		      .byte.b	1
   5268  19f6
   5269  19f6		       02 04 14 	      .byte.b	2,4,20
   5270  19f9
   5271  19f9		       01		      .byte.b	1
   5272  19fa
   5273  19fa		       01 04 18 	      .byte.b	1,4,24
   5274  19fd
   5275  19fd		       01		      .byte.b	1
   5276  19fe
   5277  19fe		       02 04 15 	      .byte.b	2,4,21
   5278  1a01
   5279  1a01		       01		      .byte.b	1
   5280  1a02
   5281  1a02		       01 04 17 	      .byte.b	1,4,23
   5282  1a05
   5283  1a05		       01		      .byte.b	1
   5284  1a06
   5285  1a06		       02 04 19 	      .byte.b	2,4,25
   5286  1a09
   5287  1a09		       01		      .byte.b	1
   5288  1a0a
   5289  1a0a		       01 04 18 	      .byte.b	1,4,24
   5290  1a0d
   5291  1a0d		       01		      .byte.b	1
   5292  1a0e
   5293  1a0e		       02 04 16 	      .byte.b	2,4,22
   5294  1a11
   5295  1a11		       01		      .byte.b	1
   5296  1a12
   5297  1a12		       ff		      .byte.b	255
   5298  1a13
   5299  1a13				   .skipL0231
   5300  1a13				   .
   5301  1a13							; 
   5302  1a13
   5303  1a13				   .
   5304  1a13							; 
   5305  1a13
   5306  1a13				   .
   5307  1a13							; 
   5308  1a13
   5309  1a13				   .
   5310  1a13							; 
   5311  1a13
   5312  1a13				   .
   5313  1a13							; 
   5314  1a13
   5315  1a13				   .
   5316  1a13							; 
   5317  1a13
   5318  1a13				   .
   5319  1a13							; 
   5320  1a13
   5321  1a13				   .
   5322  1a13							; 
   5323  1a13
   5324  1a13				   .L0232		;  data _SD_Shot
   5325  1a13
   5326  1a13		       4c 53 1a 	      JMP	.skipL0232
   5327  1a16				   _SD_Shot
   5328  1a16		       0f 0f 07 	      .byte.b	15,15,7
   5329  1a19
   5330  1a19		       01		      .byte.b	1
   5331  1a1a
   5332  1a1a		       0e 08 08 	      .byte.b	14,8,8
   5333  1a1d
   5334  1a1d		       01		      .byte.b	1
   5335  1a1e
   5336  1a1e		       0d 0f 09 	      .byte.b	13,15,9
   5337  1a21
   5338  1a21		       01		      .byte.b	1
   5339  1a22
   5340  1a22		       0c 08 0a 	      .byte.b	12,8,10
   5341  1a25
   5342  1a25		       01		      .byte.b	1
   5343  1a26
   5344  1a26		       0b 0f 0b 	      .byte.b	11,15,11
   5345  1a29
   5346  1a29		       01		      .byte.b	1
   5347  1a2a
   5348  1a2a		       0a 08 0c 	      .byte.b	10,8,12
   5349  1a2d
   5350  1a2d		       01		      .byte.b	1
   5351  1a2e
   5352  1a2e		       09 08 0d 	      .byte.b	9,8,13
   5353  1a31
   5354  1a31		       01		      .byte.b	1
   5355  1a32
   5356  1a32		       08 08 0e 	      .byte.b	8,8,14
   5357  1a35
   5358  1a35		       01		      .byte.b	1
   5359  1a36
   5360  1a36		       07 08 0f 	      .byte.b	7,8,15
   5361  1a39
   5362  1a39		       01		      .byte.b	1
   5363  1a3a
   5364  1a3a		       06 08 10 	      .byte.b	6,8,16
   5365  1a3d
   5366  1a3d		       01		      .byte.b	1
   5367  1a3e
   5368  1a3e		       05 08 11 	      .byte.b	5,8,17
   5369  1a41
   5370  1a41		       01		      .byte.b	1
   5371  1a42
   5372  1a42		       04 0f 12 	      .byte.b	4,15,18
   5373  1a45
   5374  1a45		       01		      .byte.b	1
   5375  1a46
   5376  1a46		       03 08 13 	      .byte.b	3,8,19
   5377  1a49
   5378  1a49		       01		      .byte.b	1
   5379  1a4a
   5380  1a4a		       02 0f 14 	      .byte.b	2,15,20
   5381  1a4d
   5382  1a4d		       01		      .byte.b	1
   5383  1a4e
   5384  1a4e		       01 08 15 	      .byte.b	1,8,21
   5385  1a51
   5386  1a51		       08		      .byte.b	8
   5387  1a52
   5388  1a52		       ff		      .byte.b	255
   5389  1a53
   5390  1a53				   .skipL0232
   5391  1a53				   .
   5392  1a53							; 
   5393  1a53
   5394  1a53				   .
   5395  1a53							; 
   5396  1a53
   5397  1a53				   .
   5398  1a53							; 
   5399  1a53
   5400  1a53				   .
   5401  1a53							; 
   5402  1a53
   5403  1a53				   .
   5404  1a53							; 
   5405  1a53
   5406  1a53				   .
   5407  1a53							; 
   5408  1a53
   5409  1a53				   .
   5410  1a53							; 
   5411  1a53
   5412  1a53				   .
   5413  1a53							; 
   5414  1a53
   5415  1a53				   .
   5416  1a53							; 
   5417  1a53
   5418  1a53				   .
   5419  1a53							; 
   5420  1a53
   5421  1a53				   .__Frame0
   5422  1a53							; __Frame0
   5423  1a53
   5424  1a53				   .L0233		;  player1:
   5425  1a53
   5426  1a53		       a2 0a		      LDX	#<playerL0233_1
   5427  1a55		       86 8c		      STX	player1pointerlo
   5428  1a57		       a9 f6		      LDA	#>playerL0233_1
   5429  1a59		       85 8d		      STA	player1pointerhi
   5430  1a5b		       a9 09		      LDA	#9
   5431  1a5d		       85 8f		      STA	player1height
   5432  1a5f				   .
   5433  1a5f							; 
   5434  1a5f
   5435  1a5f				   .L0234		;  goto __Done_Anim_jump
   5436  1a5f
   5437  1a5f		       4c 38 16 	      jmp	.__Done_Anim_jump
   5438  1a62
   5439  1a62				   .
   5440  1a62							; 
   5441  1a62
   5442  1a62				   .
   5443  1a62							; 
   5444  1a62
   5445  1a62				   .__Frame1
   5446  1a62							; __Frame1
   5447  1a62
   5448  1a62				   .L0235		;  player1:
   5449  1a62
   5450  1a62		       a2 14		      LDX	#<playerL0235_1
   5451  1a64		       86 8c		      STX	player1pointerlo
   5452  1a66		       a9 f6		      LDA	#>playerL0235_1
   5453  1a68		       85 8d		      STA	player1pointerhi
   5454  1a6a		       a9 09		      LDA	#9
   5455  1a6c		       85 8f		      STA	player1height
   5456  1a6e				   .
   5457  1a6e							; 
   5458  1a6e
   5459  1a6e				   .L0236		;  goto __Done_Anim_jump
   5460  1a6e
   5461  1a6e		       4c 38 16 	      jmp	.__Done_Anim_jump
   5462  1a71
   5463  1a71				   .
   5464  1a71							; 
   5465  1a71
   5466  1a71				   .
   5467  1a71							; 
   5468  1a71
   5469  1a71				   .__Frame2
   5470  1a71							; __Frame2
   5471  1a71
   5472  1a71				   .L0237		;  player1:
   5473  1a71
   5474  1a71		       a2 1e		      LDX	#<playerL0237_1
   5475  1a73		       86 8c		      STX	player1pointerlo
   5476  1a75		       a9 f6		      LDA	#>playerL0237_1
   5477  1a77		       85 8d		      STA	player1pointerhi
   5478  1a79		       a9 09		      LDA	#9
   5479  1a7b		       85 8f		      STA	player1height
   5480  1a7d				   .
   5481  1a7d							; 
   5482  1a7d
   5483  1a7d				   .L0238		;  goto __Done_Anim_jump
   5484  1a7d
   5485  1a7d		       4c 38 16 	      jmp	.__Done_Anim_jump
   5486  1a80
   5487  1a80				   .
   5488  1a80							; 
   5489  1a80
   5490  1a80				   .
   5491  1a80							; 
   5492  1a80
   5493  1a80				   .L0239		;  bank 2
   5494  1a80
   5495  1a80					      if	ECHO1
      1364 bytes of ROM space left in bank 1
   5496  1a80					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   5497  1a80					      endif
   5498  1a80		       00 01	   ECHO1      =	1
   5499  1fd4					      ORG	$1FF4-bscode_length
   5500  1fd4					      RORG	$1FF4-bscode_length
   5501  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   5502  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5503  1fd6				  -	      stx	FASTFETCH
   5504  1fd6					      endif
   5505  1fd6		       9a		      txs
   5506  1fd7				  -	      if	bankswitch == 64
   5507  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5508  1fd7					      else
   5509  1fd7		       a9 f2		      lda	#>(start-1)
   5510  1fd9					      endif
   5511  1fd9		       48		      pha
   5512  1fda		       a9 4f		      lda	#<(start-1)
   5513  1fdc		       48		      pha
   5514  1fdd		       48		      pha
   5515  1fde		       8a		      txa
   5516  1fdf		       48		      pha
   5517  1fe0		       ba		      tsx
   5518  1fe1					      if	bankswitch != 64
   5519  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   5520  1fe3		       2a		      rol
   5521  1fe4		       2a		      rol
   5522  1fe5		       2a		      rol
   5523  1fe6		       2a		      rol
   5524  1fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5525  1fe9		       aa		      tax
   5526  1fea		       e8		      inx
   5527  1feb				  -	      else
   5528  1feb				  -	      lda	4,x	; get high byte of return address
   5529  1feb				  -	      tay
   5530  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5531  1feb				  -	      sta	4,x
   5532  1feb				  -	      tya
   5533  1feb				  -	      lsr
   5534  1feb				  -	      lsr
   5535  1feb				  -	      lsr
   5536  1feb				  -	      lsr
   5537  1feb				  -	      tax
   5538  1feb				  -	      inx
   5539  1feb					      endif
   5540  1feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5541  1fee		       68		      pla
   5542  1fef		       aa		      tax
   5543  1ff0		       68		      pla
   5544  1ff1		       60		      rts
   5545  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5546  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5547  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5548  1ff2					      endif
   5549  1ffc					      ORG	$1FFC
   5550  1ffc					      RORG	$1FFC
   5551  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   5552  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   5553  2000					      ORG	$2000
   5554  2000					      RORG	$3000
   5555  2000				   .
   5556  2000							; 
   5557  2000
   5558  2000				   .__Slow_Scroll_left
   5559  2000							; __Slow_Scroll_left
   5560  2000
   5561  2000				   .L0240		;  for _Generic_Counter  =  0 to 50
   5562  2000
   5563  2000		       a9 00		      LDA	#0
   5564  2002		       85 e2		      STA	_Generic_Counter
   5565  2004				   .L0240for_Generic_Counter
   5566  2004				   .L0241		;  pfscroll left
   5567  2004
   5568  2004		       a9 00		      LDA	#0
   5569  2006		       85 ee		      sta	temp7
   5570  2008		       a9 30		      lda	#>(ret_point9-1)
   5571  200a		       48		      pha
   5572  200b		       a9 1d		      lda	#<(ret_point9-1)
   5573  200d		       48		      pha
   5574  200e		       a9 f3		      lda	#>(pfscroll-1)
   5575  2010		       48		      pha
   5576  2011		       a9 61		      lda	#<(pfscroll-1)
   5577  2013		       48		      pha
   5578  2014		       a5 ee		      lda	temp7
   5579  2016		       48		      pha
   5580  2017		       8a		      txa
   5581  2018		       48		      pha
   5582  2019		       a2 08		      ldx	#8
   5583  201b		       4c eb ff 	      jmp	BS_jsr
   5584  201e				   ret_point9
   5585  201e				   .L0242		;  return
   5586  201e
   5587  201e		       ba		      tsx
   5588  201f		       b5 02		      lda	2,x	; check return address
   5589  2021		       49 30		      eor	#(>*)	; vs. current PCH
   5590  2023		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   5591  2025		       f0 03		      beq	*+5	; if equal, do normal return
   5592  2027		       4c dd ff 	      JMP	BS_return
   5593  202a		       60		      RTS
   5594  202b				   .
   5595  202b							; 
   5596  202b
   5597  202b				   .__Slow_Scroll_right
   5598  202b							; __Slow_Scroll_right
   5599  202b
   5600  202b				   .L0243		;  for _Generic_Counter  =  0 to 50
   5601  202b
   5602  202b		       a9 00		      LDA	#0
   5603  202d		       85 e2		      STA	_Generic_Counter
   5604  202f				   .L0243for_Generic_Counter
   5605  202f				   .L0244		;  pfscroll right
   5606  202f
   5607  202f		       a9 01		      LDA	#1
   5608  2031		       85 ee		      sta	temp7
   5609  2033		       a9 30		      lda	#>(ret_point10-1)
   5610  2035		       48		      pha
   5611  2036		       a9 48		      lda	#<(ret_point10-1)
   5612  2038		       48		      pha
   5613  2039		       a9 f3		      lda	#>(pfscroll-1)
   5614  203b		       48		      pha
   5615  203c		       a9 61		      lda	#<(pfscroll-1)
   5616  203e		       48		      pha
   5617  203f		       a5 ee		      lda	temp7
   5618  2041		       48		      pha
   5619  2042		       8a		      txa
   5620  2043		       48		      pha
   5621  2044		       a2 08		      ldx	#8
   5622  2046		       4c eb ff 	      jmp	BS_jsr
   5623  2049				   ret_point10
   5624  2049				   .L0245		;  return
   5625  2049		       ba		      tsx
   5626  204a		       b5 02		      lda	2,x	; check return address
   5627  204c		       49 30		      eor	#(>*)	; vs. current PCH
   5628  204e		       29 e0		      and	#$E0	;  mask off all but top 3 bits
   5629  2050		       f0 03		      beq	*+5	; if equal, do normal return
   5630  2052		       4c dd ff 	      JMP	BS_return
   5631  2055		       60		      RTS
   5632  2056					      if	ECHO2
      3966 bytes of ROM space left in bank 2
   5633  2056					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   5634  2056					      endif
   5635  2056		       00 01	   ECHO2      =	1
   5636  2fd4					      ORG	$2FF4-bscode_length
   5637  2fd4					      RORG	$3FF4-bscode_length
   5638  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   5639  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5640  2fd6				  -	      stx	FASTFETCH
   5641  2fd6					      endif
   5642  2fd6		       9a		      txs
   5643  2fd7				  -	      if	bankswitch == 64
   5644  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5645  2fd7					      else
   5646  2fd7		       a9 f2		      lda	#>(start-1)
   5647  2fd9					      endif
   5648  2fd9		       48		      pha
   5649  2fda		       a9 4f		      lda	#<(start-1)
   5650  2fdc		       48		      pha
   5651  2fdd		       48		      pha
   5652  2fde		       8a		      txa
   5653  2fdf		       48		      pha
   5654  2fe0		       ba		      tsx
   5655  2fe1					      if	bankswitch != 64
   5656  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   5657  2fe3		       2a		      rol
   5658  2fe4		       2a		      rol
   5659  2fe5		       2a		      rol
   5660  2fe6		       2a		      rol
   5661  2fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5662  2fe9		       aa		      tax
   5663  2fea		       e8		      inx
   5664  2feb				  -	      else
   5665  2feb				  -	      lda	4,x	; get high byte of return address
   5666  2feb				  -	      tay
   5667  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5668  2feb				  -	      sta	4,x
   5669  2feb				  -	      tya
   5670  2feb				  -	      lsr
   5671  2feb				  -	      lsr
   5672  2feb				  -	      lsr
   5673  2feb				  -	      lsr
   5674  2feb				  -	      tax
   5675  2feb				  -	      inx
   5676  2feb					      endif
   5677  2feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5678  2fee		       68		      pla
   5679  2fef		       aa		      tax
   5680  2ff0		       68		      pla
   5681  2ff1		       60		      rts
   5682  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5683  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5684  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5685  2ff2					      endif
   5686  2ffc					      ORG	$2FFC
   5687  2ffc					      RORG	$3FFC
   5688  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   5689  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   5690  3000					      ORG	$3000
   5691  3000					      RORG	$5000
   5692  3000					      if	ECHO3
      4052 bytes of ROM space left in bank 3
   5693  3000					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   5694  3000					      endif
   5695  3000		       00 01	   ECHO3      =	1
   5696  3fd4					      ORG	$3FF4-bscode_length
   5697  3fd4					      RORG	$5FF4-bscode_length
   5698  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   5699  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5700  3fd6				  -	      stx	FASTFETCH
   5701  3fd6					      endif
   5702  3fd6		       9a		      txs
   5703  3fd7				  -	      if	bankswitch == 64
   5704  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5705  3fd7					      else
   5706  3fd7		       a9 f2		      lda	#>(start-1)
   5707  3fd9					      endif
   5708  3fd9		       48		      pha
   5709  3fda		       a9 4f		      lda	#<(start-1)
   5710  3fdc		       48		      pha
   5711  3fdd		       48		      pha
   5712  3fde		       8a		      txa
   5713  3fdf		       48		      pha
   5714  3fe0		       ba		      tsx
   5715  3fe1					      if	bankswitch != 64
   5716  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   5717  3fe3		       2a		      rol
   5718  3fe4		       2a		      rol
   5719  3fe5		       2a		      rol
   5720  3fe6		       2a		      rol
   5721  3fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5722  3fe9		       aa		      tax
   5723  3fea		       e8		      inx
   5724  3feb				  -	      else
   5725  3feb				  -	      lda	4,x	; get high byte of return address
   5726  3feb				  -	      tay
   5727  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5728  3feb				  -	      sta	4,x
   5729  3feb				  -	      tya
   5730  3feb				  -	      lsr
   5731  3feb				  -	      lsr
   5732  3feb				  -	      lsr
   5733  3feb				  -	      lsr
   5734  3feb				  -	      tax
   5735  3feb				  -	      inx
   5736  3feb					      endif
   5737  3feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5738  3fee		       68		      pla
   5739  3fef		       aa		      tax
   5740  3ff0		       68		      pla
   5741  3ff1		       60		      rts
   5742  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5743  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5744  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5745  3ff2					      endif
   5746  3ffc					      ORG	$3FFC
   5747  3ffc					      RORG	$5FFC
   5748  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   5749  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   5750  4000					      ORG	$4000
   5751  4000					      RORG	$7000
   5752  4000					      if	ECHO4
      4052 bytes of ROM space left in bank 4
   5753  4000					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   5754  4000					      endif
   5755  4000		       00 01	   ECHO4      =	1
   5756  4fd4					      ORG	$4FF4-bscode_length
   5757  4fd4					      RORG	$7FF4-bscode_length
   5758  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   5759  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5760  4fd6				  -	      stx	FASTFETCH
   5761  4fd6					      endif
   5762  4fd6		       9a		      txs
   5763  4fd7				  -	      if	bankswitch == 64
   5764  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5765  4fd7					      else
   5766  4fd7		       a9 f2		      lda	#>(start-1)
   5767  4fd9					      endif
   5768  4fd9		       48		      pha
   5769  4fda		       a9 4f		      lda	#<(start-1)
   5770  4fdc		       48		      pha
   5771  4fdd		       48		      pha
   5772  4fde		       8a		      txa
   5773  4fdf		       48		      pha
   5774  4fe0		       ba		      tsx
   5775  4fe1					      if	bankswitch != 64
   5776  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   5777  4fe3		       2a		      rol
   5778  4fe4		       2a		      rol
   5779  4fe5		       2a		      rol
   5780  4fe6		       2a		      rol
   5781  4fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5782  4fe9		       aa		      tax
   5783  4fea		       e8		      inx
   5784  4feb				  -	      else
   5785  4feb				  -	      lda	4,x	; get high byte of return address
   5786  4feb				  -	      tay
   5787  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5788  4feb				  -	      sta	4,x
   5789  4feb				  -	      tya
   5790  4feb				  -	      lsr
   5791  4feb				  -	      lsr
   5792  4feb				  -	      lsr
   5793  4feb				  -	      lsr
   5794  4feb				  -	      tax
   5795  4feb				  -	      inx
   5796  4feb					      endif
   5797  4feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5798  4fee		       68		      pla
   5799  4fef		       aa		      tax
   5800  4ff0		       68		      pla
   5801  4ff1		       60		      rts
   5802  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5803  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5804  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5805  4ff2					      endif
   5806  4ffc					      ORG	$4FFC
   5807  4ffc					      RORG	$7FFC
   5808  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   5809  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   5810  5000					      ORG	$5000
   5811  5000					      RORG	$9000
   5812  5000					      if	ECHO5
      4052 bytes of ROM space left in bank 5
   5813  5000					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   5814  5000					      endif
   5815  5000		       00 01	   ECHO5      =	1
   5816  5fd4					      ORG	$5FF4-bscode_length
   5817  5fd4					      RORG	$9FF4-bscode_length
   5818  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   5819  5fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5820  5fd6				  -	      stx	FASTFETCH
   5821  5fd6					      endif
   5822  5fd6		       9a		      txs
   5823  5fd7				  -	      if	bankswitch == 64
   5824  5fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5825  5fd7					      else
   5826  5fd7		       a9 f2		      lda	#>(start-1)
   5827  5fd9					      endif
   5828  5fd9		       48		      pha
   5829  5fda		       a9 4f		      lda	#<(start-1)
   5830  5fdc		       48		      pha
   5831  5fdd		       48		      pha
   5832  5fde		       8a		      txa
   5833  5fdf		       48		      pha
   5834  5fe0		       ba		      tsx
   5835  5fe1					      if	bankswitch != 64
   5836  5fe1		       b5 04		      lda	4,x	; get high byte of return address
   5837  5fe3		       2a		      rol
   5838  5fe4		       2a		      rol
   5839  5fe5		       2a		      rol
   5840  5fe6		       2a		      rol
   5841  5fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5842  5fe9		       aa		      tax
   5843  5fea		       e8		      inx
   5844  5feb				  -	      else
   5845  5feb				  -	      lda	4,x	; get high byte of return address
   5846  5feb				  -	      tay
   5847  5feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5848  5feb				  -	      sta	4,x
   5849  5feb				  -	      tya
   5850  5feb				  -	      lsr
   5851  5feb				  -	      lsr
   5852  5feb				  -	      lsr
   5853  5feb				  -	      lsr
   5854  5feb				  -	      tax
   5855  5feb				  -	      inx
   5856  5feb					      endif
   5857  5feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5858  5fee		       68		      pla
   5859  5fef		       aa		      tax
   5860  5ff0		       68		      pla
   5861  5ff1		       60		      rts
   5862  5ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5863  5ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5864  5ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5865  5ff2					      endif
   5866  5ffc					      ORG	$5FFC
   5867  5ffc					      RORG	$9FFC
   5868  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   5869  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   5870  6000					      ORG	$6000
   5871  6000					      RORG	$B000
   5872  6000					      if	ECHO6
      4052 bytes of ROM space left in bank 6
   5873  6000					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   5874  6000					      endif
   5875  6000		       00 01	   ECHO6      =	1
   5876  6fd4					      ORG	$6FF4-bscode_length
   5877  6fd4					      RORG	$BFF4-bscode_length
   5878  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   5879  6fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5880  6fd6				  -	      stx	FASTFETCH
   5881  6fd6					      endif
   5882  6fd6		       9a		      txs
   5883  6fd7				  -	      if	bankswitch == 64
   5884  6fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5885  6fd7					      else
   5886  6fd7		       a9 f2		      lda	#>(start-1)
   5887  6fd9					      endif
   5888  6fd9		       48		      pha
   5889  6fda		       a9 4f		      lda	#<(start-1)
   5890  6fdc		       48		      pha
   5891  6fdd		       48		      pha
   5892  6fde		       8a		      txa
   5893  6fdf		       48		      pha
   5894  6fe0		       ba		      tsx
   5895  6fe1					      if	bankswitch != 64
   5896  6fe1		       b5 04		      lda	4,x	; get high byte of return address
   5897  6fe3		       2a		      rol
   5898  6fe4		       2a		      rol
   5899  6fe5		       2a		      rol
   5900  6fe6		       2a		      rol
   5901  6fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5902  6fe9		       aa		      tax
   5903  6fea		       e8		      inx
   5904  6feb				  -	      else
   5905  6feb				  -	      lda	4,x	; get high byte of return address
   5906  6feb				  -	      tay
   5907  6feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5908  6feb				  -	      sta	4,x
   5909  6feb				  -	      tya
   5910  6feb				  -	      lsr
   5911  6feb				  -	      lsr
   5912  6feb				  -	      lsr
   5913  6feb				  -	      lsr
   5914  6feb				  -	      tax
   5915  6feb				  -	      inx
   5916  6feb					      endif
   5917  6feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5918  6fee		       68		      pla
   5919  6fef		       aa		      tax
   5920  6ff0		       68		      pla
   5921  6ff1		       60		      rts
   5922  6ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5923  6ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5924  6ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5925  6ff2					      endif
   5926  6ffc					      ORG	$6FFC
   5927  6ffc					      RORG	$BFFC
   5928  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   5929  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   5930  7000					      ORG	$7000
   5931  7000					      RORG	$D000
   5932  7000					      if	ECHO7
      4052 bytes of ROM space left in bank 7
   5933  7000					      echo	"    ",[(start_bank7 - *)]d , "bytes of ROM space left in bank 7")
   5934  7000					      endif
   5935  7000		       00 01	   ECHO7      =	1
   5936  7fd4					      ORG	$7FF4-bscode_length
   5937  7fd4					      RORG	$DFF4-bscode_length
   5938  7fd4		       a2 ff	   start_bank7 ldx	#$ff
   5939  7fd6				  -	      ifconst	FASTFETCH	; using DPC+
   5940  7fd6				  -	      stx	FASTFETCH
   5941  7fd6					      endif
   5942  7fd6		       9a		      txs
   5943  7fd7				  -	      if	bankswitch == 64
   5944  7fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5945  7fd7					      else
   5946  7fd7		       a9 f2		      lda	#>(start-1)
   5947  7fd9					      endif
   5948  7fd9		       48		      pha
   5949  7fda		       a9 4f		      lda	#<(start-1)
   5950  7fdc		       48		      pha
   5951  7fdd		       48		      pha
   5952  7fde		       8a		      txa
   5953  7fdf		       48		      pha
   5954  7fe0		       ba		      tsx
   5955  7fe1					      if	bankswitch != 64
   5956  7fe1		       b5 04		      lda	4,x	; get high byte of return address
   5957  7fe3		       2a		      rol
   5958  7fe4		       2a		      rol
   5959  7fe5		       2a		      rol
   5960  7fe6		       2a		      rol
   5961  7fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5962  7fe9		       aa		      tax
   5963  7fea		       e8		      inx
   5964  7feb				  -	      else
   5965  7feb				  -	      lda	4,x	; get high byte of return address
   5966  7feb				  -	      tay
   5967  7feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5968  7feb				  -	      sta	4,x
   5969  7feb				  -	      tya
   5970  7feb				  -	      lsr
   5971  7feb				  -	      lsr
   5972  7feb				  -	      lsr
   5973  7feb				  -	      lsr
   5974  7feb				  -	      tax
   5975  7feb				  -	      inx
   5976  7feb					      endif
   5977  7feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   5978  7fee		       68		      pla
   5979  7fef		       aa		      tax
   5980  7ff0		       68		      pla
   5981  7ff1		       60		      rts
   5982  7ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5983  7ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5984  7ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5985  7ff2					      endif
   5986  7ffc					      ORG	$7FFC
   5987  7ffc					      RORG	$DFFC
   5988  7ffc		       d4 df		      .word.w	(start_bank7 & $ffff)
   5989  7ffe		       d4 df		      .word.w	(start_bank7 & $ffff)
   5990  8000					      ORG	$8000
   5991  8000					      RORG	$F000
   5992  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5993  8000
   5994  8000							; This is a 2-line kernel!
   5995  8000					      ifnconst	vertical_reflect
   5996  8000				   kernel
   5997  8000					      endif
   5998  8000		       85 02		      sta	WSYNC
   5999  8002		       a9 ff		      lda	#255
   6000  8004		       8d 96 02 	      sta	TIM64T
   6001  8007
   6002  8007		       a9 01		      lda	#1
   6003  8009		       85 27		      sta	VDELBL
   6004  800b		       85 25		      sta	VDELP0
   6005  800d		       a6 92		      ldx	ballheight
   6006  800f		       e8		      inx
   6007  8010		       e8		      inx
   6008  8011		       86 9f		      stx	temp4
   6009  8013		       a5 86		      lda	player1y
   6010  8015		       85 9e		      sta	temp3
   6011  8017
   6012  8017				  -	      ifconst	shakescreen
   6013  8017				  -	      jsr	doshakescreen
   6014  8017					      else
   6015  8017		       a6 90		      ldx	missile0height
   6016  8019		       e8		      inx
   6017  801a					      endif
   6018  801a
   6019  801a		       e8		      inx
   6020  801b		       86 f6		      stx	stack1
   6021  801d
   6022  801d		       a5 89		      lda	bally
   6023  801f		       85 f7		      sta	stack2
   6024  8021
   6025  8021		       a5 85		      lda	player0y
   6026  8023		       a2 00		      ldx	#0
   6027  8025		       85 02		      sta	WSYNC
   6028  8027		       86 1b		      stx	GRP0
   6029  8029		       86 1c		      stx	GRP1
   6030  802b		       86 0e		      stx	PF1L
   6031  802d		       86 0f		      stx	PF2
   6032  802f		       86 2c		      stx	CXCLR
   6033  8031				  -	      ifconst	readpaddle
   6034  8031				  -	      stx	paddle
   6035  8031					      else
      0  8031					      sleep	3
      1  8031				   .CYCLES    SET	3
      2  8031
      3  8031				  -	      IF	.CYCLES < 2
      4  8031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8031				  -	      ERR
      6  8031					      ENDIF
      7  8031
      8  8031					      IF	.CYCLES & 1
      9  8031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8031		       04 00		      nop	0
     11  8033				  -	      ELSE
     12  8033				  -	      bit	VSYNC
     13  8033					      ENDIF
     14  8033				   .CYCLES    SET	.CYCLES - 3
     15  8033					      ENDIF
     16  8033
     17  8033				  -	      REPEAT	.CYCLES / 2
     18  8033				  -	      nop
     19  8033					      REPEND
   6037  8033					      endif
   6038  8033
   6039  8033		       95 9d		      sta	temp2,x
   6040  8035
   6041  8035							;store these so they can be retrieved later
   6042  8035					      ifnconst	pfres
   6043  8035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   6044  8037				  -	      else
   6045  8037				  -	      ldx	#132-pfres*pfwidth
   6046  8037					      endif
   6047  8037
   6048  8037		       c6 85		      dec	player0y
   6049  8039
   6050  8039		       a5 91		      lda	missile0y
   6051  803b		       85 a0		      sta	temp5
   6052  803d		       a5 88		      lda	missile1y
   6053  803f		       85 a1		      sta	temp6
   6054  8041
   6055  8041		       a5 ef		      lda	playfieldpos
   6056  8043		       85 9c		      sta	temp1
   6057  8045
   6058  8045				  -	      ifconst	pfrowheight
   6059  8045				  -	      lda	#pfrowheight+2
   6060  8045					      else
   6061  8045					      ifnconst	pfres
   6062  8045		       a9 0a		      lda	#10
   6063  8047				  -	      else
   6064  8047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   6065  8047					      endif
   6066  8047					      endif
   6067  8047		       18		      clc
   6068  8048		       e5 ef		      sbc	playfieldpos
   6069  804a		       85 ef		      sta	playfieldpos
   6070  804c		       4c 74 f0 	      jmp	.startkernel
   6071  804f
   6072  804f				   .skipDrawP0
   6073  804f		       a9 00		      lda	#0
   6074  8051		       a8		      tay
   6075  8052		       4c a3 f0 	      jmp	.continueP0
   6076  8055
   6077  8055				   .skipDrawP1
   6078  8055		       a9 00		      lda	#0
   6079  8057		       a8		      tay
   6080  8058		       4c 7e f0 	      jmp	.continueP1
   6081  805b
   6082  805b				   .kerloop		; enter at cycle 59??
   6083  805b
   6084  805b				   continuekernel
      0  805b					      sleep	2
      1  805b				   .CYCLES    SET	2
      2  805b
      3  805b				  -	      IF	.CYCLES < 2
      4  805b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  805b				  -	      ERR
      6  805b					      ENDIF
      7  805b
      8  805b				  -	      IF	.CYCLES & 1
      9  805b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  805b				  -	      nop	0
     11  805b				  -	      ELSE
     12  805b				  -	      bit	VSYNC
     13  805b				  -	      ENDIF
     14  805b				  -.CYCLES    SET	.CYCLES - 3
     15  805b					      ENDIF
     16  805b
     17  805b					      REPEAT	.CYCLES / 2
     18  805b		       ea		      nop
     19  805c					      REPEND
   6086  805c				   continuekernel2
   6087  805c		       a5 92		      lda	ballheight
   6088  805e
   6089  805e				  -	      ifconst	pfres
   6090  805e				  -	      ldy	playfield+pfres*pfwidth-132,x
   6091  805e				  -	      sty	PF1L	;3
   6092  805e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   6093  805e				  -	      sty	PF2L	;3
   6094  805e				  -	      ldy	playfield+pfres*pfwidth-129,x
   6095  805e				  -	      sty	PF1R	; 3 too early?
   6096  805e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   6097  805e				  -	      sty	PF2R	;3
   6098  805e					      else
   6099  805e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   6100  8060		       84 0e		      sty	PF1L	;3
   6101  8062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   6102  8064		       84 0f		      sty	PF2L	;3
   6103  8066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   6104  8068		       84 0e		      sty	PF1R	; 3 too early?
   6105  806a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   6106  806c		       84 0f		      sty	PF2R	;3
   6107  806e					      endif
   6108  806e
   6109  806e							; should be playfield+$38 for width=2
   6110  806e
   6111  806e		       c7 89		      dcp	bally
   6112  8070		       2a		      rol
   6113  8071		       2a		      rol
   6114  8072							; rol
   6115  8072							; rol
   6116  8072				   goback
   6117  8072		       85 1f		      sta	ENABL
   6118  8074				   .startkernel
   6119  8074		       a5 8f		      lda	player1height	;3
   6120  8076		       c7 86		      dcp	player1y	;5
   6121  8078		       90 db		      bcc	.skipDrawP1	;2
   6122  807a		       a4 86		      ldy	player1y	;3
   6123  807c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   6124  807e							; so it doesn't cross a page boundary!
   6125  807e
   6126  807e				   .continueP1
   6127  807e		       85 1c		      sta	GRP1	;3
   6128  8080
   6129  8080				  -	      ifnconst	player1colors
   6130  8080				  -	      lda	missile1height	;3
   6131  8080				  -	      dcp	missile1y	;5
   6132  8080				  -	      rol		;2
   6133  8080				  -	      rol		;2
   6134  8080				  -	      sta	ENAM1	;3
   6135  8080					      else
   6136  8080		       b1 87		      lda	(player1color),y
   6137  8082		       85 07		      sta	COLUP1
   6138  8084				  -	      ifnconst	playercolors
   6139  8084				  -	      sleep	7
   6140  8084					      else
   6141  8084		       ad 82 00 	      lda.w	player0colorstore
   6142  8087		       85 06		      sta	COLUP0
   6143  8089					      endif
   6144  8089					      endif
   6145  8089
   6146  8089				  -	      ifconst	pfres
   6147  8089				  -	      lda	playfield+pfres*pfwidth-132,x
   6148  8089				  -	      sta	PF1L	;3
   6149  8089				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   6150  8089				  -	      sta	PF2L	;3
   6151  8089				  -	      lda	playfield+pfres*pfwidth-129,x
   6152  8089				  -	      sta	PF1R	; 3 too early?
   6153  8089				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   6154  8089				  -	      sta	PF2R	;3
   6155  8089					      else
   6156  8089		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   6157  808b		       85 0e		      sta	PF1L	;3
   6158  808d		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   6159  808f		       85 0f		      sta	PF2L	;3
   6160  8091		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   6161  8093		       85 0e		      sta	PF1R	; 3 too early?
   6162  8095		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   6163  8097		       85 0f		      sta	PF2R	;3
   6164  8099					      endif
   6165  8099							; sleep 3
   6166  8099
   6167  8099		       a5 8e		      lda	player0height
   6168  809b		       c7 85		      dcp	player0y
   6169  809d		       90 b0		      bcc	.skipDrawP0
   6170  809f		       a4 85		      ldy	player0y
   6171  80a1		       b1 8a		      lda	(player0pointer),y
   6172  80a3				   .continueP0
   6173  80a3		       85 1b		      sta	GRP0
   6174  80a5
   6175  80a5					      ifnconst	no_blank_lines
   6176  80a5				  -	      ifnconst	playercolors
   6177  80a5				  -	      lda	missile0height	;3
   6178  80a5				  -	      dcp	missile0y	;5
   6179  80a5				  -	      sbc	stack1
   6180  80a5				  -	      sta	ENAM0	;3
   6181  80a5					      else
   6182  80a5		       b1 90		      lda	(player0color),y
   6183  80a7		       85 82		      sta	player0colorstore
      0  80a9					      sleep	6
      1  80a9				   .CYCLES    SET	6
      2  80a9
      3  80a9				  -	      IF	.CYCLES < 2
      4  80a9				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80a9				  -	      ERR
      6  80a9					      ENDIF
      7  80a9
      8  80a9				  -	      IF	.CYCLES & 1
      9  80a9				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  80a9				  -	      nop	0
     11  80a9				  -	      ELSE
     12  80a9				  -	      bit	VSYNC
     13  80a9				  -	      ENDIF
     14  80a9				  -.CYCLES    SET	.CYCLES - 3
     15  80a9					      ENDIF
     16  80a9
     17  80a9					      REPEAT	.CYCLES / 2
     18  80a9		       ea		      nop
     17  80a9					      REPEND
     18  80aa		       ea		      nop
     17  80aa					      REPEND
     18  80ab		       ea		      nop
     19  80ac					      REPEND
   6185  80ac					      endif
   6186  80ac		       c6 9c		      dec	temp1
   6187  80ae		       d0 ab		      bne	continuekernel
   6188  80b0				  -	      else
   6189  80b0				  -	      dec	temp1
   6190  80b0				  -	      beq	altkernel2
   6191  80b0				  -	      ifconst	readpaddle
   6192  80b0				  -	      ldy	currentpaddle
   6193  80b0				  -	      lda	INPT0,y
   6194  80b0				  -	      bpl	noreadpaddle
   6195  80b0				  -	      inc	paddle
   6196  80b0				  -	      jmp	continuekernel2
   6197  80b0				  -noreadpaddle
   6198  80b0				  -	      sleep	2
   6199  80b0				  -	      jmp	continuekernel
   6200  80b0				  -	      else
   6201  80b0				  -	      ifnconst	playercolors
   6202  80b0				  -	      ifconst	PFcolors
   6203  80b0				  -	      txa
   6204  80b0				  -	      tay
   6205  80b0				  -	      lda	(pfcolortable),y
   6206  80b0				  -	      ifnconst	backgroundchange
   6207  80b0				  -	      sta	COLUPF
   6208  80b0				  -	      else
   6209  80b0				  -	      sta	COLUBK
   6210  80b0				  -	      endif
   6211  80b0				  -	      jmp	continuekernel
   6212  80b0				  -	      else
   6213  80b0				  -	      ifconst	kernelmacrodef
   6214  80b0				  -	      kernelmacro
   6215  80b0				  -	      else
   6216  80b0				  -	      sleep	12
   6217  80b0				  -	      endif
   6218  80b0				  -	      endif
   6219  80b0				  -	      else
   6220  80b0				  -	      lda	(player0color),y
   6221  80b0				  -	      sta	player0colorstore
   6222  80b0				  -	      sleep	4
   6223  80b0				  -	      endif
   6224  80b0				  -	      jmp	continuekernel
   6225  80b0				  -	      endif
   6226  80b0				  -altkernel2
   6227  80b0				  -	      txa
   6228  80b0				  -	      ifnconst	vertical_reflect
   6229  80b0				  -	      sbx	#256-pfwidth
   6230  80b0				  -	      else
   6231  80b0				  -	      sbx	#256-pfwidth/2
   6232  80b0				  -	      endif
   6233  80b0				  -	      bmi	lastkernelline
   6234  80b0				  -	      ifconst	pfrowheight
   6235  80b0				  -	      lda	#pfrowheight
   6236  80b0				  -	      else
   6237  80b0				  -	      ifnconst	pfres
   6238  80b0				  -	      lda	#8
   6239  80b0				  -	      else
   6240  80b0				  -	      lda	#(96/pfres)	; try to come close to the real size
   6241  80b0				  -	      endif
   6242  80b0				  -	      endif
   6243  80b0				  -	      sta	temp1
   6244  80b0				  -	      jmp	continuekernel
   6245  80b0					      endif
   6246  80b0
   6247  80b0				   altkernel
   6248  80b0
   6249  80b0				  -	      ifconst	PFmaskvalue
   6250  80b0				  -	      lda	#PFmaskvalue
   6251  80b0					      else
   6252  80b0		       a9 00		      lda	#0
   6253  80b2					      endif
   6254  80b2		       85 0e		      sta	PF1L
   6255  80b4		       85 0f		      sta	PF2
   6256  80b6
   6257  80b6
   6258  80b6							;sleep 3
   6259  80b6
   6260  80b6							;28 cycles to fix things
   6261  80b6							;minus 11=17
   6262  80b6
   6263  80b6							; lax temp4
   6264  80b6							; clc
   6265  80b6		       8a		      txa
   6266  80b7					      ifnconst	vertical_reflect
   6267  80b7		       cb fc		      sbx	#256-pfwidth
   6268  80b9				  -	      else
   6269  80b9				  -	      sbx	#256-pfwidth/2
   6270  80b9					      endif
   6271  80b9
   6272  80b9		       30 12		      bmi	lastkernelline
   6273  80bb
   6274  80bb				  -	      ifconst	PFcolorandheight
   6275  80bb				  -	      ifconst	pfres
   6276  80bb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   6277  80bb				  -	      else
   6278  80bb				  -	      ldy	playfieldcolorandheight-87,x
   6279  80bb				  -	      endif
   6280  80bb				  -	      ifnconst	backgroundchange
   6281  80bb				  -	      sty	COLUPF
   6282  80bb				  -	      else
   6283  80bb				  -	      sty	COLUBK
   6284  80bb				  -	      endif
   6285  80bb				  -	      ifconst	pfres
   6286  80bb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   6287  80bb				  -	      else
   6288  80bb				  -	      lda	playfieldcolorandheight-88,x
   6289  80bb				  -	      endif
   6290  80bb				  -	      sta.w	temp1
   6291  80bb					      endif
   6292  80bb				  -	      ifconst	PFheights
   6293  80bb				  -	      lsr
   6294  80bb				  -	      lsr
   6295  80bb				  -	      tay
   6296  80bb				  -	      lda	(pfheighttable),y
   6297  80bb				  -	      sta.w	temp1
   6298  80bb					      endif
   6299  80bb					      ifconst	PFcolors
   6300  80bb		       a8		      tay
   6301  80bc		       b1 f0		      lda	(pfcolortable),y
   6302  80be					      ifnconst	backgroundchange
   6303  80be		       85 08		      sta	COLUPF
   6304  80c0				  -	      else
   6305  80c0				  -	      sta	COLUBK
   6306  80c0					      endif
   6307  80c0				  -	      ifconst	pfrowheight
   6308  80c0				  -	      lda	#pfrowheight
   6309  80c0					      else
   6310  80c0					      ifnconst	pfres
   6311  80c0		       a9 08		      lda	#8
   6312  80c2				  -	      else
   6313  80c2				  -	      lda	#(96/pfres)	; try to come close to the real size
   6314  80c2					      endif
   6315  80c2					      endif
   6316  80c2		       85 9c		      sta	temp1
   6317  80c4					      endif
   6318  80c4					      ifnconst	PFcolorandheight
   6319  80c4				  -	      ifnconst	PFcolors
   6320  80c4				  -	      ifnconst	PFheights
   6321  80c4				  -	      ifnconst	no_blank_lines
   6322  80c4				  -			; read paddle 0
   6323  80c4				  -			; lo-res paddle read
   6324  80c4				  -			; bit INPT0
   6325  80c4				  -			; bmi paddleskipread
   6326  80c4				  -			; inc paddle0
   6327  80c4				  -			;donepaddleskip
   6328  80c4				  -	      sleep	10
   6329  80c4				  -	      ifconst	pfrowheight
   6330  80c4				  -	      lda	#pfrowheight
   6331  80c4				  -	      else
   6332  80c4				  -	      ifnconst	pfres
   6333  80c4				  -	      lda	#8
   6334  80c4				  -	      else
   6335  80c4				  -	      lda	#(96/pfres)	; try to come close to the real size
   6336  80c4				  -	      endif
   6337  80c4				  -	      endif
   6338  80c4				  -	      sta	temp1
   6339  80c4				  -	      endif
   6340  80c4				  -	      endif
   6341  80c4					      endif
   6342  80c4					      endif
   6343  80c4
   6344  80c4
   6345  80c4		       a5 92		      lda	ballheight
   6346  80c6		       c7 89		      dcp	bally
   6347  80c8		       e5 9f		      sbc	temp4
   6348  80ca
   6349  80ca
   6350  80ca		       4c 72 f0 	      jmp	goback
   6351  80cd
   6352  80cd
   6353  80cd					      ifnconst	no_blank_lines
   6354  80cd				   lastkernelline
   6355  80cd				  -	      ifnconst	PFcolors
   6356  80cd				  -	      sleep	10
   6357  80cd					      else
   6358  80cd		       a0 7c		      ldy	#124
   6359  80cf		       b1 f0		      lda	(pfcolortable),y
   6360  80d1		       85 08		      sta	COLUPF
   6361  80d3					      endif
   6362  80d3
   6363  80d3				  -	      ifconst	PFheights
   6364  80d3				  -	      ldx	#1
   6365  80d3				  -			;sleep 4
   6366  80d3				  -	      sleep	3	; this was over 1 cycle
   6367  80d3					      else
   6368  80d3		       a6 ef		      ldx	playfieldpos
   6369  80d5							;sleep 3
      0  80d5					      sleep	2	; this was over 1 cycle
      1  80d5				   .CYCLES    SET	2
      2  80d5
      3  80d5				  -	      IF	.CYCLES < 2
      4  80d5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80d5				  -	      ERR
      6  80d5					      ENDIF
      7  80d5
      8  80d5				  -	      IF	.CYCLES & 1
      9  80d5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  80d5				  -	      nop	0
     11  80d5				  -	      ELSE
     12  80d5				  -	      bit	VSYNC
     13  80d5				  -	      ENDIF
     14  80d5				  -.CYCLES    SET	.CYCLES - 3
     15  80d5					      ENDIF
     16  80d5
     17  80d5					      REPEAT	.CYCLES / 2
     18  80d5		       ea		      nop
     19  80d6					      REPEND
   6371  80d6					      endif
   6372  80d6
   6373  80d6		       4c 1b f1 	      jmp	enterlastkernel
   6374  80d9
   6375  80d9				  -	      else
   6376  80d9				  -lastkernelline
   6377  80d9				  -
   6378  80d9				  -	      ifconst	PFheights
   6379  80d9				  -	      ldx	#1
   6380  80d9				  -			;sleep 5
   6381  80d9				  -	      sleep	4	; this was over 1 cycle
   6382  80d9				  -	      else
   6383  80d9				  -	      ldx	playfieldpos
   6384  80d9				  -			;sleep 4
   6385  80d9				  -	      sleep	3	; this was over 1 cycle
   6386  80d9				  -	      endif
   6387  80d9				  -
   6388  80d9				  -	      cpx	#0
   6389  80d9				  -	      bne	.enterfromNBL
   6390  80d9				  -	      jmp	no_blank_lines_bailout
   6391  80d9					      endif
   6392  80d9
   6393  80d9					      if	((<*)>$d5)
   6394  8100		       00 00 00 00*	      align	256
   6395  8100					      endif
   6396  8100							; this is a kludge to prevent page wrapping - fix!!!
   6397  8100
   6398  8100				   .skipDrawlastP1
   6399  8100		       a9 00		      lda	#0
   6400  8102		       a8		      tay		; added so we don't cross a page
   6401  8103		       4c 2d f1 	      jmp	.continuelastP1
   6402  8106
   6403  8106				   .endkerloop		; enter at cycle 59??
   6404  8106
   6405  8106		       ea		      nop
   6406  8107
   6407  8107				   .enterfromNBL
   6408  8107				  -	      ifconst	pfres
   6409  8107				  -	      ldy.w	playfield+pfres*pfwidth-4
   6410  8107				  -	      sty	PF1L	;3
   6411  8107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   6412  8107				  -	      sty	PF2L	;3
   6413  8107				  -	      ldy.w	playfield+pfres*pfwidth-1
   6414  8107				  -	      sty	PF1R	; possibly too early?
   6415  8107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   6416  8107				  -	      sty	PF2R	;3
   6417  8107					      else
   6418  8107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   6419  810a		       84 0e		      sty	PF1L	;3
   6420  810c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   6421  810f		       84 0f		      sty	PF2L	;3
   6422  8111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   6423  8114		       84 0e		      sty	PF1R	; possibly too early?
   6424  8116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   6425  8119		       84 0f		      sty	PF2R	;3
   6426  811b					      endif
   6427  811b
   6428  811b				   enterlastkernel
   6429  811b		       a5 92		      lda	ballheight
   6430  811d
   6431  811d							; tya
   6432  811d		       c7 89		      dcp	bally
   6433  811f							; sleep 4
   6434  811f
   6435  811f							; sbc stack3
   6436  811f		       2a		      rol
   6437  8120		       2a		      rol
   6438  8121		       85 1f		      sta	ENABL
   6439  8123
   6440  8123		       a5 8f		      lda	player1height	;3
   6441  8125		       c7 86		      dcp	player1y	;5
   6442  8127		       90 d7		      bcc	.skipDrawlastP1
   6443  8129		       a4 86		      ldy	player1y	;3
   6444  812b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   6445  812d							; so it doesn't cross a page boundary!
   6446  812d
   6447  812d				   .continuelastP1
   6448  812d		       85 1c		      sta	GRP1	;3
   6449  812f
   6450  812f				  -	      ifnconst	player1colors
   6451  812f				  -	      lda	missile1height	;3
   6452  812f				  -	      dcp	missile1y	;5
   6453  812f					      else
   6454  812f		       b1 87		      lda	(player1color),y
   6455  8131		       85 07		      sta	COLUP1
   6456  8133					      endif
   6457  8133
   6458  8133		       ca		      dex
   6459  8134							;dec temp4 ; might try putting this above PF writes
   6460  8134		       f0 37		      beq	endkernel
   6461  8136
   6462  8136
   6463  8136				  -	      ifconst	pfres
   6464  8136				  -	      ldy.w	playfield+pfres*pfwidth-4
   6465  8136				  -	      sty	PF1L	;3
   6466  8136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   6467  8136				  -	      sty	PF2L	;3
   6468  8136				  -	      ldy.w	playfield+pfres*pfwidth-1
   6469  8136				  -	      sty	PF1R	; possibly too early?
   6470  8136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   6471  8136				  -	      sty	PF2R	;3
   6472  8136					      else
   6473  8136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   6474  8139		       84 0e		      sty	PF1L	;3
   6475  813b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   6476  813e		       84 0f		      sty	PF2L	;3
   6477  8140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   6478  8143		       84 0e		      sty	PF1R	; possibly too early?
   6479  8145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   6480  8148		       84 0f		      sty	PF2R	;3
   6481  814a					      endif
   6482  814a
   6483  814a				  -	      ifnconst	player1colors
   6484  814a				  -	      rol		;2
   6485  814a				  -	      rol		;2
   6486  814a				  -	      sta	ENAM1	;3
   6487  814a					      else
   6488  814a				  -	      ifnconst	playercolors
   6489  814a				  -	      sleep	7
   6490  814a					      else
   6491  814a		       ad 82 00 	      lda.w	player0colorstore
   6492  814d		       85 06		      sta	COLUP0
   6493  814f					      endif
   6494  814f					      endif
   6495  814f
   6496  814f		       ad 8e 00 	      lda.w	player0height
   6497  8152		       c7 85		      dcp	player0y
   6498  8154		       90 11		      bcc	.skipDrawlastP0
   6499  8156		       a4 85		      ldy	player0y
   6500  8158		       b1 8a		      lda	(player0pointer),y
   6501  815a				   .continuelastP0
   6502  815a		       85 1b		      sta	GRP0
   6503  815c
   6504  815c
   6505  815c
   6506  815c					      ifnconst	no_blank_lines
   6507  815c		       a5 90		      lda	missile0height	;3
   6508  815e		       c7 91		      dcp	missile0y	;5
   6509  8160		       e5 f6		      sbc	stack1
   6510  8162		       85 1d		      sta	ENAM0	;3
   6511  8164		       4c 06 f1 	      jmp	.endkerloop
   6512  8167				  -	      else
   6513  8167				  -	      ifconst	readpaddle
   6514  8167				  -	      ldy	currentpaddle
   6515  8167				  -	      lda	INPT0,y
   6516  8167				  -	      bpl	noreadpaddle2
   6517  8167				  -	      inc	paddle
   6518  8167				  -	      jmp	.endkerloop
   6519  8167				  -noreadpaddle2
   6520  8167				  -	      sleep	4
   6521  8167				  -	      jmp	.endkerloop
   6522  8167				  -	      else		; no_blank_lines and no paddle reading
   6523  8167				  -	      pla
   6524  8167				  -	      pha		; 14 cycles in 4 bytes
   6525  8167				  -	      pla
   6526  8167				  -	      pha
   6527  8167				  -			; sleep 14
   6528  8167				  -	      jmp	.endkerloop
   6529  8167				  -	      endif
   6530  8167					      endif
   6531  8167
   6532  8167
   6533  8167							; ifconst donepaddleskip
   6534  8167							;paddleskipread
   6535  8167							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   6536  8167							; plus we get a lo-res paddle read
   6537  8167							; bmi donepaddleskip
   6538  8167							; endif
   6539  8167
   6540  8167				   .skipDrawlastP0
   6541  8167		       a9 00		      lda	#0
   6542  8169		       a8		      tay
   6543  816a		       4c 5a f1 	      jmp	.continuelastP0
   6544  816d
   6545  816d				  -	      ifconst	no_blank_lines
   6546  816d				  -no_blank_lines_bailout
   6547  816d				  -	      ldx	#0
   6548  816d					      endif
   6549  816d
   6550  816d				   endkernel
   6551  816d							; 6 digit score routine
   6552  816d		       86 0e		      stx	PF1
   6553  816f		       86 0f		      stx	PF2
   6554  8171		       86 0d		      stx	PF0
   6555  8173		       18		      clc
   6556  8174
   6557  8174				  -	      ifconst	pfrowheight
   6558  8174				  -	      lda	#pfrowheight+2
   6559  8174					      else
   6560  8174					      ifnconst	pfres
   6561  8174		       a9 0a		      lda	#10
   6562  8176				  -	      else
   6563  8176				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   6564  8176					      endif
   6565  8176					      endif
   6566  8176
   6567  8176		       e5 ef		      sbc	playfieldpos
   6568  8178		       85 ef		      sta	playfieldpos
   6569  817a		       8a		      txa
   6570  817b
   6571  817b				  -	      ifconst	shakescreen
   6572  817b				  -	      bit	shakescreen
   6573  817b				  -	      bmi	noshakescreen2
   6574  817b				  -	      ldx	#$3D
   6575  817b				  -noshakescreen2
   6576  817b					      endif
   6577  817b
   6578  817b		       95 02		      sta	WSYNC,x
   6579  817d
   6580  817d							; STA WSYNC ;first one, need one more
   6581  817d		       85 0b		      sta	REFP0
   6582  817f		       85 0c		      sta	REFP1
   6583  8181		       85 1b		      STA	GRP0
   6584  8183		       85 1c		      STA	GRP1
   6585  8185							; STA PF1
   6586  8185							; STA PF2
   6587  8185		       85 2b		      sta	HMCLR
   6588  8187		       85 1d		      sta	ENAM0
   6589  8189		       85 1e		      sta	ENAM1
   6590  818b		       85 1f		      sta	ENABL
   6591  818d
   6592  818d		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   6593  818f		       85 85		      sta	player0y
   6594  8191		       a5 9e		      lda	temp3
   6595  8193		       85 86		      sta	player1y
   6596  8195				  -	      ifnconst	player1colors
   6597  8195				  -	      lda	temp6
   6598  8195				  -	      sta	missile1y
   6599  8195					      endif
   6600  8195				  -	      ifnconst	playercolors
   6601  8195				  -	      ifnconst	readpaddle
   6602  8195				  -	      lda	temp5
   6603  8195				  -	      sta	missile0y
   6604  8195				  -	      endif
   6605  8195					      endif
   6606  8195		       a5 f7		      lda	stack2
   6607  8197		       85 89		      sta	bally
   6608  8199
   6609  8199							; strangely, this isn't required any more. might have
   6610  8199							; resulted from the no_blank_lines score bounce fix
   6611  8199							;ifconst no_blank_lines
   6612  8199							;sta WSYNC
   6613  8199							;endif
   6614  8199
   6615  8199		       ad 84 02 	      lda	INTIM
   6616  819c		       18		      clc
   6617  819d				  -	      ifnconst	vblank_time
   6618  819d				  -	      adc	#43+12+87
   6619  819d					      else
   6620  819d		       69 8e		      adc	#vblank_time+12+87
   6621  819f
   6622  819f					      endif
   6623  819f							; sta WSYNC
   6624  819f		       8d 96 02 	      sta	TIM64T
   6625  81a2
   6626  81a2				  -	      ifconst	minikernel
   6627  81a2				  -	      jsr	minikernel
   6628  81a2					      endif
   6629  81a2
   6630  81a2							; now reassign temp vars for score pointers
   6631  81a2
   6632  81a2							; score pointers contain:
   6633  81a2							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   6634  81a2							; swap lo2->temp1
   6635  81a2							; swap lo4->temp3
   6636  81a2							; swap lo6->temp5
   6637  81a2					      ifnconst	noscore
   6638  81a2		       a5 97		      lda	scorepointers+1
   6639  81a4							; ldy temp1
   6640  81a4		       85 9c		      sta	temp1
   6641  81a6							; sty scorepointers+1
   6642  81a6
   6643  81a6		       a5 99		      lda	scorepointers+3
   6644  81a8							; ldy temp3
   6645  81a8		       85 9e		      sta	temp3
   6646  81aa							; sty scorepointers+3
   6647  81aa
   6648  81aa
   6649  81aa		       85 2b		      sta	HMCLR
   6650  81ac		       ba		      tsx
   6651  81ad		       86 f6		      stx	stack1
   6652  81af		       a2 e0		      ldx	#$E0
   6653  81b1		       86 20		      stx	HMP0
   6654  81b3
   6655  81b3		       a5 a3		      LDA	scorecolor
   6656  81b5		       85 06		      STA	COLUP0
   6657  81b7		       85 07		      STA	COLUP1
   6658  81b9				  -	      ifconst	scorefade
   6659  81b9				  -	      STA	stack2
   6660  81b9					      endif
   6661  81b9				  -	      ifconst	pfscore
   6662  81b9				  -	      lda	pfscorecolor
   6663  81b9				  -	      sta	COLUPF
   6664  81b9					      endif
   6665  81b9		       85 02		      sta	WSYNC
   6666  81bb		       a2 00		      ldx	#0
   6667  81bd		       86 1b		      STx	GRP0
   6668  81bf		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   6669  81c1
   6670  81c1		       a5 9b		      lda	scorepointers+5
   6671  81c3							; ldy temp5
   6672  81c3		       95 a0		      sta	temp5,x
   6673  81c5							; sty scorepointers+5
   6674  81c5		       a9 ff		      lda	#>scoretable
   6675  81c7		       85 97		      sta	scorepointers+1
   6676  81c9		       85 99		      sta	scorepointers+3
   6677  81cb		       85 9b		      sta	scorepointers+5
   6678  81cd		       85 9d		      sta	temp2
   6679  81cf		       85 9f		      sta	temp4
   6680  81d1		       85 a1		      sta	temp6
   6681  81d3		       a0 07		      LDY	#7
   6682  81d5		       84 25		      STY	VDELP0
   6683  81d7		       85 10		      STA	RESP0
   6684  81d9		       85 11		      STA	RESP1
   6685  81db
   6686  81db
   6687  81db		       a9 03		      LDA	#$03
   6688  81dd		       85 04		      STA	NUSIZ0
   6689  81df		       85 05		      STA	NUSIZ1
   6690  81e1		       85 26		      STA	VDELP1
   6691  81e3		       a9 f0		      LDA	#$F0
   6692  81e5		       85 21		      STA	HMP1
   6693  81e7		       b1 96		      lda	(scorepointers),y
   6694  81e9		       85 1b		      sta	GRP0
   6695  81eb		       85 2a		      STA	HMOVE	; cycle 73 ?
   6696  81ed		       4c 08 f2 	      jmp	beginscore
   6697  81f0
   6698  81f0
   6699  81f0					      if	((<*)>$d4)
   6700  8200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   6701  8200					      endif
   6702  8200
   6703  8200				   loop2
   6704  8200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   6705  8202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   6706  8204				  -	      ifconst	pfscore
   6707  8204				  -	      lda.w	pfscore1
   6708  8204				  -	      sta	PF1
   6709  8204					      else
   6710  8204				  -	      ifconst	scorefade
   6711  8204				  -	      sleep	2
   6712  8204				  -	      dec	stack2	; decrement the temporary scorecolor
   6713  8204					      else
      0  8204					      sleep	7
      1  8204				   .CYCLES    SET	7
      2  8204
      3  8204				  -	      IF	.CYCLES < 2
      4  8204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8204				  -	      ERR
      6  8204					      ENDIF
      7  8204
      8  8204					      IF	.CYCLES & 1
      9  8204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8204		       04 00		      nop	0
     11  8206				  -	      ELSE
     12  8206				  -	      bit	VSYNC
     13  8206					      ENDIF
     14  8206				   .CYCLES    SET	.CYCLES - 3
     15  8206					      ENDIF
     16  8206
     17  8206					      REPEAT	.CYCLES / 2
     18  8206		       ea		      nop
     17  8206					      REPEND
     18  8207		       ea		      nop
     19  8208					      REPEND
   6715  8208					      endif
   6716  8208					      endif
   6717  8208							; cycle 0
   6718  8208				   beginscore
   6719  8208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   6720  820a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   6721  820c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   6722  820e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   6723  8210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   6724  8212		       9a		      txs
   6725  8213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   6726  8215				  -	      ifconst	scorefade
   6727  8215				  -	      lda	stack2
   6728  8215					      else
      0  8215					      sleep	3
      1  8215				   .CYCLES    SET	3
      2  8215
      3  8215				  -	      IF	.CYCLES < 2
      4  8215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8215				  -	      ERR
      6  8215					      ENDIF
      7  8215
      8  8215					      IF	.CYCLES & 1
      9  8215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8215		       04 00		      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217					      ENDIF
     14  8217				   .CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217				  -	      REPEAT	.CYCLES / 2
     18  8217				  -	      nop
     19  8217					      REPEND
   6730  8217					      endif
   6731  8217
   6732  8217				  -	      ifconst	pfscore
   6733  8217				  -	      lda	pfscore2
   6734  8217				  -	      sta	PF1
   6735  8217					      else
   6736  8217				  -	      ifconst	scorefade
   6737  8217				  -	      sta	COLUP0
   6738  8217				  -	      sta	COLUP1
   6739  8217					      else
      0  8217					      sleep	6
      1  8217				   .CYCLES    SET	6
      2  8217
      3  8217				  -	      IF	.CYCLES < 2
      4  8217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8217				  -	      ERR
      6  8217					      ENDIF
      7  8217
      8  8217				  -	      IF	.CYCLES & 1
      9  8217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  8217				  -	      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217				  -	      ENDIF
     14  8217				  -.CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217					      REPEAT	.CYCLES / 2
     18  8217		       ea		      nop
     17  8217					      REPEND
     18  8218		       ea		      nop
     17  8218					      REPEND
     18  8219		       ea		      nop
     19  821a					      REPEND
   6741  821a					      endif
   6742  821a					      endif
   6743  821a
   6744  821a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   6745  821c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   6746  821e		       ba		      tsx
   6747  821f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   6748  8221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   6749  8223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   6750  8225		       88		      dey
   6751  8226		       10 d8		      bpl	loop2	;+2 60 180
   6752  8228
   6753  8228		       a6 f6		      ldx	stack1
   6754  822a		       9a		      txs
   6755  822b							; lda scorepointers+1
   6756  822b		       a4 9c		      ldy	temp1
   6757  822d							; sta temp1
   6758  822d		       84 97		      sty	scorepointers+1
   6759  822f
   6760  822f		       a9 00		      LDA	#0
   6761  8231		       85 0e		      sta	PF1
   6762  8233		       85 1b		      STA	GRP0
   6763  8235		       85 1c		      STA	GRP1
   6764  8237		       85 25		      STA	VDELP0
   6765  8239		       85 26		      STA	VDELP1	;do we need these
   6766  823b		       85 04		      STA	NUSIZ0
   6767  823d		       85 05		      STA	NUSIZ1
   6768  823f
   6769  823f							; lda scorepointers+3
   6770  823f		       a4 9e		      ldy	temp3
   6771  8241							; sta temp3
   6772  8241		       84 99		      sty	scorepointers+3
   6773  8243
   6774  8243							; lda scorepointers+5
   6775  8243		       a4 a0		      ldy	temp5
   6776  8245							; sta temp5
   6777  8245		       84 9b		      sty	scorepointers+5
   6778  8247					      endif		;noscore
   6779  8247				  -	      ifconst	readpaddle
   6780  8247				  -	      lda	#%11000010
   6781  8247					      else
   6782  8247				  -	      ifconst	qtcontroller
   6783  8247				  -	      lda	qtcontroller
   6784  8247				  -	      lsr		; bit 0 in carry
   6785  8247				  -	      lda	#4
   6786  8247				  -	      ror		; carry into top of A
   6787  8247					      else
   6788  8247		       a9 02		      lda	#2
   6789  8249					      endif		; qtcontroller
   6790  8249					      endif		; readpaddle
   6791  8249		       85 02		      sta	WSYNC
   6792  824b		       85 01		      sta	VBLANK
      0  824d					      RETURN
      1  824d				  -	      ifnconst	bankswitch
      2  824d				  -	      rts
      3  824d					      else
      4  824d		       4c dd ff 	      jmp	BS_return
      5  8250					      endif
   6794  8250				  -	      ifconst	shakescreen
   6795  8250				  -doshakescreen
   6796  8250				  -	      bit	shakescreen
   6797  8250				  -	      bmi	noshakescreen
   6798  8250				  -	      sta	WSYNC
   6799  8250				  -noshakescreen
   6800  8250				  -	      ldx	missile0height
   6801  8250				  -	      inx
   6802  8250				  -	      rts
   6803  8250					      endif
   6804  8250
   6805  8250							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6806  8250
   6807  8250				   start
   6808  8250		       78		      sei
   6809  8251		       d8		      cld
   6810  8252		       a0 00		      ldy	#0
   6811  8254		       a5 d0		      lda	$D0
   6812  8256		       c9 2c		      cmp	#$2C	;check RAM location #1
   6813  8258		       d0 07		      bne	MachineIs2600
   6814  825a		       a5 d1		      lda	$D1
   6815  825c		       c9 a9		      cmp	#$A9	;check RAM location #2
   6816  825e		       d0 01		      bne	MachineIs2600
   6817  8260		       88		      dey
   6818  8261				   MachineIs2600
   6819  8261		       a2 00		      ldx	#0
   6820  8263		       8a		      txa
   6821  8264				   clearmem
   6822  8264		       e8		      inx
   6823  8265		       9a		      txs
   6824  8266		       48		      pha
   6825  8267		       d0 fb		      bne	clearmem
   6826  8269		       84 9c		      sty	temp1
   6827  826b					      ifnconst	multisprite
   6828  826b				  -	      ifconst	pfrowheight
   6829  826b				  -	      lda	#pfrowheight
   6830  826b					      else
   6831  826b				  -	      ifconst	pfres
   6832  826b				  -	      lda	#(96/pfres)
   6833  826b					      else
   6834  826b		       a9 08		      lda	#8
   6835  826d					      endif
   6836  826d					      endif
   6837  826d		       85 ef		      sta	playfieldpos
   6838  826f					      endif
   6839  826f		       a2 05		      ldx	#5
   6840  8271				   initscore
   6841  8271		       a9 74		      lda	#<scoretable
   6842  8273		       95 96		      sta	scorepointers,x
   6843  8275		       ca		      dex
   6844  8276		       10 f9		      bpl	initscore
   6845  8278		       a9 01		      lda	#1
   6846  827a		       85 0a		      sta	CTRLPF
   6847  827c		       0d 84 02 	      ora	INTIM
   6848  827f		       85 a2		      sta	rand
   6849  8281
   6850  8281				  -	      ifconst	multisprite
   6851  8281				  -	      jsr	multisprite_setup
   6852  8281					      endif
   6853  8281
   6854  8281				  -	      ifnconst	bankswitch
   6855  8281				  -	      jmp	game
   6856  8281					      else
   6857  8281		       a9 0f		      lda	#>(game-1)
   6858  8283		       48		      pha
   6859  8284		       a9 ff		      lda	#<(game-1)
   6860  8286		       48		      pha
   6861  8287		       48		      pha
   6862  8288		       48		      pha
   6863  8289		       a2 01		      ldx	#1
   6864  828b		       4c eb ff 	      jmp	BS_jsr
   6865  828e					      endif
   6866  828e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6867  828e
   6868  828e							; playfield drawing routines
   6869  828e							; you get a 32x12 bitmapped display in a single color :)
   6870  828e							; 0-31 and 0-11
   6871  828e
   6872  828e				   pfclear		; clears playfield - or fill with pattern
   6873  828e				  -	      ifconst	pfres
   6874  828e				  -	      ldx	#pfres*pfwidth-1
   6875  828e					      else
   6876  828e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   6877  8290					      endif
   6878  8290				   pfclear_loop
   6879  8290					      ifnconst	superchip
   6880  8290		       95 a4		      sta	playfield,x
   6881  8292				  -	      else
   6882  8292				  -	      sta	playfield-128,x
   6883  8292					      endif
   6884  8292		       ca		      dex
   6885  8293		       10 fb		      bpl	pfclear_loop
      0  8295					      RETURN
      1  8295				  -	      ifnconst	bankswitch
      2  8295				  -	      rts
      3  8295					      else
      4  8295		       4c dd ff 	      jmp	BS_return
      5  8298					      endif
   6887  8298
   6888  8298				   setuppointers
   6889  8298		       86 9d		      stx	temp2	; store on.off.flip value
   6890  829a		       aa		      tax		; put x-value in x 
   6891  829b		       4a		      lsr
   6892  829c		       4a		      lsr
   6893  829d		       4a		      lsr		; divide x pos by 8 
   6894  829e		       85 9c		      sta	temp1
   6895  82a0		       98		      tya
   6896  82a1		       0a		      asl
   6897  82a2					      if	pfwidth=4
   6898  82a2		       0a		      asl		; multiply y pos by 4
   6899  82a3					      endif		; else multiply by 2
   6900  82a3		       18		      clc
   6901  82a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   6902  82a6		       a8		      tay		; put the value in y
   6903  82a7		       a5 9d		      lda	temp2	; restore on.off.flip value
   6904  82a9		       60		      rts
   6905  82aa
   6906  82aa				   pfread
   6907  82aa							;x=xvalue, y=yvalue
   6908  82aa		       20 98 f2 	      jsr	setuppointers
   6909  82ad		       bd 42 f3 	      lda	setbyte,x
   6910  82b0		       39 a4 00 	      and	playfield,y
   6911  82b3		       5d 42 f3 	      eor	setbyte,x
   6912  82b6							; beq readzero
   6913  82b6							; lda #1
   6914  82b6							; readzero
      0  82b6					      RETURN
      1  82b6				  -	      ifnconst	bankswitch
      2  82b6				  -	      rts
      3  82b6					      else
      4  82b6		       4c dd ff 	      jmp	BS_return
      5  82b9					      endif
   6916  82b9
   6917  82b9				   pfpixel
   6918  82b9							;x=xvalue, y=yvalue, a=0,1,2
   6919  82b9		       20 98 f2 	      jsr	setuppointers
   6920  82bc
   6921  82bc					      ifconst	bankswitch
   6922  82bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   6923  82be		       f0 0f		      beq	pixelon_r	; if "on" go to on
   6924  82c0		       4a		      lsr
   6925  82c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   6926  82c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   6927  82c6		       5d 42 f3 	      eor	setbyte,x
   6928  82c9				  -	      ifconst	superchip
   6929  82c9				  -	      sta	playfield-128,y
   6930  82c9					      else
   6931  82c9		       99 a4 00 	      sta	playfield,y
   6932  82cc					      endif
      0  82cc					      RETURN
      1  82cc				  -	      ifnconst	bankswitch
      2  82cc				  -	      rts
      3  82cc					      else
      4  82cc		       4c dd ff 	      jmp	BS_return
      5  82cf					      endif
   6934  82cf				   pixelon_r
   6935  82cf		       b9 a4 00 	      lda	playfield,y
   6936  82d2		       1d 42 f3 	      ora	setbyte,x
   6937  82d5				  -	      ifconst	superchip
   6938  82d5				  -	      sta	playfield-128,y
   6939  82d5					      else
   6940  82d5		       99 a4 00 	      sta	playfield,y
   6941  82d8					      endif
      0  82d8					      RETURN
      1  82d8				  -	      ifnconst	bankswitch
      2  82d8				  -	      rts
      3  82d8					      else
      4  82d8		       4c dd ff 	      jmp	BS_return
      5  82db					      endif
   6943  82db				   pixeloff_r
   6944  82db		       bd 42 f3 	      lda	setbyte,x
   6945  82de		       49 ff		      eor	#$ff
   6946  82e0		       39 a4 00 	      and	playfield,y
   6947  82e3				  -	      ifconst	superchip
   6948  82e3				  -	      sta	playfield-128,y
   6949  82e3					      else
   6950  82e3		       99 a4 00 	      sta	playfield,y
   6951  82e6					      endif
      0  82e6					      RETURN
      1  82e6				  -	      ifnconst	bankswitch
      2  82e6				  -	      rts
      3  82e6					      else
      4  82e6		       4c dd ff 	      jmp	BS_return
      5  82e9					      endif
   6953  82e9
   6954  82e9				  -	      else
   6955  82e9				  -	      jmp	plotpoint
   6956  82e9					      endif
   6957  82e9
   6958  82e9				   pfhline
   6959  82e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   6960  82e9		       20 98 f2 	      jsr	setuppointers
   6961  82ec		       4c f6 f2 	      jmp	noinc
   6962  82ef				   keepgoing
   6963  82ef		       e8		      inx
   6964  82f0		       8a		      txa
   6965  82f1		       29 07		      and	#7
   6966  82f3		       d0 01		      bne	noinc
   6967  82f5		       c8		      iny
   6968  82f6				   noinc
   6969  82f6		       20 1b f3 	      jsr	plotpoint
   6970  82f9		       e4 9e		      cpx	temp3
   6971  82fb		       30 f2		      bmi	keepgoing
      0  82fd					      RETURN
      1  82fd				  -	      ifnconst	bankswitch
      2  82fd				  -	      rts
      3  82fd					      else
      4  82fd		       4c dd ff 	      jmp	BS_return
      5  8300					      endif
   6973  8300
   6974  8300				   pfvline
   6975  8300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   6976  8300		       20 98 f2 	      jsr	setuppointers
   6977  8303		       84 9c		      sty	temp1	; store memory location offset
   6978  8305		       e6 9e		      inc	temp3	; increase final x by 1 
   6979  8307		       a5 9e		      lda	temp3
   6980  8309		       0a		      asl
   6981  830a					      if	pfwidth=4
   6982  830a		       0a		      asl		; multiply by 4
   6983  830b					      endif		; else multiply by 2
   6984  830b		       85 9e		      sta	temp3	; store it
   6985  830d							; Thanks to Michael Rideout for fixing a bug in this code
   6986  830d							; right now, temp1=y=starting memory location, temp3=final
   6987  830d							; x should equal original x value
   6988  830d				   keepgoingy
   6989  830d		       20 1b f3 	      jsr	plotpoint
   6990  8310		       c8		      iny
   6991  8311		       c8		      iny
   6992  8312					      if	pfwidth=4
   6993  8312		       c8		      iny
   6994  8313		       c8		      iny
   6995  8314					      endif
   6996  8314		       c4 9e		      cpy	temp3
   6997  8316		       30 f5		      bmi	keepgoingy
      0  8318					      RETURN
      1  8318				  -	      ifnconst	bankswitch
      2  8318				  -	      rts
      3  8318					      else
      4  8318		       4c dd ff 	      jmp	BS_return
      5  831b					      endif
   6999  831b
   7000  831b				   plotpoint
   7001  831b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   7002  831d		       f0 0d		      beq	pixelon	; if "on" go to on
   7003  831f		       4a		      lsr
   7004  8320		       b0 14		      bcs	pixeloff	; value is 1 if true
   7005  8322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   7006  8325		       5d 42 f3 	      eor	setbyte,x
   7007  8328				  -	      ifconst	superchip
   7008  8328				  -	      sta	playfield-128,y
   7009  8328					      else
   7010  8328		       99 a4 00 	      sta	playfield,y
   7011  832b					      endif
   7012  832b		       60		      rts
   7013  832c				   pixelon
   7014  832c		       b9 a4 00 	      lda	playfield,y
   7015  832f		       1d 42 f3 	      ora	setbyte,x
   7016  8332				  -	      ifconst	superchip
   7017  8332				  -	      sta	playfield-128,y
   7018  8332					      else
   7019  8332		       99 a4 00 	      sta	playfield,y
   7020  8335					      endif
   7021  8335		       60		      rts
   7022  8336				   pixeloff
   7023  8336		       bd 42 f3 	      lda	setbyte,x
   7024  8339		       49 ff		      eor	#$ff
   7025  833b		       39 a4 00 	      and	playfield,y
   7026  833e				  -	      ifconst	superchip
   7027  833e				  -	      sta	playfield-128,y
   7028  833e					      else
   7029  833e		       99 a4 00 	      sta	playfield,y
   7030  8341					      endif
   7031  8341		       60		      rts
   7032  8342
   7033  8342				   setbyte
   7034  8342					      ifnconst	pfcenter
   7035  8342		       80		      .byte.b	$80
   7036  8343		       40		      .byte.b	$40
   7037  8344		       20		      .byte.b	$20
   7038  8345		       10		      .byte.b	$10
   7039  8346		       08		      .byte.b	$08
   7040  8347		       04		      .byte.b	$04
   7041  8348		       02		      .byte.b	$02
   7042  8349		       01		      .byte.b	$01
   7043  834a					      endif
   7044  834a		       01		      .byte.b	$01
   7045  834b		       02		      .byte.b	$02
   7046  834c		       04		      .byte.b	$04
   7047  834d		       08		      .byte.b	$08
   7048  834e		       10		      .byte.b	$10
   7049  834f		       20		      .byte.b	$20
   7050  8350		       40		      .byte.b	$40
   7051  8351		       80		      .byte.b	$80
   7052  8352		       80		      .byte.b	$80
   7053  8353		       40		      .byte.b	$40
   7054  8354		       20		      .byte.b	$20
   7055  8355		       10		      .byte.b	$10
   7056  8356		       08		      .byte.b	$08
   7057  8357		       04		      .byte.b	$04
   7058  8358		       02		      .byte.b	$02
   7059  8359		       01		      .byte.b	$01
   7060  835a		       01		      .byte.b	$01
   7061  835b		       02		      .byte.b	$02
   7062  835c		       04		      .byte.b	$04
   7063  835d		       08		      .byte.b	$08
   7064  835e		       10		      .byte.b	$10
   7065  835f		       20		      .byte.b	$20
   7066  8360		       40		      .byte.b	$40
   7067  8361		       80		      .byte.b	$80
   7068  8362							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7069  8362
   7070  8362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   7071  8362		       d0 15		      bne	notleft
   7072  8364							;left
   7073  8364				  -	      ifconst	pfres
   7074  8364				  -	      ldx	#pfres*4
   7075  8364					      else
   7076  8364		       a2 30		      ldx	#48
   7077  8366					      endif
   7078  8366				   leftloop
   7079  8366		       b5 a3		      lda	playfield-1,x
   7080  8368		       4a		      lsr
   7081  8369
   7082  8369				  -	      ifconst	superchip
   7083  8369				  -	      lda	playfield-2,x
   7084  8369				  -	      rol
   7085  8369				  -	      sta	playfield-130,x
   7086  8369				  -	      lda	playfield-3,x
   7087  8369				  -	      ror
   7088  8369				  -	      sta	playfield-131,x
   7089  8369				  -	      lda	playfield-4,x
   7090  8369				  -	      rol
   7091  8369				  -	      sta	playfield-132,x
   7092  8369				  -	      lda	playfield-1,x
   7093  8369				  -	      ror
   7094  8369				  -	      sta	playfield-129,x
   7095  8369					      else
   7096  8369		       36 a2		      rol	playfield-2,x
   7097  836b		       76 a1		      ror	playfield-3,x
   7098  836d		       36 a0		      rol	playfield-4,x
   7099  836f		       76 a3		      ror	playfield-1,x
   7100  8371					      endif
   7101  8371
   7102  8371		       8a		      txa
   7103  8372		       cb 04		      sbx	#4
   7104  8374		       d0 f0		      bne	leftloop
      0  8376					      RETURN
      1  8376				  -	      ifnconst	bankswitch
      2  8376				  -	      rts
      3  8376					      else
      4  8376		       4c dd ff 	      jmp	BS_return
      5  8379					      endif
   7106  8379
   7107  8379				   notleft
   7108  8379		       4a		      lsr
   7109  837a		       90 15		      bcc	notright
   7110  837c							;right
   7111  837c
   7112  837c				  -	      ifconst	pfres
   7113  837c				  -	      ldx	#pfres*4
   7114  837c					      else
   7115  837c		       a2 30		      ldx	#48
   7116  837e					      endif
   7117  837e				   rightloop
   7118  837e		       b5 a0		      lda	playfield-4,x
   7119  8380		       4a		      lsr
   7120  8381				  -	      ifconst	superchip
   7121  8381				  -	      lda	playfield-3,x
   7122  8381				  -	      rol
   7123  8381				  -	      sta	playfield-131,x
   7124  8381				  -	      lda	playfield-2,x
   7125  8381				  -	      ror
   7126  8381				  -	      sta	playfield-130,x
   7127  8381				  -	      lda	playfield-1,x
   7128  8381				  -	      rol
   7129  8381				  -	      sta	playfield-129,x
   7130  8381				  -	      lda	playfield-4,x
   7131  8381				  -	      ror
   7132  8381				  -	      sta	playfield-132,x
   7133  8381					      else
   7134  8381		       36 a1		      rol	playfield-3,x
   7135  8383		       76 a2		      ror	playfield-2,x
   7136  8385		       36 a3		      rol	playfield-1,x
   7137  8387		       76 a0		      ror	playfield-4,x
   7138  8389					      endif
   7139  8389		       8a		      txa
   7140  838a		       cb 04		      sbx	#4
   7141  838c		       d0 f0		      bne	rightloop
      0  838e					      RETURN
      1  838e				  -	      ifnconst	bankswitch
      2  838e				  -	      rts
      3  838e					      else
      4  838e		       4c dd ff 	      jmp	BS_return
      5  8391					      endif
   7143  8391
   7144  8391				   notright
   7145  8391		       4a		      lsr
   7146  8392		       90 4b		      bcc	notup
   7147  8394							;up
   7148  8394		       4a		      lsr
   7149  8395		       90 02		      bcc	onedecup
   7150  8397		       c6 ef		      dec	playfieldpos
   7151  8399				   onedecup
   7152  8399		       c6 ef		      dec	playfieldpos
   7153  839b		       f0 02		      beq	shiftdown
   7154  839d		       10 3d		      bpl	noshiftdown2
   7155  839f				   shiftdown
   7156  839f				  -	      ifconst	pfrowheight
   7157  839f				  -	      lda	#pfrowheight
   7158  839f					      else
   7159  839f					      ifnconst	pfres
   7160  839f		       a9 08		      lda	#8
   7161  83a1				  -	      else
   7162  83a1				  -	      lda	#(96/pfres)	; try to come close to the real size
   7163  83a1					      endif
   7164  83a1					      endif
   7165  83a1
   7166  83a1		       85 ef		      sta	playfieldpos
   7167  83a3		       a5 a7		      lda	playfield+3
   7168  83a5		       85 9f		      sta	temp4
   7169  83a7		       a5 a6		      lda	playfield+2
   7170  83a9		       85 9e		      sta	temp3
   7171  83ab		       a5 a5		      lda	playfield+1
   7172  83ad		       85 9d		      sta	temp2
   7173  83af		       a5 a4		      lda	playfield
   7174  83b1		       85 9c		      sta	temp1
   7175  83b3		       a2 00		      ldx	#0
   7176  83b5				   up2
   7177  83b5		       b5 a8		      lda	playfield+4,x
   7178  83b7				  -	      ifconst	superchip
   7179  83b7				  -	      sta	playfield-128,x
   7180  83b7				  -	      lda	playfield+5,x
   7181  83b7				  -	      sta	playfield-127,x
   7182  83b7				  -	      lda	playfield+6,x
   7183  83b7				  -	      sta	playfield-126,x
   7184  83b7				  -	      lda	playfield+7,x
   7185  83b7				  -	      sta	playfield-125,x
   7186  83b7					      else
   7187  83b7		       95 a4		      sta	playfield,x
   7188  83b9		       b5 a9		      lda	playfield+5,x
   7189  83bb		       95 a5		      sta	playfield+1,x
   7190  83bd		       b5 aa		      lda	playfield+6,x
   7191  83bf		       95 a6		      sta	playfield+2,x
   7192  83c1		       b5 ab		      lda	playfield+7,x
   7193  83c3		       95 a7		      sta	playfield+3,x
   7194  83c5					      endif
   7195  83c5		       8a		      txa
   7196  83c6		       cb fc		      sbx	#252
   7197  83c8				  -	      ifconst	pfres
   7198  83c8				  -	      cpx	#(pfres-1)*4
   7199  83c8					      else
   7200  83c8		       e0 2c		      cpx	#44
   7201  83ca					      endif
   7202  83ca		       d0 e9		      bne	up2
   7203  83cc
   7204  83cc		       a5 9f		      lda	temp4
   7205  83ce
   7206  83ce				  -	      ifconst	superchip
   7207  83ce				  -	      ifconst	pfres
   7208  83ce				  -	      sta	playfield+pfres*4-129
   7209  83ce				  -	      lda	temp3
   7210  83ce				  -	      sta	playfield+pfres*4-130
   7211  83ce				  -	      lda	temp2
   7212  83ce				  -	      sta	playfield+pfres*4-131
   7213  83ce				  -	      lda	temp1
   7214  83ce				  -	      sta	playfield+pfres*4-132
   7215  83ce				  -	      else
   7216  83ce				  -	      sta	playfield+47-128
   7217  83ce				  -	      lda	temp3
   7218  83ce				  -	      sta	playfield+46-128
   7219  83ce				  -	      lda	temp2
   7220  83ce				  -	      sta	playfield+45-128
   7221  83ce				  -	      lda	temp1
   7222  83ce				  -	      sta	playfield+44-128
   7223  83ce				  -	      endif
   7224  83ce					      else
   7225  83ce				  -	      ifconst	pfres
   7226  83ce				  -	      sta	playfield+pfres*4-1
   7227  83ce				  -	      lda	temp3
   7228  83ce				  -	      sta	playfield+pfres*4-2
   7229  83ce				  -	      lda	temp2
   7230  83ce				  -	      sta	playfield+pfres*4-3
   7231  83ce				  -	      lda	temp1
   7232  83ce				  -	      sta	playfield+pfres*4-4
   7233  83ce					      else
   7234  83ce		       85 d3		      sta	playfield+47
   7235  83d0		       a5 9e		      lda	temp3
   7236  83d2		       85 d2		      sta	playfield+46
   7237  83d4		       a5 9d		      lda	temp2
   7238  83d6		       85 d1		      sta	playfield+45
   7239  83d8		       a5 9c		      lda	temp1
   7240  83da		       85 d0		      sta	playfield+44
   7241  83dc					      endif
   7242  83dc					      endif
   7243  83dc				   noshiftdown2
      0  83dc					      RETURN
      1  83dc				  -	      ifnconst	bankswitch
      2  83dc				  -	      rts
      3  83dc					      else
      4  83dc		       4c dd ff 	      jmp	BS_return
      5  83df					      endif
   7245  83df
   7246  83df
   7247  83df				   notup
   7248  83df							;down
   7249  83df		       4a		      lsr
   7250  83e0		       b0 02		      bcs	oneincup
   7251  83e2		       e6 ef		      inc	playfieldpos
   7252  83e4				   oneincup
   7253  83e4		       e6 ef		      inc	playfieldpos
   7254  83e6		       a5 ef		      lda	playfieldpos
   7255  83e8
   7256  83e8				  -	      ifconst	pfrowheight
   7257  83e8				  -	      cmp	#pfrowheight+1
   7258  83e8					      else
   7259  83e8					      ifnconst	pfres
   7260  83e8		       c9 09		      cmp	#9
   7261  83ea				  -	      else
   7262  83ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   7263  83ea					      endif
   7264  83ea					      endif
   7265  83ea
   7266  83ea		       90 3b		      bcc	noshiftdown
   7267  83ec		       a9 01		      lda	#1
   7268  83ee		       85 ef		      sta	playfieldpos
   7269  83f0
   7270  83f0				  -	      ifconst	pfres
   7271  83f0				  -	      lda	playfield+pfres*4-1
   7272  83f0				  -	      sta	temp4
   7273  83f0				  -	      lda	playfield+pfres*4-2
   7274  83f0				  -	      sta	temp3
   7275  83f0				  -	      lda	playfield+pfres*4-3
   7276  83f0				  -	      sta	temp2
   7277  83f0				  -	      lda	playfield+pfres*4-4
   7278  83f0					      else
   7279  83f0		       a5 d3		      lda	playfield+47
   7280  83f2		       85 9f		      sta	temp4
   7281  83f4		       a5 d2		      lda	playfield+46
   7282  83f6		       85 9e		      sta	temp3
   7283  83f8		       a5 d1		      lda	playfield+45
   7284  83fa		       85 9d		      sta	temp2
   7285  83fc		       a5 d0		      lda	playfield+44
   7286  83fe					      endif
   7287  83fe
   7288  83fe		       85 9c		      sta	temp1
   7289  8400
   7290  8400				  -	      ifconst	pfres
   7291  8400				  -	      ldx	#(pfres-1)*4
   7292  8400					      else
   7293  8400		       a2 2c		      ldx	#44
   7294  8402					      endif
   7295  8402				   down2
   7296  8402		       b5 a3		      lda	playfield-1,x
   7297  8404				  -	      ifconst	superchip
   7298  8404				  -	      sta	playfield-125,x
   7299  8404				  -	      lda	playfield-2,x
   7300  8404				  -	      sta	playfield-126,x
   7301  8404				  -	      lda	playfield-3,x
   7302  8404				  -	      sta	playfield-127,x
   7303  8404				  -	      lda	playfield-4,x
   7304  8404				  -	      sta	playfield-128,x
   7305  8404					      else
   7306  8404		       95 a7		      sta	playfield+3,x
   7307  8406		       b5 a2		      lda	playfield-2,x
   7308  8408		       95 a6		      sta	playfield+2,x
   7309  840a		       b5 a1		      lda	playfield-3,x
   7310  840c		       95 a5		      sta	playfield+1,x
   7311  840e		       b5 a0		      lda	playfield-4,x
   7312  8410		       95 a4		      sta	playfield,x
   7313  8412					      endif
   7314  8412		       8a		      txa
   7315  8413		       cb 04		      sbx	#4
   7316  8415		       d0 eb		      bne	down2
   7317  8417
   7318  8417		       a5 9f		      lda	temp4
   7319  8419				  -	      ifconst	superchip
   7320  8419				  -	      sta	playfield-125
   7321  8419				  -	      lda	temp3
   7322  8419				  -	      sta	playfield-126
   7323  8419				  -	      lda	temp2
   7324  8419				  -	      sta	playfield-127
   7325  8419				  -	      lda	temp1
   7326  8419				  -	      sta	playfield-128
   7327  8419					      else
   7328  8419		       85 a7		      sta	playfield+3
   7329  841b		       a5 9e		      lda	temp3
   7330  841d		       85 a6		      sta	playfield+2
   7331  841f		       a5 9d		      lda	temp2
   7332  8421		       85 a5		      sta	playfield+1
   7333  8423		       a5 9c		      lda	temp1
   7334  8425		       85 a4		      sta	playfield
   7335  8427					      endif
   7336  8427				   noshiftdown
      0  8427					      RETURN
      1  8427				  -	      ifnconst	bankswitch
      2  8427				  -	      rts
      3  8427					      else
      4  8427		       4c dd ff 	      jmp	BS_return
      5  842a					      endif
   7338  842a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7339  842a
   7340  842a							;standard routines needed for pretty much all games
   7341  842a							; just the random number generator is left - maybe we should remove this asm file altogether?
   7342  842a							; repositioning code and score pointer setup moved to overscan
   7343  842a							; read switches, joysticks now compiler generated (more efficient)
   7344  842a
   7345  842a				   randomize
   7346  842a		       a5 a2		      lda	rand
   7347  842c		       4a		      lsr
   7348  842d					      ifconst	rand16
   7349  842d		       26 ed		      rol	rand16
   7350  842f					      endif
   7351  842f		       90 02		      bcc	noeor
   7352  8431		       49 b4		      eor	#$B4
   7353  8433				   noeor
   7354  8433		       85 a2		      sta	rand
   7355  8435					      ifconst	rand16
   7356  8435		       45 ed		      eor	rand16
   7357  8437					      endif
      0  8437					      RETURN
      1  8437				  -	      ifnconst	bankswitch
      2  8437				  -	      rts
      3  8437					      else
      4  8437		       4c dd ff 	      jmp	BS_return
      5  843a					      endif
   7359  843a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7360  843a
   7361  843a				   drawscreen
   7362  843a				  -	      ifconst	debugscore
   7363  843a				  -	      ldx	#14
   7364  843a				  -	      lda	INTIM	; display # cycles left in the score
   7365  843a				  -
   7366  843a				  -	      ifconst	mincycles
   7367  843a				  -	      lda	mincycles
   7368  843a				  -	      cmp	INTIM
   7369  843a				  -	      lda	mincycles
   7370  843a				  -	      bcc	nochange
   7371  843a				  -	      lda	INTIM
   7372  843a				  -	      sta	mincycles
   7373  843a				  -nochange
   7374  843a				  -	      endif
   7375  843a				  -
   7376  843a				  -			; cmp #$2B
   7377  843a				  -			; bcs no_cycles_left
   7378  843a				  -	      bmi	cycles_left
   7379  843a				  -	      ldx	#64
   7380  843a				  -	      eor	#$ff	;make negative
   7381  843a				  -cycles_left
   7382  843a				  -	      stx	scorecolor
   7383  843a				  -	      and	#$7f	; clear sign bit
   7384  843a				  -	      tax
   7385  843a				  -	      lda	scorebcd,x
   7386  843a				  -	      sta	score+2
   7387  843a				  -	      lda	scorebcd1,x
   7388  843a				  -	      sta	score+1
   7389  843a				  -	      jmp	done_debugscore
   7390  843a				  -scorebcd
   7391  843a				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   7392  843a				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   7393  843a				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   7394  843a				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   7395  843a				  -scorebcd1
   7396  843a				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   7397  843a				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   7398  843a				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   7399  843a				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   7400  843a				  -done_debugscore
   7401  843a					      endif
   7402  843a
   7403  843a				  -	      ifconst	debugcycles
   7404  843a				  -	      lda	INTIM	; if we go over, it mucks up the background color
   7405  843a				  -			; cmp #$2B
   7406  843a				  -			; BCC overscan
   7407  843a				  -	      bmi	overscan
   7408  843a				  -	      sta	COLUBK
   7409  843a				  -	      bcs	doneoverscan
   7410  843a					      endif
   7411  843a
   7412  843a				   overscan
   7413  843a				  -	      ifconst	interlaced
   7414  843a				  -	      PHP
   7415  843a				  -	      PLA
   7416  843a				  -	      EOR	#4	; flip interrupt bit
   7417  843a				  -	      PHA
   7418  843a				  -	      PLP
   7419  843a				  -	      AND	#4	; isolate the interrupt bit
   7420  843a				  -	      TAX		; save it for later
   7421  843a					      endif
   7422  843a
   7423  843a				   overscanloop
   7424  843a		       ad 84 02 	      lda	INTIM	;wait for sync
   7425  843d		       30 fb		      bmi	overscanloop
   7426  843f				   doneoverscan
   7427  843f
   7428  843f							;do VSYNC
   7429  843f
   7430  843f				  -	      ifconst	interlaced
   7431  843f				  -	      CPX	#4
   7432  843f				  -	      BNE	oddframevsync
   7433  843f					      endif
   7434  843f
   7435  843f		       a9 02		      lda	#2
   7436  8441		       85 02		      sta	WSYNC
   7437  8443		       85 00		      sta	VSYNC
   7438  8445		       85 02		      STA	WSYNC
   7439  8447		       85 02		      STA	WSYNC
   7440  8449		       4a		      lsr
   7441  844a		       85 02		      STA	WSYNC
   7442  844c		       85 00		      STA	VSYNC
   7443  844e		       85 01		      sta	VBLANK
   7444  8450				  -	      ifnconst	overscan_time
   7445  8450				  -	      lda	#37+128
   7446  8450					      else
   7447  8450		       a9 a5		      lda	#overscan_time+128
   7448  8452					      endif
   7449  8452		       8d 96 02 	      sta	TIM64T
   7450  8455
   7451  8455				  -	      ifconst	interlaced
   7452  8455				  -	      jmp	postsync
   7453  8455				  -
   7454  8455				  -oddframevsync
   7455  8455				  -	      sta	WSYNC
   7456  8455				  -
   7457  8455				  -	      LDA	($80,X)	; 11 waste
   7458  8455				  -	      LDA	($80,X)	; 11 waste
   7459  8455				  -	      LDA	($80,X)	; 11 waste
   7460  8455				  -
   7461  8455				  -	      lda	#2
   7462  8455				  -	      sta	VSYNC
   7463  8455				  -	      sta	WSYNC
   7464  8455				  -	      sta	WSYNC
   7465  8455				  -	      sta	WSYNC
   7466  8455				  -
   7467  8455				  -	      LDA	($80,X)	; 11 waste
   7468  8455				  -	      LDA	($80,X)	; 11 waste
   7469  8455				  -	      LDA	($80,X)	; 11 waste
   7470  8455				  -
   7471  8455				  -	      lda	#0
   7472  8455				  -	      sta	VSYNC
   7473  8455				  -	      sta	VBLANK
   7474  8455				  -	      ifnconst	overscan_time
   7475  8455				  -	      lda	#37+128
   7476  8455				  -	      else
   7477  8455				  -	      lda	#overscan_time+128
   7478  8455				  -	      endif
   7479  8455				  -	      sta	TIM64T
   7480  8455				  -
   7481  8455				  -postsync
   7482  8455					      endif
   7483  8455
   7484  8455				  -	      ifconst	legacy
   7485  8455				  -	      if	legacy < 100
   7486  8455				  -	      ldx	#4
   7487  8455				  -adjustloop
   7488  8455				  -	      lda	player0x,x
   7489  8455				  -	      sec
   7490  8455				  -	      sbc	#14	;?
   7491  8455				  -	      sta	player0x,x
   7492  8455				  -	      dex
   7493  8455				  -	      bpl	adjustloop
   7494  8455				  -	      endif
   7495  8455					      endif
   7496  8455				  -	      if	((<*)>$e9)&&((<*)<$fa)
   7497  8455				  -	      repeat	($fa-(<*))
   7498  8455				  -	      nop
   7499  8455				  -	      repend
   7500  8455					      endif
   7501  8455		       85 02		      sta	WSYNC
   7502  8457		       a2 04		      ldx	#4
      0  8459					      SLEEP	3
      1  8459				   .CYCLES    SET	3
      2  8459
      3  8459				  -	      IF	.CYCLES < 2
      4  8459				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8459				  -	      ERR
      6  8459					      ENDIF
      7  8459
      8  8459					      IF	.CYCLES & 1
      9  8459					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8459		       04 00		      nop	0
     11  845b				  -	      ELSE
     12  845b				  -	      bit	VSYNC
     13  845b					      ENDIF
     14  845b				   .CYCLES    SET	.CYCLES - 3
     15  845b					      ENDIF
     16  845b
     17  845b				  -	      REPEAT	.CYCLES / 2
     18  845b				  -	      nop
     19  845b					      REPEND
   7504  845b				   HorPosLoop		; 5
   7505  845b		       b5 80		      lda	player0x,X	;+4 9
   7506  845d		       38		      sec		;+2 11
   7507  845e				   DivideLoop
   7508  845e		       e9 0f		      sbc	#15
   7509  8460		       b0 fc		      bcs	DivideLoop	;+4 15
   7510  8462		       95 9c		      sta	temp1,X	;+4 19
   7511  8464		       95 10		      sta	RESP0,X	;+4 23
   7512  8466		       85 02		      sta	WSYNC
   7513  8468		       ca		      dex
   7514  8469		       10 f0		      bpl	HorPosLoop	;+5 5
   7515  846b							; 4
   7516  846b
   7517  846b		       a2 04		      ldx	#4
   7518  846d		       b4 9c		      ldy	temp1,X
   7519  846f		       b9 cb f3 	      lda	repostable-256,Y
   7520  8472		       95 20		      sta	HMP0,X	;+14 18
   7521  8474
   7522  8474		       ca		      dex
   7523  8475		       b4 9c		      ldy	temp1,X
   7524  8477		       b9 cb f3 	      lda	repostable-256,Y
   7525  847a		       95 20		      sta	HMP0,X	;+14 32
   7526  847c
   7527  847c		       ca		      dex
   7528  847d		       b4 9c		      ldy	temp1,X
   7529  847f		       b9 cb f3 	      lda	repostable-256,Y
   7530  8482		       95 20		      sta	HMP0,X	;+14 46
   7531  8484
   7532  8484		       ca		      dex
   7533  8485		       b4 9c		      ldy	temp1,X
   7534  8487		       b9 cb f3 	      lda	repostable-256,Y
   7535  848a		       95 20		      sta	HMP0,X	;+14 60
   7536  848c
   7537  848c		       ca		      dex
   7538  848d		       b4 9c		      ldy	temp1,X
   7539  848f		       b9 cb f3 	      lda	repostable-256,Y
   7540  8492		       95 20		      sta	HMP0,X	;+14 74
   7541  8494
   7542  8494		       85 02		      sta	WSYNC
   7543  8496
   7544  8496		       85 2a		      sta	HMOVE	;+3 3
   7545  8498
   7546  8498
   7547  8498				  -	      ifconst	legacy
   7548  8498				  -	      if	legacy < 100
   7549  8498				  -	      ldx	#4
   7550  8498				  -adjustloop2
   7551  8498				  -	      lda	player0x,x
   7552  8498				  -	      clc
   7553  8498				  -	      adc	#14	;?
   7554  8498				  -	      sta	player0x,x
   7555  8498				  -	      dex
   7556  8498				  -	      bpl	adjustloop2
   7557  8498				  -	      endif
   7558  8498					      endif
   7559  8498
   7560  8498
   7561  8498
   7562  8498
   7563  8498							;set score pointers
   7564  8498		       a7 95		      lax	score+2
   7565  849a		       20 cb f4 	      jsr	scorepointerset
   7566  849d		       84 9b		      sty	scorepointers+5
   7567  849f		       86 98		      stx	scorepointers+2
   7568  84a1		       a7 94		      lax	score+1
   7569  84a3		       20 cb f4 	      jsr	scorepointerset
   7570  84a6		       84 9a		      sty	scorepointers+4
   7571  84a8		       86 97		      stx	scorepointers+1
   7572  84aa		       a7 93		      lax	score
   7573  84ac		       20 cb f4 	      jsr	scorepointerset
   7574  84af		       84 99		      sty	scorepointers+3
   7575  84b1		       86 96		      stx	scorepointers
   7576  84b3
   7577  84b3				   vblk
   7578  84b3							; run possible vblank bB code
   7579  84b3				  -	      ifconst	vblank_bB_code
   7580  84b3				  -	      jsr	vblank_bB_code
   7581  84b3					      endif
   7582  84b3				   vblk2
   7583  84b3		       ad 84 02 	      LDA	INTIM
   7584  84b6		       30 fb		      bmi	vblk2
   7585  84b8		       4c 00 f0 	      jmp	kernel
   7586  84bb
   7587  84bb
   7588  84bb		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   7589  84c4		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   7590  84cb				   repostable
   7591  84cb
   7592  84cb				   scorepointerset
   7593  84cb		       29 0f		      and	#$0F
   7594  84cd		       0a		      asl
   7595  84ce		       0a		      asl
   7596  84cf		       0a		      asl
   7597  84d0		       69 74		      adc	#<scoretable
   7598  84d2		       a8		      tay
   7599  84d3		       8a		      txa
   7600  84d4							; and #$F0
   7601  84d4							; lsr
   7602  84d4		       4b f0		      asr	#$F0
   7603  84d6		       69 74		      adc	#<scoretable
   7604  84d8		       aa		      tax
   7605  84d9		       60		      rts
   7606  84da							;bB.asm
   7607  84da							; bB.asm file is split here
   7608  84da				  -	      ifconst	pfres
   7609  84da				  -	      if	(<*) > (254-pfres*pfwidth)
   7610  84da				  -	      align	256
   7611  84da				  -	      endif
   7612  84da				  -	      if	(<*) < (136-pfres*pfwidth)
   7613  84da				  -	      repeat	((136-pfres*pfwidth)-(<*))
   7614  84da				  -	      .byte	0
   7615  84da				  -	      repend
   7616  84da				  -	      endif
   7617  84da					      else
   7618  84da					      if	(<*) > 206
   7619  8500		       00 00 00 00*	      align	256
   7620  8500					      endif
   7621  8500					      if	(<*) < 88
   7622  8500					      repeat	(88-(<*))
   7623  8500		       00		      .byte.b	0
   7622  8500					      repend
   7623  8501		       00		      .byte.b	0
   7622  8501					      repend
   7623  8502		       00		      .byte.b	0
   7622  8502					      repend
   7623  8503		       00		      .byte.b	0
   7622  8503					      repend
   7623  8504		       00		      .byte.b	0
   7622  8504					      repend
   7623  8505		       00		      .byte.b	0
   7622  8505					      repend
   7623  8506		       00		      .byte.b	0
   7622  8506					      repend
   7623  8507		       00		      .byte.b	0
   7622  8507					      repend
   7623  8508		       00		      .byte.b	0
   7622  8508					      repend
   7623  8509		       00		      .byte.b	0
   7622  8509					      repend
   7623  850a		       00		      .byte.b	0
   7622  850a					      repend
   7623  850b		       00		      .byte.b	0
   7622  850b					      repend
   7623  850c		       00		      .byte.b	0
   7622  850c					      repend
   7623  850d		       00		      .byte.b	0
   7622  850d					      repend
   7623  850e		       00		      .byte.b	0
   7622  850e					      repend
   7623  850f		       00		      .byte.b	0
   7622  850f					      repend
   7623  8510		       00		      .byte.b	0
   7622  8510					      repend
   7623  8511		       00		      .byte.b	0
   7622  8511					      repend
   7623  8512		       00		      .byte.b	0
   7622  8512					      repend
   7623  8513		       00		      .byte.b	0
   7622  8513					      repend
   7623  8514		       00		      .byte.b	0
   7622  8514					      repend
   7623  8515		       00		      .byte.b	0
   7622  8515					      repend
   7623  8516		       00		      .byte.b	0
   7622  8516					      repend
   7623  8517		       00		      .byte.b	0
   7622  8517					      repend
   7623  8518		       00		      .byte.b	0
   7622  8518					      repend
   7623  8519		       00		      .byte.b	0
   7622  8519					      repend
   7623  851a		       00		      .byte.b	0
   7622  851a					      repend
   7623  851b		       00		      .byte.b	0
   7622  851b					      repend
   7623  851c		       00		      .byte.b	0
   7622  851c					      repend
   7623  851d		       00		      .byte.b	0
   7622  851d					      repend
   7623  851e		       00		      .byte.b	0
   7622  851e					      repend
   7623  851f		       00		      .byte.b	0
   7622  851f					      repend
   7623  8520		       00		      .byte.b	0
   7622  8520					      repend
   7623  8521		       00		      .byte.b	0
   7622  8521					      repend
   7623  8522		       00		      .byte.b	0
   7622  8522					      repend
   7623  8523		       00		      .byte.b	0
   7622  8523					      repend
   7623  8524		       00		      .byte.b	0
   7622  8524					      repend
   7623  8525		       00		      .byte.b	0
   7622  8525					      repend
   7623  8526		       00		      .byte.b	0
   7622  8526					      repend
   7623  8527		       00		      .byte.b	0
   7622  8527					      repend
   7623  8528		       00		      .byte.b	0
   7622  8528					      repend
   7623  8529		       00		      .byte.b	0
   7622  8529					      repend
   7623  852a		       00		      .byte.b	0
   7622  852a					      repend
   7623  852b		       00		      .byte.b	0
   7622  852b					      repend
   7623  852c		       00		      .byte.b	0
   7622  852c					      repend
   7623  852d		       00		      .byte.b	0
   7622  852d					      repend
   7623  852e		       00		      .byte.b	0
   7622  852e					      repend
   7623  852f		       00		      .byte.b	0
   7622  852f					      repend
   7623  8530		       00		      .byte.b	0
   7622  8530					      repend
   7623  8531		       00		      .byte.b	0
   7622  8531					      repend
   7623  8532		       00		      .byte.b	0
   7622  8532					      repend
   7623  8533		       00		      .byte.b	0
   7622  8533					      repend
   7623  8534		       00		      .byte.b	0
   7622  8534					      repend
   7623  8535		       00		      .byte.b	0
   7622  8535					      repend
   7623  8536		       00		      .byte.b	0
   7622  8536					      repend
   7623  8537		       00		      .byte.b	0
   7622  8537					      repend
   7623  8538		       00		      .byte.b	0
   7622  8538					      repend
   7623  8539		       00		      .byte.b	0
   7622  8539					      repend
   7623  853a		       00		      .byte.b	0
   7622  853a					      repend
   7623  853b		       00		      .byte.b	0
   7622  853b					      repend
   7623  853c		       00		      .byte.b	0
   7622  853c					      repend
   7623  853d		       00		      .byte.b	0
   7622  853d					      repend
   7623  853e		       00		      .byte.b	0
   7622  853e					      repend
   7623  853f		       00		      .byte.b	0
   7622  853f					      repend
   7623  8540		       00		      .byte.b	0
   7622  8540					      repend
   7623  8541		       00		      .byte.b	0
   7622  8541					      repend
   7623  8542		       00		      .byte.b	0
   7622  8542					      repend
   7623  8543		       00		      .byte.b	0
   7622  8543					      repend
   7623  8544		       00		      .byte.b	0
   7622  8544					      repend
   7623  8545		       00		      .byte.b	0
   7622  8545					      repend
   7623  8546		       00		      .byte.b	0
   7622  8546					      repend
   7623  8547		       00		      .byte.b	0
   7622  8547					      repend
   7623  8548		       00		      .byte.b	0
   7622  8548					      repend
   7623  8549		       00		      .byte.b	0
   7622  8549					      repend
   7623  854a		       00		      .byte.b	0
   7622  854a					      repend
   7623  854b		       00		      .byte.b	0
   7622  854b					      repend
   7623  854c		       00		      .byte.b	0
   7622  854c					      repend
   7623  854d		       00		      .byte.b	0
   7622  854d					      repend
   7623  854e		       00		      .byte.b	0
   7622  854e					      repend
   7623  854f		       00		      .byte.b	0
   7622  854f					      repend
   7623  8550		       00		      .byte.b	0
   7622  8550					      repend
   7623  8551		       00		      .byte.b	0
   7622  8551					      repend
   7623  8552		       00		      .byte.b	0
   7622  8552					      repend
   7623  8553		       00		      .byte.b	0
   7622  8553					      repend
   7623  8554		       00		      .byte.b	0
   7622  8554					      repend
   7623  8555		       00		      .byte.b	0
   7622  8555					      repend
   7623  8556		       00		      .byte.b	0
   7622  8556					      repend
   7623  8557		       00		      .byte.b	0
   7624  8558					      repend
   7625  8558					      endif
   7626  8558					      endif
   7627  8558				   pfcolorlabel13
   7628  8558		       0c 00 00 00	      .byte.b	$0C,0,0,0
   7629  855c		       0c 00 00 00	      .byte.b	$0C,0,0,0
   7630  8560		       0c 00 00 00	      .byte.b	$0C,0,0,0
   7631  8564		       1c 00 00 00	      .byte.b	$1C,0,0,0
   7632  8568		       00 00 00 00	      .byte.b	$00,0,0,0
   7633  856c		       0c 00 00 00	      .byte.b	$0C,0,0,0
   7634  8570		       3c 00 00 00	      .byte.b	$3C,0,0,0
   7635  8574		       00 00 00 00	      .byte.b	$00,0,0,0
   7636  8578		       0c 00 00 00	      .byte.b	$0C,0,0,0
   7637  857c		       cc 00 00 00	      .byte.b	$CC,0,0,0
   7638  8580		       c6 00 00 00	      .byte.b	$C6,0,0,0
   7639  8584				  -	      if	(<*) > (<(*+9))
   7640  8584				  -	      repeat	($100-<*)
   7641  8584				  -	      .byte	0
   7642  8584				  -	      repend
   7643  8584					      endif
   7644  8584				   playercolorL061_1
   7645  8584		       26		      .byte.b	$26
   7646  8585		       9c		      .byte.b	$9C
   7647  8586		       9c		      .byte.b	$9C
   7648  8587		       9c		      .byte.b	$9C
   7649  8588		       da		      .byte.b	$DA
   7650  8589		       da		      .byte.b	$DA
   7651  858a		       3c		      .byte.b	$3C
   7652  858b		       3c		      .byte.b	$3C
   7653  858c		       3c		      .byte.b	$3C
   7654  858d		       26		      .byte.b	$26
   7655  858e				  -	      if	(<*) > (<(*+9))
   7656  858e				  -	      repeat	($100-<*)
   7657  858e				  -	      .byte	0
   7658  858e				  -	      repend
   7659  858e					      endif
   7660  858e				   playerL062_1
   7661  858e		       66		      .byte.b	%01100110
   7662  858f		       24		      .byte.b	%00100100
   7663  8590		       3c		      .byte.b	%00111100
   7664  8591		       18		      .byte.b	%00011000
   7665  8592		       5a		      .byte.b	%01011010
   7666  8593		       3c		      .byte.b	%00111100
   7667  8594		       18		      .byte.b	%00011000
   7668  8595		       3c		      .byte.b	%00111100
   7669  8596		       3c		      .byte.b	%00111100
   7670  8597		       18		      .byte.b	%00011000
   7671  8598				  -	      if	(<*) > (<(*+9))
   7672  8598				  -	      repeat	($100-<*)
   7673  8598				  -	      .byte	0
   7674  8598				  -	      repend
   7675  8598					      endif
   7676  8598				   player5then_1
   7677  8598		       c3		      .byte.b	%11000011
   7678  8599		       63		      .byte.b	%01100011
   7679  859a		       3e		      .byte.b	%00111110
   7680  859b		       1c		      .byte.b	%00011100
   7681  859c		       3d		      .byte.b	%00111101
   7682  859d		       5e		      .byte.b	%01011110
   7683  859e		       18		      .byte.b	%00011000
   7684  859f		       3c		      .byte.b	%00111100
   7685  85a0		       3c		      .byte.b	%00111100
   7686  85a1		       18		      .byte.b	%00011000
   7687  85a2				  -	      if	(<*) > (<(*+9))
   7688  85a2				  -	      repeat	($100-<*)
   7689  85a2				  -	      .byte	0
   7690  85a2				  -	      repend
   7691  85a2					      endif
   7692  85a2				   player8then_1
   7693  85a2		       66		      .byte.b	%01100110
   7694  85a3		       24		      .byte.b	%00100100
   7695  85a4		       3c		      .byte.b	%00111100
   7696  85a5		       18		      .byte.b	%00011000
   7697  85a6		       18		      .byte.b	%00011000
   7698  85a7		       7e		      .byte.b	%01111110
   7699  85a8		       99		      .byte.b	%10011001
   7700  85a9		       3c		      .byte.b	%00111100
   7701  85aa		       3c		      .byte.b	%00111100
   7702  85ab		       18		      .byte.b	%00011000
   7703  85ac				  -	      if	(<*) > (<(*+9))
   7704  85ac				  -	      repeat	($100-<*)
   7705  85ac				  -	      .byte	0
   7706  85ac				  -	      repend
   7707  85ac					      endif
   7708  85ac				   playerL083_1
   7709  85ac		       c3		      .byte.b	%11000011
   7710  85ad		       63		      .byte.b	%01100011
   7711  85ae		       3e		      .byte.b	%00111110
   7712  85af		       1c		      .byte.b	%00011100
   7713  85b0		       3d		      .byte.b	%00111101
   7714  85b1		       5e		      .byte.b	%01011110
   7715  85b2		       18		      .byte.b	%00011000
   7716  85b3		       3c		      .byte.b	%00111100
   7717  85b4		       3c		      .byte.b	%00111100
   7718  85b5		       18		      .byte.b	%00011000
   7719  85b6				  -	      if	(<*) > (<(*+9))
   7720  85b6				  -	      repeat	($100-<*)
   7721  85b6				  -	      .byte	0
   7722  85b6				  -	      repend
   7723  85b6					      endif
   7724  85b6				   player24then_1
   7725  85b6		       66		      .byte.b	%01100110
   7726  85b7		       24		      .byte.b	%00100100
   7727  85b8		       3c		      .byte.b	%00111100
   7728  85b9		       18		      .byte.b	%00011000
   7729  85ba		       18		      .byte.b	%00011000
   7730  85bb		       7e		      .byte.b	%01111110
   7731  85bc		       99		      .byte.b	%10011001
   7732  85bd		       3c		      .byte.b	%00111100
   7733  85be		       3c		      .byte.b	%00111100
   7734  85bf		       18		      .byte.b	%00011000
   7735  85c0				  -	      if	(<*) > (<(*+7))
   7736  85c0				  -	      repeat	($100-<*)
   7737  85c0				  -	      .byte	0
   7738  85c0				  -	      repend
   7739  85c0					      endif
   7740  85c0				   playercolorL0104_1
   7741  85c0		       26		      .byte.b	$26
   7742  85c1		       9c		      .byte.b	$9C
   7743  85c2		       da		      .byte.b	$DA
   7744  85c3		       da		      .byte.b	$DA
   7745  85c4		       3c		      .byte.b	$3C
   7746  85c5		       3c		      .byte.b	$3C
   7747  85c6		       3c		      .byte.b	$3C
   7748  85c7		       26		      .byte.b	$26
   7749  85c8				  -	      if	(<*) > (<(*+7))
   7750  85c8				  -	      repeat	($100-<*)
   7751  85c8				  -	      .byte	0
   7752  85c8				  -	      repend
   7753  85c8					      endif
   7754  85c8				   playerL0105_1
   7755  85c8		       66		      .byte.b	%01100110
   7756  85c9		       7e		      .byte.b	%01111110
   7757  85ca		       5a		      .byte.b	%01011010
   7758  85cb		       3c		      .byte.b	%00111100
   7759  85cc		       18		      .byte.b	%00011000
   7760  85cd		       3c		      .byte.b	%00111100
   7761  85ce		       3c		      .byte.b	%00111100
   7762  85cf		       18		      .byte.b	%00011000
   7763  85d0				  -	      if	(<*) > (<(*+9))
   7764  85d0				  -	      repeat	($100-<*)
   7765  85d0				  -	      .byte	0
   7766  85d0				  -	      repend
   7767  85d0					      endif
   7768  85d0				   playercolorL0114_1
   7769  85d0		       26		      .byte.b	$26
   7770  85d1		       9c		      .byte.b	$9C
   7771  85d2		       9c		      .byte.b	$9C
   7772  85d3		       9c		      .byte.b	$9C
   7773  85d4		       da		      .byte.b	$DA
   7774  85d5		       da		      .byte.b	$DA
   7775  85d6		       3c		      .byte.b	$3C
   7776  85d7		       3c		      .byte.b	$3C
   7777  85d8		       3c		      .byte.b	$3C
   7778  85d9		       26		      .byte.b	$26
   7779  85da				  -	      if	(<*) > (<(*+9))
   7780  85da				  -	      repeat	($100-<*)
   7781  85da				  -	      .byte	0
   7782  85da				  -	      repend
   7783  85da					      endif
   7784  85da				   playerL0115_1
   7785  85da		       66		      .byte.b	%01100110
   7786  85db		       24		      .byte.b	%00100100
   7787  85dc		       3c		      .byte.b	%00111100
   7788  85dd		       18		      .byte.b	%00011000
   7789  85de		       1a		      .byte.b	%00011010
   7790  85df		       7c		      .byte.b	%01111100
   7791  85e0		       98		      .byte.b	%10011000
   7792  85e1		       3c		      .byte.b	%00111100
   7793  85e2		       3c		      .byte.b	%00111100
   7794  85e3		       18		      .byte.b	%00011000
   7795  85e4				  -	      if	(<*) > (<(*+9))
   7796  85e4				  -	      repeat	($100-<*)
   7797  85e4				  -	      .byte	0
   7798  85e4				  -	      repend
   7799  85e4					      endif
   7800  85e4				   playercolorL0153_1
   7801  85e4		       26		      .byte.b	$26
   7802  85e5		       9c		      .byte.b	$9C
   7803  85e6		       9c		      .byte.b	$9C
   7804  85e7		       9c		      .byte.b	$9C
   7805  85e8		       da		      .byte.b	$DA
   7806  85e9		       da		      .byte.b	$DA
   7807  85ea		       3c		      .byte.b	$3C
   7808  85eb		       3c		      .byte.b	$3C
   7809  85ec		       3c		      .byte.b	$3C
   7810  85ed		       26		      .byte.b	$26
   7811  85ee				  -	      if	(<*) > (<(*+9))
   7812  85ee				  -	      repeat	($100-<*)
   7813  85ee				  -	      .byte	0
   7814  85ee				  -	      repend
   7815  85ee					      endif
   7816  85ee				   playerL0164_1
   7817  85ee		       63		      .byte.b	%01100011
   7818  85ef		       36		      .byte.b	%00110110
   7819  85f0		       1c		      .byte.b	%00011100
   7820  85f1		       18		      .byte.b	%00011000
   7821  85f2		       ba		      .byte.b	%10111010
   7822  85f3		       7c		      .byte.b	%01111100
   7823  85f4		       30		      .byte.b	%00110000
   7824  85f5		       78		      .byte.b	%01111000
   7825  85f6		       78		      .byte.b	%01111000
   7826  85f7		       30		      .byte.b	%00110000
   7827  85f8					      if	(<*) > (<(*+9))
   7828  85f8					      repeat	($100-<*)
   7829  85f8		       00		      .byte.b	0
   7828  85f8					      repend
   7829  85f9		       00		      .byte.b	0
   7828  85f9					      repend
   7829  85fa		       00		      .byte.b	0
   7828  85fa					      repend
   7829  85fb		       00		      .byte.b	0
   7828  85fb					      repend
   7829  85fc		       00		      .byte.b	0
   7828  85fc					      repend
   7829  85fd		       00		      .byte.b	0
   7828  85fd					      repend
   7829  85fe		       00		      .byte.b	0
   7828  85fe					      repend
   7829  85ff		       00		      .byte.b	0
   7830  8600					      repend
   7831  8600					      endif
   7832  8600				   playercolorL0165_1
   7833  8600		       26		      .byte.b	$26
   7834  8601		       9c		      .byte.b	$9C
   7835  8602		       9c		      .byte.b	$9C
   7836  8603		       9c		      .byte.b	$9C
   7837  8604		       da		      .byte.b	$DA
   7838  8605		       da		      .byte.b	$DA
   7839  8606		       3c		      .byte.b	$3C
   7840  8607		       3c		      .byte.b	$3C
   7841  8608		       3c		      .byte.b	$3C
   7842  8609		       26		      .byte.b	$26
   7843  860a				  -	      if	(<*) > (<(*+9))
   7844  860a				  -	      repeat	($100-<*)
   7845  860a				  -	      .byte	0
   7846  860a				  -	      repend
   7847  860a					      endif
   7848  860a				   playerL0233_1
   7849  860a		       66		      .byte.b	%01100110
   7850  860b		       26		      .byte.b	%00100110
   7851  860c		       3c		      .byte.b	%00111100
   7852  860d		       1c		      .byte.b	%00011100
   7853  860e		       3c		      .byte.b	%00111100
   7854  860f		       1c		      .byte.b	%00011100
   7855  8610		       18		      .byte.b	%00011000
   7856  8611		       3c		      .byte.b	%00111100
   7857  8612		       3c		      .byte.b	%00111100
   7858  8613		       18		      .byte.b	%00011000
   7859  8614				  -	      if	(<*) > (<(*+9))
   7860  8614				  -	      repeat	($100-<*)
   7861  8614				  -	      .byte	0
   7862  8614				  -	      repend
   7863  8614					      endif
   7864  8614				   playerL0235_1
   7865  8614		       c3		      .byte.b	%11000011
   7866  8615		       63		      .byte.b	%01100011
   7867  8616		       3e		      .byte.b	%00111110
   7868  8617		       1c		      .byte.b	%00011100
   7869  8618		       3c		      .byte.b	%00111100
   7870  8619		       5e		      .byte.b	%01011110
   7871  861a		       18		      .byte.b	%00011000
   7872  861b		       3c		      .byte.b	%00111100
   7873  861c		       3c		      .byte.b	%00111100
   7874  861d		       18		      .byte.b	%00011000
   7875  861e				  -	      if	(<*) > (<(*+9))
   7876  861e				  -	      repeat	($100-<*)
   7877  861e				  -	      .byte	0
   7878  861e				  -	      repend
   7879  861e					      endif
   7880  861e				   playerL0237_1
   7881  861e		       3c		      .byte.b	%00111100
   7882  861f		       1c		      .byte.b	%00011100
   7883  8620		       1c		      .byte.b	%00011100
   7884  8621		       1c		      .byte.b	%00011100
   7885  8622		       1c		      .byte.b	%00011100
   7886  8623		       1c		      .byte.b	%00011100
   7887  8624		       18		      .byte.b	%00011000
   7888  8625		       3c		      .byte.b	%00111100
   7889  8626		       3c		      .byte.b	%00111100
   7890  8627		       18		      .byte.b	%00011000
   7891  8628					      if	ECHOFIRST
      2380 bytes of ROM space left in bank 8
   7892  8628					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 8")
   7893  8628					      endif
   7894  8628		       00 01	   ECHOFIRST  =	1
   7895  8628
   7896  8628
   7897  8628							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7898  8628
   7899  8628							; feel free to modify the score graphics - just keep each digit 8 high
   7900  8628							; and keep the conditional compilation stuff intact
   7901  8628				  -	      ifconst	ROM2k
   7902  8628				  -	      ORG	$F7AC-8
   7903  8628					      else
   7904  8628					      ifconst	bankswitch
   7905  8628				  -	      if	bankswitch == 8
   7906  8628				  -	      ORG	$2F94-bscode_length
   7907  8628				  -	      RORG	$FF94-bscode_length
   7908  8628					      endif
   7909  8628				  -	      if	bankswitch == 16
   7910  8628				  -	      ORG	$4F94-bscode_length
   7911  8628				  -	      RORG	$FF94-bscode_length
   7912  8628					      endif
   7913  8628					      if	bankswitch == 32
   7914  8f74					      ORG	$8F94-bscode_length
   7915  8f74					      RORG	$FF94-bscode_length
   7916  8f74					      endif
   7917  8f74				  -	      if	bankswitch == 64
   7918  8f74				  -	      ORG	$10F80-bscode_length
   7919  8f74				  -	      RORG	$1FF80-bscode_length
   7920  8f74					      endif
   7921  8f74				  -	      else
   7922  8f74				  -	      ORG	$FF9C
   7923  8f74					      endif
   7924  8f74					      endif
   7925  8f74
   7926  8f74							; font equates
   7927  8f74		       00 01	   .21stcentury =	1
   7928  8f74		       00 02	   alarmclock =	2
   7929  8f74		       00 03	   handwritten =	3
   7930  8f74		       00 04	   interrupted =	4
   7931  8f74		       00 05	   retroputer =	5
   7932  8f74		       00 06	   whimsey    =	6
   7933  8f74		       00 07	   tiny       =	7
   7934  8f74		       00 08	   hex	      =	8
   7935  8f74
   7936  8f74				  -	      ifconst	font
   7937  8f74				  -	      if	font == hex
   7938  8f74				  -	      ORG	. - 48
   7939  8f74				  -	      endif
   7940  8f74					      endif
   7941  8f74
   7942  8f74				   scoretable
   7943  8f74
   7944  8f74				  -	      ifconst	font
   7945  8f74				  -	      if	font == .21stcentury
   7946  8f74				  -	      include	"score_graphics.asm.21stcentury"
   7947  8f74				  -	      endif
   7948  8f74				  -	      if	font == alarmclock
   7949  8f74				  -	      include	"score_graphics.asm.alarmclock"
   7950  8f74				  -	      endif
   7951  8f74				  -	      if	font == handwritten
   7952  8f74				  -	      include	"score_graphics.asm.handwritten"
   7953  8f74				  -	      endif
   7954  8f74				  -	      if	font == interrupted
   7955  8f74				  -	      include	"score_graphics.asm.interrupted"
   7956  8f74				  -	      endif
   7957  8f74				  -	      if	font == retroputer
   7958  8f74				  -	      include	"score_graphics.asm.retroputer"
   7959  8f74				  -	      endif
   7960  8f74				  -	      if	font == whimsey
   7961  8f74				  -	      include	"score_graphics.asm.whimsey"
   7962  8f74				  -	      endif
   7963  8f74				  -	      if	font == tiny
   7964  8f74				  -	      include	"score_graphics.asm.tiny"
   7965  8f74				  -	      endif
   7966  8f74				  -	      if	font == hex
   7967  8f74				  -	      include	"score_graphics.asm.hex"
   7968  8f74				  -	      endif
   7969  8f74					      else		; default font
   7970  8f74
   7971  8f74		       3c		      .byte.b	%00111100
   7972  8f75		       66		      .byte.b	%01100110
   7973  8f76		       66		      .byte.b	%01100110
   7974  8f77		       66		      .byte.b	%01100110
   7975  8f78		       66		      .byte.b	%01100110
   7976  8f79		       66		      .byte.b	%01100110
   7977  8f7a		       66		      .byte.b	%01100110
   7978  8f7b		       3c		      .byte.b	%00111100
   7979  8f7c
   7980  8f7c		       7e		      .byte.b	%01111110
   7981  8f7d		       18		      .byte.b	%00011000
   7982  8f7e		       18		      .byte.b	%00011000
   7983  8f7f		       18		      .byte.b	%00011000
   7984  8f80		       18		      .byte.b	%00011000
   7985  8f81		       38		      .byte.b	%00111000
   7986  8f82		       18		      .byte.b	%00011000
   7987  8f83		       08		      .byte.b	%00001000
   7988  8f84
   7989  8f84		       7e		      .byte.b	%01111110
   7990  8f85		       60		      .byte.b	%01100000
   7991  8f86		       60		      .byte.b	%01100000
   7992  8f87		       3c		      .byte.b	%00111100
   7993  8f88		       06		      .byte.b	%00000110
   7994  8f89		       06		      .byte.b	%00000110
   7995  8f8a		       46		      .byte.b	%01000110
   7996  8f8b		       3c		      .byte.b	%00111100
   7997  8f8c
   7998  8f8c		       3c		      .byte.b	%00111100
   7999  8f8d		       46		      .byte.b	%01000110
   8000  8f8e		       06		      .byte.b	%00000110
   8001  8f8f		       06		      .byte.b	%00000110
   8002  8f90		       1c		      .byte.b	%00011100
   8003  8f91		       06		      .byte.b	%00000110
   8004  8f92		       46		      .byte.b	%01000110
   8005  8f93		       3c		      .byte.b	%00111100
   8006  8f94
   8007  8f94		       0c		      .byte.b	%00001100
   8008  8f95		       0c		      .byte.b	%00001100
   8009  8f96		       7e		      .byte.b	%01111110
   8010  8f97		       4c		      .byte.b	%01001100
   8011  8f98		       4c		      .byte.b	%01001100
   8012  8f99		       2c		      .byte.b	%00101100
   8013  8f9a		       1c		      .byte.b	%00011100
   8014  8f9b		       0c		      .byte.b	%00001100
   8015  8f9c
   8016  8f9c		       3c		      .byte.b	%00111100
   8017  8f9d		       46		      .byte.b	%01000110
   8018  8f9e		       06		      .byte.b	%00000110
   8019  8f9f		       06		      .byte.b	%00000110
   8020  8fa0		       3c		      .byte.b	%00111100
   8021  8fa1		       60		      .byte.b	%01100000
   8022  8fa2		       60		      .byte.b	%01100000
   8023  8fa3		       7e		      .byte.b	%01111110
   8024  8fa4
   8025  8fa4		       3c		      .byte.b	%00111100
   8026  8fa5		       66		      .byte.b	%01100110
   8027  8fa6		       66		      .byte.b	%01100110
   8028  8fa7		       66		      .byte.b	%01100110
   8029  8fa8		       7c		      .byte.b	%01111100
   8030  8fa9		       60		      .byte.b	%01100000
   8031  8faa		       62		      .byte.b	%01100010
   8032  8fab		       3c		      .byte.b	%00111100
   8033  8fac
   8034  8fac		       30		      .byte.b	%00110000
   8035  8fad		       30		      .byte.b	%00110000
   8036  8fae		       30		      .byte.b	%00110000
   8037  8faf		       18		      .byte.b	%00011000
   8038  8fb0		       0c		      .byte.b	%00001100
   8039  8fb1		       06		      .byte.b	%00000110
   8040  8fb2		       42		      .byte.b	%01000010
   8041  8fb3		       3e		      .byte.b	%00111110
   8042  8fb4
   8043  8fb4		       3c		      .byte.b	%00111100
   8044  8fb5		       66		      .byte.b	%01100110
   8045  8fb6		       66		      .byte.b	%01100110
   8046  8fb7		       66		      .byte.b	%01100110
   8047  8fb8		       3c		      .byte.b	%00111100
   8048  8fb9		       66		      .byte.b	%01100110
   8049  8fba		       66		      .byte.b	%01100110
   8050  8fbb		       3c		      .byte.b	%00111100
   8051  8fbc
   8052  8fbc		       3c		      .byte.b	%00111100
   8053  8fbd		       46		      .byte.b	%01000110
   8054  8fbe		       06		      .byte.b	%00000110
   8055  8fbf		       3e		      .byte.b	%00111110
   8056  8fc0		       66		      .byte.b	%01100110
   8057  8fc1		       66		      .byte.b	%01100110
   8058  8fc2		       66		      .byte.b	%01100110
   8059  8fc3		       3c		      .byte.b	%00111100
   8060  8fc4
   8061  8fc4					      ifnconst	DPC_kernel_options
   8062  8fc4
   8063  8fc4		       00		      .byte.b	%00000000
   8064  8fc5		       00		      .byte.b	%00000000
   8065  8fc6		       00		      .byte.b	%00000000
   8066  8fc7		       00		      .byte.b	%00000000
   8067  8fc8		       00		      .byte.b	%00000000
   8068  8fc9		       00		      .byte.b	%00000000
   8069  8fca		       00		      .byte.b	%00000000
   8070  8fcb		       00		      .byte.b	%00000000
   8071  8fcc
   8072  8fcc					      endif
   8073  8fcc
   8074  8fcc					      endif
   8075  8fcc
   8076  8fcc				  -	      ifconst	ROM2k
   8077  8fcc				  -	      ORG	$F7FC
   8078  8fcc					      else
   8079  8fcc					      ifconst	bankswitch
   8080  8fcc				  -	      if	bankswitch == 8
   8081  8fcc				  -	      ORG	$2FF4-bscode_length
   8082  8fcc				  -	      RORG	$FFF4-bscode_length
   8083  8fcc					      endif
   8084  8fcc				  -	      if	bankswitch == 16
   8085  8fcc				  -	      ORG	$4FF4-bscode_length
   8086  8fcc				  -	      RORG	$FFF4-bscode_length
   8087  8fcc					      endif
   8088  8fcc					      if	bankswitch == 32
   8089  8fd4					      ORG	$8FF4-bscode_length
   8090  8fd4					      RORG	$FFF4-bscode_length
   8091  8fd4					      endif
   8092  8fd4				  -	      if	bankswitch == 64
   8093  8fd4				  -	      ORG	$10FE0-bscode_length
   8094  8fd4				  -	      RORG	$1FFE0-bscode_length
   8095  8fd4					      endif
   8096  8fd4				  -	      else
   8097  8fd4				  -	      ORG	$FFFC
   8098  8fd4					      endif
   8099  8fd4					      endif
   8100  8fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   8101  8fd4
   8102  8fd4							; every bank has this stuff at the same place
   8103  8fd4							; this code can switch to/from any bank at any entry point
   8104  8fd4							; and can preserve register values
   8105  8fd4							; note: lines not starting with a space are not placed in all banks
   8106  8fd4							;
   8107  8fd4							; line below tells the compiler how long this is - do not remove
   8108  8fd4							;size=32
   8109  8fd4
   8110  8fd4				   begin_bscode
   8111  8fd4		       a2 ff		      ldx	#$ff
   8112  8fd6				  -	      ifconst	FASTFETCH	; using DPC+
   8113  8fd6				  -	      stx	FASTFETCH
   8114  8fd6					      endif
   8115  8fd6		       9a		      txs
   8116  8fd7				  -	      if	bankswitch == 64
   8117  8fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   8118  8fd7					      else
   8119  8fd7		       a9 f2		      lda	#>(start-1)
   8120  8fd9					      endif
   8121  8fd9		       48		      pha
   8122  8fda		       a9 4f		      lda	#<(start-1)
   8123  8fdc		       48		      pha
   8124  8fdd
   8125  8fdd				   BS_return
   8126  8fdd		       48		      pha
   8127  8fde		       8a		      txa
   8128  8fdf		       48		      pha
   8129  8fe0		       ba		      tsx
   8130  8fe1
   8131  8fe1					      if	bankswitch != 64
   8132  8fe1		       b5 04		      lda	4,x	; get high byte of return address
   8133  8fe3
   8134  8fe3		       2a		      rol
   8135  8fe4		       2a		      rol
   8136  8fe5		       2a		      rol
   8137  8fe6		       2a		      rol
   8138  8fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   8139  8fe9		       aa		      tax
   8140  8fea		       e8		      inx
   8141  8feb				  -	      else
   8142  8feb				  -	      lda	4,x	; get high byte of return address
   8143  8feb				  -	      tay
   8144  8feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   8145  8feb				  -	      sta	4,x
   8146  8feb				  -	      tya
   8147  8feb				  -	      lsr
   8148  8feb				  -	      lsr
   8149  8feb				  -	      lsr
   8150  8feb				  -	      lsr
   8151  8feb				  -	      tax
   8152  8feb				  -	      inx
   8153  8feb					      endif
   8154  8feb
   8155  8feb				   BS_jsr
   8156  8feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   8157  8fee		       68		      pla
   8158  8fef		       aa		      tax
   8159  8ff0		       68		      pla
   8160  8ff1		       60		      rts
   8161  8ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   8162  8ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   8163  8ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   8164  8ff2					      endif
   8165  8ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   8166  8ff2
   8167  8ff2					      ifconst	bankswitch
   8168  8ff2				  -	      if	bankswitch == 8
   8169  8ff2				  -	      ORG	$2FFC
   8170  8ff2				  -	      RORG	$FFFC
   8171  8ff2					      endif
   8172  8ff2				  -	      if	bankswitch == 16
   8173  8ff2				  -	      ORG	$4FFC
   8174  8ff2				  -	      RORG	$FFFC
   8175  8ff2					      endif
   8176  8ff2					      if	bankswitch == 32
   8177  8ffc					      ORG	$8FFC
   8178  8ffc					      RORG	$FFFC
   8179  8ffc					      endif
   8180  8ffc				  -	      if	bankswitch == 64
   8181  8ffc				  -	      ORG	$10FF0
   8182  8ffc				  -	      RORG	$1FFF0
   8183  8ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   8184  8ffc				  -	      ORG	$10FF8
   8185  8ffc				  -	      RORG	$1FFF8
   8186  8ffc				  -	      ifconst	superchip
   8187  8ffc				  -	      .byte	"E","F","S","C"
   8188  8ffc				  -	      else
   8189  8ffc				  -	      .byte	"E","F","E","F"
   8190  8ffc				  -	      endif
   8191  8ffc				  -	      ORG	$10FFC
   8192  8ffc				  -	      RORG	$1FFFC
   8193  8ffc					      endif
   8194  8ffc				  -	      else
   8195  8ffc				  -	      ifconst	ROM2k
   8196  8ffc				  -	      ORG	$F7FC
   8197  8ffc				  -	      else
   8198  8ffc				  -	      ORG	$FFFC
   8199  8ffc				  -	      endif
   8200  8ffc					      endif
   8201  8ffc		       50 f2		      .word.w	(start & $ffff)
   8202  8ffe		       50 f2		      .word.w	(start & $ffff)
