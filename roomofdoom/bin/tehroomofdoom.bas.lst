------- FILE c:\xampp\htdocs\BatariBasicProjects\roomofdoom\tehroomofdoom.bas.asm LEVEL 1 PASS 2
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE c:\xampp\htdocs\BatariBasicProjects\roomofdoom\tehroomofdoom.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE c:\xampp\htdocs\BatariBasicProjects\roomofdoom\tehroomofdoom.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; VCS.H
      4  9000 ????						; Version 1.05, 13/November/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_VCS =	105
      7  9000 ????
      8  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines hardware registers and memory mapping for the
     13  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  9000 ????						; with your views.  Please contribute, if you think you can improve this
     21  9000 ????						; file!
     22  9000 ????						;
     23  9000 ????						; Latest Revisions...
     24  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  9000 ????						;			    This will allow conditional code to verify VCS.H being
     27  9000 ????						;			    used for code assembly.
     28  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  9000 ????						;			 mirrored reading/writing differences.	This is more a 
     31  9000 ????						;			 readability issue, and binary compatibility with disassembled
     32  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  9000 ????						;			 which was broken by the use of segments in this file, as
     35  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  9000 ????						;						   it is safe to leave it undefined, and the base address will
     40  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  9000 ????						;			  - register definitions are now generated through assignment
     43  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     44  9000 ????						;			    address architecture.
     45  9000 ????						; 1.0	22/MAR/2003		Initial release
     46  9000 ????
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????
     50  9000 ????						; TIA_BASE_ADDRESS
     51  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  9000 ????						; Normally 0, the base address should (externally, before including this file)
     53  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  9000 ????						; < $40 as a bankswitch.
     56  9000 ????
     57  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  9000 ????			  -TIA_BASE_ADDRESS =	0
     59  9000 ????				      ENDIF
     60  9000 ????
     61  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  9000 ????						; *OR* by declaring the label before including this file, eg:
     64  9000 ????						; TIA_BASE_ADDRESS = $40
     65  9000 ????						;   include "vcs.h"
     66  9000 ????
     67  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  9000 ????						; for the mirrored ROM hardware registers.
     70  9000 ????
     71  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  9000 ????
     75  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  9000 ????				      ENDIF
     78  9000 ????
     79  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  9000 ????				      ENDIF
     82  9000 ????
     83  9000 ????						;-------------------------------------------------------------------------------
     84  9000 ????
     85 U002d					      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e					      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298					      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  9000 ????				      SEG
    201  9000 ????
    202  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  9000 ????
      3  9000 ????						; MACRO.H
      4  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      5  9000 ????
      6  9000 ????	       00 69	   VERSION_MACRO =	105
      7  9000 ????
      8  9000 ????						;
      9  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  9000 ????						;
     12  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  9000 ????						; It is distributed as a companion machine-specific support package
     14  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  9000 ????						; available at at http://www.atari2600.org/dasm
     16  9000 ????						;
     17  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  9000 ????						; contents, or would like to add something, please write to me
     19  9000 ????						; (atari2600@taswegian.com) with your contribution.
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						;
     23  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  9000 ????						;
     28  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  9000 ????						;
     30  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  9000 ????						;			   (standardised macro for vertical synch code)
     32  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  9000 ????						; 1.0	22/MAR/2003		Initial release
     35  9000 ????
     36  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  9000 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  9000 ????						;   registers and require them to be defined first).
     41  9000 ????
     42  9000 ????						; Available macros...
     43  9000 ????						;   SLEEP n		 - sleep for n cycles
     44  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     46  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  9000 ????
     48  9000 ????						;-------------------------------------------------------------------------------
     49  9000 ????						; SLEEP duration
     50  9000 ????						; Original author: Thomas Jentzsch
     51  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  9000 ????						; useful for code where precise timing is required.
     53  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  9000 ????
     57  9000 ????				      MAC	sleep
     58  9000 ????			   .CYCLES    SET	{1}
     59  9000 ????
     60  9000 ????				      IF	.CYCLES < 2
     61  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  9000 ????				      ERR
     63  9000 ????				      ENDIF
     64  9000 ????
     65  9000 ????				      IF	.CYCLES & 1
     66  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  9000 ????				      nop	0
     68  9000 ????				      ELSE
     69  9000 ????				      bit	VSYNC
     70  9000 ????				      ENDIF
     71  9000 ????			   .CYCLES    SET	.CYCLES - 3
     72  9000 ????				      ENDIF
     73  9000 ????
     74  9000 ????				      REPEAT	.CYCLES / 2
     75  9000 ????				      nop
     76  9000 ????				      REPEND
     77  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     78  9000 ????
     79  9000 ????						;-------------------------------------------------------------------------------
     80  9000 ????						; VERTICAL_SYNC
     81  9000 ????						; Original author: Manuel Polik
     82  9000 ????						; Inserts the code required for a proper 3 scannline 
     83  9000 ????						; vertical sync sequence
     84  9000 ????						;
     85  9000 ????						; Note: Alters the accumulator
     86  9000 ????						;
     87  9000 ????						; IN:
     88  9000 ????						; OUT: A = 1
     89  9000 ????
     90  9000 ????				      MAC	vertical_sync
     91  9000 ????				      LDA	#$02	; A = VSYNC enable
     92  9000 ????				      STA	WSYNC	; Finish current line
     93  9000 ????				      STA	VSYNC	; Start vertical sync
     94  9000 ????				      STA	WSYNC	; 1st line vertical sync
     95  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     96  9000 ????				      LSR		; A = VSYNC disable
     97  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     98  9000 ????				      STA	VSYNC	; Stop vertical sync
     99  9000 ????				      ENDM
    100  9000 ????
    101  9000 ????						;-------------------------------------------------------------------------------
    102  9000 ????						; CLEAN_START
    103  9000 ????						; Original author: Andrew Davie
    104  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    106  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  9000 ????						; Use as very first section of code on boot (ie: at reset)
    108  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  9000 ????
    110  9000 ????				      MAC	clean_start
    111  9000 ????				      sei
    112  9000 ????				      cld
    113  9000 ????
    114  9000 ????				      ldx	#0
    115  9000 ????				      txa
    116  9000 ????				      tay
    117  9000 ????			   .CLEAR_STACK dex
    118  9000 ????				      txs
    119  9000 ????				      pha
    120  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  9000 ????
    122  9000 ????				      ENDM
    123  9000 ????
    124  9000 ????						;-------------------------------------------------------
    125  9000 ????						; SET_POINTER
    126  9000 ????						; Original author: Manuel Rotschkar
    127  9000 ????						;
    128  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  9000 ????						;
    130  9000 ????						; Usage: SET_POINTER pointer, address
    131  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  9000 ????						;
    133  9000 ????						; Note: Alters the accumulator, NZ flags
    134  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  9000 ????						; IN 2: absolute address
    136  9000 ????
    137  9000 ????				      MAC	set_pointer
    138  9000 ????			   .POINTER   SET	{1}
    139  9000 ????			   .ADDRESS   SET	{2}
    140  9000 ????
    141  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  9000 ????				      STA	.POINTER	; Store in pointer
    143  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    145  9000 ????
    146  9000 ????				      ENDM
    147  9000 ????
    148  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 e9	   _Frame_sD_Anim =	v
      5  9000 ????
      6  9000 ????	       00 d4	   _Lives     =	a
      7  9000 ????
      8  9000 ????	       00 07	   bs_mask    =	7
      9  9000 ????	       00 20	   bankswitch =	32
     10  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
     11  9000 ????	       00 01	   PFcolors   =	1
     12  9000 ????	       00 01	   no_blank_lines =	1
     13  9000 ????	       00 01	   player1colors =	1
     14  9000 ????	       00 2b	   vblank_time =	43
     15  9000 ????	       00 25	   overscan_time =	37
------- FILE 2600basic.h
      7  9000 ????
      8  9000 ????	       00 80	   player0x   =	$80
      9  9000 ????	       00 81	   player1x   =	$81
     10  9000 ????	       00 82	   missile0x  =	$82
     11  9000 ????	       00 83	   missile1x  =	$83
     12  9000 ????	       00 84	   ballx      =	$84
     13  9000 ????
     14  9000 ????	       00 85	   objecty    =	$85
     15  9000 ????	       00 85	   player0y   =	$85
     16  9000 ????	       00 86	   player1y   =	$86
     17  9000 ????	       00 87	   missile1height =	$87
     18  9000 ????	       00 88	   missile1y  =	$88
     19  9000 ????	       00 89	   bally      =	$89
     20  9000 ????
     21  9000 ????	       00 87	   player1color =	$87	; replaces missile 1
     22  9000 ????
     23  9000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     24  9000 ????	       00 8a	   player0pointerlo =	$8A
     25  9000 ????	       00 8b	   player0pointerhi =	$8B
     26  9000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     27  9000 ????	       00 8c	   player1pointerlo =	$8C
     28  9000 ????	       00 8d	   player1pointerhi =	$8D
     29  9000 ????
     30  9000 ????	       00 8e	   player0height =	$8E
     31  9000 ????	       00 8f	   player1height =	$8F
     32  9000 ????	       00 90	   missile0height =	$90
     33  9000 ????	       00 91	   missile0y  =	$91
     34  9000 ????	       00 92	   ballheight =	$92
     35  9000 ????
     36  9000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     37  9000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     38  9000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     39  9000 ????	       00 90	   player0color =	$90	; replaces missile 0
     40  9000 ????
     41  9000 ????	       00 93	   score      =	$93	; $93-$95
     42  9000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     43  9000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     44  9000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     45  9000 ????	       00 9e	   temp3      =	$9E
     46  9000 ????	       00 9f	   temp4      =	$9F
     47  9000 ????	       00 a0	   temp5      =	$A0
     48  9000 ????	       00 a1	   temp6      =	$A1
     49  9000 ????
     50  9000 ????	       00 a2	   rand       =	$A2
     51  9000 ????	       00 a3	   scorecolor =	$A3
     52  9000 ????
     53  9000 ????	       00 a4	   var0       =	$A4
     54  9000 ????	       00 a5	   var1       =	$A5
     55  9000 ????	       00 a6	   var2       =	$A6
     56  9000 ????	       00 a7	   var3       =	$A7
     57  9000 ????	       00 a8	   var4       =	$A8
     58  9000 ????	       00 a9	   var5       =	$A9
     59  9000 ????	       00 aa	   var6       =	$AA
     60  9000 ????	       00 ab	   var7       =	$AB
     61  9000 ????	       00 ac	   var8       =	$AC
     62  9000 ????	       00 ad	   var9       =	$AD
     63  9000 ????	       00 ae	   var10      =	$AE
     64  9000 ????	       00 af	   var11      =	$AF
     65  9000 ????	       00 b0	   var12      =	$B0
     66  9000 ????	       00 b1	   var13      =	$B1
     67  9000 ????	       00 b2	   var14      =	$B2
     68  9000 ????	       00 b3	   var15      =	$B3
     69  9000 ????	       00 b4	   var16      =	$B4
     70  9000 ????	       00 b5	   var17      =	$B5
     71  9000 ????	       00 b6	   var18      =	$B6
     72  9000 ????	       00 b7	   var19      =	$B7
     73  9000 ????	       00 b8	   var20      =	$B8
     74  9000 ????	       00 b9	   var21      =	$B9
     75  9000 ????	       00 ba	   var22      =	$BA
     76  9000 ????	       00 bb	   var23      =	$BB
     77  9000 ????	       00 bc	   var24      =	$BC
     78  9000 ????	       00 bd	   var25      =	$BD
     79  9000 ????	       00 be	   var26      =	$BE
     80  9000 ????	       00 bf	   var27      =	$BF
     81  9000 ????	       00 c0	   var28      =	$C0
     82  9000 ????	       00 c1	   var29      =	$C1
     83  9000 ????	       00 c2	   var30      =	$C2
     84  9000 ????	       00 c3	   var31      =	$C3
     85  9000 ????	       00 c4	   var32      =	$C4
     86  9000 ????	       00 c5	   var33      =	$C5
     87  9000 ????	       00 c6	   var34      =	$C6
     88  9000 ????	       00 c7	   var35      =	$C7
     89  9000 ????	       00 c8	   var36      =	$C8
     90  9000 ????	       00 c9	   var37      =	$C9
     91  9000 ????	       00 ca	   var38      =	$CA
     92  9000 ????	       00 cb	   var39      =	$CB
     93  9000 ????	       00 cc	   var40      =	$CC
     94  9000 ????	       00 cd	   var41      =	$CD
     95  9000 ????	       00 ce	   var42      =	$CE
     96  9000 ????	       00 cf	   var43      =	$CF
     97  9000 ????	       00 d0	   var44      =	$D0
     98  9000 ????	       00 d1	   var45      =	$D1
     99  9000 ????	       00 d2	   var46      =	$D2
    100  9000 ????	       00 d3	   var47      =	$D3
    101  9000 ????
    102  9000 ????	       00 d4	   A	      =	$d4
    103  9000 ????	       00 d4	   a	      =	$d4
    104  9000 ????	       00 d5	   B	      =	$d5
    105  9000 ????	       00 d5	   b	      =	$d5
    106  9000 ????	       00 d6	   C	      =	$d6
    107  9000 ????	       00 d6	   c	      =	$d6
    108  9000 ????	       00 d7	   D	      =	$d7
    109  9000 ????	       00 d7	   d	      =	$d7
    110  9000 ????	       00 d8	   E	      =	$d8
    111  9000 ????	       00 d8	   e	      =	$d8
    112  9000 ????	       00 d9	   F	      =	$d9
    113  9000 ????	       00 d9	   f	      =	$d9
    114  9000 ????	       00 da	   G	      =	$da
    115  9000 ????	       00 da	   g	      =	$da
    116  9000 ????	       00 db	   H	      =	$db
    117  9000 ????	       00 db	   h	      =	$db
    118  9000 ????	       00 dc	   I	      =	$dc
    119  9000 ????	       00 dc	   i	      =	$dc
    120  9000 ????	       00 dd	   J	      =	$dd
    121  9000 ????	       00 dd	   j	      =	$dd
    122  9000 ????	       00 de	   K	      =	$de
    123  9000 ????	       00 de	   k	      =	$de
    124  9000 ????	       00 df	   L	      =	$df
    125  9000 ????	       00 df	   l	      =	$df
    126  9000 ????	       00 e0	   M	      =	$e0
    127  9000 ????	       00 e0	   m	      =	$e0
    128  9000 ????	       00 e1	   N	      =	$e1
    129  9000 ????	       00 e1	   n	      =	$e1
    130  9000 ????	       00 e2	   O	      =	$e2
    131  9000 ????	       00 e2	   o	      =	$e2
    132  9000 ????	       00 e3	   P	      =	$e3
    133  9000 ????	       00 e3	   p	      =	$e3
    134  9000 ????	       00 e4	   Q	      =	$e4
    135  9000 ????	       00 e4	   q	      =	$e4
    136  9000 ????	       00 e5	   R	      =	$e5
    137  9000 ????	       00 e5	   r	      =	$e5
    138  9000 ????	       00 e6	   S	      =	$e6
    139  9000 ????	       00 e6	   s	      =	$e6
    140  9000 ????	       00 e7	   T	      =	$e7
    141  9000 ????	       00 e7	   t	      =	$e7
    142  9000 ????	       00 e8	   U	      =	$e8
    143  9000 ????	       00 e8	   u	      =	$e8
    144  9000 ????	       00 e9	   V	      =	$e9
    145  9000 ????	       00 e9	   v	      =	$e9
    146  9000 ????	       00 ea	   W	      =	$ea
    147  9000 ????	       00 ea	   w	      =	$ea
    148  9000 ????	       00 eb	   X	      =	$eb
    149  9000 ????	       00 eb	   x	      =	$eb
    150  9000 ????	       00 ec	   Y	      =	$ec
    151  9000 ????	       00 ec	   y	      =	$ec
    152  9000 ????	       00 ed	   Z	      =	$ed
    153  9000 ????	       00 ed	   z	      =	$ed
    154  9000 ????
    155  9000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    156  9000 ????	       00 ef	   playfieldpos =	$ef
    157  9000 ????
    158  9000 ????						; available for other uses, or if unused, provide more stack space
    159  9000 ????
    160  9000 ????	       00 f0	   aux1       =	$f0
    161  9000 ????	       00 f1	   aux2       =	$f1
    162  9000 ????	       00 f2	   aux3       =	$f2
    163  9000 ????	       00 f3	   aux4       =	$f3
    164  9000 ????	       00 f4	   aux5       =	$f4
    165  9000 ????	       00 f5	   aux6       =	$f5
    166  9000 ????
    167  9000 ????						; playfield color/height pointers
    168  9000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    169  9000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    170  9000 ????						; the above pointers are the same because if color and height are both used together,
    171  9000 ????						; they must used absolute indexed and cannot use pointers
    172  9000 ????
    173  9000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    174  9000 ????						; upper 3 bits of $f2 contain the number of lives
    175  9000 ????	       00 f4	   lifecolor  =	$f4
    176  9000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    177  9000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    178  9000 ????
    179  9000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    180  9000 ????	       00 f3	   pfscore2   =	$f3
    181  9000 ????	       00 f4	   pfscorecolor =	$f4
    182  9000 ????
    183  9000 ????	       00 f6	   stack1     =	$f6
    184  9000 ????	       00 f7	   stack2     =	$f7
    185  9000 ????	       00 f8	   stack3     =	$f8
    186  9000 ????	       00 f9	   stack4     =	$f9
    187  9000 ????						; the stack bytes above may be used in the kernel
    188  9000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    189  9000 ????
    190  9000 ????				      MAC	return
    191  9000 ????				      ifnconst	bankswitch
    192  9000 ????				      rts
    193  9000 ????				      else
    194  9000 ????				      jmp	BS_return
    195  9000 ????				      endif
    196  9000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    197  9000 ????
    198  9000 ????			  -	      ifconst	superchip
    199  9000 ????			  -playfieldbase =	$10D0
    200  9000 ????			  -	      include	superchip.h
    201  9000 ????				      else
    202  9000 ????	       00 a4	   playfieldbase =	$A4
    203  9000 ????				      endif
    204  9000 ????
    205  9000 ????				      ifnconst	pfhalfwidth
    206  9000 ????	       00 04	   pfwidth    =	4
    207  9000 ????	       00 0e	   PF1L       =	PF1
    208  9000 ????	       00 0f	   PF2L       =	PF2
    209  9000 ????	       00 0e	   PF1R       =	PF1
    210  9000 ????	       00 0f	   PF2R       =	PF2
    211  9000 ????	       00 00	   pfadjust   =	0
    212  9000 ????			  -	      else
    213  9000 ????			  -pfwidth    =	2
    214  9000 ????			  -	      ifconst	pfcenter
    215  9000 ????			  -PF1L       =	$3F	; no effect
    216  9000 ????			  -PF2L       =	PF2
    217  9000 ????			  -PF1R       =	$3F
    218  9000 ????			  -PF2R       =	PF2	; no effect
    219  9000 ????			  -pfadjust   =	1
    220  9000 ????			  -	      else
    221  9000 ????			  -PF1L       =	PF1
    222  9000 ????			  -PF2L       =	PF2
    223  9000 ????			  -PF1R       =	$3F	; no effect
    224  9000 ????			  -PF2R       =	$3F	; no effect
    225  9000 ????			  -pfadjust   =	0
    226  9000 ????			  -	      endif
    227  9000 ????				      endif
    228  9000 ????
    229  9000 ????						; define playfield start based on height
    230  9000 ????				      ifnconst	pfres
    231  9000 ????	       00 a4	   playfield  =	playfieldbase
    232  9000 ????			  -	      else
    233  9000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    234  9000 ????				      endif
------- FILE c:\xampp\htdocs\BatariBasicProjects\roomofdoom\tehroomofdoom.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 e9	   _Frame_sD_Anim =	v
      5  9000 ????
      6  9000 ????	       00 d4	   _Lives     =	a
      7  9000 ????
      8  9000 ????	       00 07	   bs_mask    =	7
      9  9000 ????	       00 20	   bankswitch =	32
     10  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
     11  9000 ????	       00 01	   PFcolors   =	1
     12  9000 ????	       00 01	   no_blank_lines =	1
     13  9000 ????	       00 01	   player1colors =	1
     14  9000 ????	       00 2b	   vblank_time =	43
     15  9000 ????	       00 25	   overscan_time =	37
------- FILE c:\xampp\htdocs\BatariBasicProjects\roomofdoom\tehroomofdoom.bas.asm
      8  9000 ????				      ifconst	bankswitch
      9  9000 ????			  -	      if	bankswitch == 8
     10  9000 ????			  -	      ORG	$1000
     11  9000 ????			  -	      RORG	$D000
     12  9000 ????				      endif
     13  9000 ????			  -	      if	bankswitch == 16
     14  9000 ????			  -	      ORG	$1000
     15  9000 ????			  -	      RORG	$9000
     16  9000 ????				      endif
     17  9000 ????				      if	bankswitch == 32
     18  1000					      ORG	$1000
     19  1000					      RORG	$1000
     20  1000					      endif
     21  1000				  -	      if	bankswitch == 64
     22  1000				  -	      ORG	$1000
     23  1000				  -	      RORG	$1000
     24  1000					      endif
     25  1000				  -	      else
     26  1000				  -	      ORG	$F000
     27  1000					      endif
     28  1000
     29  1000					      ifconst	bankswitch_hotspot
     30  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     31  1000				  -	      .byte	0	; stop unexpected bankswitches
     32  1000					      endif
     33  1000					      endif
     34  1000				   game
     35  1000				   .
     36  1000							; 
     37  1000
     38  1000				   .
     39  1000							; 
     40  1000
     41  1000				   .
     42  1000							; 
     43  1000
     44  1000				   .L00 		;  set tv ntsc
     45  1000
     46  1000				   .L01 		;  set kernel_options player1colors pfcolors no_blank_lines
     47  1000
     48  1000				   .L02 		;  set romsize 32k
     49  1000
     50  1000				   .
     51  1000							; 
     52  1000
     53  1000				   .
     54  1000							; 
     55  1000
     56  1000				   .
     57  1000							; 
     58  1000
     59  1000				   .
     60  1000							; 
     61  1000
     62  1000				   .
     63  1000							; 
     64  1000
     65  1000				   .
     66  1000							; 
     67  1000
     68  1000				   .
     69  1000							; 
     70  1000
     71  1000				   .
     72  1000							; 
     73  1000
     74  1000				   .
     75  1000							; 
     76  1000
     77  1000				   .L03 		;  dim _Lives	=  a
     78  1000
     79  1000				   .L04 		;  dim _Frame_sD_Anim	=  v
     80  1000
     81  1000				   .
     82  1000							; 
     83  1000
     84  1000				   .
     85  1000							; 
     86  1000
     87  1000				   .
     88  1000							; 
     89  1000
     90  1000				   .L05 		;  rem Create the title screen
     91  1000
     92  1000				   .opening
     93  1000							; opening
     94  1000
     95  1000				   .L06 		;  pfcolors:
     96  1000
     97  1000		       a9 8a		      lda	# $8A
     98  1002		       85 08		      sta	COLUPF
     99  1004				  -	      ifconst	pfres
    100  1004				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
    101  1004					      else
    102  1004		       a9 f5		      lda	#>(pfcolorlabel13-84)
    103  1006					      endif
    104  1006		       85 f1		      sta	pfcolortable+1
    105  1008				  -	      ifconst	pfres
    106  1008				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
    107  1008					      else
    108  1008		       a9 04		      lda	#<(pfcolorlabel13-84)
    109  100a					      endif
    110  100a		       85 f0		      sta	pfcolortable
    111  100c				   .L07 		;  playfield:
    112  100c
    113  100c				  -	      ifconst	pfres
    114  100c				  -	      ldx	#(12>pfres)*(pfres*pfwidth-1)+(12<=pfres)*47
    115  100c					      else
    116  100c		       a2 2f		      ldx	#((12*pfwidth-1)*((12*pfwidth-1)<47))+(47*((12*pfwidth-1)>=47))
    117  100e					      endif
    118  100e		       4c 41 10 	      jmp	pflabel0
    119  1011				   PF_data0
    120  1011		       20 08		      .byte.b	%00100000, %00001000
    121  1013					      if	(pfwidth>2)
    122  1013		       44 08		      .byte.b	%01000100, %00001000
    123  1015					      endif
    124  1015		       38 14		      .byte.b	%00111000, %00010100
    125  1017					      if	(pfwidth>2)
    126  1017		       a6 0c		      .byte.b	%10100110, %00001100
    127  1019					      endif
    128  1019		       26 a2		      .byte.b	%00100110, %10100010
    129  101b					      if	(pfwidth>2)
    130  101b		       15 0a		      .byte.b	%00010101, %00001010
    131  101d					      endif
    132  101d		       21 a2		      .byte.b	%00100001, %10100010
    133  101f					      if	(pfwidth>2)
    134  101f		       14 09		      .byte.b	%00010100, %00001001
    135  1021					      endif
    136  1021		       21 a2		      .byte.b	%00100001, %10100010
    137  1023					      if	(pfwidth>2)
    138  1023		       14 08		      .byte.b	%00010100, %00001000
    139  1025					      endif
    140  1025		       21 a2		      .byte.b	%00100001, %10100010
    141  1027					      if	(pfwidth>2)
    142  1027		       14 08		      .byte.b	%00010100, %00001000
    143  1029					      endif
    144  1029		       22 a2		      .byte.b	%00100010, %10100010
    145  102b					      if	(pfwidth>2)
    146  102b		       14 08		      .byte.b	%00010100, %00001000
    147  102d					      endif
    148  102d		       24 a2		      .byte.b	%00100100, %10100010
    149  102f					      if	(pfwidth>2)
    150  102f		       14 08		      .byte.b	%00010100, %00001000
    151  1031					      endif
    152  1031		       24 14		      .byte.b	%00100100, %00010100
    153  1033					      if	(pfwidth>2)
    154  1033		       a4 08		      .byte.b	%10100100, %00001000
    155  1035					      endif
    156  1035		       28 08		      .byte.b	%00101000, %00001000
    157  1037					      if	(pfwidth>2)
    158  1037		       44 08		      .byte.b	%01000100, %00001000
    159  1039					      endif
    160  1039		       30 00		      .byte.b	%00110000, %00000000
    161  103b					      if	(pfwidth>2)
    162  103b		       00 08		      .byte.b	%00000000, %00001000
    163  103d					      endif
    164  103d		       20 00		      .byte.b	%00100000, %00000000
    165  103f					      if	(pfwidth>2)
    166  103f		       00 08		      .byte.b	%00000000, %00001000
    167  1041					      endif
    168  1041				   pflabel0
    169  1041		       bd 11 10 	      lda	PF_data0,x
    170  1044		       95 a4		      sta	playfield,x
    171  1046		       ca		      dex
    172  1047		       10 f8		      bpl	pflabel0
    173  1049				   .
    174  1049							; 
    175  1049
    176  1049				   .L08 		;  rem Loop the screen until the spacebar is pressed
    177  1049
    178  1049				   .title
    179  1049							; title
    180  1049
    181  1049				   .L09 		;  drawscreen
    182  1049
    183  1049		       85 ee		      sta	temp7
    184  104b		       a9 10		      lda	#>(ret_point1-1)
    185  104d		       48		      pha
    186  104e		       a9 60		      lda	#<(ret_point1-1)
    187  1050		       48		      pha
    188  1051		       a9 f4		      lda	#>(drawscreen-1)
    189  1053		       48		      pha
    190  1054		       a9 35		      lda	#<(drawscreen-1)
    191  1056		       48		      pha
    192  1057		       a5 ee		      lda	temp7
    193  1059		       48		      pha
    194  105a		       8a		      txa
    195  105b		       48		      pha
    196  105c		       a2 08		      ldx	#8
    197  105e		       4c eb ff 	      jmp	BS_jsr
    198  1061				   ret_point1
    199  1061				   .L010		;  if joy0fire  ||  joy1fire then goto skiptitle
    200  1061
    201  1061		       24 0c		      bit	INPT4
    202  1063		       30 03		      BMI	.skipL010
    203  1065				   .condpart0
    204  1065		       4c 6c 10 	      jmp	.condpart1
    205  1068				   .skipL010
    206  1068		       24 0d		      bit	INPT5
    207  106a		       30 03		      BMI	.skip0OR
    208  106c				   .condpart1
    209  106c		       4c 72 10 	      jmp	.skiptitle
    210  106f
    211  106f				   .skip0OR
    212  106f				   .L011		;  goto title
    213  106f
    214  106f		       4c 49 10 	      jmp	.title
    215  1072
    216  1072				   .
    217  1072							; 
    218  1072
    219  1072				   .L012		;  rem This function displays after the title is skipped
    220  1072
    221  1072				   .skiptitle
    222  1072							; skiptitle
    223  1072
    224  1072				   .
    225  1072							; 
    226  1072
    227  1072				   .L013		;  rem Colors
    228  1072
    229  1072				   .L014		;  COLUPF  =  0
    230  1072
    231  1072		       a9 00		      LDA	#0
    232  1074		       85 08		      STA	COLUPF
    233  1076				   .L015		;  COLUBK  =  $08
    234  1076
    235  1076		       a9 08		      LDA	#$08
    236  1078		       85 09		      STA	COLUBK
    237  107a				   .
    238  107a							; 
    239  107a
    240  107a				   .L016		;  rem Player location
    241  107a
    242  107a				   .L017		;  player0x  =  78  :	player0y  =  88
    243  107a
    244  107a		       a9 4e		      LDA	#78
    245  107c		       85 80		      STA	player0x
    246  107e		       a9 58		      LDA	#88
    247  1080		       85 85		      STA	player0y
    248  1082				   .L018		;  player1x  =  20  :	player1y  =  20
    249  1082
    250  1082		       a9 14		      LDA	#20
    251  1084		       85 81		      STA	player1x
    252  1086		       85 86		      STA	player1y
    253  1088				   .
    254  1088							; 
    255  1088
    256  1088				   .L019		;  rem Score setting and color
    257  1088
    258  1088				   .L020		;  score  =  5  :  scorecolor	=  0
    259  1088
    260  1088		       a9 05		      LDA	#$05
    261  108a		       85 95		      STA	score+2
    262  108c		       a9 00		      LDA	#$00
    263  108e		       85 94		      STA	score+1
    264  1090		       a9 00		      LDA	#$00
    265  1092		       85 93		      STA	score
    266  1094		       a9 00		      LDA	#0
    267  1096		       85 a3		      STA	scorecolor
    268  1098				   .
    269  1098							; 
    270  1098
    271  1098				   .L021		;  rem Missle size and location
    272  1098
    273  1098				   .L022		;  ballheight = 4 : bally = 255
    274  1098
    275  1098		       a9 04		      LDA	#4
    276  109a		       85 92		      STA	ballheight
    277  109c		       a9 ff		      LDA	#255
    278  109e		       85 89		      STA	bally
    279  10a0				   .L023		;  NUSIZ0  =  16
    280  10a0
    281  10a0		       a9 10		      LDA	#16
    282  10a2		       85 04		      STA	NUSIZ0
    283  10a4				   .
    284  10a4							; 
    285  10a4
    286  10a4				   .L024		;  rem Create a variable to keep up with lives
    287  10a4
    288  10a4				   .L025		;  _Lives  =  5
    289  10a4
    290  10a4		       a9 05		      LDA	#5
    291  10a6		       85 d4		      STA	_Lives
    292  10a8				   .
    293  10a8							; 
    294  10a8
    295  10a8				   .L026		;  rem Create the playfield
    296  10a8
    297  10a8				   .
    298  10a8							; 
    299  10a8
    300  10a8				   .L027		;  pfcolors:
    301  10a8
    302  10a8		       a9 36		      lda	# $36
    303  10aa		       85 08		      sta	COLUPF
    304  10ac				  -	      ifconst	pfres
    305  10ac				  -	      lda	#>(pfcolorlabel13-131+pfres*pfwidth)
    306  10ac					      else
    307  10ac		       a9 f5		      lda	#>(pfcolorlabel13-83)
    308  10ae					      endif
    309  10ae		       85 f1		      sta	pfcolortable+1
    310  10b0				  -	      ifconst	pfres
    311  10b0				  -	      lda	#<(pfcolorlabel13-131+pfres*pfwidth)
    312  10b0					      else
    313  10b0		       a9 05		      lda	#<(pfcolorlabel13-83)
    314  10b2					      endif
    315  10b2		       85 f0		      sta	pfcolortable
    316  10b4				   .L028		;  playfield:
    317  10b4
    318  10b4				  -	      ifconst	pfres
    319  10b4				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    320  10b4					      else
    321  10b4		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    322  10b6					      endif
    323  10b6		       4c e5 10 	      jmp	pflabel1
    324  10b9				   PF_data1
    325  10b9		       1f ff		      .byte.b	%00011111, %11111111
    326  10bb					      if	(pfwidth>2)
    327  10bb		       ff 1f		      .byte.b	%11111111, %00011111
    328  10bd					      endif
    329  10bd		       01 ff		      .byte.b	%00000001, %11111111
    330  10bf					      if	(pfwidth>2)
    331  10bf		       ff 01		      .byte.b	%11111111, %00000001
    332  10c1					      endif
    333  10c1		       00 fe		      .byte.b	%00000000, %11111110
    334  10c3					      if	(pfwidth>2)
    335  10c3		       fe 00		      .byte.b	%11111110, %00000000
    336  10c5					      endif
    337  10c5		       00 f8		      .byte.b	%00000000, %11111000
    338  10c7					      if	(pfwidth>2)
    339  10c7		       f8 00		      .byte.b	%11111000, %00000000
    340  10c9					      endif
    341  10c9		       00 e0		      .byte.b	%00000000, %11100000
    342  10cb					      if	(pfwidth>2)
    343  10cb		       e0 00		      .byte.b	%11100000, %00000000
    344  10cd					      endif
    345  10cd		       00 e0		      .byte.b	%00000000, %11100000
    346  10cf					      if	(pfwidth>2)
    347  10cf		       e0 00		      .byte.b	%11100000, %00000000
    348  10d1					      endif
    349  10d1		       00 e0		      .byte.b	%00000000, %11100000
    350  10d3					      if	(pfwidth>2)
    351  10d3		       e0 00		      .byte.b	%11100000, %00000000
    352  10d5					      endif
    353  10d5		       00 f8		      .byte.b	%00000000, %11111000
    354  10d7					      if	(pfwidth>2)
    355  10d7		       f8 00		      .byte.b	%11111000, %00000000
    356  10d9					      endif
    357  10d9		       00 fe		      .byte.b	%00000000, %11111110
    358  10db					      if	(pfwidth>2)
    359  10db		       fe 00		      .byte.b	%11111110, %00000000
    360  10dd					      endif
    361  10dd		       01 ff		      .byte.b	%00000001, %11111111
    362  10df					      if	(pfwidth>2)
    363  10df		       ff 01		      .byte.b	%11111111, %00000001
    364  10e1					      endif
    365  10e1		       1f ff		      .byte.b	%00011111, %11111111
    366  10e3					      if	(pfwidth>2)
    367  10e3		       ff 1f		      .byte.b	%11111111, %00011111
    368  10e5					      endif
    369  10e5				   pflabel1
    370  10e5		       bd b9 10 	      lda	PF_data1,x
    371  10e8		       95 a4		      sta	playfield,x
    372  10ea		       ca		      dex
    373  10eb		       10 f8		      bpl	pflabel1
    374  10ed				   .
    375  10ed							; 
    376  10ed
    377  10ed				   .
    378  10ed							; 
    379  10ed
    380  10ed				   .L029		;  rem This main function is what loops constantly
    381  10ed
    382  10ed				   .main
    383  10ed							; main
    384  10ed
    385  10ed				   .
    386  10ed							; 
    387  10ed
    388  10ed				   .L030		;  rem This is the animation function
    389  10ed
    390  10ed				   .animate
    391  10ed							; animate
    392  10ed
    393  10ed				   .L031		;  rem This frame variable slows down the animation
    394  10ed
    395  10ed				   .L032		;  _Frame_sD_Anim  =  _Frame_sD_Anim  +  1
    396  10ed
    397  10ed		       e6 e9		      INC	_Frame_sD_Anim
    398  10ef				   .
    399  10ef							; 
    400  10ef
    401  10ef				   .L033		;  rem This code animates the sprites
    402  10ef
    403  10ef				   .L034		;  if _Frame_sD_Anim  =  7  &&  w  =  0 then ax
    404  10ef
    405  10ef		       a5 e9		      LDA	_Frame_sD_Anim
    406  10f1		       c9 07		      CMP	#7
    407  10f3		       d0 06		      BNE	.skipL034
    408  10f5				   .condpart2
    409  10f5		       a5 ea		      LDA	w
    410  10f7		       c9 00		      CMP	#0
    411  10f9		       f0 27		      beq	.ax
    412  10fb				  -	      if	( (((((#>*)&$1f)*256)|(#<.ax))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.ax))<=(bankswitch_hotspot+bs_mask)) )
    413  10fb				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    414  10fb					      endif
    415  10fb				   .skipL034
    416  10fb				   .L035		;  if _Frame_sD_Anim  =  7  &&  w  =  1 then bx
    417  10fb
    418  10fb		       a5 e9		      LDA	_Frame_sD_Anim
    419  10fd		       c9 07		      CMP	#7
    420  10ff		       d0 06		      BNE	.skipL035
    421  1101				   .condpart3
    422  1101		       a5 ea		      LDA	w
    423  1103		       c9 01		      CMP	#1
    424  1105		       f0 32		      beq	.bx
    425  1107				  -	      if	( (((((#>*)&$1f)*256)|(#<.bx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.bx))<=(bankswitch_hotspot+bs_mask)) )
    426  1107				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    427  1107					      endif
    428  1107				   .skipL035
    429  1107				   .L036		;  if _Frame_sD_Anim  =  7  &&  w  =  2 then cx
    430  1107
    431  1107		       a5 e9		      LDA	_Frame_sD_Anim
    432  1109		       c9 07		      CMP	#7
    433  110b		       d0 06		      BNE	.skipL036
    434  110d				   .condpart4
    435  110d		       a5 ea		      LDA	w
    436  110f		       c9 02		      CMP	#2
    437  1111		       f0 3d		      beq	.cx
    438  1113				  -	      if	( (((((#>*)&$1f)*256)|(#<.cx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.cx))<=(bankswitch_hotspot+bs_mask)) )
    439  1113				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    440  1113					      endif
    441  1113				   .skipL036
    442  1113				   .L037		;  if _Frame_sD_Anim  =  7  &&  w  =  3 then dx
    443  1113
    444  1113		       a5 e9		      LDA	_Frame_sD_Anim
    445  1115		       c9 07		      CMP	#7
    446  1117		       d0 06		      BNE	.skipL037
    447  1119				   .condpart5
    448  1119		       a5 ea		      LDA	w
    449  111b		       c9 03		      CMP	#3
    450  111d		       f0 48		      beq	.dx
    451  111f				  -	      if	( (((((#>*)&$1f)*256)|(#<.dx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.dx))<=(bankswitch_hotspot+bs_mask)) )
    452  111f				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    453  111f					      endif
    454  111f				   .skipL037
    455  111f				   .
    456  111f							; 
    457  111f
    458  111f				   .L038		;  goto nextstep
    459  111f
    460  111f		       4c 7e 11 	      jmp	.nextstep
    461  1122
    462  1122				   .
    463  1122							; 
    464  1122
    465  1122				   .L039		;  rem These four sprites are different stages of the animation
    466  1122
    467  1122				   .ax
    468  1122							; ax
    469  1122
    470  1122				   .L040		;  _Frame_sD_Anim  =  0
    471  1122
    472  1122		       a9 00		      LDA	#0
    473  1124		       85 e9		      STA	_Frame_sD_Anim
    474  1126				   .L041		;  w  =  1
    475  1126
    476  1126		       a9 01		      LDA	#1
    477  1128		       85 ea		      STA	w
    478  112a				   .L042		;  player1:
    479  112a
    480  112a		       a2 84		      LDX	#<playerL042_1
    481  112c		       86 8c		      STX	player1pointerlo
    482  112e		       a9 f5		      LDA	#>playerL042_1
    483  1130		       85 8d		      STA	player1pointerhi
    484  1132		       a9 03		      LDA	#3
    485  1134		       85 8f		      STA	player1height
    486  1136				   .L043		;  goto nextstep
    487  1136
    488  1136		       4c 7e 11 	      jmp	.nextstep
    489  1139
    490  1139				   .
    491  1139							; 
    492  1139
    493  1139				   .bx
    494  1139							; bx
    495  1139
    496  1139				   .L044		;  _Frame_sD_Anim  =  0
    497  1139
    498  1139		       a9 00		      LDA	#0
    499  113b		       85 e9		      STA	_Frame_sD_Anim
    500  113d				   .L045		;  w  =  2
    501  113d
    502  113d		       a9 02		      LDA	#2
    503  113f		       85 ea		      STA	w
    504  1141				   .L046		;  player1:
    505  1141
    506  1141		       a2 88		      LDX	#<playerL046_1
    507  1143		       86 8c		      STX	player1pointerlo
    508  1145		       a9 f5		      LDA	#>playerL046_1
    509  1147		       85 8d		      STA	player1pointerhi
    510  1149		       a9 03		      LDA	#3
    511  114b		       85 8f		      STA	player1height
    512  114d				   .L047		;  goto nextstep
    513  114d
    514  114d		       4c 7e 11 	      jmp	.nextstep
    515  1150
    516  1150				   .
    517  1150							; 
    518  1150
    519  1150				   .cx
    520  1150							; cx
    521  1150
    522  1150				   .L048		;  _Frame_sD_Anim  =  0
    523  1150
    524  1150		       a9 00		      LDA	#0
    525  1152		       85 e9		      STA	_Frame_sD_Anim
    526  1154				   .L049		;  w  =  3
    527  1154
    528  1154		       a9 03		      LDA	#3
    529  1156		       85 ea		      STA	w
    530  1158				   .L050		;  player1:
    531  1158
    532  1158		       a2 8c		      LDX	#<playerL050_1
    533  115a		       86 8c		      STX	player1pointerlo
    534  115c		       a9 f5		      LDA	#>playerL050_1
    535  115e		       85 8d		      STA	player1pointerhi
    536  1160		       a9 03		      LDA	#3
    537  1162		       85 8f		      STA	player1height
    538  1164				   .L051		;  goto nextstep
    539  1164
    540  1164		       4c 7e 11 	      jmp	.nextstep
    541  1167
    542  1167				   .
    543  1167							; 
    544  1167
    545  1167				   .dx
    546  1167							; dx
    547  1167
    548  1167				   .L052		;  _Frame_sD_Anim  =  0
    549  1167
    550  1167		       a9 00		      LDA	#0
    551  1169		       85 e9		      STA	_Frame_sD_Anim
    552  116b				   .L053		;  w  =  0
    553  116b
    554  116b		       a9 00		      LDA	#0
    555  116d		       85 ea		      STA	w
    556  116f				   .L054		;  player1:
    557  116f
    558  116f		       a2 90		      LDX	#<playerL054_1
    559  1171		       86 8c		      STX	player1pointerlo
    560  1173		       a9 f5		      LDA	#>playerL054_1
    561  1175		       85 8d		      STA	player1pointerhi
    562  1177		       a9 03		      LDA	#3
    563  1179		       85 8f		      STA	player1height
    564  117b				   .L055		;  goto nextstep
    565  117b
    566  117b		       4c 7e 11 	      jmp	.nextstep
    567  117e
    568  117e				   .
    569  117e							; 
    570  117e
    571  117e				   .L056		;  rem Create acorn sprite
    572  117e
    573  117e				   .nextstep
    574  117e							; nextstep
    575  117e
    576  117e				   .L057		;  player0:
    577  117e
    578  117e		       a2 94		      LDX	#<playerL057_0
    579  1180		       86 8a		      STX	player0pointerlo
    580  1182		       a9 f5		      LDA	#>playerL057_0
    581  1184		       85 8b		      STA	player0pointerhi
    582  1186		       a9 0e		      LDA	#14
    583  1188		       85 8e		      STA	player0height
    584  118a				   .
    585  118a							; 
    586  118a
    587  118a				   .L058		;  rem check to see if a missile has already been fired
    588  118a
    589  118a				   .checkfire
    590  118a							; checkfire
    591  118a
    592  118a				   .L059		;  if bally > 240 then goto skip
    593  118a
    594  118a		       a9 f0		      LDA	#240
    595  118c		       c5 89		      CMP	bally
    596  118e		       b0 03		      BCS	.skipL059
    597  1190				   .condpart6
    598  1190		       4c 9d 11 	      jmp	.skip
    599  1193
    600  1193				   .skipL059
    601  1193				   .L060		;  bally  =  bally  -	2  :  goto draw
    602  1193
    603  1193		       a5 89		      LDA	bally
    604  1195		       38		      SEC
    605  1196		       e9 02		      SBC	#2
    606  1198		       85 89		      STA	bally
    607  119a		       4c af 11 	      jmp	.draw
    608  119d
    609  119d				   .
    610  119d							; 
    611  119d
    612  119d				   .L061		;  rem if a missile hasn't been fired, then fire missile
    613  119d
    614  119d				   .skip
    615  119d							; skip
    616  119d
    617  119d				   .L062		;  if joy0fire then bally = player0y - 2 : ballx = player0x + 4
    618  119d
    619  119d		       24 0c		      bit	INPT4
    620  119f		       30 0e		      BMI	.skipL062
    621  11a1				   .condpart7
    622  11a1		       a5 85		      LDA	player0y
    623  11a3		       38		      SEC
    624  11a4		       e9 02		      SBC	#2
    625  11a6		       85 89		      STA	bally
    626  11a8		       a5 80		      LDA	player0x
    627  11aa		       18		      CLC
    628  11ab		       69 04		      ADC	#4
    629  11ad		       85 84		      STA	ballx
    630  11af				   .skipL062
    631  11af				   .
    632  11af							; 
    633  11af
    634  11af				   .L063		;  rem Draw output to screen
    635  11af
    636  11af				   .draw
    637  11af							; draw
    638  11af
    639  11af				   .L064		;  drawscreen
    640  11af
    641  11af		       85 ee		      sta	temp7
    642  11b1		       a9 11		      lda	#>(ret_point2-1)
    643  11b3		       48		      pha
    644  11b4		       a9 c6		      lda	#<(ret_point2-1)
    645  11b6		       48		      pha
    646  11b7		       a9 f4		      lda	#>(drawscreen-1)
    647  11b9		       48		      pha
    648  11ba		       a9 35		      lda	#<(drawscreen-1)
    649  11bc		       48		      pha
    650  11bd		       a5 ee		      lda	temp7
    651  11bf		       48		      pha
    652  11c0		       8a		      txa
    653  11c1		       48		      pha
    654  11c2		       a2 08		      ldx	#8
    655  11c4		       4c eb ff 	      jmp	BS_jsr
    656  11c7				   ret_point2
    657  11c7				   .
    658  11c7							; 
    659  11c7
    660  11c7				   .L065		;  rem Fix player wraparound bug
    661  11c7
    662  11c7				   .L066		;  if player0x  <  8 then player0x  =	8
    663  11c7
    664  11c7		       a5 80		      LDA	player0x
    665  11c9		       c9 08		      CMP	#8
    666  11cb		       b0 04		      BCS	.skipL066
    667  11cd				   .condpart8
    668  11cd		       a9 08		      LDA	#8
    669  11cf		       85 80		      STA	player0x
    670  11d1				   .skipL066
    671  11d1				   .L067		;  if player0x  >  150 then player0x  =  150
    672  11d1
    673  11d1		       a9 96		      LDA	#150
    674  11d3		       c5 80		      CMP	player0x
    675  11d5		       b0 04		      BCS	.skipL067
    676  11d7				   .condpart9
    677  11d7		       a9 96		      LDA	#150
    678  11d9		       85 80		      STA	player0x
    679  11db				   .skipL067
    680  11db				   .L068		;  if player0y  <  8 then player0y  =	8
    681  11db
    682  11db		       a5 85		      LDA	player0y
    683  11dd		       c9 08		      CMP	#8
    684  11df		       b0 04		      BCS	.skipL068
    685  11e1				   .condpart10
    686  11e1		       a9 08		      LDA	#8
    687  11e3		       85 85		      STA	player0y
    688  11e5				   .skipL068
    689  11e5				   .L069		;  if player0y  >  88 then player0y  =  88
    690  11e5
    691  11e5		       a9 58		      LDA	#88
    692  11e7		       c5 85		      CMP	player0y
    693  11e9		       b0 04		      BCS	.skipL069
    694  11eb				   .condpart11
    695  11eb		       a9 58		      LDA	#88
    696  11ed		       85 85		      STA	player0y
    697  11ef				   .skipL069
    698  11ef				   .
    699  11ef							; 
    700  11ef
    701  11ef				   .L070		;  rem Have player 1 chase player 2
    702  11ef
    703  11ef				   .L071		;  if player1y  <  player0y then player1y  =  player1y  +  1
    704  11ef
    705  11ef		       a5 86		      LDA	player1y
    706  11f1		       c5 85		      CMP	player0y
    707  11f3		       b0 02		      BCS	.skipL071
    708  11f5				   .condpart12
    709  11f5		       e6 86		      INC	player1y
    710  11f7				   .skipL071
    711  11f7				   .L072		;  if player1y  >  player0y then player1y  =  player1y  -  1
    712  11f7
    713  11f7		       a5 85		      LDA	player0y
    714  11f9		       c5 86		      CMP	player1y
    715  11fb		       b0 02		      BCS	.skipL072
    716  11fd				   .condpart13
    717  11fd		       c6 86		      DEC	player1y
    718  11ff				   .skipL072
    719  11ff				   .L073		;  if player1x  <  player0x then player1x  =  player1x  +  1
    720  11ff
    721  11ff		       a5 81		      LDA	player1x
    722  1201		       c5 80		      CMP	player0x
    723  1203		       b0 02		      BCS	.skipL073
    724  1205				   .condpart14
    725  1205		       e6 81		      INC	player1x
    726  1207				   .skipL073
    727  1207				   .L074		;  if player1x  >  player0x then player1x  =  player1x  -  1
    728  1207
    729  1207		       a5 80		      LDA	player0x
    730  1209		       c5 81		      CMP	player1x
    731  120b		       b0 02		      BCS	.skipL074
    732  120d				   .condpart15
    733  120d		       c6 81		      DEC	player1x
    734  120f				   .skipL074
    735  120f				   .L075		;  player1x  =  player1x  :  player1y	=  player1y
    736  120f
    737  120f		       a5 81		      LDA	player1x
    738  1211		       85 81		      STA	player1x
    739  1213		       a5 86		      LDA	player1y
    740  1215		       85 86		      STA	player1y
    741  1217				   .
    742  1217							; 
    743  1217
    744  1217				   .
    745  1217							; 
    746  1217
    747  1217				   .L076		;  rem Detect missile collision with squirrel
    748  1217
    749  1217				   .L077		;  if collision(ball,player1) then score = score + 1 : player1x = rand / 2 : player1y = 0 : bally = 255 : goto pointsound
    750  1217
    751  1217		       24 03		      bit	CXP1FB
    752  1219		       50 3b		      BVC	.skipL077
    753  121b				   .condpart16
    754  121b		       f8		      SED
    755  121c		       18		      CLC
    756  121d		       a5 95		      LDA	score+2
    757  121f		       69 01		      ADC	#$01
    758  1221		       85 95		      STA	score+2
    759  1223		       a5 94		      LDA	score+1
    760  1225		       69 00		      ADC	#$00
    761  1227		       85 94		      STA	score+1
    762  1229		       a5 93		      LDA	score
    763  122b		       69 00		      ADC	#$00
    764  122d		       85 93		      STA	score
    765  122f		       d8		      CLD
    766  1230		       85 ee		      sta	temp7
    767  1232		       a9 12		      lda	#>(ret_point3-1)
    768  1234		       48		      pha
    769  1235		       a9 47		      lda	#<(ret_point3-1)
    770  1237		       48		      pha
    771  1238		       a9 f4		      lda	#>(randomize-1)
    772  123a		       48		      pha
    773  123b		       a9 29		      lda	#<(randomize-1)
    774  123d		       48		      pha
    775  123e		       a5 ee		      lda	temp7
    776  1240		       48		      pha
    777  1241		       8a		      txa
    778  1242		       48		      pha
    779  1243		       a2 08		      ldx	#8
    780  1245		       4c eb ff 	      jmp	BS_jsr
    781  1248				   ret_point3
    782  1248		       4a		      lsr
    783  1249		       85 81		      STA	player1x
    784  124b		       a9 00		      LDA	#0
    785  124d		       85 86		      STA	player1y
    786  124f		       a9 ff		      LDA	#255
    787  1251		       85 89		      STA	bally
    788  1253		       4c ae 12 	      jmp	.pointsound
    789  1256
    790  1256				   .skipL077
    791  1256				   .L078		;  rem Detect squirrel collision with the acorn
    792  1256
    793  1256				   .L079		;  if collision(player0,player1) then score = score - 1 : player1x = rand / 2 : player1y = 0 : bally = 255 : _Lives = _Lives - 1 : goto deadsound
    794  1256
    795  1256		       24 07		      bit	CXPPMM
    796  1258		       10 3d		      BPL	.skipL079
    797  125a				   .condpart17
    798  125a		       f8		      SED
    799  125b		       38		      SEC
    800  125c		       a5 95		      LDA	score+2
    801  125e		       e9 01		      SBC	#$01
    802  1260		       85 95		      STA	score+2
    803  1262		       a5 94		      LDA	score+1
    804  1264		       e9 00		      SBC	#$00
    805  1266		       85 94		      STA	score+1
    806  1268		       a5 93		      LDA	score
    807  126a		       e9 00		      SBC	#$00
    808  126c		       85 93		      STA	score
    809  126e		       d8		      CLD
    810  126f		       85 ee		      sta	temp7
    811  1271		       a9 12		      lda	#>(ret_point4-1)
    812  1273		       48		      pha
    813  1274		       a9 86		      lda	#<(ret_point4-1)
    814  1276		       48		      pha
    815  1277		       a9 f4		      lda	#>(randomize-1)
    816  1279		       48		      pha
    817  127a		       a9 29		      lda	#<(randomize-1)
    818  127c		       48		      pha
    819  127d		       a5 ee		      lda	temp7
    820  127f		       48		      pha
    821  1280		       8a		      txa
    822  1281		       48		      pha
    823  1282		       a2 08		      ldx	#8
    824  1284		       4c eb ff 	      jmp	BS_jsr
    825  1287				   ret_point4
    826  1287		       4a		      lsr
    827  1288		       85 81		      STA	player1x
    828  128a		       a9 00		      LDA	#0
    829  128c		       85 86		      STA	player1y
    830  128e		       a9 ff		      LDA	#255
    831  1290		       85 89		      STA	bally
    832  1292		       c6 d4		      DEC	_Lives
    833  1294		       4c e9 12 	      jmp	.deadsound
    834  1297
    835  1297				   .skipL079
    836  1297				   .
    837  1297							; 
    838  1297
    839  1297				   .
    840  1297							; 
    841  1297
    842  1297				   .L080		;  rem joystick movements
    843  1297
    844  1297				   .
    845  1297							; 
    846  1297
    847  1297				   .
    848  1297							; 
    849  1297
    850  1297				   .L081		;  if joy0left then player0x  =  player0x - 1	:  goto skipmove
    851  1297
    852  1297		       2c 80 02 	      bit	SWCHA
    853  129a		       70 05		      BVS	.skipL081
    854  129c				   .condpart18
    855  129c		       c6 80		      DEC	player0x
    856  129e		       4c ab 12 	      jmp	.skipmove
    857  12a1
    858  12a1				   .skipL081
    859  12a1				   .L082		;  if joy0right then player0x	=  player0x  + 1  :  goto skipmove
    860  12a1
    861  12a1		       2c 80 02 	      bit	SWCHA
    862  12a4		       30 05		      BMI	.skipL082
    863  12a6				   .condpart19
    864  12a6		       e6 80		      INC	player0x
    865  12a8		       4c ab 12 	      jmp	.skipmove
    866  12ab
    867  12ab				   .skipL082
    868  12ab				   .
    869  12ab							; 
    870  12ab
    871  12ab				   .L083		;  rem refresh the screen
    872  12ab
    873  12ab				   .skipmove
    874  12ab							; skipmove
    875  12ab
    876  12ab				   .L084		;  goto main
    877  12ab
    878  12ab		       4c ed 10 	      jmp	.main
    879  12ae
    880  12ae				   .
    881  12ae							; 
    882  12ae
    883  12ae				   .L085		;  rem Play point sound
    884  12ae
    885  12ae				   .pointsound
    886  12ae							; pointsound
    887  12ae
    888  12ae				   .L086		;  AUDV0  =  5  :  AUDC0  =  4  :  AUDF0  =  10
    889  12ae
    890  12ae		       a9 05		      LDA	#5
    891  12b0		       85 19		      STA	AUDV0
    892  12b2		       a9 04		      LDA	#4
    893  12b4		       85 15		      STA	AUDC0
    894  12b6		       a9 0a		      LDA	#10
    895  12b8		       85 17		      STA	AUDF0
    896  12ba				   .L087		;  p  =  p  +	1
    897  12ba
    898  12ba		       e6 e3		      INC	p
    899  12bc				   .L088		;  drawscreen
    900  12bc
    901  12bc		       85 ee		      sta	temp7
    902  12be		       a9 12		      lda	#>(ret_point5-1)
    903  12c0		       48		      pha
    904  12c1		       a9 d3		      lda	#<(ret_point5-1)
    905  12c3		       48		      pha
    906  12c4		       a9 f4		      lda	#>(drawscreen-1)
    907  12c6		       48		      pha
    908  12c7		       a9 35		      lda	#<(drawscreen-1)
    909  12c9		       48		      pha
    910  12ca		       a5 ee		      lda	temp7
    911  12cc		       48		      pha
    912  12cd		       8a		      txa
    913  12ce		       48		      pha
    914  12cf		       a2 08		      ldx	#8
    915  12d1		       4c eb ff 	      jmp	BS_jsr
    916  12d4				   ret_point5
    917  12d4				   .L089		;  if p  <  2 then pointsound
    918  12d4
    919  12d4		       a5 e3		      LDA	p
    920  12d6		       c9 02		      CMP	#2
    921  12d8		       90 d4		      bcc	.pointsound
    922  12da				  -	      if	( (((((#>*)&$1f)*256)|(#<.pointsound))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.pointsound))<=(bankswitch_hotspot+bs_mask)) )
    923  12da				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    924  12da					      endif
    925  12da				   .L090		;  p  =  0
    926  12da
    927  12da		       a9 00		      LDA	#0
    928  12dc		       85 e3		      STA	p
    929  12de				   .L091		;  AUDV0  =  0  :  AUDC0  =  0  :  AUDF0  =  0
    930  12de
    931  12de		       a9 00		      LDA	#0
    932  12e0		       85 19		      STA	AUDV0
    933  12e2		       85 15		      STA	AUDC0
    934  12e4		       85 17		      STA	AUDF0
    935  12e6				   .L092		;  goto main
    936  12e6
    937  12e6		       4c ed 10 	      jmp	.main
    938  12e9
    939  12e9				   .
    940  12e9							; 
    941  12e9
    942  12e9				   .L093		;  rem Play dead sound
    943  12e9
    944  12e9				   .deadsound
    945  12e9							; deadsound
    946  12e9
    947  12e9				   .L094		;  AUDV1  =  10
    948  12e9
    949  12e9		       a9 0a		      LDA	#10
    950  12eb		       85 1a		      STA	AUDV1
    951  12ed				   .L095		;  AUDC1  =  7
    952  12ed
    953  12ed		       a9 07		      LDA	#7
    954  12ef		       85 16		      STA	AUDC1
    955  12f1				   .L096		;  AUDF1  =  12
    956  12f1
    957  12f1		       a9 0c		      LDA	#12
    958  12f3		       85 18		      STA	AUDF1
    959  12f5				   .L097		;  p  =  p  +	1
    960  12f5
    961  12f5		       e6 e3		      INC	p
    962  12f7				   .L098		;  drawscreen
    963  12f7
    964  12f7		       85 ee		      sta	temp7
    965  12f9		       a9 13		      lda	#>(ret_point6-1)
    966  12fb		       48		      pha
    967  12fc		       a9 0e		      lda	#<(ret_point6-1)
    968  12fe		       48		      pha
    969  12ff		       a9 f4		      lda	#>(drawscreen-1)
    970  1301		       48		      pha
    971  1302		       a9 35		      lda	#<(drawscreen-1)
    972  1304		       48		      pha
    973  1305		       a5 ee		      lda	temp7
    974  1307		       48		      pha
    975  1308		       8a		      txa
    976  1309		       48		      pha
    977  130a		       a2 08		      ldx	#8
    978  130c		       4c eb ff 	      jmp	BS_jsr
    979  130f				   ret_point6
    980  130f				   .L099		;  if p  <  10 then deadsound
    981  130f
    982  130f		       a5 e3		      LDA	p
    983  1311		       c9 0a		      CMP	#10
    984  1313		       90 d4		      bcc	.deadsound
    985  1315				  -	      if	( (((((#>*)&$1f)*256)|(#<.deadsound))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.deadsound))<=(bankswitch_hotspot+bs_mask)) )
    986  1315				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    987  1315					      endif
    988  1315				   .L0100		;  p  =  0
    989  1315
    990  1315		       a9 00		      LDA	#0
    991  1317		       85 e3		      STA	p
    992  1319				   .L0101		;  AUDV1  =  0  :  AUDC1  =  0  :  AUDF1  =  0
    993  1319
    994  1319		       a9 00		      LDA	#0
    995  131b		       85 1a		      STA	AUDV1
    996  131d		       85 16		      STA	AUDC1
    997  131f		       85 18		      STA	AUDF1
    998  1321				   .L0102		;  if _Lives  =  0 then goto opening
    999  1321
   1000  1321		       a5 d4		      LDA	_Lives
   1001  1323		       c9 00		      CMP	#0
   1002  1325		       d0 03		      BNE	.skipL0102
   1003  1327				   .condpart20
   1004  1327		       4c 00 10 	      jmp	.opening
   1005  132a
   1006  132a				   .skipL0102
   1007  132a				   .L0103		;  goto main
   1008  132a
   1009  132a		       4c ed 10 	      jmp	.main
   1010  132d
   1011  132d				   .
   1012  132d							; 
   1013  132d
   1014  132d				   .
   1015  132d							; 
   1016  132d
   1017  132d				   .
   1018  132d							; 
   1019  132d
   1020  132d				   .
   1021  132d							; 
   1022  132d
   1023  132d				   .
   1024  132d							; 
   1025  132d
   1026  132d				   .
   1027  132d							; 
   1028  132d
   1029  132d				   .
   1030  132d							; 
   1031  132d
   1032  132d				   .
   1033  132d							; 
   1034  132d
   1035  132d				   .
   1036  132d							; 
   1037  132d
   1038  132d					      if	ECHO1
      3239 bytes of ROM space left in bank 1
   1039  132d					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1040  132d					      endif
   1041  132d		       00 01	   ECHO1      =	1
   1042  1fd4					      ORG	$1FF4-bscode_length
   1043  1fd4					      RORG	$1FF4-bscode_length
   1044  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1045  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1046  1fd6				  -	      stx	FASTFETCH
   1047  1fd6					      endif
   1048  1fd6		       9a		      txs
   1049  1fd7				  -	      if	bankswitch == 64
   1050  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1051  1fd7					      else
   1052  1fd7		       a9 f2		      lda	#>(start-1)
   1053  1fd9					      endif
   1054  1fd9		       48		      pha
   1055  1fda		       a9 4f		      lda	#<(start-1)
   1056  1fdc		       48		      pha
   1057  1fdd		       48		      pha
   1058  1fde		       8a		      txa
   1059  1fdf		       48		      pha
   1060  1fe0		       ba		      tsx
   1061  1fe1					      if	bankswitch != 64
   1062  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1063  1fe3		       2a		      rol
   1064  1fe4		       2a		      rol
   1065  1fe5		       2a		      rol
   1066  1fe6		       2a		      rol
   1067  1fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1068  1fe9		       aa		      tax
   1069  1fea		       e8		      inx
   1070  1feb				  -	      else
   1071  1feb				  -	      lda	4,x	; get high byte of return address
   1072  1feb				  -	      tay
   1073  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1074  1feb				  -	      sta	4,x
   1075  1feb				  -	      tya
   1076  1feb				  -	      lsr
   1077  1feb				  -	      lsr
   1078  1feb				  -	      lsr
   1079  1feb				  -	      lsr
   1080  1feb				  -	      tax
   1081  1feb				  -	      inx
   1082  1feb					      endif
   1083  1feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1084  1fee		       68		      pla
   1085  1fef		       aa		      tax
   1086  1ff0		       68		      pla
   1087  1ff1		       60		      rts
   1088  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1089  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1090  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1091  1ff2					      endif
   1092  1ffc					      ORG	$1FFC
   1093  1ffc					      RORG	$1FFC
   1094  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1095  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1096  2000					      ORG	$2000
   1097  2000					      RORG	$3000
   1098  2000					      if	ECHO2
      4052 bytes of ROM space left in bank 2
   1099  2000					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   1100  2000					      endif
   1101  2000		       00 01	   ECHO2      =	1
   1102  2fd4					      ORG	$2FF4-bscode_length
   1103  2fd4					      RORG	$3FF4-bscode_length
   1104  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   1105  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1106  2fd6				  -	      stx	FASTFETCH
   1107  2fd6					      endif
   1108  2fd6		       9a		      txs
   1109  2fd7				  -	      if	bankswitch == 64
   1110  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1111  2fd7					      else
   1112  2fd7		       a9 f2		      lda	#>(start-1)
   1113  2fd9					      endif
   1114  2fd9		       48		      pha
   1115  2fda		       a9 4f		      lda	#<(start-1)
   1116  2fdc		       48		      pha
   1117  2fdd		       48		      pha
   1118  2fde		       8a		      txa
   1119  2fdf		       48		      pha
   1120  2fe0		       ba		      tsx
   1121  2fe1					      if	bankswitch != 64
   1122  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   1123  2fe3		       2a		      rol
   1124  2fe4		       2a		      rol
   1125  2fe5		       2a		      rol
   1126  2fe6		       2a		      rol
   1127  2fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1128  2fe9		       aa		      tax
   1129  2fea		       e8		      inx
   1130  2feb				  -	      else
   1131  2feb				  -	      lda	4,x	; get high byte of return address
   1132  2feb				  -	      tay
   1133  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1134  2feb				  -	      sta	4,x
   1135  2feb				  -	      tya
   1136  2feb				  -	      lsr
   1137  2feb				  -	      lsr
   1138  2feb				  -	      lsr
   1139  2feb				  -	      lsr
   1140  2feb				  -	      tax
   1141  2feb				  -	      inx
   1142  2feb					      endif
   1143  2feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1144  2fee		       68		      pla
   1145  2fef		       aa		      tax
   1146  2ff0		       68		      pla
   1147  2ff1		       60		      rts
   1148  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1149  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1150  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1151  2ff2					      endif
   1152  2ffc					      ORG	$2FFC
   1153  2ffc					      RORG	$3FFC
   1154  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   1155  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   1156  3000					      ORG	$3000
   1157  3000					      RORG	$5000
   1158  3000					      if	ECHO3
      4052 bytes of ROM space left in bank 3
   1159  3000					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   1160  3000					      endif
   1161  3000		       00 01	   ECHO3      =	1
   1162  3fd4					      ORG	$3FF4-bscode_length
   1163  3fd4					      RORG	$5FF4-bscode_length
   1164  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   1165  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1166  3fd6				  -	      stx	FASTFETCH
   1167  3fd6					      endif
   1168  3fd6		       9a		      txs
   1169  3fd7				  -	      if	bankswitch == 64
   1170  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1171  3fd7					      else
   1172  3fd7		       a9 f2		      lda	#>(start-1)
   1173  3fd9					      endif
   1174  3fd9		       48		      pha
   1175  3fda		       a9 4f		      lda	#<(start-1)
   1176  3fdc		       48		      pha
   1177  3fdd		       48		      pha
   1178  3fde		       8a		      txa
   1179  3fdf		       48		      pha
   1180  3fe0		       ba		      tsx
   1181  3fe1					      if	bankswitch != 64
   1182  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   1183  3fe3		       2a		      rol
   1184  3fe4		       2a		      rol
   1185  3fe5		       2a		      rol
   1186  3fe6		       2a		      rol
   1187  3fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1188  3fe9		       aa		      tax
   1189  3fea		       e8		      inx
   1190  3feb				  -	      else
   1191  3feb				  -	      lda	4,x	; get high byte of return address
   1192  3feb				  -	      tay
   1193  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1194  3feb				  -	      sta	4,x
   1195  3feb				  -	      tya
   1196  3feb				  -	      lsr
   1197  3feb				  -	      lsr
   1198  3feb				  -	      lsr
   1199  3feb				  -	      lsr
   1200  3feb				  -	      tax
   1201  3feb				  -	      inx
   1202  3feb					      endif
   1203  3feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1204  3fee		       68		      pla
   1205  3fef		       aa		      tax
   1206  3ff0		       68		      pla
   1207  3ff1		       60		      rts
   1208  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1209  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1210  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1211  3ff2					      endif
   1212  3ffc					      ORG	$3FFC
   1213  3ffc					      RORG	$5FFC
   1214  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   1215  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   1216  4000					      ORG	$4000
   1217  4000					      RORG	$7000
   1218  4000					      if	ECHO4
      4052 bytes of ROM space left in bank 4
   1219  4000					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   1220  4000					      endif
   1221  4000		       00 01	   ECHO4      =	1
   1222  4fd4					      ORG	$4FF4-bscode_length
   1223  4fd4					      RORG	$7FF4-bscode_length
   1224  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   1225  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1226  4fd6				  -	      stx	FASTFETCH
   1227  4fd6					      endif
   1228  4fd6		       9a		      txs
   1229  4fd7				  -	      if	bankswitch == 64
   1230  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1231  4fd7					      else
   1232  4fd7		       a9 f2		      lda	#>(start-1)
   1233  4fd9					      endif
   1234  4fd9		       48		      pha
   1235  4fda		       a9 4f		      lda	#<(start-1)
   1236  4fdc		       48		      pha
   1237  4fdd		       48		      pha
   1238  4fde		       8a		      txa
   1239  4fdf		       48		      pha
   1240  4fe0		       ba		      tsx
   1241  4fe1					      if	bankswitch != 64
   1242  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   1243  4fe3		       2a		      rol
   1244  4fe4		       2a		      rol
   1245  4fe5		       2a		      rol
   1246  4fe6		       2a		      rol
   1247  4fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1248  4fe9		       aa		      tax
   1249  4fea		       e8		      inx
   1250  4feb				  -	      else
   1251  4feb				  -	      lda	4,x	; get high byte of return address
   1252  4feb				  -	      tay
   1253  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1254  4feb				  -	      sta	4,x
   1255  4feb				  -	      tya
   1256  4feb				  -	      lsr
   1257  4feb				  -	      lsr
   1258  4feb				  -	      lsr
   1259  4feb				  -	      lsr
   1260  4feb				  -	      tax
   1261  4feb				  -	      inx
   1262  4feb					      endif
   1263  4feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1264  4fee		       68		      pla
   1265  4fef		       aa		      tax
   1266  4ff0		       68		      pla
   1267  4ff1		       60		      rts
   1268  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1269  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1270  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1271  4ff2					      endif
   1272  4ffc					      ORG	$4FFC
   1273  4ffc					      RORG	$7FFC
   1274  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   1275  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   1276  5000					      ORG	$5000
   1277  5000					      RORG	$9000
   1278  5000					      if	ECHO5
      4052 bytes of ROM space left in bank 5
   1279  5000					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   1280  5000					      endif
   1281  5000		       00 01	   ECHO5      =	1
   1282  5fd4					      ORG	$5FF4-bscode_length
   1283  5fd4					      RORG	$9FF4-bscode_length
   1284  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   1285  5fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1286  5fd6				  -	      stx	FASTFETCH
   1287  5fd6					      endif
   1288  5fd6		       9a		      txs
   1289  5fd7				  -	      if	bankswitch == 64
   1290  5fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1291  5fd7					      else
   1292  5fd7		       a9 f2		      lda	#>(start-1)
   1293  5fd9					      endif
   1294  5fd9		       48		      pha
   1295  5fda		       a9 4f		      lda	#<(start-1)
   1296  5fdc		       48		      pha
   1297  5fdd		       48		      pha
   1298  5fde		       8a		      txa
   1299  5fdf		       48		      pha
   1300  5fe0		       ba		      tsx
   1301  5fe1					      if	bankswitch != 64
   1302  5fe1		       b5 04		      lda	4,x	; get high byte of return address
   1303  5fe3		       2a		      rol
   1304  5fe4		       2a		      rol
   1305  5fe5		       2a		      rol
   1306  5fe6		       2a		      rol
   1307  5fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1308  5fe9		       aa		      tax
   1309  5fea		       e8		      inx
   1310  5feb				  -	      else
   1311  5feb				  -	      lda	4,x	; get high byte of return address
   1312  5feb				  -	      tay
   1313  5feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1314  5feb				  -	      sta	4,x
   1315  5feb				  -	      tya
   1316  5feb				  -	      lsr
   1317  5feb				  -	      lsr
   1318  5feb				  -	      lsr
   1319  5feb				  -	      lsr
   1320  5feb				  -	      tax
   1321  5feb				  -	      inx
   1322  5feb					      endif
   1323  5feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1324  5fee		       68		      pla
   1325  5fef		       aa		      tax
   1326  5ff0		       68		      pla
   1327  5ff1		       60		      rts
   1328  5ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1329  5ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1330  5ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1331  5ff2					      endif
   1332  5ffc					      ORG	$5FFC
   1333  5ffc					      RORG	$9FFC
   1334  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   1335  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   1336  6000					      ORG	$6000
   1337  6000					      RORG	$B000
   1338  6000					      if	ECHO6
      4052 bytes of ROM space left in bank 6
   1339  6000					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   1340  6000					      endif
   1341  6000		       00 01	   ECHO6      =	1
   1342  6fd4					      ORG	$6FF4-bscode_length
   1343  6fd4					      RORG	$BFF4-bscode_length
   1344  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   1345  6fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1346  6fd6				  -	      stx	FASTFETCH
   1347  6fd6					      endif
   1348  6fd6		       9a		      txs
   1349  6fd7				  -	      if	bankswitch == 64
   1350  6fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1351  6fd7					      else
   1352  6fd7		       a9 f2		      lda	#>(start-1)
   1353  6fd9					      endif
   1354  6fd9		       48		      pha
   1355  6fda		       a9 4f		      lda	#<(start-1)
   1356  6fdc		       48		      pha
   1357  6fdd		       48		      pha
   1358  6fde		       8a		      txa
   1359  6fdf		       48		      pha
   1360  6fe0		       ba		      tsx
   1361  6fe1					      if	bankswitch != 64
   1362  6fe1		       b5 04		      lda	4,x	; get high byte of return address
   1363  6fe3		       2a		      rol
   1364  6fe4		       2a		      rol
   1365  6fe5		       2a		      rol
   1366  6fe6		       2a		      rol
   1367  6fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1368  6fe9		       aa		      tax
   1369  6fea		       e8		      inx
   1370  6feb				  -	      else
   1371  6feb				  -	      lda	4,x	; get high byte of return address
   1372  6feb				  -	      tay
   1373  6feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1374  6feb				  -	      sta	4,x
   1375  6feb				  -	      tya
   1376  6feb				  -	      lsr
   1377  6feb				  -	      lsr
   1378  6feb				  -	      lsr
   1379  6feb				  -	      lsr
   1380  6feb				  -	      tax
   1381  6feb				  -	      inx
   1382  6feb					      endif
   1383  6feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1384  6fee		       68		      pla
   1385  6fef		       aa		      tax
   1386  6ff0		       68		      pla
   1387  6ff1		       60		      rts
   1388  6ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1389  6ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1390  6ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1391  6ff2					      endif
   1392  6ffc					      ORG	$6FFC
   1393  6ffc					      RORG	$BFFC
   1394  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   1395  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   1396  7000					      ORG	$7000
   1397  7000					      RORG	$D000
   1398  7000					      if	ECHO7
      4052 bytes of ROM space left in bank 7
   1399  7000					      echo	"    ",[(start_bank7 - *)]d , "bytes of ROM space left in bank 7")
   1400  7000					      endif
   1401  7000		       00 01	   ECHO7      =	1
   1402  7fd4					      ORG	$7FF4-bscode_length
   1403  7fd4					      RORG	$DFF4-bscode_length
   1404  7fd4		       a2 ff	   start_bank7 ldx	#$ff
   1405  7fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1406  7fd6				  -	      stx	FASTFETCH
   1407  7fd6					      endif
   1408  7fd6		       9a		      txs
   1409  7fd7				  -	      if	bankswitch == 64
   1410  7fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1411  7fd7					      else
   1412  7fd7		       a9 f2		      lda	#>(start-1)
   1413  7fd9					      endif
   1414  7fd9		       48		      pha
   1415  7fda		       a9 4f		      lda	#<(start-1)
   1416  7fdc		       48		      pha
   1417  7fdd		       48		      pha
   1418  7fde		       8a		      txa
   1419  7fdf		       48		      pha
   1420  7fe0		       ba		      tsx
   1421  7fe1					      if	bankswitch != 64
   1422  7fe1		       b5 04		      lda	4,x	; get high byte of return address
   1423  7fe3		       2a		      rol
   1424  7fe4		       2a		      rol
   1425  7fe5		       2a		      rol
   1426  7fe6		       2a		      rol
   1427  7fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1428  7fe9		       aa		      tax
   1429  7fea		       e8		      inx
   1430  7feb				  -	      else
   1431  7feb				  -	      lda	4,x	; get high byte of return address
   1432  7feb				  -	      tay
   1433  7feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1434  7feb				  -	      sta	4,x
   1435  7feb				  -	      tya
   1436  7feb				  -	      lsr
   1437  7feb				  -	      lsr
   1438  7feb				  -	      lsr
   1439  7feb				  -	      lsr
   1440  7feb				  -	      tax
   1441  7feb				  -	      inx
   1442  7feb					      endif
   1443  7feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1444  7fee		       68		      pla
   1445  7fef		       aa		      tax
   1446  7ff0		       68		      pla
   1447  7ff1		       60		      rts
   1448  7ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1449  7ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1450  7ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1451  7ff2					      endif
   1452  7ffc					      ORG	$7FFC
   1453  7ffc					      RORG	$DFFC
   1454  7ffc		       d4 df		      .word.w	(start_bank7 & $ffff)
   1455  7ffe		       d4 df		      .word.w	(start_bank7 & $ffff)
   1456  8000					      ORG	$8000
   1457  8000					      RORG	$F000
   1458  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   1459  8000
   1460  8000							; This is a 2-line kernel!
   1461  8000					      ifnconst	vertical_reflect
   1462  8000				   kernel
   1463  8000					      endif
   1464  8000		       85 02		      sta	WSYNC
   1465  8002		       a9 ff		      lda	#255
   1466  8004		       8d 96 02 	      sta	TIM64T
   1467  8007
   1468  8007		       a9 01		      lda	#1
   1469  8009		       85 27		      sta	VDELBL
   1470  800b		       85 25		      sta	VDELP0
   1471  800d		       a6 92		      ldx	ballheight
   1472  800f		       e8		      inx
   1473  8010		       e8		      inx
   1474  8011		       86 9f		      stx	temp4
   1475  8013		       a5 86		      lda	player1y
   1476  8015		       85 9e		      sta	temp3
   1477  8017
   1478  8017				  -	      ifconst	shakescreen
   1479  8017				  -	      jsr	doshakescreen
   1480  8017					      else
   1481  8017		       a6 90		      ldx	missile0height
   1482  8019		       e8		      inx
   1483  801a					      endif
   1484  801a
   1485  801a		       e8		      inx
   1486  801b		       86 f6		      stx	stack1
   1487  801d
   1488  801d		       a5 89		      lda	bally
   1489  801f		       85 f7		      sta	stack2
   1490  8021
   1491  8021		       a5 85		      lda	player0y
   1492  8023		       a2 00		      ldx	#0
   1493  8025		       85 02		      sta	WSYNC
   1494  8027		       86 1b		      stx	GRP0
   1495  8029		       86 1c		      stx	GRP1
   1496  802b		       86 0e		      stx	PF1L
   1497  802d		       86 0f		      stx	PF2
   1498  802f		       86 2c		      stx	CXCLR
   1499  8031				  -	      ifconst	readpaddle
   1500  8031				  -	      stx	paddle
   1501  8031					      else
      0  8031					      sleep	3
      1  8031				   .CYCLES    SET	3
      2  8031
      3  8031				  -	      IF	.CYCLES < 2
      4  8031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8031				  -	      ERR
      6  8031					      ENDIF
      7  8031
      8  8031					      IF	.CYCLES & 1
      9  8031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8031		       04 00		      nop	0
     11  8033				  -	      ELSE
     12  8033				  -	      bit	VSYNC
     13  8033					      ENDIF
     14  8033				   .CYCLES    SET	.CYCLES - 3
     15  8033					      ENDIF
     16  8033
     17  8033				  -	      REPEAT	.CYCLES / 2
     18  8033				  -	      nop
     19  8033					      REPEND
   1503  8033					      endif
   1504  8033
   1505  8033		       95 9d		      sta	temp2,x
   1506  8035
   1507  8035							;store these so they can be retrieved later
   1508  8035					      ifnconst	pfres
   1509  8035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   1510  8037				  -	      else
   1511  8037				  -	      ldx	#132-pfres*pfwidth
   1512  8037					      endif
   1513  8037
   1514  8037		       c6 85		      dec	player0y
   1515  8039
   1516  8039		       a5 91		      lda	missile0y
   1517  803b		       85 a0		      sta	temp5
   1518  803d		       a5 88		      lda	missile1y
   1519  803f		       85 a1		      sta	temp6
   1520  8041
   1521  8041		       a5 ef		      lda	playfieldpos
   1522  8043		       85 9c		      sta	temp1
   1523  8045
   1524  8045				  -	      ifconst	pfrowheight
   1525  8045				  -	      lda	#pfrowheight+2
   1526  8045					      else
   1527  8045					      ifnconst	pfres
   1528  8045		       a9 0a		      lda	#10
   1529  8047				  -	      else
   1530  8047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1531  8047					      endif
   1532  8047					      endif
   1533  8047		       18		      clc
   1534  8048		       e5 ef		      sbc	playfieldpos
   1535  804a		       85 ef		      sta	playfieldpos
   1536  804c		       4c 74 f0 	      jmp	.startkernel
   1537  804f
   1538  804f				   .skipDrawP0
   1539  804f		       a9 00		      lda	#0
   1540  8051		       a8		      tay
   1541  8052		       4c a2 f0 	      jmp	.continueP0
   1542  8055
   1543  8055				   .skipDrawP1
   1544  8055		       a9 00		      lda	#0
   1545  8057		       a8		      tay
   1546  8058		       4c 7e f0 	      jmp	.continueP1
   1547  805b
   1548  805b				   .kerloop		; enter at cycle 59??
   1549  805b
   1550  805b				   continuekernel
      0  805b					      sleep	2
      1  805b				   .CYCLES    SET	2
      2  805b
      3  805b				  -	      IF	.CYCLES < 2
      4  805b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  805b				  -	      ERR
      6  805b					      ENDIF
      7  805b
      8  805b				  -	      IF	.CYCLES & 1
      9  805b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  805b				  -	      nop	0
     11  805b				  -	      ELSE
     12  805b				  -	      bit	VSYNC
     13  805b				  -	      ENDIF
     14  805b				  -.CYCLES    SET	.CYCLES - 3
     15  805b					      ENDIF
     16  805b
     17  805b					      REPEAT	.CYCLES / 2
     18  805b		       ea		      nop
     19  805c					      REPEND
   1552  805c				   continuekernel2
   1553  805c		       a5 92		      lda	ballheight
   1554  805e
   1555  805e				  -	      ifconst	pfres
   1556  805e				  -	      ldy	playfield+pfres*pfwidth-132,x
   1557  805e				  -	      sty	PF1L	;3
   1558  805e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   1559  805e				  -	      sty	PF2L	;3
   1560  805e				  -	      ldy	playfield+pfres*pfwidth-129,x
   1561  805e				  -	      sty	PF1R	; 3 too early?
   1562  805e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   1563  805e				  -	      sty	PF2R	;3
   1564  805e					      else
   1565  805e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   1566  8060		       84 0e		      sty	PF1L	;3
   1567  8062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1568  8064		       84 0f		      sty	PF2L	;3
   1569  8066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   1570  8068		       84 0e		      sty	PF1R	; 3 too early?
   1571  806a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1572  806c		       84 0f		      sty	PF2R	;3
   1573  806e					      endif
   1574  806e
   1575  806e							; should be playfield+$38 for width=2
   1576  806e
   1577  806e		       c7 89		      dcp	bally
   1578  8070		       2a		      rol
   1579  8071		       2a		      rol
   1580  8072							; rol
   1581  8072							; rol
   1582  8072				   goback
   1583  8072		       85 1f		      sta	ENABL
   1584  8074				   .startkernel
   1585  8074		       a5 8f		      lda	player1height	;3
   1586  8076		       c7 86		      dcp	player1y	;5
   1587  8078		       90 db		      bcc	.skipDrawP1	;2
   1588  807a		       a4 86		      ldy	player1y	;3
   1589  807c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1590  807e							; so it doesn't cross a page boundary!
   1591  807e
   1592  807e				   .continueP1
   1593  807e		       85 1c		      sta	GRP1	;3
   1594  8080
   1595  8080				  -	      ifnconst	player1colors
   1596  8080				  -	      lda	missile1height	;3
   1597  8080				  -	      dcp	missile1y	;5
   1598  8080				  -	      rol		;2
   1599  8080				  -	      rol		;2
   1600  8080				  -	      sta	ENAM1	;3
   1601  8080					      else
   1602  8080		       b1 87		      lda	(player1color),y
   1603  8082		       85 07		      sta	COLUP1
   1604  8084					      ifnconst	playercolors
      0  8084					      sleep	7
      1  8084				   .CYCLES    SET	7
      2  8084
      3  8084				  -	      IF	.CYCLES < 2
      4  8084				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8084				  -	      ERR
      6  8084					      ENDIF
      7  8084
      8  8084					      IF	.CYCLES & 1
      9  8084					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8084		       04 00		      nop	0
     11  8086				  -	      ELSE
     12  8086				  -	      bit	VSYNC
     13  8086					      ENDIF
     14  8086				   .CYCLES    SET	.CYCLES - 3
     15  8086					      ENDIF
     16  8086
     17  8086					      REPEAT	.CYCLES / 2
     18  8086		       ea		      nop
     17  8086					      REPEND
     18  8087		       ea		      nop
     19  8088					      REPEND
   1606  8088				  -	      else
   1607  8088				  -	      lda.w	player0colorstore
   1608  8088				  -	      sta	COLUP0
   1609  8088					      endif
   1610  8088					      endif
   1611  8088
   1612  8088				  -	      ifconst	pfres
   1613  8088				  -	      lda	playfield+pfres*pfwidth-132,x
   1614  8088				  -	      sta	PF1L	;3
   1615  8088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   1616  8088				  -	      sta	PF2L	;3
   1617  8088				  -	      lda	playfield+pfres*pfwidth-129,x
   1618  8088				  -	      sta	PF1R	; 3 too early?
   1619  8088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   1620  8088				  -	      sta	PF2R	;3
   1621  8088					      else
   1622  8088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   1623  808a		       85 0e		      sta	PF1L	;3
   1624  808c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1625  808e		       85 0f		      sta	PF2L	;3
   1626  8090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   1627  8092		       85 0e		      sta	PF1R	; 3 too early?
   1628  8094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1629  8096		       85 0f		      sta	PF2R	;3
   1630  8098					      endif
   1631  8098							; sleep 3
   1632  8098
   1633  8098		       a5 8e		      lda	player0height
   1634  809a		       c7 85		      dcp	player0y
   1635  809c		       90 b1		      bcc	.skipDrawP0
   1636  809e		       a4 85		      ldy	player0y
   1637  80a0		       b1 8a		      lda	(player0pointer),y
   1638  80a2				   .continueP0
   1639  80a2		       85 1b		      sta	GRP0
   1640  80a4
   1641  80a4				  -	      ifnconst	no_blank_lines
   1642  80a4				  -	      ifnconst	playercolors
   1643  80a4				  -	      lda	missile0height	;3
   1644  80a4				  -	      dcp	missile0y	;5
   1645  80a4				  -	      sbc	stack1
   1646  80a4				  -	      sta	ENAM0	;3
   1647  80a4				  -	      else
   1648  80a4				  -	      lda	(player0color),y
   1649  80a4				  -	      sta	player0colorstore
   1650  80a4				  -	      sleep	6
   1651  80a4				  -	      endif
   1652  80a4				  -	      dec	temp1
   1653  80a4				  -	      bne	continuekernel
   1654  80a4					      else
   1655  80a4		       c6 9c		      dec	temp1
   1656  80a6		       f0 0c		      beq	altkernel2
   1657  80a8				  -	      ifconst	readpaddle
   1658  80a8				  -	      ldy	currentpaddle
   1659  80a8				  -	      lda	INPT0,y
   1660  80a8				  -	      bpl	noreadpaddle
   1661  80a8				  -	      inc	paddle
   1662  80a8				  -	      jmp	continuekernel2
   1663  80a8				  -noreadpaddle
   1664  80a8				  -	      sleep	2
   1665  80a8				  -	      jmp	continuekernel
   1666  80a8					      else
   1667  80a8					      ifnconst	playercolors
   1668  80a8					      ifconst	PFcolors
   1669  80a8		       8a		      txa
   1670  80a9		       a8		      tay
   1671  80aa		       b1 f0		      lda	(pfcolortable),y
   1672  80ac					      ifnconst	backgroundchange
   1673  80ac		       85 08		      sta	COLUPF
   1674  80ae				  -	      else
   1675  80ae				  -	      sta	COLUBK
   1676  80ae					      endif
   1677  80ae		       4c 5b f0 	      jmp	continuekernel
   1678  80b1				  -	      else
   1679  80b1				  -	      ifconst	kernelmacrodef
   1680  80b1				  -	      kernelmacro
   1681  80b1				  -	      else
   1682  80b1				  -	      sleep	12
   1683  80b1				  -	      endif
   1684  80b1					      endif
   1685  80b1				  -	      else
   1686  80b1				  -	      lda	(player0color),y
   1687  80b1				  -	      sta	player0colorstore
   1688  80b1				  -	      sleep	4
   1689  80b1					      endif
   1690  80b1		       4c 5b f0 	      jmp	continuekernel
   1691  80b4					      endif
   1692  80b4				   altkernel2
   1693  80b4		       8a		      txa
   1694  80b5					      ifnconst	vertical_reflect
   1695  80b5		       cb fc		      sbx	#256-pfwidth
   1696  80b7				  -	      else
   1697  80b7				  -	      sbx	#256-pfwidth/2
   1698  80b7					      endif
   1699  80b7		       30 24		      bmi	lastkernelline
   1700  80b9				  -	      ifconst	pfrowheight
   1701  80b9				  -	      lda	#pfrowheight
   1702  80b9					      else
   1703  80b9					      ifnconst	pfres
   1704  80b9		       a9 08		      lda	#8
   1705  80bb				  -	      else
   1706  80bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   1707  80bb					      endif
   1708  80bb					      endif
   1709  80bb		       85 9c		      sta	temp1
   1710  80bd		       4c 5b f0 	      jmp	continuekernel
   1711  80c0					      endif
   1712  80c0
   1713  80c0				   altkernel
   1714  80c0
   1715  80c0				  -	      ifconst	PFmaskvalue
   1716  80c0				  -	      lda	#PFmaskvalue
   1717  80c0					      else
   1718  80c0		       a9 00		      lda	#0
   1719  80c2					      endif
   1720  80c2		       85 0e		      sta	PF1L
   1721  80c4		       85 0f		      sta	PF2
   1722  80c6
   1723  80c6
   1724  80c6							;sleep 3
   1725  80c6
   1726  80c6							;28 cycles to fix things
   1727  80c6							;minus 11=17
   1728  80c6
   1729  80c6							; lax temp4
   1730  80c6							; clc
   1731  80c6		       8a		      txa
   1732  80c7					      ifnconst	vertical_reflect
   1733  80c7		       cb fc		      sbx	#256-pfwidth
   1734  80c9				  -	      else
   1735  80c9				  -	      sbx	#256-pfwidth/2
   1736  80c9					      endif
   1737  80c9
   1738  80c9		       30 12		      bmi	lastkernelline
   1739  80cb
   1740  80cb				  -	      ifconst	PFcolorandheight
   1741  80cb				  -	      ifconst	pfres
   1742  80cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   1743  80cb				  -	      else
   1744  80cb				  -	      ldy	playfieldcolorandheight-87,x
   1745  80cb				  -	      endif
   1746  80cb				  -	      ifnconst	backgroundchange
   1747  80cb				  -	      sty	COLUPF
   1748  80cb				  -	      else
   1749  80cb				  -	      sty	COLUBK
   1750  80cb				  -	      endif
   1751  80cb				  -	      ifconst	pfres
   1752  80cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   1753  80cb				  -	      else
   1754  80cb				  -	      lda	playfieldcolorandheight-88,x
   1755  80cb				  -	      endif
   1756  80cb				  -	      sta.w	temp1
   1757  80cb					      endif
   1758  80cb				  -	      ifconst	PFheights
   1759  80cb				  -	      lsr
   1760  80cb				  -	      lsr
   1761  80cb				  -	      tay
   1762  80cb				  -	      lda	(pfheighttable),y
   1763  80cb				  -	      sta.w	temp1
   1764  80cb					      endif
   1765  80cb					      ifconst	PFcolors
   1766  80cb		       a8		      tay
   1767  80cc		       b1 f0		      lda	(pfcolortable),y
   1768  80ce					      ifnconst	backgroundchange
   1769  80ce		       85 08		      sta	COLUPF
   1770  80d0				  -	      else
   1771  80d0				  -	      sta	COLUBK
   1772  80d0					      endif
   1773  80d0				  -	      ifconst	pfrowheight
   1774  80d0				  -	      lda	#pfrowheight
   1775  80d0					      else
   1776  80d0					      ifnconst	pfres
   1777  80d0		       a9 08		      lda	#8
   1778  80d2				  -	      else
   1779  80d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   1780  80d2					      endif
   1781  80d2					      endif
   1782  80d2		       85 9c		      sta	temp1
   1783  80d4					      endif
   1784  80d4					      ifnconst	PFcolorandheight
   1785  80d4				  -	      ifnconst	PFcolors
   1786  80d4				  -	      ifnconst	PFheights
   1787  80d4				  -	      ifnconst	no_blank_lines
   1788  80d4				  -			; read paddle 0
   1789  80d4				  -			; lo-res paddle read
   1790  80d4				  -			; bit INPT0
   1791  80d4				  -			; bmi paddleskipread
   1792  80d4				  -			; inc paddle0
   1793  80d4				  -			;donepaddleskip
   1794  80d4				  -	      sleep	10
   1795  80d4				  -	      ifconst	pfrowheight
   1796  80d4				  -	      lda	#pfrowheight
   1797  80d4				  -	      else
   1798  80d4				  -	      ifnconst	pfres
   1799  80d4				  -	      lda	#8
   1800  80d4				  -	      else
   1801  80d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   1802  80d4				  -	      endif
   1803  80d4				  -	      endif
   1804  80d4				  -	      sta	temp1
   1805  80d4				  -	      endif
   1806  80d4				  -	      endif
   1807  80d4					      endif
   1808  80d4					      endif
   1809  80d4
   1810  80d4
   1811  80d4		       a5 92		      lda	ballheight
   1812  80d6		       c7 89		      dcp	bally
   1813  80d8		       e5 9f		      sbc	temp4
   1814  80da
   1815  80da
   1816  80da		       4c 72 f0 	      jmp	goback
   1817  80dd
   1818  80dd
   1819  80dd				  -	      ifnconst	no_blank_lines
   1820  80dd				  -lastkernelline
   1821  80dd				  -	      ifnconst	PFcolors
   1822  80dd				  -	      sleep	10
   1823  80dd				  -	      else
   1824  80dd				  -	      ldy	#124
   1825  80dd				  -	      lda	(pfcolortable),y
   1826  80dd				  -	      sta	COLUPF
   1827  80dd				  -	      endif
   1828  80dd				  -
   1829  80dd				  -	      ifconst	PFheights
   1830  80dd				  -	      ldx	#1
   1831  80dd				  -			;sleep 4
   1832  80dd				  -	      sleep	3	; this was over 1 cycle
   1833  80dd				  -	      else
   1834  80dd				  -	      ldx	playfieldpos
   1835  80dd				  -			;sleep 3
   1836  80dd				  -	      sleep	2	; this was over 1 cycle
   1837  80dd				  -	      endif
   1838  80dd				  -
   1839  80dd				  -	      jmp	enterlastkernel
   1840  80dd				  -
   1841  80dd					      else
   1842  80dd				   lastkernelline
   1843  80dd
   1844  80dd				  -	      ifconst	PFheights
   1845  80dd				  -	      ldx	#1
   1846  80dd				  -			;sleep 5
   1847  80dd				  -	      sleep	4	; this was over 1 cycle
   1848  80dd					      else
   1849  80dd		       a6 ef		      ldx	playfieldpos
   1850  80df							;sleep 4
      0  80df					      sleep	3	; this was over 1 cycle
      1  80df				   .CYCLES    SET	3
      2  80df
      3  80df				  -	      IF	.CYCLES < 2
      4  80df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80df				  -	      ERR
      6  80df					      ENDIF
      7  80df
      8  80df					      IF	.CYCLES & 1
      9  80df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  80df		       04 00		      nop	0
     11  80e1				  -	      ELSE
     12  80e1				  -	      bit	VSYNC
     13  80e1					      ENDIF
     14  80e1				   .CYCLES    SET	.CYCLES - 3
     15  80e1					      ENDIF
     16  80e1
     17  80e1				  -	      REPEAT	.CYCLES / 2
     18  80e1				  -	      nop
     19  80e1					      REPEND
   1852  80e1					      endif
   1853  80e1
   1854  80e1		       e0 00		      cpx	#0
   1855  80e3		       d0 22		      bne	.enterfromNBL
   1856  80e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   1857  80e8					      endif
   1858  80e8
   1859  80e8					      if	((<*)>$d5)
   1860  8100		       00 00 00 00*	      align	256
   1861  8100					      endif
   1862  8100							; this is a kludge to prevent page wrapping - fix!!!
   1863  8100
   1864  8100				   .skipDrawlastP1
   1865  8100		       a9 00		      lda	#0
   1866  8102		       a8		      tay		; added so we don't cross a page
   1867  8103		       4c 2d f1 	      jmp	.continuelastP1
   1868  8106
   1869  8106				   .endkerloop		; enter at cycle 59??
   1870  8106
   1871  8106		       ea		      nop
   1872  8107
   1873  8107				   .enterfromNBL
   1874  8107				  -	      ifconst	pfres
   1875  8107				  -	      ldy.w	playfield+pfres*pfwidth-4
   1876  8107				  -	      sty	PF1L	;3
   1877  8107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1878  8107				  -	      sty	PF2L	;3
   1879  8107				  -	      ldy.w	playfield+pfres*pfwidth-1
   1880  8107				  -	      sty	PF1R	; possibly too early?
   1881  8107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1882  8107				  -	      sty	PF2R	;3
   1883  8107					      else
   1884  8107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1885  810a		       84 0e		      sty	PF1L	;3
   1886  810c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1887  810f		       84 0f		      sty	PF2L	;3
   1888  8111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1889  8114		       84 0e		      sty	PF1R	; possibly too early?
   1890  8116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1891  8119		       84 0f		      sty	PF2R	;3
   1892  811b					      endif
   1893  811b
   1894  811b				   enterlastkernel
   1895  811b		       a5 92		      lda	ballheight
   1896  811d
   1897  811d							; tya
   1898  811d		       c7 89		      dcp	bally
   1899  811f							; sleep 4
   1900  811f
   1901  811f							; sbc stack3
   1902  811f		       2a		      rol
   1903  8120		       2a		      rol
   1904  8121		       85 1f		      sta	ENABL
   1905  8123
   1906  8123		       a5 8f		      lda	player1height	;3
   1907  8125		       c7 86		      dcp	player1y	;5
   1908  8127		       90 d7		      bcc	.skipDrawlastP1
   1909  8129		       a4 86		      ldy	player1y	;3
   1910  812b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1911  812d							; so it doesn't cross a page boundary!
   1912  812d
   1913  812d				   .continuelastP1
   1914  812d		       85 1c		      sta	GRP1	;3
   1915  812f
   1916  812f				  -	      ifnconst	player1colors
   1917  812f				  -	      lda	missile1height	;3
   1918  812f				  -	      dcp	missile1y	;5
   1919  812f					      else
   1920  812f		       b1 87		      lda	(player1color),y
   1921  8131		       85 07		      sta	COLUP1
   1922  8133					      endif
   1923  8133
   1924  8133		       ca		      dex
   1925  8134							;dec temp4 ; might try putting this above PF writes
   1926  8134		       f0 34		      beq	endkernel
   1927  8136
   1928  8136
   1929  8136				  -	      ifconst	pfres
   1930  8136				  -	      ldy.w	playfield+pfres*pfwidth-4
   1931  8136				  -	      sty	PF1L	;3
   1932  8136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1933  8136				  -	      sty	PF2L	;3
   1934  8136				  -	      ldy.w	playfield+pfres*pfwidth-1
   1935  8136				  -	      sty	PF1R	; possibly too early?
   1936  8136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1937  8136				  -	      sty	PF2R	;3
   1938  8136					      else
   1939  8136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1940  8139		       84 0e		      sty	PF1L	;3
   1941  813b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1942  813e		       84 0f		      sty	PF2L	;3
   1943  8140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1944  8143		       84 0e		      sty	PF1R	; possibly too early?
   1945  8145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1946  8148		       84 0f		      sty	PF2R	;3
   1947  814a					      endif
   1948  814a
   1949  814a				  -	      ifnconst	player1colors
   1950  814a				  -	      rol		;2
   1951  814a				  -	      rol		;2
   1952  814a				  -	      sta	ENAM1	;3
   1953  814a					      else
   1954  814a					      ifnconst	playercolors
      0  814a					      sleep	7
      1  814a				   .CYCLES    SET	7
      2  814a
      3  814a				  -	      IF	.CYCLES < 2
      4  814a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  814a				  -	      ERR
      6  814a					      ENDIF
      7  814a
      8  814a					      IF	.CYCLES & 1
      9  814a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  814a		       04 00		      nop	0
     11  814c				  -	      ELSE
     12  814c				  -	      bit	VSYNC
     13  814c					      ENDIF
     14  814c				   .CYCLES    SET	.CYCLES - 3
     15  814c					      ENDIF
     16  814c
     17  814c					      REPEAT	.CYCLES / 2
     18  814c		       ea		      nop
     17  814c					      REPEND
     18  814d		       ea		      nop
     19  814e					      REPEND
   1956  814e				  -	      else
   1957  814e				  -	      lda.w	player0colorstore
   1958  814e				  -	      sta	COLUP0
   1959  814e					      endif
   1960  814e					      endif
   1961  814e
   1962  814e		       ad 8e 00 	      lda.w	player0height
   1963  8151		       c7 85		      dcp	player0y
   1964  8153		       90 0d		      bcc	.skipDrawlastP0
   1965  8155		       a4 85		      ldy	player0y
   1966  8157		       b1 8a		      lda	(player0pointer),y
   1967  8159				   .continuelastP0
   1968  8159		       85 1b		      sta	GRP0
   1969  815b
   1970  815b
   1971  815b
   1972  815b				  -	      ifnconst	no_blank_lines
   1973  815b				  -	      lda	missile0height	;3
   1974  815b				  -	      dcp	missile0y	;5
   1975  815b				  -	      sbc	stack1
   1976  815b				  -	      sta	ENAM0	;3
   1977  815b				  -	      jmp	.endkerloop
   1978  815b					      else
   1979  815b				  -	      ifconst	readpaddle
   1980  815b				  -	      ldy	currentpaddle
   1981  815b				  -	      lda	INPT0,y
   1982  815b				  -	      bpl	noreadpaddle2
   1983  815b				  -	      inc	paddle
   1984  815b				  -	      jmp	.endkerloop
   1985  815b				  -noreadpaddle2
   1986  815b				  -	      sleep	4
   1987  815b				  -	      jmp	.endkerloop
   1988  815b					      else		; no_blank_lines and no paddle reading
   1989  815b		       68		      pla
   1990  815c		       48		      pha		; 14 cycles in 4 bytes
   1991  815d		       68		      pla
   1992  815e		       48		      pha
   1993  815f							; sleep 14
   1994  815f		       4c 06 f1 	      jmp	.endkerloop
   1995  8162					      endif
   1996  8162					      endif
   1997  8162
   1998  8162
   1999  8162							; ifconst donepaddleskip
   2000  8162							;paddleskipread
   2001  8162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   2002  8162							; plus we get a lo-res paddle read
   2003  8162							; bmi donepaddleskip
   2004  8162							; endif
   2005  8162
   2006  8162				   .skipDrawlastP0
   2007  8162		       a9 00		      lda	#0
   2008  8164		       a8		      tay
   2009  8165		       4c 59 f1 	      jmp	.continuelastP0
   2010  8168
   2011  8168					      ifconst	no_blank_lines
   2012  8168				   no_blank_lines_bailout
   2013  8168		       a2 00		      ldx	#0
   2014  816a					      endif
   2015  816a
   2016  816a				   endkernel
   2017  816a							; 6 digit score routine
   2018  816a		       86 0e		      stx	PF1
   2019  816c		       86 0f		      stx	PF2
   2020  816e		       86 0d		      stx	PF0
   2021  8170		       18		      clc
   2022  8171
   2023  8171				  -	      ifconst	pfrowheight
   2024  8171				  -	      lda	#pfrowheight+2
   2025  8171					      else
   2026  8171					      ifnconst	pfres
   2027  8171		       a9 0a		      lda	#10
   2028  8173				  -	      else
   2029  8173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   2030  8173					      endif
   2031  8173					      endif
   2032  8173
   2033  8173		       e5 ef		      sbc	playfieldpos
   2034  8175		       85 ef		      sta	playfieldpos
   2035  8177		       8a		      txa
   2036  8178
   2037  8178				  -	      ifconst	shakescreen
   2038  8178				  -	      bit	shakescreen
   2039  8178				  -	      bmi	noshakescreen2
   2040  8178				  -	      ldx	#$3D
   2041  8178				  -noshakescreen2
   2042  8178					      endif
   2043  8178
   2044  8178		       95 02		      sta	WSYNC,x
   2045  817a
   2046  817a							; STA WSYNC ;first one, need one more
   2047  817a		       85 0b		      sta	REFP0
   2048  817c		       85 0c		      sta	REFP1
   2049  817e		       85 1b		      STA	GRP0
   2050  8180		       85 1c		      STA	GRP1
   2051  8182							; STA PF1
   2052  8182							; STA PF2
   2053  8182		       85 2b		      sta	HMCLR
   2054  8184		       85 1d		      sta	ENAM0
   2055  8186		       85 1e		      sta	ENAM1
   2056  8188		       85 1f		      sta	ENABL
   2057  818a
   2058  818a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   2059  818c		       85 85		      sta	player0y
   2060  818e		       a5 9e		      lda	temp3
   2061  8190		       85 86		      sta	player1y
   2062  8192				  -	      ifnconst	player1colors
   2063  8192				  -	      lda	temp6
   2064  8192				  -	      sta	missile1y
   2065  8192					      endif
   2066  8192					      ifnconst	playercolors
   2067  8192					      ifnconst	readpaddle
   2068  8192		       a5 a0		      lda	temp5
   2069  8194		       85 91		      sta	missile0y
   2070  8196					      endif
   2071  8196					      endif
   2072  8196		       a5 f7		      lda	stack2
   2073  8198		       85 89		      sta	bally
   2074  819a
   2075  819a							; strangely, this isn't required any more. might have
   2076  819a							; resulted from the no_blank_lines score bounce fix
   2077  819a							;ifconst no_blank_lines
   2078  819a							;sta WSYNC
   2079  819a							;endif
   2080  819a
   2081  819a		       ad 84 02 	      lda	INTIM
   2082  819d		       18		      clc
   2083  819e				  -	      ifnconst	vblank_time
   2084  819e				  -	      adc	#43+12+87
   2085  819e					      else
   2086  819e		       69 8e		      adc	#vblank_time+12+87
   2087  81a0
   2088  81a0					      endif
   2089  81a0							; sta WSYNC
   2090  81a0		       8d 96 02 	      sta	TIM64T
   2091  81a3
   2092  81a3				  -	      ifconst	minikernel
   2093  81a3				  -	      jsr	minikernel
   2094  81a3					      endif
   2095  81a3
   2096  81a3							; now reassign temp vars for score pointers
   2097  81a3
   2098  81a3							; score pointers contain:
   2099  81a3							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   2100  81a3							; swap lo2->temp1
   2101  81a3							; swap lo4->temp3
   2102  81a3							; swap lo6->temp5
   2103  81a3					      ifnconst	noscore
   2104  81a3		       a5 97		      lda	scorepointers+1
   2105  81a5							; ldy temp1
   2106  81a5		       85 9c		      sta	temp1
   2107  81a7							; sty scorepointers+1
   2108  81a7
   2109  81a7		       a5 99		      lda	scorepointers+3
   2110  81a9							; ldy temp3
   2111  81a9		       85 9e		      sta	temp3
   2112  81ab							; sty scorepointers+3
   2113  81ab
   2114  81ab
   2115  81ab		       85 2b		      sta	HMCLR
   2116  81ad		       ba		      tsx
   2117  81ae		       86 f6		      stx	stack1
   2118  81b0		       a2 e0		      ldx	#$E0
   2119  81b2		       86 20		      stx	HMP0
   2120  81b4
   2121  81b4		       a5 a3		      LDA	scorecolor
   2122  81b6		       85 06		      STA	COLUP0
   2123  81b8		       85 07		      STA	COLUP1
   2124  81ba				  -	      ifconst	scorefade
   2125  81ba				  -	      STA	stack2
   2126  81ba					      endif
   2127  81ba				  -	      ifconst	pfscore
   2128  81ba				  -	      lda	pfscorecolor
   2129  81ba				  -	      sta	COLUPF
   2130  81ba					      endif
   2131  81ba		       85 02		      sta	WSYNC
   2132  81bc		       a2 00		      ldx	#0
   2133  81be		       86 1b		      STx	GRP0
   2134  81c0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2135  81c2
   2136  81c2		       a5 9b		      lda	scorepointers+5
   2137  81c4							; ldy temp5
   2138  81c4		       95 a0		      sta	temp5,x
   2139  81c6							; sty scorepointers+5
   2140  81c6		       a9 ff		      lda	#>scoretable
   2141  81c8		       85 97		      sta	scorepointers+1
   2142  81ca		       85 99		      sta	scorepointers+3
   2143  81cc		       85 9b		      sta	scorepointers+5
   2144  81ce		       85 9d		      sta	temp2
   2145  81d0		       85 9f		      sta	temp4
   2146  81d2		       85 a1		      sta	temp6
   2147  81d4		       a0 07		      LDY	#7
   2148  81d6		       84 25		      STY	VDELP0
   2149  81d8		       85 10		      STA	RESP0
   2150  81da		       85 11		      STA	RESP1
   2151  81dc
   2152  81dc
   2153  81dc		       a9 03		      LDA	#$03
   2154  81de		       85 04		      STA	NUSIZ0
   2155  81e0		       85 05		      STA	NUSIZ1
   2156  81e2		       85 26		      STA	VDELP1
   2157  81e4		       a9 f0		      LDA	#$F0
   2158  81e6		       85 21		      STA	HMP1
   2159  81e8		       b1 96		      lda	(scorepointers),y
   2160  81ea		       85 1b		      sta	GRP0
   2161  81ec		       85 2a		      STA	HMOVE	; cycle 73 ?
   2162  81ee		       4c 08 f2 	      jmp	beginscore
   2163  81f1
   2164  81f1
   2165  81f1					      if	((<*)>$d4)
   2166  8200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   2167  8200					      endif
   2168  8200
   2169  8200				   loop2
   2170  8200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   2171  8202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   2172  8204				  -	      ifconst	pfscore
   2173  8204				  -	      lda.w	pfscore1
   2174  8204				  -	      sta	PF1
   2175  8204					      else
   2176  8204				  -	      ifconst	scorefade
   2177  8204				  -	      sleep	2
   2178  8204				  -	      dec	stack2	; decrement the temporary scorecolor
   2179  8204					      else
      0  8204					      sleep	7
      1  8204				   .CYCLES    SET	7
      2  8204
      3  8204				  -	      IF	.CYCLES < 2
      4  8204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8204				  -	      ERR
      6  8204					      ENDIF
      7  8204
      8  8204					      IF	.CYCLES & 1
      9  8204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8204		       04 00		      nop	0
     11  8206				  -	      ELSE
     12  8206				  -	      bit	VSYNC
     13  8206					      ENDIF
     14  8206				   .CYCLES    SET	.CYCLES - 3
     15  8206					      ENDIF
     16  8206
     17  8206					      REPEAT	.CYCLES / 2
     18  8206		       ea		      nop
     17  8206					      REPEND
     18  8207		       ea		      nop
     19  8208					      REPEND
   2181  8208					      endif
   2182  8208					      endif
   2183  8208							; cycle 0
   2184  8208				   beginscore
   2185  8208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   2186  820a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   2187  820c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   2188  820e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   2189  8210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   2190  8212		       9a		      txs
   2191  8213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   2192  8215				  -	      ifconst	scorefade
   2193  8215				  -	      lda	stack2
   2194  8215					      else
      0  8215					      sleep	3
      1  8215				   .CYCLES    SET	3
      2  8215
      3  8215				  -	      IF	.CYCLES < 2
      4  8215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8215				  -	      ERR
      6  8215					      ENDIF
      7  8215
      8  8215					      IF	.CYCLES & 1
      9  8215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8215		       04 00		      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217					      ENDIF
     14  8217				   .CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217				  -	      REPEAT	.CYCLES / 2
     18  8217				  -	      nop
     19  8217					      REPEND
   2196  8217					      endif
   2197  8217
   2198  8217				  -	      ifconst	pfscore
   2199  8217				  -	      lda	pfscore2
   2200  8217				  -	      sta	PF1
   2201  8217					      else
   2202  8217				  -	      ifconst	scorefade
   2203  8217				  -	      sta	COLUP0
   2204  8217				  -	      sta	COLUP1
   2205  8217					      else
      0  8217					      sleep	6
      1  8217				   .CYCLES    SET	6
      2  8217
      3  8217				  -	      IF	.CYCLES < 2
      4  8217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8217				  -	      ERR
      6  8217					      ENDIF
      7  8217
      8  8217				  -	      IF	.CYCLES & 1
      9  8217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  8217				  -	      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217				  -	      ENDIF
     14  8217				  -.CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217					      REPEAT	.CYCLES / 2
     18  8217		       ea		      nop
     17  8217					      REPEND
     18  8218		       ea		      nop
     17  8218					      REPEND
     18  8219		       ea		      nop
     19  821a					      REPEND
   2207  821a					      endif
   2208  821a					      endif
   2209  821a
   2210  821a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   2211  821c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   2212  821e		       ba		      tsx
   2213  821f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   2214  8221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   2215  8223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   2216  8225		       88		      dey
   2217  8226		       10 d8		      bpl	loop2	;+2 60 180
   2218  8228
   2219  8228		       a6 f6		      ldx	stack1
   2220  822a		       9a		      txs
   2221  822b							; lda scorepointers+1
   2222  822b		       a4 9c		      ldy	temp1
   2223  822d							; sta temp1
   2224  822d		       84 97		      sty	scorepointers+1
   2225  822f
   2226  822f		       a9 00		      LDA	#0
   2227  8231		       85 0e		      sta	PF1
   2228  8233		       85 1b		      STA	GRP0
   2229  8235		       85 1c		      STA	GRP1
   2230  8237		       85 25		      STA	VDELP0
   2231  8239		       85 26		      STA	VDELP1	;do we need these
   2232  823b		       85 04		      STA	NUSIZ0
   2233  823d		       85 05		      STA	NUSIZ1
   2234  823f
   2235  823f							; lda scorepointers+3
   2236  823f		       a4 9e		      ldy	temp3
   2237  8241							; sta temp3
   2238  8241		       84 99		      sty	scorepointers+3
   2239  8243
   2240  8243							; lda scorepointers+5
   2241  8243		       a4 a0		      ldy	temp5
   2242  8245							; sta temp5
   2243  8245		       84 9b		      sty	scorepointers+5
   2244  8247					      endif		;noscore
   2245  8247				  -	      ifconst	readpaddle
   2246  8247				  -	      lda	#%11000010
   2247  8247					      else
   2248  8247				  -	      ifconst	qtcontroller
   2249  8247				  -	      lda	qtcontroller
   2250  8247				  -	      lsr		; bit 0 in carry
   2251  8247				  -	      lda	#4
   2252  8247				  -	      ror		; carry into top of A
   2253  8247					      else
   2254  8247		       a9 02		      lda	#2
   2255  8249					      endif		; qtcontroller
   2256  8249					      endif		; readpaddle
   2257  8249		       85 02		      sta	WSYNC
   2258  824b		       85 01		      sta	VBLANK
      0  824d					      RETURN
      1  824d				  -	      ifnconst	bankswitch
      2  824d				  -	      rts
      3  824d					      else
      4  824d		       4c dd ff 	      jmp	BS_return
      5  8250					      endif
   2260  8250				  -	      ifconst	shakescreen
   2261  8250				  -doshakescreen
   2262  8250				  -	      bit	shakescreen
   2263  8250				  -	      bmi	noshakescreen
   2264  8250				  -	      sta	WSYNC
   2265  8250				  -noshakescreen
   2266  8250				  -	      ldx	missile0height
   2267  8250				  -	      inx
   2268  8250				  -	      rts
   2269  8250					      endif
   2270  8250
   2271  8250							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2272  8250
   2273  8250				   start
   2274  8250		       78		      sei
   2275  8251		       d8		      cld
   2276  8252		       a0 00		      ldy	#0
   2277  8254		       a5 d0		      lda	$D0
   2278  8256		       c9 2c		      cmp	#$2C	;check RAM location #1
   2279  8258		       d0 07		      bne	MachineIs2600
   2280  825a		       a5 d1		      lda	$D1
   2281  825c		       c9 a9		      cmp	#$A9	;check RAM location #2
   2282  825e		       d0 01		      bne	MachineIs2600
   2283  8260		       88		      dey
   2284  8261				   MachineIs2600
   2285  8261		       a2 00		      ldx	#0
   2286  8263		       8a		      txa
   2287  8264				   clearmem
   2288  8264		       e8		      inx
   2289  8265		       9a		      txs
   2290  8266		       48		      pha
   2291  8267		       d0 fb		      bne	clearmem
   2292  8269		       84 9c		      sty	temp1
   2293  826b					      ifnconst	multisprite
   2294  826b				  -	      ifconst	pfrowheight
   2295  826b				  -	      lda	#pfrowheight
   2296  826b					      else
   2297  826b				  -	      ifconst	pfres
   2298  826b				  -	      lda	#(96/pfres)
   2299  826b					      else
   2300  826b		       a9 08		      lda	#8
   2301  826d					      endif
   2302  826d					      endif
   2303  826d		       85 ef		      sta	playfieldpos
   2304  826f					      endif
   2305  826f		       a2 05		      ldx	#5
   2306  8271				   initscore
   2307  8271		       a9 74		      lda	#<scoretable
   2308  8273		       95 96		      sta	scorepointers,x
   2309  8275		       ca		      dex
   2310  8276		       10 f9		      bpl	initscore
   2311  8278		       a9 01		      lda	#1
   2312  827a		       85 0a		      sta	CTRLPF
   2313  827c		       0d 84 02 	      ora	INTIM
   2314  827f		       85 a2		      sta	rand
   2315  8281
   2316  8281				  -	      ifconst	multisprite
   2317  8281				  -	      jsr	multisprite_setup
   2318  8281					      endif
   2319  8281
   2320  8281				  -	      ifnconst	bankswitch
   2321  8281				  -	      jmp	game
   2322  8281					      else
   2323  8281		       a9 0f		      lda	#>(game-1)
   2324  8283		       48		      pha
   2325  8284		       a9 ff		      lda	#<(game-1)
   2326  8286		       48		      pha
   2327  8287		       48		      pha
   2328  8288		       48		      pha
   2329  8289		       a2 01		      ldx	#1
   2330  828b		       4c eb ff 	      jmp	BS_jsr
   2331  828e					      endif
   2332  828e							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2333  828e
   2334  828e							; playfield drawing routines
   2335  828e							; you get a 32x12 bitmapped display in a single color :)
   2336  828e							; 0-31 and 0-11
   2337  828e
   2338  828e				   pfclear		; clears playfield - or fill with pattern
   2339  828e				  -	      ifconst	pfres
   2340  828e				  -	      ldx	#pfres*pfwidth-1
   2341  828e					      else
   2342  828e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   2343  8290					      endif
   2344  8290				   pfclear_loop
   2345  8290					      ifnconst	superchip
   2346  8290		       95 a4		      sta	playfield,x
   2347  8292				  -	      else
   2348  8292				  -	      sta	playfield-128,x
   2349  8292					      endif
   2350  8292		       ca		      dex
   2351  8293		       10 fb		      bpl	pfclear_loop
      0  8295					      RETURN
      1  8295				  -	      ifnconst	bankswitch
      2  8295				  -	      rts
      3  8295					      else
      4  8295		       4c dd ff 	      jmp	BS_return
      5  8298					      endif
   2353  8298
   2354  8298				   setuppointers
   2355  8298		       86 9d		      stx	temp2	; store on.off.flip value
   2356  829a		       aa		      tax		; put x-value in x 
   2357  829b		       4a		      lsr
   2358  829c		       4a		      lsr
   2359  829d		       4a		      lsr		; divide x pos by 8 
   2360  829e		       85 9c		      sta	temp1
   2361  82a0		       98		      tya
   2362  82a1		       0a		      asl
   2363  82a2					      if	pfwidth=4
   2364  82a2		       0a		      asl		; multiply y pos by 4
   2365  82a3					      endif		; else multiply by 2
   2366  82a3		       18		      clc
   2367  82a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   2368  82a6		       a8		      tay		; put the value in y
   2369  82a7		       a5 9d		      lda	temp2	; restore on.off.flip value
   2370  82a9		       60		      rts
   2371  82aa
   2372  82aa				   pfread
   2373  82aa							;x=xvalue, y=yvalue
   2374  82aa		       20 98 f2 	      jsr	setuppointers
   2375  82ad		       bd 42 f3 	      lda	setbyte,x
   2376  82b0		       39 a4 00 	      and	playfield,y
   2377  82b3		       5d 42 f3 	      eor	setbyte,x
   2378  82b6							; beq readzero
   2379  82b6							; lda #1
   2380  82b6							; readzero
      0  82b6					      RETURN
      1  82b6				  -	      ifnconst	bankswitch
      2  82b6				  -	      rts
      3  82b6					      else
      4  82b6		       4c dd ff 	      jmp	BS_return
      5  82b9					      endif
   2382  82b9
   2383  82b9				   pfpixel
   2384  82b9							;x=xvalue, y=yvalue, a=0,1,2
   2385  82b9		       20 98 f2 	      jsr	setuppointers
   2386  82bc
   2387  82bc					      ifconst	bankswitch
   2388  82bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2389  82be		       f0 0f		      beq	pixelon_r	; if "on" go to on
   2390  82c0		       4a		      lsr
   2391  82c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   2392  82c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2393  82c6		       5d 42 f3 	      eor	setbyte,x
   2394  82c9				  -	      ifconst	superchip
   2395  82c9				  -	      sta	playfield-128,y
   2396  82c9					      else
   2397  82c9		       99 a4 00 	      sta	playfield,y
   2398  82cc					      endif
      0  82cc					      RETURN
      1  82cc				  -	      ifnconst	bankswitch
      2  82cc				  -	      rts
      3  82cc					      else
      4  82cc		       4c dd ff 	      jmp	BS_return
      5  82cf					      endif
   2400  82cf				   pixelon_r
   2401  82cf		       b9 a4 00 	      lda	playfield,y
   2402  82d2		       1d 42 f3 	      ora	setbyte,x
   2403  82d5				  -	      ifconst	superchip
   2404  82d5				  -	      sta	playfield-128,y
   2405  82d5					      else
   2406  82d5		       99 a4 00 	      sta	playfield,y
   2407  82d8					      endif
      0  82d8					      RETURN
      1  82d8				  -	      ifnconst	bankswitch
      2  82d8				  -	      rts
      3  82d8					      else
      4  82d8		       4c dd ff 	      jmp	BS_return
      5  82db					      endif
   2409  82db				   pixeloff_r
   2410  82db		       bd 42 f3 	      lda	setbyte,x
   2411  82de		       49 ff		      eor	#$ff
   2412  82e0		       39 a4 00 	      and	playfield,y
   2413  82e3				  -	      ifconst	superchip
   2414  82e3				  -	      sta	playfield-128,y
   2415  82e3					      else
   2416  82e3		       99 a4 00 	      sta	playfield,y
   2417  82e6					      endif
      0  82e6					      RETURN
      1  82e6				  -	      ifnconst	bankswitch
      2  82e6				  -	      rts
      3  82e6					      else
      4  82e6		       4c dd ff 	      jmp	BS_return
      5  82e9					      endif
   2419  82e9
   2420  82e9				  -	      else
   2421  82e9				  -	      jmp	plotpoint
   2422  82e9					      endif
   2423  82e9
   2424  82e9				   pfhline
   2425  82e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2426  82e9		       20 98 f2 	      jsr	setuppointers
   2427  82ec		       4c f6 f2 	      jmp	noinc
   2428  82ef				   keepgoing
   2429  82ef		       e8		      inx
   2430  82f0		       8a		      txa
   2431  82f1		       29 07		      and	#7
   2432  82f3		       d0 01		      bne	noinc
   2433  82f5		       c8		      iny
   2434  82f6				   noinc
   2435  82f6		       20 1b f3 	      jsr	plotpoint
   2436  82f9		       e4 9e		      cpx	temp3
   2437  82fb		       30 f2		      bmi	keepgoing
      0  82fd					      RETURN
      1  82fd				  -	      ifnconst	bankswitch
      2  82fd				  -	      rts
      3  82fd					      else
      4  82fd		       4c dd ff 	      jmp	BS_return
      5  8300					      endif
   2439  8300
   2440  8300				   pfvline
   2441  8300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2442  8300		       20 98 f2 	      jsr	setuppointers
   2443  8303		       84 9c		      sty	temp1	; store memory location offset
   2444  8305		       e6 9e		      inc	temp3	; increase final x by 1 
   2445  8307		       a5 9e		      lda	temp3
   2446  8309		       0a		      asl
   2447  830a					      if	pfwidth=4
   2448  830a		       0a		      asl		; multiply by 4
   2449  830b					      endif		; else multiply by 2
   2450  830b		       85 9e		      sta	temp3	; store it
   2451  830d							; Thanks to Michael Rideout for fixing a bug in this code
   2452  830d							; right now, temp1=y=starting memory location, temp3=final
   2453  830d							; x should equal original x value
   2454  830d				   keepgoingy
   2455  830d		       20 1b f3 	      jsr	plotpoint
   2456  8310		       c8		      iny
   2457  8311		       c8		      iny
   2458  8312					      if	pfwidth=4
   2459  8312		       c8		      iny
   2460  8313		       c8		      iny
   2461  8314					      endif
   2462  8314		       c4 9e		      cpy	temp3
   2463  8316		       30 f5		      bmi	keepgoingy
      0  8318					      RETURN
      1  8318				  -	      ifnconst	bankswitch
      2  8318				  -	      rts
      3  8318					      else
      4  8318		       4c dd ff 	      jmp	BS_return
      5  831b					      endif
   2465  831b
   2466  831b				   plotpoint
   2467  831b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2468  831d		       f0 0d		      beq	pixelon	; if "on" go to on
   2469  831f		       4a		      lsr
   2470  8320		       b0 14		      bcs	pixeloff	; value is 1 if true
   2471  8322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2472  8325		       5d 42 f3 	      eor	setbyte,x
   2473  8328				  -	      ifconst	superchip
   2474  8328				  -	      sta	playfield-128,y
   2475  8328					      else
   2476  8328		       99 a4 00 	      sta	playfield,y
   2477  832b					      endif
   2478  832b		       60		      rts
   2479  832c				   pixelon
   2480  832c		       b9 a4 00 	      lda	playfield,y
   2481  832f		       1d 42 f3 	      ora	setbyte,x
   2482  8332				  -	      ifconst	superchip
   2483  8332				  -	      sta	playfield-128,y
   2484  8332					      else
   2485  8332		       99 a4 00 	      sta	playfield,y
   2486  8335					      endif
   2487  8335		       60		      rts
   2488  8336				   pixeloff
   2489  8336		       bd 42 f3 	      lda	setbyte,x
   2490  8339		       49 ff		      eor	#$ff
   2491  833b		       39 a4 00 	      and	playfield,y
   2492  833e				  -	      ifconst	superchip
   2493  833e				  -	      sta	playfield-128,y
   2494  833e					      else
   2495  833e		       99 a4 00 	      sta	playfield,y
   2496  8341					      endif
   2497  8341		       60		      rts
   2498  8342
   2499  8342				   setbyte
   2500  8342					      ifnconst	pfcenter
   2501  8342		       80		      .byte.b	$80
   2502  8343		       40		      .byte.b	$40
   2503  8344		       20		      .byte.b	$20
   2504  8345		       10		      .byte.b	$10
   2505  8346		       08		      .byte.b	$08
   2506  8347		       04		      .byte.b	$04
   2507  8348		       02		      .byte.b	$02
   2508  8349		       01		      .byte.b	$01
   2509  834a					      endif
   2510  834a		       01		      .byte.b	$01
   2511  834b		       02		      .byte.b	$02
   2512  834c		       04		      .byte.b	$04
   2513  834d		       08		      .byte.b	$08
   2514  834e		       10		      .byte.b	$10
   2515  834f		       20		      .byte.b	$20
   2516  8350		       40		      .byte.b	$40
   2517  8351		       80		      .byte.b	$80
   2518  8352		       80		      .byte.b	$80
   2519  8353		       40		      .byte.b	$40
   2520  8354		       20		      .byte.b	$20
   2521  8355		       10		      .byte.b	$10
   2522  8356		       08		      .byte.b	$08
   2523  8357		       04		      .byte.b	$04
   2524  8358		       02		      .byte.b	$02
   2525  8359		       01		      .byte.b	$01
   2526  835a		       01		      .byte.b	$01
   2527  835b		       02		      .byte.b	$02
   2528  835c		       04		      .byte.b	$04
   2529  835d		       08		      .byte.b	$08
   2530  835e		       10		      .byte.b	$10
   2531  835f		       20		      .byte.b	$20
   2532  8360		       40		      .byte.b	$40
   2533  8361		       80		      .byte.b	$80
   2534  8362							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2535  8362
   2536  8362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   2537  8362		       d0 15		      bne	notleft
   2538  8364							;left
   2539  8364				  -	      ifconst	pfres
   2540  8364				  -	      ldx	#pfres*4
   2541  8364					      else
   2542  8364		       a2 30		      ldx	#48
   2543  8366					      endif
   2544  8366				   leftloop
   2545  8366		       b5 a3		      lda	playfield-1,x
   2546  8368		       4a		      lsr
   2547  8369
   2548  8369				  -	      ifconst	superchip
   2549  8369				  -	      lda	playfield-2,x
   2550  8369				  -	      rol
   2551  8369				  -	      sta	playfield-130,x
   2552  8369				  -	      lda	playfield-3,x
   2553  8369				  -	      ror
   2554  8369				  -	      sta	playfield-131,x
   2555  8369				  -	      lda	playfield-4,x
   2556  8369				  -	      rol
   2557  8369				  -	      sta	playfield-132,x
   2558  8369				  -	      lda	playfield-1,x
   2559  8369				  -	      ror
   2560  8369				  -	      sta	playfield-129,x
   2561  8369					      else
   2562  8369		       36 a2		      rol	playfield-2,x
   2563  836b		       76 a1		      ror	playfield-3,x
   2564  836d		       36 a0		      rol	playfield-4,x
   2565  836f		       76 a3		      ror	playfield-1,x
   2566  8371					      endif
   2567  8371
   2568  8371		       8a		      txa
   2569  8372		       cb 04		      sbx	#4
   2570  8374		       d0 f0		      bne	leftloop
      0  8376					      RETURN
      1  8376				  -	      ifnconst	bankswitch
      2  8376				  -	      rts
      3  8376					      else
      4  8376		       4c dd ff 	      jmp	BS_return
      5  8379					      endif
   2572  8379
   2573  8379				   notleft
   2574  8379		       4a		      lsr
   2575  837a		       90 15		      bcc	notright
   2576  837c							;right
   2577  837c
   2578  837c				  -	      ifconst	pfres
   2579  837c				  -	      ldx	#pfres*4
   2580  837c					      else
   2581  837c		       a2 30		      ldx	#48
   2582  837e					      endif
   2583  837e				   rightloop
   2584  837e		       b5 a0		      lda	playfield-4,x
   2585  8380		       4a		      lsr
   2586  8381				  -	      ifconst	superchip
   2587  8381				  -	      lda	playfield-3,x
   2588  8381				  -	      rol
   2589  8381				  -	      sta	playfield-131,x
   2590  8381				  -	      lda	playfield-2,x
   2591  8381				  -	      ror
   2592  8381				  -	      sta	playfield-130,x
   2593  8381				  -	      lda	playfield-1,x
   2594  8381				  -	      rol
   2595  8381				  -	      sta	playfield-129,x
   2596  8381				  -	      lda	playfield-4,x
   2597  8381				  -	      ror
   2598  8381				  -	      sta	playfield-132,x
   2599  8381					      else
   2600  8381		       36 a1		      rol	playfield-3,x
   2601  8383		       76 a2		      ror	playfield-2,x
   2602  8385		       36 a3		      rol	playfield-1,x
   2603  8387		       76 a0		      ror	playfield-4,x
   2604  8389					      endif
   2605  8389		       8a		      txa
   2606  838a		       cb 04		      sbx	#4
   2607  838c		       d0 f0		      bne	rightloop
      0  838e					      RETURN
      1  838e				  -	      ifnconst	bankswitch
      2  838e				  -	      rts
      3  838e					      else
      4  838e		       4c dd ff 	      jmp	BS_return
      5  8391					      endif
   2609  8391
   2610  8391				   notright
   2611  8391		       4a		      lsr
   2612  8392		       90 4b		      bcc	notup
   2613  8394							;up
   2614  8394		       4a		      lsr
   2615  8395		       90 02		      bcc	onedecup
   2616  8397		       c6 ef		      dec	playfieldpos
   2617  8399				   onedecup
   2618  8399		       c6 ef		      dec	playfieldpos
   2619  839b		       f0 02		      beq	shiftdown
   2620  839d		       10 3d		      bpl	noshiftdown2
   2621  839f				   shiftdown
   2622  839f				  -	      ifconst	pfrowheight
   2623  839f				  -	      lda	#pfrowheight
   2624  839f					      else
   2625  839f					      ifnconst	pfres
   2626  839f		       a9 08		      lda	#8
   2627  83a1				  -	      else
   2628  83a1				  -	      lda	#(96/pfres)	; try to come close to the real size
   2629  83a1					      endif
   2630  83a1					      endif
   2631  83a1
   2632  83a1		       85 ef		      sta	playfieldpos
   2633  83a3		       a5 a7		      lda	playfield+3
   2634  83a5		       85 9f		      sta	temp4
   2635  83a7		       a5 a6		      lda	playfield+2
   2636  83a9		       85 9e		      sta	temp3
   2637  83ab		       a5 a5		      lda	playfield+1
   2638  83ad		       85 9d		      sta	temp2
   2639  83af		       a5 a4		      lda	playfield
   2640  83b1		       85 9c		      sta	temp1
   2641  83b3		       a2 00		      ldx	#0
   2642  83b5				   up2
   2643  83b5		       b5 a8		      lda	playfield+4,x
   2644  83b7				  -	      ifconst	superchip
   2645  83b7				  -	      sta	playfield-128,x
   2646  83b7				  -	      lda	playfield+5,x
   2647  83b7				  -	      sta	playfield-127,x
   2648  83b7				  -	      lda	playfield+6,x
   2649  83b7				  -	      sta	playfield-126,x
   2650  83b7				  -	      lda	playfield+7,x
   2651  83b7				  -	      sta	playfield-125,x
   2652  83b7					      else
   2653  83b7		       95 a4		      sta	playfield,x
   2654  83b9		       b5 a9		      lda	playfield+5,x
   2655  83bb		       95 a5		      sta	playfield+1,x
   2656  83bd		       b5 aa		      lda	playfield+6,x
   2657  83bf		       95 a6		      sta	playfield+2,x
   2658  83c1		       b5 ab		      lda	playfield+7,x
   2659  83c3		       95 a7		      sta	playfield+3,x
   2660  83c5					      endif
   2661  83c5		       8a		      txa
   2662  83c6		       cb fc		      sbx	#252
   2663  83c8				  -	      ifconst	pfres
   2664  83c8				  -	      cpx	#(pfres-1)*4
   2665  83c8					      else
   2666  83c8		       e0 2c		      cpx	#44
   2667  83ca					      endif
   2668  83ca		       d0 e9		      bne	up2
   2669  83cc
   2670  83cc		       a5 9f		      lda	temp4
   2671  83ce
   2672  83ce				  -	      ifconst	superchip
   2673  83ce				  -	      ifconst	pfres
   2674  83ce				  -	      sta	playfield+pfres*4-129
   2675  83ce				  -	      lda	temp3
   2676  83ce				  -	      sta	playfield+pfres*4-130
   2677  83ce				  -	      lda	temp2
   2678  83ce				  -	      sta	playfield+pfres*4-131
   2679  83ce				  -	      lda	temp1
   2680  83ce				  -	      sta	playfield+pfres*4-132
   2681  83ce				  -	      else
   2682  83ce				  -	      sta	playfield+47-128
   2683  83ce				  -	      lda	temp3
   2684  83ce				  -	      sta	playfield+46-128
   2685  83ce				  -	      lda	temp2
   2686  83ce				  -	      sta	playfield+45-128
   2687  83ce				  -	      lda	temp1
   2688  83ce				  -	      sta	playfield+44-128
   2689  83ce				  -	      endif
   2690  83ce					      else
   2691  83ce				  -	      ifconst	pfres
   2692  83ce				  -	      sta	playfield+pfres*4-1
   2693  83ce				  -	      lda	temp3
   2694  83ce				  -	      sta	playfield+pfres*4-2
   2695  83ce				  -	      lda	temp2
   2696  83ce				  -	      sta	playfield+pfres*4-3
   2697  83ce				  -	      lda	temp1
   2698  83ce				  -	      sta	playfield+pfres*4-4
   2699  83ce					      else
   2700  83ce		       85 d3		      sta	playfield+47
   2701  83d0		       a5 9e		      lda	temp3
   2702  83d2		       85 d2		      sta	playfield+46
   2703  83d4		       a5 9d		      lda	temp2
   2704  83d6		       85 d1		      sta	playfield+45
   2705  83d8		       a5 9c		      lda	temp1
   2706  83da		       85 d0		      sta	playfield+44
   2707  83dc					      endif
   2708  83dc					      endif
   2709  83dc				   noshiftdown2
      0  83dc					      RETURN
      1  83dc				  -	      ifnconst	bankswitch
      2  83dc				  -	      rts
      3  83dc					      else
      4  83dc		       4c dd ff 	      jmp	BS_return
      5  83df					      endif
   2711  83df
   2712  83df
   2713  83df				   notup
   2714  83df							;down
   2715  83df		       4a		      lsr
   2716  83e0		       b0 02		      bcs	oneincup
   2717  83e2		       e6 ef		      inc	playfieldpos
   2718  83e4				   oneincup
   2719  83e4		       e6 ef		      inc	playfieldpos
   2720  83e6		       a5 ef		      lda	playfieldpos
   2721  83e8
   2722  83e8				  -	      ifconst	pfrowheight
   2723  83e8				  -	      cmp	#pfrowheight+1
   2724  83e8					      else
   2725  83e8					      ifnconst	pfres
   2726  83e8		       c9 09		      cmp	#9
   2727  83ea				  -	      else
   2728  83ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   2729  83ea					      endif
   2730  83ea					      endif
   2731  83ea
   2732  83ea		       90 3b		      bcc	noshiftdown
   2733  83ec		       a9 01		      lda	#1
   2734  83ee		       85 ef		      sta	playfieldpos
   2735  83f0
   2736  83f0				  -	      ifconst	pfres
   2737  83f0				  -	      lda	playfield+pfres*4-1
   2738  83f0				  -	      sta	temp4
   2739  83f0				  -	      lda	playfield+pfres*4-2
   2740  83f0				  -	      sta	temp3
   2741  83f0				  -	      lda	playfield+pfres*4-3
   2742  83f0				  -	      sta	temp2
   2743  83f0				  -	      lda	playfield+pfres*4-4
   2744  83f0					      else
   2745  83f0		       a5 d3		      lda	playfield+47
   2746  83f2		       85 9f		      sta	temp4
   2747  83f4		       a5 d2		      lda	playfield+46
   2748  83f6		       85 9e		      sta	temp3
   2749  83f8		       a5 d1		      lda	playfield+45
   2750  83fa		       85 9d		      sta	temp2
   2751  83fc		       a5 d0		      lda	playfield+44
   2752  83fe					      endif
   2753  83fe
   2754  83fe		       85 9c		      sta	temp1
   2755  8400
   2756  8400				  -	      ifconst	pfres
   2757  8400				  -	      ldx	#(pfres-1)*4
   2758  8400					      else
   2759  8400		       a2 2c		      ldx	#44
   2760  8402					      endif
   2761  8402				   down2
   2762  8402		       b5 a3		      lda	playfield-1,x
   2763  8404				  -	      ifconst	superchip
   2764  8404				  -	      sta	playfield-125,x
   2765  8404				  -	      lda	playfield-2,x
   2766  8404				  -	      sta	playfield-126,x
   2767  8404				  -	      lda	playfield-3,x
   2768  8404				  -	      sta	playfield-127,x
   2769  8404				  -	      lda	playfield-4,x
   2770  8404				  -	      sta	playfield-128,x
   2771  8404					      else
   2772  8404		       95 a7		      sta	playfield+3,x
   2773  8406		       b5 a2		      lda	playfield-2,x
   2774  8408		       95 a6		      sta	playfield+2,x
   2775  840a		       b5 a1		      lda	playfield-3,x
   2776  840c		       95 a5		      sta	playfield+1,x
   2777  840e		       b5 a0		      lda	playfield-4,x
   2778  8410		       95 a4		      sta	playfield,x
   2779  8412					      endif
   2780  8412		       8a		      txa
   2781  8413		       cb 04		      sbx	#4
   2782  8415		       d0 eb		      bne	down2
   2783  8417
   2784  8417		       a5 9f		      lda	temp4
   2785  8419				  -	      ifconst	superchip
   2786  8419				  -	      sta	playfield-125
   2787  8419				  -	      lda	temp3
   2788  8419				  -	      sta	playfield-126
   2789  8419				  -	      lda	temp2
   2790  8419				  -	      sta	playfield-127
   2791  8419				  -	      lda	temp1
   2792  8419				  -	      sta	playfield-128
   2793  8419					      else
   2794  8419		       85 a7		      sta	playfield+3
   2795  841b		       a5 9e		      lda	temp3
   2796  841d		       85 a6		      sta	playfield+2
   2797  841f		       a5 9d		      lda	temp2
   2798  8421		       85 a5		      sta	playfield+1
   2799  8423		       a5 9c		      lda	temp1
   2800  8425		       85 a4		      sta	playfield
   2801  8427					      endif
   2802  8427				   noshiftdown
      0  8427					      RETURN
      1  8427				  -	      ifnconst	bankswitch
      2  8427				  -	      rts
      3  8427					      else
      4  8427		       4c dd ff 	      jmp	BS_return
      5  842a					      endif
   2804  842a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2805  842a
   2806  842a							;standard routines needed for pretty much all games
   2807  842a							; just the random number generator is left - maybe we should remove this asm file altogether?
   2808  842a							; repositioning code and score pointer setup moved to overscan
   2809  842a							; read switches, joysticks now compiler generated (more efficient)
   2810  842a
   2811  842a				   randomize
   2812  842a		       a5 a2		      lda	rand
   2813  842c		       4a		      lsr
   2814  842d				  -	      ifconst	rand16
   2815  842d				  -	      rol	rand16
   2816  842d					      endif
   2817  842d		       90 02		      bcc	noeor
   2818  842f		       49 b4		      eor	#$B4
   2819  8431				   noeor
   2820  8431		       85 a2		      sta	rand
   2821  8433				  -	      ifconst	rand16
   2822  8433				  -	      eor	rand16
   2823  8433					      endif
      0  8433					      RETURN
      1  8433				  -	      ifnconst	bankswitch
      2  8433				  -	      rts
      3  8433					      else
      4  8433		       4c dd ff 	      jmp	BS_return
      5  8436					      endif
   2825  8436							; Provided under the CC0 license. See the included LICENSE.txt for details.
   2826  8436
   2827  8436				   drawscreen
   2828  8436				  -	      ifconst	debugscore
   2829  8436				  -	      ldx	#14
   2830  8436				  -	      lda	INTIM	; display # cycles left in the score
   2831  8436				  -
   2832  8436				  -	      ifconst	mincycles
   2833  8436				  -	      lda	mincycles
   2834  8436				  -	      cmp	INTIM
   2835  8436				  -	      lda	mincycles
   2836  8436				  -	      bcc	nochange
   2837  8436				  -	      lda	INTIM
   2838  8436				  -	      sta	mincycles
   2839  8436				  -nochange
   2840  8436				  -	      endif
   2841  8436				  -
   2842  8436				  -			; cmp #$2B
   2843  8436				  -			; bcs no_cycles_left
   2844  8436				  -	      bmi	cycles_left
   2845  8436				  -	      ldx	#64
   2846  8436				  -	      eor	#$ff	;make negative
   2847  8436				  -cycles_left
   2848  8436				  -	      stx	scorecolor
   2849  8436				  -	      and	#$7f	; clear sign bit
   2850  8436				  -	      tax
   2851  8436				  -	      lda	scorebcd,x
   2852  8436				  -	      sta	score+2
   2853  8436				  -	      lda	scorebcd1,x
   2854  8436				  -	      sta	score+1
   2855  8436				  -	      jmp	done_debugscore
   2856  8436				  -scorebcd
   2857  8436				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2858  8436				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2859  8436				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2860  8436				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2861  8436				  -scorebcd1
   2862  8436				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2863  8436				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2864  8436				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2865  8436				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2866  8436				  -done_debugscore
   2867  8436					      endif
   2868  8436
   2869  8436				  -	      ifconst	debugcycles
   2870  8436				  -	      lda	INTIM	; if we go over, it mucks up the background color
   2871  8436				  -			; cmp #$2B
   2872  8436				  -			; BCC overscan
   2873  8436				  -	      bmi	overscan
   2874  8436				  -	      sta	COLUBK
   2875  8436				  -	      bcs	doneoverscan
   2876  8436					      endif
   2877  8436
   2878  8436				   overscan
   2879  8436				  -	      ifconst	interlaced
   2880  8436				  -	      PHP
   2881  8436				  -	      PLA
   2882  8436				  -	      EOR	#4	; flip interrupt bit
   2883  8436				  -	      PHA
   2884  8436				  -	      PLP
   2885  8436				  -	      AND	#4	; isolate the interrupt bit
   2886  8436				  -	      TAX		; save it for later
   2887  8436					      endif
   2888  8436
   2889  8436				   overscanloop
   2890  8436		       ad 84 02 	      lda	INTIM	;wait for sync
   2891  8439		       30 fb		      bmi	overscanloop
   2892  843b				   doneoverscan
   2893  843b
   2894  843b							;do VSYNC
   2895  843b
   2896  843b				  -	      ifconst	interlaced
   2897  843b				  -	      CPX	#4
   2898  843b				  -	      BNE	oddframevsync
   2899  843b					      endif
   2900  843b
   2901  843b		       a9 02		      lda	#2
   2902  843d		       85 02		      sta	WSYNC
   2903  843f		       85 00		      sta	VSYNC
   2904  8441		       85 02		      STA	WSYNC
   2905  8443		       85 02		      STA	WSYNC
   2906  8445		       4a		      lsr
   2907  8446		       85 02		      STA	WSYNC
   2908  8448		       85 00		      STA	VSYNC
   2909  844a		       85 01		      sta	VBLANK
   2910  844c				  -	      ifnconst	overscan_time
   2911  844c				  -	      lda	#37+128
   2912  844c					      else
   2913  844c		       a9 a5		      lda	#overscan_time+128
   2914  844e					      endif
   2915  844e		       8d 96 02 	      sta	TIM64T
   2916  8451
   2917  8451				  -	      ifconst	interlaced
   2918  8451				  -	      jmp	postsync
   2919  8451				  -
   2920  8451				  -oddframevsync
   2921  8451				  -	      sta	WSYNC
   2922  8451				  -
   2923  8451				  -	      LDA	($80,X)	; 11 waste
   2924  8451				  -	      LDA	($80,X)	; 11 waste
   2925  8451				  -	      LDA	($80,X)	; 11 waste
   2926  8451				  -
   2927  8451				  -	      lda	#2
   2928  8451				  -	      sta	VSYNC
   2929  8451				  -	      sta	WSYNC
   2930  8451				  -	      sta	WSYNC
   2931  8451				  -	      sta	WSYNC
   2932  8451				  -
   2933  8451				  -	      LDA	($80,X)	; 11 waste
   2934  8451				  -	      LDA	($80,X)	; 11 waste
   2935  8451				  -	      LDA	($80,X)	; 11 waste
   2936  8451				  -
   2937  8451				  -	      lda	#0
   2938  8451				  -	      sta	VSYNC
   2939  8451				  -	      sta	VBLANK
   2940  8451				  -	      ifnconst	overscan_time
   2941  8451				  -	      lda	#37+128
   2942  8451				  -	      else
   2943  8451				  -	      lda	#overscan_time+128
   2944  8451				  -	      endif
   2945  8451				  -	      sta	TIM64T
   2946  8451				  -
   2947  8451				  -postsync
   2948  8451					      endif
   2949  8451
   2950  8451				  -	      ifconst	legacy
   2951  8451				  -	      if	legacy < 100
   2952  8451				  -	      ldx	#4
   2953  8451				  -adjustloop
   2954  8451				  -	      lda	player0x,x
   2955  8451				  -	      sec
   2956  8451				  -	      sbc	#14	;?
   2957  8451				  -	      sta	player0x,x
   2958  8451				  -	      dex
   2959  8451				  -	      bpl	adjustloop
   2960  8451				  -	      endif
   2961  8451					      endif
   2962  8451				  -	      if	((<*)>$e9)&&((<*)<$fa)
   2963  8451				  -	      repeat	($fa-(<*))
   2964  8451				  -	      nop
   2965  8451				  -	      repend
   2966  8451					      endif
   2967  8451		       85 02		      sta	WSYNC
   2968  8453		       a2 04		      ldx	#4
      0  8455					      SLEEP	3
      1  8455				   .CYCLES    SET	3
      2  8455
      3  8455				  -	      IF	.CYCLES < 2
      4  8455				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8455				  -	      ERR
      6  8455					      ENDIF
      7  8455
      8  8455					      IF	.CYCLES & 1
      9  8455					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8455		       04 00		      nop	0
     11  8457				  -	      ELSE
     12  8457				  -	      bit	VSYNC
     13  8457					      ENDIF
     14  8457				   .CYCLES    SET	.CYCLES - 3
     15  8457					      ENDIF
     16  8457
     17  8457				  -	      REPEAT	.CYCLES / 2
     18  8457				  -	      nop
     19  8457					      REPEND
   2970  8457				   HorPosLoop		; 5
   2971  8457		       b5 80		      lda	player0x,X	;+4 9
   2972  8459		       38		      sec		;+2 11
   2973  845a				   DivideLoop
   2974  845a		       e9 0f		      sbc	#15
   2975  845c		       b0 fc		      bcs	DivideLoop	;+4 15
   2976  845e		       95 9c		      sta	temp1,X	;+4 19
   2977  8460		       95 10		      sta	RESP0,X	;+4 23
   2978  8462		       85 02		      sta	WSYNC
   2979  8464		       ca		      dex
   2980  8465		       10 f0		      bpl	HorPosLoop	;+5 5
   2981  8467							; 4
   2982  8467
   2983  8467		       a2 04		      ldx	#4
   2984  8469		       b4 9c		      ldy	temp1,X
   2985  846b		       b9 c7 f3 	      lda	repostable-256,Y
   2986  846e		       95 20		      sta	HMP0,X	;+14 18
   2987  8470
   2988  8470		       ca		      dex
   2989  8471		       b4 9c		      ldy	temp1,X
   2990  8473		       b9 c7 f3 	      lda	repostable-256,Y
   2991  8476		       95 20		      sta	HMP0,X	;+14 32
   2992  8478
   2993  8478		       ca		      dex
   2994  8479		       b4 9c		      ldy	temp1,X
   2995  847b		       b9 c7 f3 	      lda	repostable-256,Y
   2996  847e		       95 20		      sta	HMP0,X	;+14 46
   2997  8480
   2998  8480		       ca		      dex
   2999  8481		       b4 9c		      ldy	temp1,X
   3000  8483		       b9 c7 f3 	      lda	repostable-256,Y
   3001  8486		       95 20		      sta	HMP0,X	;+14 60
   3002  8488
   3003  8488		       ca		      dex
   3004  8489		       b4 9c		      ldy	temp1,X
   3005  848b		       b9 c7 f3 	      lda	repostable-256,Y
   3006  848e		       95 20		      sta	HMP0,X	;+14 74
   3007  8490
   3008  8490		       85 02		      sta	WSYNC
   3009  8492
   3010  8492		       85 2a		      sta	HMOVE	;+3 3
   3011  8494
   3012  8494
   3013  8494				  -	      ifconst	legacy
   3014  8494				  -	      if	legacy < 100
   3015  8494				  -	      ldx	#4
   3016  8494				  -adjustloop2
   3017  8494				  -	      lda	player0x,x
   3018  8494				  -	      clc
   3019  8494				  -	      adc	#14	;?
   3020  8494				  -	      sta	player0x,x
   3021  8494				  -	      dex
   3022  8494				  -	      bpl	adjustloop2
   3023  8494				  -	      endif
   3024  8494					      endif
   3025  8494
   3026  8494
   3027  8494
   3028  8494
   3029  8494							;set score pointers
   3030  8494		       a7 95		      lax	score+2
   3031  8496		       20 c7 f4 	      jsr	scorepointerset
   3032  8499		       84 9b		      sty	scorepointers+5
   3033  849b		       86 98		      stx	scorepointers+2
   3034  849d		       a7 94		      lax	score+1
   3035  849f		       20 c7 f4 	      jsr	scorepointerset
   3036  84a2		       84 9a		      sty	scorepointers+4
   3037  84a4		       86 97		      stx	scorepointers+1
   3038  84a6		       a7 93		      lax	score
   3039  84a8		       20 c7 f4 	      jsr	scorepointerset
   3040  84ab		       84 99		      sty	scorepointers+3
   3041  84ad		       86 96		      stx	scorepointers
   3042  84af
   3043  84af				   vblk
   3044  84af							; run possible vblank bB code
   3045  84af				  -	      ifconst	vblank_bB_code
   3046  84af				  -	      jsr	vblank_bB_code
   3047  84af					      endif
   3048  84af				   vblk2
   3049  84af		       ad 84 02 	      LDA	INTIM
   3050  84b2		       30 fb		      bmi	vblk2
   3051  84b4		       4c 00 f0 	      jmp	kernel
   3052  84b7
   3053  84b7
   3054  84b7		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   3055  84c0		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   3056  84c7				   repostable
   3057  84c7
   3058  84c7				   scorepointerset
   3059  84c7		       29 0f		      and	#$0F
   3060  84c9		       0a		      asl
   3061  84ca		       0a		      asl
   3062  84cb		       0a		      asl
   3063  84cc		       69 74		      adc	#<scoretable
   3064  84ce		       a8		      tay
   3065  84cf		       8a		      txa
   3066  84d0							; and #$F0
   3067  84d0							; lsr
   3068  84d0		       4b f0		      asr	#$F0
   3069  84d2		       69 74		      adc	#<scoretable
   3070  84d4		       aa		      tax
   3071  84d5		       60		      rts
   3072  84d6							;bB.asm
   3073  84d6							; bB.asm file is split here
   3074  84d6				  -	      ifconst	pfres
   3075  84d6				  -	      if	(<*) > (254-pfres*pfwidth)
   3076  84d6				  -	      align	256
   3077  84d6				  -	      endif
   3078  84d6				  -	      if	(<*) < (136-pfres*pfwidth)
   3079  84d6				  -	      repeat	((136-pfres*pfwidth)-(<*))
   3080  84d6				  -	      .byte	0
   3081  84d6				  -	      repend
   3082  84d6				  -	      endif
   3083  84d6					      else
   3084  84d6					      if	(<*) > 206
   3085  8500		       00 00 00 00*	      align	256
   3086  8500					      endif
   3087  8500					      if	(<*) < 88
   3088  8500					      repeat	(88-(<*))
   3089  8500		       00		      .byte.b	0
   3088  8500					      repend
   3089  8501		       00		      .byte.b	0
   3088  8501					      repend
   3089  8502		       00		      .byte.b	0
   3088  8502					      repend
   3089  8503		       00		      .byte.b	0
   3088  8503					      repend
   3089  8504		       00		      .byte.b	0
   3088  8504					      repend
   3089  8505		       00		      .byte.b	0
   3088  8505					      repend
   3089  8506		       00		      .byte.b	0
   3088  8506					      repend
   3089  8507		       00		      .byte.b	0
   3088  8507					      repend
   3089  8508		       00		      .byte.b	0
   3088  8508					      repend
   3089  8509		       00		      .byte.b	0
   3088  8509					      repend
   3089  850a		       00		      .byte.b	0
   3088  850a					      repend
   3089  850b		       00		      .byte.b	0
   3088  850b					      repend
   3089  850c		       00		      .byte.b	0
   3088  850c					      repend
   3089  850d		       00		      .byte.b	0
   3088  850d					      repend
   3089  850e		       00		      .byte.b	0
   3088  850e					      repend
   3089  850f		       00		      .byte.b	0
   3088  850f					      repend
   3089  8510		       00		      .byte.b	0
   3088  8510					      repend
   3089  8511		       00		      .byte.b	0
   3088  8511					      repend
   3089  8512		       00		      .byte.b	0
   3088  8512					      repend
   3089  8513		       00		      .byte.b	0
   3088  8513					      repend
   3089  8514		       00		      .byte.b	0
   3088  8514					      repend
   3089  8515		       00		      .byte.b	0
   3088  8515					      repend
   3089  8516		       00		      .byte.b	0
   3088  8516					      repend
   3089  8517		       00		      .byte.b	0
   3088  8517					      repend
   3089  8518		       00		      .byte.b	0
   3088  8518					      repend
   3089  8519		       00		      .byte.b	0
   3088  8519					      repend
   3089  851a		       00		      .byte.b	0
   3088  851a					      repend
   3089  851b		       00		      .byte.b	0
   3088  851b					      repend
   3089  851c		       00		      .byte.b	0
   3088  851c					      repend
   3089  851d		       00		      .byte.b	0
   3088  851d					      repend
   3089  851e		       00		      .byte.b	0
   3088  851e					      repend
   3089  851f		       00		      .byte.b	0
   3088  851f					      repend
   3089  8520		       00		      .byte.b	0
   3088  8520					      repend
   3089  8521		       00		      .byte.b	0
   3088  8521					      repend
   3089  8522		       00		      .byte.b	0
   3088  8522					      repend
   3089  8523		       00		      .byte.b	0
   3088  8523					      repend
   3089  8524		       00		      .byte.b	0
   3088  8524					      repend
   3089  8525		       00		      .byte.b	0
   3088  8525					      repend
   3089  8526		       00		      .byte.b	0
   3088  8526					      repend
   3089  8527		       00		      .byte.b	0
   3088  8527					      repend
   3089  8528		       00		      .byte.b	0
   3088  8528					      repend
   3089  8529		       00		      .byte.b	0
   3088  8529					      repend
   3089  852a		       00		      .byte.b	0
   3088  852a					      repend
   3089  852b		       00		      .byte.b	0
   3088  852b					      repend
   3089  852c		       00		      .byte.b	0
   3088  852c					      repend
   3089  852d		       00		      .byte.b	0
   3088  852d					      repend
   3089  852e		       00		      .byte.b	0
   3088  852e					      repend
   3089  852f		       00		      .byte.b	0
   3088  852f					      repend
   3089  8530		       00		      .byte.b	0
   3088  8530					      repend
   3089  8531		       00		      .byte.b	0
   3088  8531					      repend
   3089  8532		       00		      .byte.b	0
   3088  8532					      repend
   3089  8533		       00		      .byte.b	0
   3088  8533					      repend
   3089  8534		       00		      .byte.b	0
   3088  8534					      repend
   3089  8535		       00		      .byte.b	0
   3088  8535					      repend
   3089  8536		       00		      .byte.b	0
   3088  8536					      repend
   3089  8537		       00		      .byte.b	0
   3088  8537					      repend
   3089  8538		       00		      .byte.b	0
   3088  8538					      repend
   3089  8539		       00		      .byte.b	0
   3088  8539					      repend
   3089  853a		       00		      .byte.b	0
   3088  853a					      repend
   3089  853b		       00		      .byte.b	0
   3088  853b					      repend
   3089  853c		       00		      .byte.b	0
   3088  853c					      repend
   3089  853d		       00		      .byte.b	0
   3088  853d					      repend
   3089  853e		       00		      .byte.b	0
   3088  853e					      repend
   3089  853f		       00		      .byte.b	0
   3088  853f					      repend
   3089  8540		       00		      .byte.b	0
   3088  8540					      repend
   3089  8541		       00		      .byte.b	0
   3088  8541					      repend
   3089  8542		       00		      .byte.b	0
   3088  8542					      repend
   3089  8543		       00		      .byte.b	0
   3088  8543					      repend
   3089  8544		       00		      .byte.b	0
   3088  8544					      repend
   3089  8545		       00		      .byte.b	0
   3088  8545					      repend
   3089  8546		       00		      .byte.b	0
   3088  8546					      repend
   3089  8547		       00		      .byte.b	0
   3088  8547					      repend
   3089  8548		       00		      .byte.b	0
   3088  8548					      repend
   3089  8549		       00		      .byte.b	0
   3088  8549					      repend
   3089  854a		       00		      .byte.b	0
   3088  854a					      repend
   3089  854b		       00		      .byte.b	0
   3088  854b					      repend
   3089  854c		       00		      .byte.b	0
   3088  854c					      repend
   3089  854d		       00		      .byte.b	0
   3088  854d					      repend
   3089  854e		       00		      .byte.b	0
   3088  854e					      repend
   3089  854f		       00		      .byte.b	0
   3088  854f					      repend
   3089  8550		       00		      .byte.b	0
   3088  8550					      repend
   3089  8551		       00		      .byte.b	0
   3088  8551					      repend
   3089  8552		       00		      .byte.b	0
   3088  8552					      repend
   3089  8553		       00		      .byte.b	0
   3088  8553					      repend
   3089  8554		       00		      .byte.b	0
   3088  8554					      repend
   3089  8555		       00		      .byte.b	0
   3088  8555					      repend
   3089  8556		       00		      .byte.b	0
   3088  8556					      repend
   3089  8557		       00		      .byte.b	0
   3090  8558					      repend
   3091  8558					      endif
   3092  8558					      endif
   3093  8558				   pfcolorlabel13
   3094  8558		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3095  855c		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3096  8560		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3097  8564		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3098  8568		       28 82 00 00	      .byte.b	$28, $82,0,0
   3099  856c		       28 82 00 00	      .byte.b	$28, $82,0,0
   3100  8570		       28 82 00 00	      .byte.b	$28, $82,0,0
   3101  8574		       28 38 00 00	      .byte.b	$28, $38,0,0
   3102  8578		       28 38 00 00	      .byte.b	$28, $38,0,0
   3103  857c		       28 38 00 00	      .byte.b	$28, $38,0,0
   3104  8580		       28 38 00 00	      .byte.b	$28, $38,0,0
   3105  8584				  -	      if	(<*) > (<(*+3))
   3106  8584				  -	      repeat	($100-<*)
   3107  8584				  -	      .byte	0
   3108  8584				  -	      repend
   3109  8584					      endif
   3110  8584				   playerL042_1
   3111  8584		       0a		      .byte.b	%00001010
   3112  8585		       0e		      .byte.b	%00001110
   3113  8586		       33		      .byte.b	%00110011
   3114  8587		       74		      .byte.b	%01110100
   3115  8588				  -	      if	(<*) > (<(*+3))
   3116  8588				  -	      repeat	($100-<*)
   3117  8588				  -	      .byte	0
   3118  8588				  -	      repend
   3119  8588					      endif
   3120  8588				   playerL046_1
   3121  8588		       09		      .byte.b	%00001001
   3122  8589		       0e		      .byte.b	%00001110
   3123  858a		       33		      .byte.b	%00110011
   3124  858b		       74		      .byte.b	%01110100
   3125  858c				  -	      if	(<*) > (<(*+3))
   3126  858c				  -	      repeat	($100-<*)
   3127  858c				  -	      .byte	0
   3128  858c				  -	      repend
   3129  858c					      endif
   3130  858c				   playerL050_1
   3131  858c		       11		      .byte.b	%00010001
   3132  858d		       0e		      .byte.b	%00001110
   3133  858e		       33		      .byte.b	%00110011
   3134  858f		       74		      .byte.b	%01110100
   3135  8590				  -	      if	(<*) > (<(*+3))
   3136  8590				  -	      repeat	($100-<*)
   3137  8590				  -	      .byte	0
   3138  8590				  -	      repend
   3139  8590					      endif
   3140  8590				   playerL054_1
   3141  8590		       12		      .byte.b	%00010010
   3142  8591		       0e		      .byte.b	%00001110
   3143  8592		       33		      .byte.b	%00110011
   3144  8593		       74		      .byte.b	%01110100
   3145  8594				  -	      if	(<*) > (<(*+14))
   3146  8594				  -	      repeat	($100-<*)
   3147  8594				  -	      .byte	0
   3148  8594				  -	      repend
   3149  8594					      endif
   3150  8594				   playerL057_0
   3151  8594		       3c		      .byte.b	%00111100
   3152  8595		       3c		      .byte.b	%00111100
   3153  8596		       3c		      .byte.b	%00111100
   3154  8597		       7e		      .byte.b	%01111110
   3155  8598		       3c		      .byte.b	%00111100
   3156  8599		       3c		      .byte.b	%00111100
   3157  859a		       18		      .byte.b	%00011000
   3158  859b		       00		      .byte.b	%00000000
   3159  859c		       00		      .byte.b	%00000000
   3160  859d		       00		      .byte.b	%00000000
   3161  859e		       00		      .byte.b	%00000000
   3162  859f		       00		      .byte.b	%00000000
   3163  85a0		       00		      .byte.b	%00000000
   3164  85a1		       00		      .byte.b	%00000000
   3165  85a2		       00		      .byte.b	%00000000
   3166  85a3					      if	ECHOFIRST
      2513 bytes of ROM space left in bank 8
   3167  85a3					      echo	"    ",[(scoretable - *)]d , "bytes of ROM space left in bank 8")
   3168  85a3					      endif
   3169  85a3		       00 01	   ECHOFIRST  =	1
   3170  85a3
   3171  85a3
   3172  85a3							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3173  85a3
   3174  85a3							; feel free to modify the score graphics - just keep each digit 8 high
   3175  85a3							; and keep the conditional compilation stuff intact
   3176  85a3				  -	      ifconst	ROM2k
   3177  85a3				  -	      ORG	$F7AC-8
   3178  85a3					      else
   3179  85a3					      ifconst	bankswitch
   3180  85a3				  -	      if	bankswitch == 8
   3181  85a3				  -	      ORG	$2F94-bscode_length
   3182  85a3				  -	      RORG	$FF94-bscode_length
   3183  85a3					      endif
   3184  85a3				  -	      if	bankswitch == 16
   3185  85a3				  -	      ORG	$4F94-bscode_length
   3186  85a3				  -	      RORG	$FF94-bscode_length
   3187  85a3					      endif
   3188  85a3					      if	bankswitch == 32
   3189  8f74					      ORG	$8F94-bscode_length
   3190  8f74					      RORG	$FF94-bscode_length
   3191  8f74					      endif
   3192  8f74				  -	      if	bankswitch == 64
   3193  8f74				  -	      ORG	$10F80-bscode_length
   3194  8f74				  -	      RORG	$1FF80-bscode_length
   3195  8f74					      endif
   3196  8f74				  -	      else
   3197  8f74				  -	      ORG	$FF9C
   3198  8f74					      endif
   3199  8f74					      endif
   3200  8f74
   3201  8f74							; font equates
   3202  8f74		       00 01	   .21stcentury =	1
   3203  8f74		       00 02	   alarmclock =	2
   3204  8f74		       00 03	   handwritten =	3
   3205  8f74		       00 04	   interrupted =	4
   3206  8f74		       00 05	   retroputer =	5
   3207  8f74		       00 06	   whimsey    =	6
   3208  8f74		       00 07	   tiny       =	7
   3209  8f74		       00 08	   hex	      =	8
   3210  8f74
   3211  8f74				  -	      ifconst	font
   3212  8f74				  -	      if	font == hex
   3213  8f74				  -	      ORG	. - 48
   3214  8f74				  -	      endif
   3215  8f74					      endif
   3216  8f74
   3217  8f74				   scoretable
   3218  8f74
   3219  8f74				  -	      ifconst	font
   3220  8f74				  -	      if	font == .21stcentury
   3221  8f74				  -	      include	"score_graphics.asm.21stcentury"
   3222  8f74				  -	      endif
   3223  8f74				  -	      if	font == alarmclock
   3224  8f74				  -	      include	"score_graphics.asm.alarmclock"
   3225  8f74				  -	      endif
   3226  8f74				  -	      if	font == handwritten
   3227  8f74				  -	      include	"score_graphics.asm.handwritten"
   3228  8f74				  -	      endif
   3229  8f74				  -	      if	font == interrupted
   3230  8f74				  -	      include	"score_graphics.asm.interrupted"
   3231  8f74				  -	      endif
   3232  8f74				  -	      if	font == retroputer
   3233  8f74				  -	      include	"score_graphics.asm.retroputer"
   3234  8f74				  -	      endif
   3235  8f74				  -	      if	font == whimsey
   3236  8f74				  -	      include	"score_graphics.asm.whimsey"
   3237  8f74				  -	      endif
   3238  8f74				  -	      if	font == tiny
   3239  8f74				  -	      include	"score_graphics.asm.tiny"
   3240  8f74				  -	      endif
   3241  8f74				  -	      if	font == hex
   3242  8f74				  -	      include	"score_graphics.asm.hex"
   3243  8f74				  -	      endif
   3244  8f74					      else		; default font
   3245  8f74
   3246  8f74		       3c		      .byte.b	%00111100
   3247  8f75		       66		      .byte.b	%01100110
   3248  8f76		       66		      .byte.b	%01100110
   3249  8f77		       66		      .byte.b	%01100110
   3250  8f78		       66		      .byte.b	%01100110
   3251  8f79		       66		      .byte.b	%01100110
   3252  8f7a		       66		      .byte.b	%01100110
   3253  8f7b		       3c		      .byte.b	%00111100
   3254  8f7c
   3255  8f7c		       7e		      .byte.b	%01111110
   3256  8f7d		       18		      .byte.b	%00011000
   3257  8f7e		       18		      .byte.b	%00011000
   3258  8f7f		       18		      .byte.b	%00011000
   3259  8f80		       18		      .byte.b	%00011000
   3260  8f81		       38		      .byte.b	%00111000
   3261  8f82		       18		      .byte.b	%00011000
   3262  8f83		       08		      .byte.b	%00001000
   3263  8f84
   3264  8f84		       7e		      .byte.b	%01111110
   3265  8f85		       60		      .byte.b	%01100000
   3266  8f86		       60		      .byte.b	%01100000
   3267  8f87		       3c		      .byte.b	%00111100
   3268  8f88		       06		      .byte.b	%00000110
   3269  8f89		       06		      .byte.b	%00000110
   3270  8f8a		       46		      .byte.b	%01000110
   3271  8f8b		       3c		      .byte.b	%00111100
   3272  8f8c
   3273  8f8c		       3c		      .byte.b	%00111100
   3274  8f8d		       46		      .byte.b	%01000110
   3275  8f8e		       06		      .byte.b	%00000110
   3276  8f8f		       06		      .byte.b	%00000110
   3277  8f90		       1c		      .byte.b	%00011100
   3278  8f91		       06		      .byte.b	%00000110
   3279  8f92		       46		      .byte.b	%01000110
   3280  8f93		       3c		      .byte.b	%00111100
   3281  8f94
   3282  8f94		       0c		      .byte.b	%00001100
   3283  8f95		       0c		      .byte.b	%00001100
   3284  8f96		       7e		      .byte.b	%01111110
   3285  8f97		       4c		      .byte.b	%01001100
   3286  8f98		       4c		      .byte.b	%01001100
   3287  8f99		       2c		      .byte.b	%00101100
   3288  8f9a		       1c		      .byte.b	%00011100
   3289  8f9b		       0c		      .byte.b	%00001100
   3290  8f9c
   3291  8f9c		       3c		      .byte.b	%00111100
   3292  8f9d		       46		      .byte.b	%01000110
   3293  8f9e		       06		      .byte.b	%00000110
   3294  8f9f		       06		      .byte.b	%00000110
   3295  8fa0		       3c		      .byte.b	%00111100
   3296  8fa1		       60		      .byte.b	%01100000
   3297  8fa2		       60		      .byte.b	%01100000
   3298  8fa3		       7e		      .byte.b	%01111110
   3299  8fa4
   3300  8fa4		       3c		      .byte.b	%00111100
   3301  8fa5		       66		      .byte.b	%01100110
   3302  8fa6		       66		      .byte.b	%01100110
   3303  8fa7		       66		      .byte.b	%01100110
   3304  8fa8		       7c		      .byte.b	%01111100
   3305  8fa9		       60		      .byte.b	%01100000
   3306  8faa		       62		      .byte.b	%01100010
   3307  8fab		       3c		      .byte.b	%00111100
   3308  8fac
   3309  8fac		       30		      .byte.b	%00110000
   3310  8fad		       30		      .byte.b	%00110000
   3311  8fae		       30		      .byte.b	%00110000
   3312  8faf		       18		      .byte.b	%00011000
   3313  8fb0		       0c		      .byte.b	%00001100
   3314  8fb1		       06		      .byte.b	%00000110
   3315  8fb2		       42		      .byte.b	%01000010
   3316  8fb3		       3e		      .byte.b	%00111110
   3317  8fb4
   3318  8fb4		       3c		      .byte.b	%00111100
   3319  8fb5		       66		      .byte.b	%01100110
   3320  8fb6		       66		      .byte.b	%01100110
   3321  8fb7		       66		      .byte.b	%01100110
   3322  8fb8		       3c		      .byte.b	%00111100
   3323  8fb9		       66		      .byte.b	%01100110
   3324  8fba		       66		      .byte.b	%01100110
   3325  8fbb		       3c		      .byte.b	%00111100
   3326  8fbc
   3327  8fbc		       3c		      .byte.b	%00111100
   3328  8fbd		       46		      .byte.b	%01000110
   3329  8fbe		       06		      .byte.b	%00000110
   3330  8fbf		       3e		      .byte.b	%00111110
   3331  8fc0		       66		      .byte.b	%01100110
   3332  8fc1		       66		      .byte.b	%01100110
   3333  8fc2		       66		      .byte.b	%01100110
   3334  8fc3		       3c		      .byte.b	%00111100
   3335  8fc4
   3336  8fc4					      ifnconst	DPC_kernel_options
   3337  8fc4
   3338  8fc4		       00		      .byte.b	%00000000
   3339  8fc5		       00		      .byte.b	%00000000
   3340  8fc6		       00		      .byte.b	%00000000
   3341  8fc7		       00		      .byte.b	%00000000
   3342  8fc8		       00		      .byte.b	%00000000
   3343  8fc9		       00		      .byte.b	%00000000
   3344  8fca		       00		      .byte.b	%00000000
   3345  8fcb		       00		      .byte.b	%00000000
   3346  8fcc
   3347  8fcc					      endif
   3348  8fcc
   3349  8fcc					      endif
   3350  8fcc
   3351  8fcc				  -	      ifconst	ROM2k
   3352  8fcc				  -	      ORG	$F7FC
   3353  8fcc					      else
   3354  8fcc					      ifconst	bankswitch
   3355  8fcc				  -	      if	bankswitch == 8
   3356  8fcc				  -	      ORG	$2FF4-bscode_length
   3357  8fcc				  -	      RORG	$FFF4-bscode_length
   3358  8fcc					      endif
   3359  8fcc				  -	      if	bankswitch == 16
   3360  8fcc				  -	      ORG	$4FF4-bscode_length
   3361  8fcc				  -	      RORG	$FFF4-bscode_length
   3362  8fcc					      endif
   3363  8fcc					      if	bankswitch == 32
   3364  8fd4					      ORG	$8FF4-bscode_length
   3365  8fd4					      RORG	$FFF4-bscode_length
   3366  8fd4					      endif
   3367  8fd4				  -	      if	bankswitch == 64
   3368  8fd4				  -	      ORG	$10FE0-bscode_length
   3369  8fd4				  -	      RORG	$1FFE0-bscode_length
   3370  8fd4					      endif
   3371  8fd4				  -	      else
   3372  8fd4				  -	      ORG	$FFFC
   3373  8fd4					      endif
   3374  8fd4					      endif
   3375  8fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3376  8fd4
   3377  8fd4							; every bank has this stuff at the same place
   3378  8fd4							; this code can switch to/from any bank at any entry point
   3379  8fd4							; and can preserve register values
   3380  8fd4							; note: lines not starting with a space are not placed in all banks
   3381  8fd4							;
   3382  8fd4							; line below tells the compiler how long this is - do not remove
   3383  8fd4							;size=32
   3384  8fd4
   3385  8fd4				   begin_bscode
   3386  8fd4		       a2 ff		      ldx	#$ff
   3387  8fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3388  8fd6				  -	      stx	FASTFETCH
   3389  8fd6					      endif
   3390  8fd6		       9a		      txs
   3391  8fd7				  -	      if	bankswitch == 64
   3392  8fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3393  8fd7					      else
   3394  8fd7		       a9 f2		      lda	#>(start-1)
   3395  8fd9					      endif
   3396  8fd9		       48		      pha
   3397  8fda		       a9 4f		      lda	#<(start-1)
   3398  8fdc		       48		      pha
   3399  8fdd
   3400  8fdd				   BS_return
   3401  8fdd		       48		      pha
   3402  8fde		       8a		      txa
   3403  8fdf		       48		      pha
   3404  8fe0		       ba		      tsx
   3405  8fe1
   3406  8fe1					      if	bankswitch != 64
   3407  8fe1		       b5 04		      lda	4,x	; get high byte of return address
   3408  8fe3
   3409  8fe3		       2a		      rol
   3410  8fe4		       2a		      rol
   3411  8fe5		       2a		      rol
   3412  8fe6		       2a		      rol
   3413  8fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3414  8fe9		       aa		      tax
   3415  8fea		       e8		      inx
   3416  8feb				  -	      else
   3417  8feb				  -	      lda	4,x	; get high byte of return address
   3418  8feb				  -	      tay
   3419  8feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3420  8feb				  -	      sta	4,x
   3421  8feb				  -	      tya
   3422  8feb				  -	      lsr
   3423  8feb				  -	      lsr
   3424  8feb				  -	      lsr
   3425  8feb				  -	      lsr
   3426  8feb				  -	      tax
   3427  8feb				  -	      inx
   3428  8feb					      endif
   3429  8feb
   3430  8feb				   BS_jsr
   3431  8feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   3432  8fee		       68		      pla
   3433  8fef		       aa		      tax
   3434  8ff0		       68		      pla
   3435  8ff1		       60		      rts
   3436  8ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3437  8ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3438  8ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3439  8ff2					      endif
   3440  8ff2							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3441  8ff2
   3442  8ff2					      ifconst	bankswitch
   3443  8ff2				  -	      if	bankswitch == 8
   3444  8ff2				  -	      ORG	$2FFC
   3445  8ff2				  -	      RORG	$FFFC
   3446  8ff2					      endif
   3447  8ff2				  -	      if	bankswitch == 16
   3448  8ff2				  -	      ORG	$4FFC
   3449  8ff2				  -	      RORG	$FFFC
   3450  8ff2					      endif
   3451  8ff2					      if	bankswitch == 32
   3452  8ffc					      ORG	$8FFC
   3453  8ffc					      RORG	$FFFC
   3454  8ffc					      endif
   3455  8ffc				  -	      if	bankswitch == 64
   3456  8ffc				  -	      ORG	$10FF0
   3457  8ffc				  -	      RORG	$1FFF0
   3458  8ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3459  8ffc				  -	      ORG	$10FF8
   3460  8ffc				  -	      RORG	$1FFF8
   3461  8ffc				  -	      ifconst	superchip
   3462  8ffc				  -	      .byte	"E","F","S","C"
   3463  8ffc				  -	      else
   3464  8ffc				  -	      .byte	"E","F","E","F"
   3465  8ffc				  -	      endif
   3466  8ffc				  -	      ORG	$10FFC
   3467  8ffc				  -	      RORG	$1FFFC
   3468  8ffc					      endif
   3469  8ffc				  -	      else
   3470  8ffc				  -	      ifconst	ROM2k
   3471  8ffc				  -	      ORG	$F7FC
   3472  8ffc				  -	      else
   3473  8ffc				  -	      ORG	$FFFC
   3474  8ffc				  -	      endif
   3475  8ffc					      endif
   3476  8ffc		       50 f2		      .word.w	(start & $ffff)
   3477  8ffe		       50 f2		      .word.w	(start & $ffff)
