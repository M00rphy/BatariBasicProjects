------- FILE C:\Users\Lex de Fadrique\Documents\VisualbB\projects\roomofdoom\tehroomofdoom.bas.asm LEVEL 1 PASS 2
      1  8ffe					      processor	6502
------- FILE vcs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; VCS.H
      2  9000 ????						; Version 1.05, 13/November/2003
      3  9000 ????
      4  9000 ????	       00 69	   VERSION_VCS =	105
      5  9000 ????
      6  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  9000 ????						;
     10  9000 ????						; This file defines hardware registers and memory mapping for the
     11  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  9000 ????						; available at at http://www.atari2600.org/dasm
     14  9000 ????						;
     15  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  9000 ????						; with your views.  Please contribute, if you think you can improve this
     19  9000 ????						; file!
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify VCS.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  9000 ????						;			 mirrored reading/writing differences.	This is more a
     29  9000 ????						;			 readability issue, and binary compatibility with disassembled
     30  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  9000 ????						;			 which was broken by the use of segments in this file, as
     33  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  9000 ????						;						   it is safe to leave it undefined, and the base address will
     38  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  9000 ????						;			  - register definitions are now generated through assignment
     41  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  9000 ????						;			    address architecture.
     43  9000 ????						; 1.0	22/MAR/2003		Initial release
     44  9000 ????
     45  9000 ????
     46  9000 ????						;-------------------------------------------------------------------------------
     47  9000 ????
     48  9000 ????						; TIA_BASE_ADDRESS
     49  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  9000 ????						; Normally 0, the base address should (externally, before including this file)
     51  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  9000 ????						; < $40 as a bankswitch.
     54  9000 ????
     55  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  9000 ????			  -TIA_BASE_ADDRESS =	0
     57  9000 ????				      ENDIF
     58  9000 ????
     59  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  9000 ????						; *OR* by declaring the label before including this file, eg:
     62  9000 ????						; TIA_BASE_ADDRESS = $40
     63  9000 ????						;   include "vcs.h"
     64  9000 ????
     65  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  9000 ????						; for the mirrored ROM hardware registers.
     68  9000 ????
     69  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  9000 ????
     73  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  9000 ????				      ENDIF
     76  9000 ????
     77  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  9000 ????				      ENDIF
     80  9000 ????
     81  9000 ????						;-------------------------------------------------------------------------------
     82  9000 ????
     83 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e ????				      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298 ????				      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  9000 ????				      SEG
    199  9000 ????
    200  9000 ????						; EOF
------- FILE C:\Users\Lex de Fadrique\Documents\VisualbB\projects\roomofdoom\tehroomofdoom.bas.asm
------- FILE macro.h LEVEL 2 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; MACRO.H
      2  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      3  9000 ????
      4  9000 ????	       00 69	   VERSION_MACRO =	105
      5  9000 ????
      6  9000 ????						;
      7  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  9000 ????						;
     10  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  9000 ????						; It is distributed as a companion machine-specific support package
     12  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  9000 ????						; available at at http://www.atari2600.org/dasm
     14  9000 ????						;
     15  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  9000 ????						; contents, or would like to add something, please write to me
     17  9000 ????						; (atari2600@taswegian.com) with your contribution.
     18  9000 ????						;
     19  9000 ????						; Latest Revisions...
     20  9000 ????						;
     21  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     22  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     23  9000 ????						;			    used for code assembly.
     24  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     25  9000 ????						;
     26  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     27  9000 ????						;
     28  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     29  9000 ????						;			   (standardised macro for vertical synch code)
     30  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     31  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     32  9000 ????						; 1.0	22/MAR/2003		Initial release
     33  9000 ????
     34  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     35  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     36  9000 ????						;   If you do not allow illegal opcode usage, you must include this file
     37  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     38  9000 ????						;   registers and require them to be defined first).
     39  9000 ????
     40  9000 ????						; Available macros...
     41  9000 ????						;   SLEEP n		 - sleep for n cycles
     42  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     43  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     44  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     45  9000 ????
     46  9000 ????						;-------------------------------------------------------------------------------
     47  9000 ????						; SLEEP duration
     48  9000 ????						; Original author: Thomas Jentzsch
     49  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     50  9000 ????						; useful for code where precise timing is required.
     51  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     52  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     53  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     54  9000 ????
     55  9000 ????				      MAC	sleep
     56  9000 ????			   .CYCLES    SET	{1}
     57  9000 ????
     58  9000 ????				      IF	.CYCLES < 2
     59  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     60  9000 ????				      ERR
     61  9000 ????				      ENDIF
     62  9000 ????
     63  9000 ????				      IF	.CYCLES & 1
     64  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     65  9000 ????				      nop	0
     66  9000 ????				      ELSE
     67  9000 ????				      bit	VSYNC
     68  9000 ????				      ENDIF
     69  9000 ????			   .CYCLES    SET	.CYCLES - 3
     70  9000 ????				      ENDIF
     71  9000 ????
     72  9000 ????				      REPEAT	.CYCLES / 2
     73  9000 ????				      nop
     74  9000 ????				      REPEND
     75  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     76  9000 ????
     77  9000 ????						;-------------------------------------------------------------------------------
     78  9000 ????						; VERTICAL_SYNC
     79  9000 ????						; Original author: Manuel Polik
     80  9000 ????						; Inserts the code required for a proper 3 scannline
     81  9000 ????						; vertical sync sequence
     82  9000 ????						;
     83  9000 ????						; Note: Alters the accumulator
     84  9000 ????						;
     85  9000 ????						; IN:
     86  9000 ????						; OUT: A = 1
     87  9000 ????
     88  9000 ????				      MAC	vertical_sync
     89  9000 ????				      LDA	#$02	; A = VSYNC enable
     90  9000 ????				      STA	WSYNC	; Finish current line
     91  9000 ????				      STA	VSYNC	; Start vertical sync
     92  9000 ????				      STA	WSYNC	; 1st line vertical sync
     93  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     94  9000 ????				      LSR		; A = VSYNC disable
     95  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     96  9000 ????				      STA	VSYNC	; Stop vertical sync
     97  9000 ????				      ENDM
     98  9000 ????
     99  9000 ????						;-------------------------------------------------------------------------------
    100  9000 ????						; CLEAN_START
    101  9000 ????						; Original author: Andrew Davie
    102  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    103  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    104  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    105  9000 ????						; Use as very first section of code on boot (ie: at reset)
    106  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    107  9000 ????
    108  9000 ????				      MAC	clean_start
    109  9000 ????				      sei
    110  9000 ????				      cld
    111  9000 ????
    112  9000 ????				      ldx	#0
    113  9000 ????				      txa
    114  9000 ????				      tay
    115  9000 ????			   .CLEAR_STACK dex
    116  9000 ????				      txs
    117  9000 ????				      pha
    118  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    119  9000 ????
    120  9000 ????				      ENDM
    121  9000 ????
    122  9000 ????						;-------------------------------------------------------
    123  9000 ????						; SET_POINTER
    124  9000 ????						; Original author: Manuel Rotschkar
    125  9000 ????						;
    126  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    127  9000 ????						;
    128  9000 ????						; Usage: SET_POINTER pointer, address
    129  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    130  9000 ????						;
    131  9000 ????						; Note: Alters the accumulator, NZ flags
    132  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    133  9000 ????						; IN 2: absolute address
    134  9000 ????
    135  9000 ????				      MAC	set_pointer
    136  9000 ????			   .POINTER   SET	{1}
    137  9000 ????			   .ADDRESS   SET	{2}
    138  9000 ????
    139  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    140  9000 ????				      STA	.POINTER	; Store in pointer
    141  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    142  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    143  9000 ????
    144  9000 ????				      ENDM
    145  9000 ????
    146  9000 ????						; EOF
------- FILE C:\Users\Lex de Fadrique\Documents\VisualbB\projects\roomofdoom\tehroomofdoom.bas.asm
------- FILE 2600basic.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic.h"
      1  9000 ????				      processor	6502
------- FILE vcs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"vcs.h"
      1  9000 ????						; VCS.H
      2  9000 ????						; Version 1.05, 13/November/2003
      3  9000 ????
      4  9000 ????	       00 69	   VERSION_VCS =	105
      5  9000 ????
      6  9000 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      7  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
      9  9000 ????						;
     10  9000 ????						; This file defines hardware registers and memory mapping for the
     11  9000 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     12  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  9000 ????						; available at at http://www.atari2600.org/dasm
     14  9000 ????						;
     15  9000 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     16  9000 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     17  9000 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     18  9000 ????						; with your views.  Please contribute, if you think you can improve this
     19  9000 ????						; file!
     20  9000 ????						;
     21  9000 ????						; Latest Revisions...
     22  9000 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     23  9000 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     24  9000 ????						;			    This will allow conditional code to verify VCS.H being
     25  9000 ????						;			    used for code assembly.
     26  9000 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     27  9000 ????						;			 convenient disassembly/reassembly compatibility for hardware
     28  9000 ????						;			 mirrored reading/writing differences.	This is more a
     29  9000 ????						;			 readability issue, and binary compatibility with disassembled
     30  9000 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     31  9000 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     32  9000 ????						;			 which was broken by the use of segments in this file, as
     33  9000 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     34  9000 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     35  9000 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     36  9000 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     37  9000 ????						;						   it is safe to leave it undefined, and the base address will
     38  9000 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     39  9000 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     40  9000 ????						;			  - register definitions are now generated through assignment
     41  9000 ????						;			    in uninitialised segments.	This allows a changeable base
     42  9000 ????						;			    address architecture.
     43  9000 ????						; 1.0	22/MAR/2003		Initial release
     44  9000 ????
     45  9000 ????
     46  9000 ????						;-------------------------------------------------------------------------------
     47  9000 ????
     48  9000 ????						; TIA_BASE_ADDRESS
     49  9000 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     50  9000 ????						; Normally 0, the base address should (externally, before including this file)
     51  9000 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     52  9000 ????						; The reason is that this bankswitching scheme treats any access to locations
     53  9000 ????						; < $40 as a bankswitch.
     54  9000 ????
     55  9000 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     56  9000 ????			  -TIA_BASE_ADDRESS =	0
     57  9000 ????				      ENDIF
     58  9000 ????
     59  9000 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     60  9000 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     61  9000 ????						; *OR* by declaring the label before including this file, eg:
     62  9000 ????						; TIA_BASE_ADDRESS = $40
     63  9000 ????						;   include "vcs.h"
     64  9000 ????
     65  9000 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     66  9000 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     67  9000 ????						; for the mirrored ROM hardware registers.
     68  9000 ????
     69  9000 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     70  9000 ????						; using the -D command-line switch, as required.  If the addresses are not defined,
     71  9000 ????						; they defaut to the TIA_BASE_ADDRESS.
     72  9000 ????
     73  9000 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     74  9000 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     75  9000 ????				      ENDIF
     76  9000 ????
     77  9000 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     78  9000 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     79  9000 ????				      ENDIF
     80  9000 ????
     81  9000 ????						;-------------------------------------------------------------------------------
     82  9000 ????
     83 U002d					      SEG.U	TIA_REGISTERS_WRITE
     84 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     85 U0000
     86 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     87 U0000
     88 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     89 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     90 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     91 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     92 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     93 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     94 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     95 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     96 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     97 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
     98 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
     99 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    100 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    101 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    102 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    103 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    104 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    105 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    106 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    107 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    108 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    109 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    110 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    111 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    112 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    113 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    114 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    115 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    116 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    117 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    118 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    119 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    120 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    121 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    122 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    123 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    124 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    125 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    126 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    127 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    128 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    129 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    130 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    131 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    132 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    133 U002d
    134 U002d							;-------------------------------------------------------------------------------
    135 U002d
    136 U000e					      SEG.U	TIA_REGISTERS_READ
    137 U0000					      ORG	TIA_BASE_READ_ADDRESS
    138 U0000
    139 U0000							;											bit 7	 bit 6
    140 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    141 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    142 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    143 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    144 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    145 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    146 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    147 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    148 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    149 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    150 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    151 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    152 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    153 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    154 U000e
    155 U000e							;-------------------------------------------------------------------------------
    156 U000e
    157 U0298					      SEG.U	RIOT
    158 U0280					      ORG	$280
    159 U0280
    160 U0280							; RIOT MEMORY MAP
    161 U0280
    162 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    163 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    164 U0281
    165 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    166 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    167 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    168 U0284		       00	   INTIM      ds	1	; $284		Timer output
    169 U0285
    170 U0285		       00	   TIMINT     ds	1	; $285
    171 U0286
    172 U0286							; Unused/undefined registers ($285-$294)
    173 U0286
    174 U0286		       00		      ds	1	; $286
    175 U0287		       00		      ds	1	; $287
    176 U0288		       00		      ds	1	; $288
    177 U0289		       00		      ds	1	; $289
    178 U028a		       00		      ds	1	; $28A
    179 U028b		       00		      ds	1	; $28B
    180 U028c		       00		      ds	1	; $28C
    181 U028d		       00		      ds	1	; $28D
    182 U028e		       00		      ds	1	; $28E
    183 U028f		       00		      ds	1	; $28F
    184 U0290		       00		      ds	1	; $290
    185 U0291		       00		      ds	1	; $291
    186 U0292		       00		      ds	1	; $292
    187 U0293		       00		      ds	1	; $293
    188 U0294
    189 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    190 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    191 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    192 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    193 U0298
    194 U0298							;-------------------------------------------------------------------------------
    195 U0298							; The following required for back-compatibility with code which does not use
    196 U0298							; segments.
    197 U0298
    198  9000 ????				      SEG
    199  9000 ????
    200  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE macro.h LEVEL 3 PASS 2
      0  9000 ????				      include	"macro.h"
      1  9000 ????						; MACRO.H
      2  9000 ????						; Version 1.05, 13/NOVEMBER/2003
      3  9000 ????
      4  9000 ????	       00 69	   VERSION_MACRO =	105
      5  9000 ????
      6  9000 ????						;
      7  9000 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
      8  9000 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
      9  9000 ????						;
     10  9000 ????						; This file defines DASM macros useful for development for the Atari 2600.
     11  9000 ????						; It is distributed as a companion machine-specific support package
     12  9000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     13  9000 ????						; available at at http://www.atari2600.org/dasm
     14  9000 ????						;
     15  9000 ????						; Many thanks to the people who have contributed.  If you take issue with the
     16  9000 ????						; contents, or would like to add something, please write to me
     17  9000 ????						; (atari2600@taswegian.com) with your contribution.
     18  9000 ????						;
     19  9000 ????						; Latest Revisions...
     20  9000 ????						;
     21  9000 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     22  9000 ????						;			    This will allow conditional code to verify MACRO.H being
     23  9000 ????						;			    used for code assembly.
     24  9000 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     25  9000 ????						;
     26  9000 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     27  9000 ????						;
     28  9000 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     29  9000 ????						;			   (standardised macro for vertical synch code)
     30  9000 ????						; 1.01  22/MAR/2003	 - SLEEP macro added.
     31  9000 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     32  9000 ????						; 1.0	22/MAR/2003		Initial release
     33  9000 ????
     34  9000 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage,
     35  9000 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     36  9000 ????						;   If you do not allow illegal opcode usage, you must include this file
     37  9000 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     38  9000 ????						;   registers and require them to be defined first).
     39  9000 ????
     40  9000 ????						; Available macros...
     41  9000 ????						;   SLEEP n		 - sleep for n cycles
     42  9000 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     43  9000 ????						;   CLEAN_START	 - set machine to known state on startup
     44  9000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     45  9000 ????
     46  9000 ????						;-------------------------------------------------------------------------------
     47  9000 ????						; SLEEP duration
     48  9000 ????						; Original author: Thomas Jentzsch
     49  9000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     50  9000 ????						; useful for code where precise timing is required.
     51  9000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     52  9000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     53  9000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     54  9000 ????
     55  9000 ????				      MAC	sleep
     56  9000 ????			   .CYCLES    SET	{1}
     57  9000 ????
     58  9000 ????				      IF	.CYCLES < 2
     59  9000 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     60  9000 ????				      ERR
     61  9000 ????				      ENDIF
     62  9000 ????
     63  9000 ????				      IF	.CYCLES & 1
     64  9000 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     65  9000 ????				      nop	0
     66  9000 ????				      ELSE
     67  9000 ????				      bit	VSYNC
     68  9000 ????				      ENDIF
     69  9000 ????			   .CYCLES    SET	.CYCLES - 3
     70  9000 ????				      ENDIF
     71  9000 ????
     72  9000 ????				      REPEAT	.CYCLES / 2
     73  9000 ????				      nop
     74  9000 ????				      REPEND
     75  9000 ????				      ENDM		;usage: SLEEP n (n>1)
     76  9000 ????
     77  9000 ????						;-------------------------------------------------------------------------------
     78  9000 ????						; VERTICAL_SYNC
     79  9000 ????						; Original author: Manuel Polik
     80  9000 ????						; Inserts the code required for a proper 3 scannline
     81  9000 ????						; vertical sync sequence
     82  9000 ????						;
     83  9000 ????						; Note: Alters the accumulator
     84  9000 ????						;
     85  9000 ????						; IN:
     86  9000 ????						; OUT: A = 1
     87  9000 ????
     88  9000 ????				      MAC	vertical_sync
     89  9000 ????				      LDA	#$02	; A = VSYNC enable
     90  9000 ????				      STA	WSYNC	; Finish current line
     91  9000 ????				      STA	VSYNC	; Start vertical sync
     92  9000 ????				      STA	WSYNC	; 1st line vertical sync
     93  9000 ????				      STA	WSYNC	; 2nd line vertical sync
     94  9000 ????				      LSR		; A = VSYNC disable
     95  9000 ????				      STA	WSYNC	; 3rd line vertical sync
     96  9000 ????				      STA	VSYNC	; Stop vertical sync
     97  9000 ????				      ENDM
     98  9000 ????
     99  9000 ????						;-------------------------------------------------------------------------------
    100  9000 ????						; CLEAN_START
    101  9000 ????						; Original author: Andrew Davie
    102  9000 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    103  9000 ????						; Sets stack pointer to $FF, and all registers to 0
    104  9000 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    105  9000 ????						; Use as very first section of code on boot (ie: at reset)
    106  9000 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    107  9000 ????
    108  9000 ????				      MAC	clean_start
    109  9000 ????				      sei
    110  9000 ????				      cld
    111  9000 ????
    112  9000 ????				      ldx	#0
    113  9000 ????				      txa
    114  9000 ????				      tay
    115  9000 ????			   .CLEAR_STACK dex
    116  9000 ????				      txs
    117  9000 ????				      pha
    118  9000 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    119  9000 ????
    120  9000 ????				      ENDM
    121  9000 ????
    122  9000 ????						;-------------------------------------------------------
    123  9000 ????						; SET_POINTER
    124  9000 ????						; Original author: Manuel Rotschkar
    125  9000 ????						;
    126  9000 ????						; Sets a 2 byte RAM pointer to an absolute address.
    127  9000 ????						;
    128  9000 ????						; Usage: SET_POINTER pointer, address
    129  9000 ????						; Example: SET_POINTER SpritePTR, SpriteData
    130  9000 ????						;
    131  9000 ????						; Note: Alters the accumulator, NZ flags
    132  9000 ????						; IN 1: 2 byte RAM location reserved for pointer
    133  9000 ????						; IN 2: absolute address
    134  9000 ????
    135  9000 ????				      MAC	set_pointer
    136  9000 ????			   .POINTER   SET	{1}
    137  9000 ????			   .ADDRESS   SET	{2}
    138  9000 ????
    139  9000 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    140  9000 ????				      STA	.POINTER	; Store in pointer
    141  9000 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    142  9000 ????				      STA	.POINTER+1	; Store in pointer+1
    143  9000 ????
    144  9000 ????				      ENDM
    145  9000 ????
    146  9000 ????						; EOF
------- FILE 2600basic.h
------- FILE 2600basic_variable_redefs.h LEVEL 3 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 07	   bs_mask    =	7
      5  9000 ????	       00 20	   bankswitch =	32
      6  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
      7  9000 ????	       00 01	   PFcolors   =	1
      8  9000 ????	       00 01	   no_blank_lines =	1
      9  9000 ????	       00 01	   player1colors =	1
     10  9000 ????	       00 2b	   vblank_time =	43
     11  9000 ????	       00 25	   overscan_time =	37
------- FILE 2600basic.h
      5  9000 ????
      6  9000 ????	       00 80	   player0x   =	$80
      7  9000 ????	       00 81	   player1x   =	$81
      8  9000 ????	       00 82	   missile0x  =	$82
      9  9000 ????	       00 83	   missile1x  =	$83
     10  9000 ????	       00 84	   ballx      =	$84
     11  9000 ????
     12  9000 ????	       00 85	   objecty    =	$85
     13  9000 ????	       00 85	   player0y   =	$85
     14  9000 ????	       00 86	   player1y   =	$86
     15  9000 ????	       00 87	   missile1height =	$87
     16  9000 ????	       00 88	   missile1y  =	$88
     17  9000 ????	       00 89	   bally      =	$89
     18  9000 ????
     19  9000 ????	       00 87	   player1color =	$87	; replaces missile 1
     20  9000 ????
     21  9000 ????	       00 8a	   player0pointer =	$8A	;uses $8A-$8B
     22  9000 ????	       00 8a	   player0pointerlo =	$8A
     23  9000 ????	       00 8b	   player0pointerhi =	$8B
     24  9000 ????	       00 8c	   player1pointer =	$8C	; $8C-$8D
     25  9000 ????	       00 8c	   player1pointerlo =	$8C
     26  9000 ????	       00 8d	   player1pointerhi =	$8D
     27  9000 ????
     28  9000 ????	       00 8e	   player0height =	$8E
     29  9000 ????	       00 8f	   player1height =	$8F
     30  9000 ????	       00 90	   missile0height =	$90
     31  9000 ????	       00 91	   missile0y  =	$91
     32  9000 ????	       00 92	   ballheight =	$92
     33  9000 ????
     34  9000 ????	       00 90	   currentpaddle =	$90	; replaces missile 0 (and can't be used with playercolor)
     35  9000 ????	       00 91	   paddle     =	$91	; replaces missile 0
     36  9000 ????	       00 82	   player0colorstore =	$82	; replaces missile 0
     37  9000 ????	       00 90	   player0color =	$90	; replaces missile 0
     38  9000 ????
     39  9000 ????	       00 93	   score      =	$93	; $93-$95
     40  9000 ????	       00 96	   scorepointers =	$96	; $96-$9B = 6 bytes
     41  9000 ????	       00 9c	   temp1      =	$9C	;used by kernel.  can be used in program too, but
     42  9000 ????	       00 9d	   temp2      =	$9D	;are obliterated when drawscreen is called.
     43  9000 ????	       00 9e	   temp3      =	$9E
     44  9000 ????	       00 9f	   temp4      =	$9F
     45  9000 ????	       00 a0	   temp5      =	$A0
     46  9000 ????	       00 a1	   temp6      =	$A1
     47  9000 ????
     48  9000 ????	       00 a2	   rand       =	$A2
     49  9000 ????	       00 a3	   scorecolor =	$A3
     50  9000 ????
     51  9000 ????	       00 a4	   var0       =	$A4
     52  9000 ????	       00 a5	   var1       =	$A5
     53  9000 ????	       00 a6	   var2       =	$A6
     54  9000 ????	       00 a7	   var3       =	$A7
     55  9000 ????	       00 a8	   var4       =	$A8
     56  9000 ????	       00 a9	   var5       =	$A9
     57  9000 ????	       00 aa	   var6       =	$AA
     58  9000 ????	       00 ab	   var7       =	$AB
     59  9000 ????	       00 ac	   var8       =	$AC
     60  9000 ????	       00 ad	   var9       =	$AD
     61  9000 ????	       00 ae	   var10      =	$AE
     62  9000 ????	       00 af	   var11      =	$AF
     63  9000 ????	       00 b0	   var12      =	$B0
     64  9000 ????	       00 b1	   var13      =	$B1
     65  9000 ????	       00 b2	   var14      =	$B2
     66  9000 ????	       00 b3	   var15      =	$B3
     67  9000 ????	       00 b4	   var16      =	$B4
     68  9000 ????	       00 b5	   var17      =	$B5
     69  9000 ????	       00 b6	   var18      =	$B6
     70  9000 ????	       00 b7	   var19      =	$B7
     71  9000 ????	       00 b8	   var20      =	$B8
     72  9000 ????	       00 b9	   var21      =	$B9
     73  9000 ????	       00 ba	   var22      =	$BA
     74  9000 ????	       00 bb	   var23      =	$BB
     75  9000 ????	       00 bc	   var24      =	$BC
     76  9000 ????	       00 bd	   var25      =	$BD
     77  9000 ????	       00 be	   var26      =	$BE
     78  9000 ????	       00 bf	   var27      =	$BF
     79  9000 ????	       00 c0	   var28      =	$C0
     80  9000 ????	       00 c1	   var29      =	$C1
     81  9000 ????	       00 c2	   var30      =	$C2
     82  9000 ????	       00 c3	   var31      =	$C3
     83  9000 ????	       00 c4	   var32      =	$C4
     84  9000 ????	       00 c5	   var33      =	$C5
     85  9000 ????	       00 c6	   var34      =	$C6
     86  9000 ????	       00 c7	   var35      =	$C7
     87  9000 ????	       00 c8	   var36      =	$C8
     88  9000 ????	       00 c9	   var37      =	$C9
     89  9000 ????	       00 ca	   var38      =	$CA
     90  9000 ????	       00 cb	   var39      =	$CB
     91  9000 ????	       00 cc	   var40      =	$CC
     92  9000 ????	       00 cd	   var41      =	$CD
     93  9000 ????	       00 ce	   var42      =	$CE
     94  9000 ????	       00 cf	   var43      =	$CF
     95  9000 ????	       00 d0	   var44      =	$D0
     96  9000 ????	       00 d1	   var45      =	$D1
     97  9000 ????	       00 d2	   var46      =	$D2
     98  9000 ????	       00 d3	   var47      =	$D3
     99  9000 ????
    100  9000 ????	       00 d4	   A	      =	$d4
    101  9000 ????	       00 d4	   a	      =	$d4
    102  9000 ????	       00 d5	   B	      =	$d5
    103  9000 ????	       00 d5	   b	      =	$d5
    104  9000 ????	       00 d6	   C	      =	$d6
    105  9000 ????	       00 d6	   c	      =	$d6
    106  9000 ????	       00 d7	   D	      =	$d7
    107  9000 ????	       00 d7	   d	      =	$d7
    108  9000 ????	       00 d8	   E	      =	$d8
    109  9000 ????	       00 d8	   e	      =	$d8
    110  9000 ????	       00 d9	   F	      =	$d9
    111  9000 ????	       00 d9	   f	      =	$d9
    112  9000 ????	       00 da	   G	      =	$da
    113  9000 ????	       00 da	   g	      =	$da
    114  9000 ????	       00 db	   H	      =	$db
    115  9000 ????	       00 db	   h	      =	$db
    116  9000 ????	       00 dc	   I	      =	$dc
    117  9000 ????	       00 dc	   i	      =	$dc
    118  9000 ????	       00 dd	   J	      =	$dd
    119  9000 ????	       00 dd	   j	      =	$dd
    120  9000 ????	       00 de	   K	      =	$de
    121  9000 ????	       00 de	   k	      =	$de
    122  9000 ????	       00 df	   L	      =	$df
    123  9000 ????	       00 df	   l	      =	$df
    124  9000 ????	       00 e0	   M	      =	$e0
    125  9000 ????	       00 e0	   m	      =	$e0
    126  9000 ????	       00 e1	   N	      =	$e1
    127  9000 ????	       00 e1	   n	      =	$e1
    128  9000 ????	       00 e2	   O	      =	$e2
    129  9000 ????	       00 e2	   o	      =	$e2
    130  9000 ????	       00 e3	   P	      =	$e3
    131  9000 ????	       00 e3	   p	      =	$e3
    132  9000 ????	       00 e4	   Q	      =	$e4
    133  9000 ????	       00 e4	   q	      =	$e4
    134  9000 ????	       00 e5	   R	      =	$e5
    135  9000 ????	       00 e5	   r	      =	$e5
    136  9000 ????	       00 e6	   S	      =	$e6
    137  9000 ????	       00 e6	   s	      =	$e6
    138  9000 ????	       00 e7	   T	      =	$e7
    139  9000 ????	       00 e7	   t	      =	$e7
    140  9000 ????	       00 e8	   U	      =	$e8
    141  9000 ????	       00 e8	   u	      =	$e8
    142  9000 ????	       00 e9	   V	      =	$e9
    143  9000 ????	       00 e9	   v	      =	$e9
    144  9000 ????	       00 ea	   W	      =	$ea
    145  9000 ????	       00 ea	   w	      =	$ea
    146  9000 ????	       00 eb	   X	      =	$eb
    147  9000 ????	       00 eb	   x	      =	$eb
    148  9000 ????	       00 ec	   Y	      =	$ec
    149  9000 ????	       00 ec	   y	      =	$ec
    150  9000 ????	       00 ed	   Z	      =	$ed
    151  9000 ????	       00 ed	   z	      =	$ed
    152  9000 ????
    153  9000 ????	       00 ee	   temp7      =	$ee	; This is used to aid in bankswitching
    154  9000 ????	       00 ef	   playfieldpos =	$ef
    155  9000 ????
    156  9000 ????						; available for other uses, or if unused, provide more stack space
    157  9000 ????
    158  9000 ????	       00 f0	   aux1       =	$f0
    159  9000 ????	       00 f1	   aux2       =	$f1
    160  9000 ????	       00 f2	   aux3       =	$f2
    161  9000 ????	       00 f3	   aux4       =	$f3
    162  9000 ????	       00 f4	   aux5       =	$f4
    163  9000 ????	       00 f5	   aux6       =	$f5
    164  9000 ????
    165  9000 ????						; playfield color/height pointers
    166  9000 ????	       00 f0	   pfcolortable =	$f0	; and $d5
    167  9000 ????	       00 f0	   pfheighttable =	$f0	; and $d5
    168  9000 ????						; the above pointers are the same because if color and height are both used together,
    169  9000 ????						; they must used absolute indexed and cannot use pointers
    170  9000 ????
    171  9000 ????	       00 f2	   lifepointer =	$f2	; pointer to "lives" shape
    172  9000 ????						; upper 3 bits of $f2 contain the number of lives
    173  9000 ????	       00 f4	   lifecolor  =	$f4
    174  9000 ????	       00 f3	   lives      =	$f3	; # lives >> 5
    175  9000 ????	       00 f5	   statusbarlength =	$f5	; only uses upper 5 bits; other bits free
    176  9000 ????
    177  9000 ????	       00 f2	   pfscore1   =	$f2	; optional playfield bytes in score
    178  9000 ????	       00 f3	   pfscore2   =	$f3
    179  9000 ????	       00 f4	   pfscorecolor =	$f4
    180  9000 ????
    181  9000 ????	       00 f6	   stack1     =	$f6
    182  9000 ????	       00 f7	   stack2     =	$f7
    183  9000 ????	       00 f8	   stack3     =	$f8
    184  9000 ????	       00 f9	   stack4     =	$f9
    185  9000 ????						; the stack bytes above may be used in the kernel
    186  9000 ????						; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    187  9000 ????
    188  9000 ????				      MAC	return
    189  9000 ????				      ifnconst	bankswitch
    190  9000 ????				      rts
    191  9000 ????				      else
    192  9000 ????				      jmp	BS_return
    193  9000 ????				      endif
    194  9000 ????				      ENDM		; auto-return from either a regular or bankswitched module
    195  9000 ????
    196  9000 ????			  -	      ifconst	superchip
    197  9000 ????			  -playfieldbase =	$10D0
    198  9000 ????			  -	      include	superchip.h
    199  9000 ????				      else
    200  9000 ????	       00 a4	   playfieldbase =	$A4
    201  9000 ????				      endif
    202  9000 ????
    203  9000 ????				      ifnconst	pfhalfwidth
    204  9000 ????	       00 04	   pfwidth    =	4
    205  9000 ????	       00 0e	   PF1L       =	PF1
    206  9000 ????	       00 0f	   PF2L       =	PF2
    207  9000 ????	       00 0e	   PF1R       =	PF1
    208  9000 ????	       00 0f	   PF2R       =	PF2
    209  9000 ????	       00 00	   pfadjust   =	0
    210  9000 ????			  -	      else
    211  9000 ????			  -pfwidth    =	2
    212  9000 ????			  -	      ifconst	pfcenter
    213  9000 ????			  -PF1L       =	$3F	; no effect
    214  9000 ????			  -PF2L       =	PF2
    215  9000 ????			  -PF1R       =	$3F
    216  9000 ????			  -PF2R       =	PF2	; no effect
    217  9000 ????			  -pfadjust   =	1
    218  9000 ????			  -	      else
    219  9000 ????			  -PF1L       =	PF1
    220  9000 ????			  -PF2L       =	PF2
    221  9000 ????			  -PF1R       =	$3F	; no effect
    222  9000 ????			  -PF2R       =	$3F	; no effect
    223  9000 ????			  -pfadjust   =	0
    224  9000 ????			  -	      endif
    225  9000 ????				      endif
    226  9000 ????
    227  9000 ????						; define playfield start based on height
    228  9000 ????				      ifnconst	pfres
    229  9000 ????	       00 a4	   playfield  =	playfieldbase
    230  9000 ????			  -	      else
    231  9000 ????			  -playfield  =	playfieldbase-(pfres-12*(4/pfwidth))*pfwidth
    232  9000 ????				      endif
------- FILE C:\Users\Lex de Fadrique\Documents\VisualbB\projects\roomofdoom\tehroomofdoom.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 2
      0  9000 ????				      include	"2600basic_variable_redefs.h"
      1  9000 ????						; This file contains variable mapping and other information for the current project.
      2  9000 ????
      3  9000 ????	       00 20	   bscode_length =	32
      4  9000 ????	       00 07	   bs_mask    =	7
      5  9000 ????	       00 20	   bankswitch =	32
      6  9000 ????	       1f f4	   bankswitch_hotspot =	$1FF4
      7  9000 ????	       00 01	   PFcolors   =	1
      8  9000 ????	       00 01	   no_blank_lines =	1
      9  9000 ????	       00 01	   player1colors =	1
     10  9000 ????	       00 2b	   vblank_time =	43
     11  9000 ????	       00 25	   overscan_time =	37
------- FILE C:\Users\Lex de Fadrique\Documents\VisualbB\projects\roomofdoom\tehroomofdoom.bas.asm
      6  9000 ????				      ifconst	bankswitch
      7  9000 ????			  -	      if	bankswitch == 8
      8  9000 ????			  -	      ORG	$1000
      9  9000 ????			  -	      RORG	$D000
     10  9000 ????				      endif
     11  9000 ????			  -	      if	bankswitch == 16
     12  9000 ????			  -	      ORG	$1000
     13  9000 ????			  -	      RORG	$9000
     14  9000 ????				      endif
     15  9000 ????				      if	bankswitch == 32
     16  1000					      ORG	$1000
     17  1000					      RORG	$1000
     18  1000					      endif
     19  1000				  -	      if	bankswitch == 64
     20  1000				  -	      ORG	$1000
     21  1000				  -	      RORG	$1000
     22  1000					      endif
     23  1000				  -	      else
     24  1000				  -	      ORG	$F000
     25  1000					      endif
     26  1000
     27  1000					      ifconst	bankswitch_hotspot
     28  1000				  -	      if	bankswitch_hotspot = $083F	; 0840 bankswitching hotspot
     29  1000				  -	      .byte	0	; stop unexpected bankswitches
     30  1000					      endif
     31  1000					      endif
     32  1000				   game
     33  1000				   .
     34  1000							;
     35  1000
     36  1000				   .
     37  1000							;
     38  1000
     39  1000				   .
     40  1000							;
     41  1000
     42  1000				   .L00 		; set tv ntsc
     43  1000
     44  1000				   .L01 		; set kernel_options player1colors pfcolors no_blank_lines
     45  1000
     46  1000				   .L02 		; set romsize 32k
     47  1000
     48  1000				   .L03 		; rem Create the title screen
     49  1000
     50  1000				   .opening
     51  1000							; opening
     52  1000
     53  1000				   .L04 		; pfcolors:
     54  1000
     55  1000		       a9 8a		      lda	# $8A
     56  1002		       85 08		      sta	COLUPF
     57  1004				  -	      ifconst	pfres
     58  1004				  -	      lda	#>(pfcolorlabel13-132+pfres*pfwidth)
     59  1004					      else
     60  1004		       a9 f5		      lda	#>(pfcolorlabel13-84)
     61  1006					      endif
     62  1006		       85 f1		      sta	pfcolortable+1
     63  1008				  -	      ifconst	pfres
     64  1008				  -	      lda	#<(pfcolorlabel13-132+pfres*pfwidth)
     65  1008					      else
     66  1008		       a9 04		      lda	#<(pfcolorlabel13-84)
     67  100a					      endif
     68  100a		       85 f0		      sta	pfcolortable
     69  100c				   .L05 		; playfield:
     70  100c
     71  100c				  -	      ifconst	pfres
     72  100c				  -	      ldx	#(12>pfres)*(pfres*pfwidth-1)+(12<=pfres)*47
     73  100c					      else
     74  100c		       a2 2f		      ldx	#((12*pfwidth-1)*((12*pfwidth-1)<47))+(47*((12*pfwidth-1)>=47))
     75  100e					      endif
     76  100e		       4c 41 10 	      jmp	pflabel0
     77  1011				   PF_data0
     78  1011		       20 08		      .byte.b	%00100000, %00001000
     79  1013					      if	(pfwidth>2)
     80  1013		       44 08		      .byte.b	%01000100, %00001000
     81  1015					      endif
     82  1015		       38 14		      .byte.b	%00111000, %00010100
     83  1017					      if	(pfwidth>2)
     84  1017		       a6 0c		      .byte.b	%10100110, %00001100
     85  1019					      endif
     86  1019		       26 a2		      .byte.b	%00100110, %10100010
     87  101b					      if	(pfwidth>2)
     88  101b		       15 0a		      .byte.b	%00010101, %00001010
     89  101d					      endif
     90  101d		       21 a2		      .byte.b	%00100001, %10100010
     91  101f					      if	(pfwidth>2)
     92  101f		       14 09		      .byte.b	%00010100, %00001001
     93  1021					      endif
     94  1021		       21 a2		      .byte.b	%00100001, %10100010
     95  1023					      if	(pfwidth>2)
     96  1023		       14 08		      .byte.b	%00010100, %00001000
     97  1025					      endif
     98  1025		       21 a2		      .byte.b	%00100001, %10100010
     99  1027					      if	(pfwidth>2)
    100  1027		       14 08		      .byte.b	%00010100, %00001000
    101  1029					      endif
    102  1029		       22 a2		      .byte.b	%00100010, %10100010
    103  102b					      if	(pfwidth>2)
    104  102b		       14 08		      .byte.b	%00010100, %00001000
    105  102d					      endif
    106  102d		       24 a2		      .byte.b	%00100100, %10100010
    107  102f					      if	(pfwidth>2)
    108  102f		       14 08		      .byte.b	%00010100, %00001000
    109  1031					      endif
    110  1031		       24 14		      .byte.b	%00100100, %00010100
    111  1033					      if	(pfwidth>2)
    112  1033		       a4 08		      .byte.b	%10100100, %00001000
    113  1035					      endif
    114  1035		       28 08		      .byte.b	%00101000, %00001000
    115  1037					      if	(pfwidth>2)
    116  1037		       44 08		      .byte.b	%01000100, %00001000
    117  1039					      endif
    118  1039		       30 00		      .byte.b	%00110000, %00000000
    119  103b					      if	(pfwidth>2)
    120  103b		       00 08		      .byte.b	%00000000, %00001000
    121  103d					      endif
    122  103d		       20 00		      .byte.b	%00100000, %00000000
    123  103f					      if	(pfwidth>2)
    124  103f		       00 08		      .byte.b	%00000000, %00001000
    125  1041					      endif
    126  1041				   pflabel0
    127  1041		       bd 11 10 	      lda	PF_data0,x
    128  1044		       95 a4		      sta	playfield,x
    129  1046		       ca		      dex
    130  1047		       10 f8		      bpl	pflabel0
    131  1049				   .
    132  1049							;
    133  1049
    134  1049				   .L06 		; rem Loop the screen until the spacebar is pressed
    135  1049
    136  1049				   .title
    137  1049							; title
    138  1049
    139  1049				   .L07 		; drawscreen
    140  1049
    141  1049		       85 ee		      sta	temp7
    142  104b		       a9 10		      lda	#>(ret_point1-1)
    143  104d		       48		      pha
    144  104e		       a9 60		      lda	#<(ret_point1-1)
    145  1050		       48		      pha
    146  1051		       a9 f4		      lda	#>(drawscreen-1)
    147  1053		       48		      pha
    148  1054		       a9 35		      lda	#<(drawscreen-1)
    149  1056		       48		      pha
    150  1057		       a5 ee		      lda	temp7
    151  1059		       48		      pha
    152  105a		       8a		      txa
    153  105b		       48		      pha
    154  105c		       a2 08		      ldx	#8
    155  105e		       4c eb ff 	      jmp	BS_jsr
    156  1061				   ret_point1
    157  1061				   .L08 		; if joy0fire || joy1fire then goto skiptitle
    158  1061
    159  1061		       24 0c		      bit	INPT4
    160  1063		       30 03		      BMI	.skipL08
    161  1065				   .condpart0
    162  1065		       4c 6c 10 	      jmp	.condpart1
    163  1068				   .skipL08
    164  1068		       24 0d		      bit	INPT5
    165  106a		       30 03		      BMI	.skip0OR
    166  106c				   .condpart1
    167  106c		       4c 72 10 	      jmp	.skiptitle
    168  106f
    169  106f				   .skip0OR
    170  106f				   .L09 		; goto title
    171  106f
    172  106f		       4c 49 10 	      jmp	.title
    173  1072
    174  1072				   .
    175  1072							;
    176  1072
    177  1072				   .L010		; rem This function displays after the title is skipped
    178  1072
    179  1072				   .skiptitle
    180  1072							; skiptitle
    181  1072
    182  1072				   .
    183  1072							;
    184  1072
    185  1072				   .L011		; rem Colors
    186  1072
    187  1072				   .L012		; COLUPF = 0
    188  1072
    189  1072		       a9 00		      LDA	#0
    190  1074		       85 08		      STA	COLUPF
    191  1076				   .L013		; COLUBK = $08
    192  1076
    193  1076		       a9 08		      LDA	#$08
    194  1078		       85 09		      STA	COLUBK
    195  107a				   .
    196  107a							;
    197  107a
    198  107a				   .L014		; rem Player location
    199  107a
    200  107a				   .L015		; player0x = 78 : player0y = 88
    201  107a
    202  107a		       a9 4e		      LDA	#78
    203  107c		       85 80		      STA	player0x
    204  107e		       a9 58		      LDA	#88
    205  1080		       85 85		      STA	player0y
    206  1082				   .L016		; player1x = 20 : player1y = 20
    207  1082
    208  1082		       a9 14		      LDA	#20
    209  1084		       85 81		      STA	player1x
    210  1086		       85 86		      STA	player1y
    211  1088				   .
    212  1088							;
    213  1088
    214  1088				   .L017		; rem Score setting and color
    215  1088
    216  1088				   .L018		; score = 5 : scorecolor = 0
    217  1088
    218  1088		       a9 05		      LDA	#$05
    219  108a		       85 95		      STA	score+2
    220  108c		       a9 00		      LDA	#$00
    221  108e		       85 94		      STA	score+1
    222  1090		       a9 00		      LDA	#$00
    223  1092		       85 93		      STA	score
    224  1094		       a9 00		      LDA	#0
    225  1096		       85 a3		      STA	scorecolor
    226  1098				   .
    227  1098							;
    228  1098
    229  1098				   .L019		; rem Missle size and location
    230  1098
    231  1098				   .L020		; ballheight = 4 : bally = 255
    232  1098
    233  1098		       a9 04		      LDA	#4
    234  109a		       85 92		      STA	ballheight
    235  109c		       a9 ff		      LDA	#255
    236  109e		       85 89		      STA	bally
    237  10a0				   .L021		; NUSIZ0 = 16
    238  10a0
    239  10a0		       a9 10		      LDA	#16
    240  10a2		       85 04		      STA	NUSIZ0
    241  10a4				   .
    242  10a4							;
    243  10a4
    244  10a4				   .L022		; rem Create a variable to keep up with lives
    245  10a4
    246  10a4				   .L023		; a = 5
    247  10a4
    248  10a4		       a9 05		      LDA	#5
    249  10a6		       85 d4		      STA	a
    250  10a8				   .
    251  10a8							;
    252  10a8
    253  10a8				   .L024		; rem Create the playfield
    254  10a8
    255  10a8				   .
    256  10a8							;
    257  10a8
    258  10a8				   .L025		; pfcolors:
    259  10a8
    260  10a8		       a9 36		      lda	# $36
    261  10aa		       85 08		      sta	COLUPF
    262  10ac				  -	      ifconst	pfres
    263  10ac				  -	      lda	#>(pfcolorlabel13-131+pfres*pfwidth)
    264  10ac					      else
    265  10ac		       a9 f5		      lda	#>(pfcolorlabel13-83)
    266  10ae					      endif
    267  10ae		       85 f1		      sta	pfcolortable+1
    268  10b0				  -	      ifconst	pfres
    269  10b0				  -	      lda	#<(pfcolorlabel13-131+pfres*pfwidth)
    270  10b0					      else
    271  10b0		       a9 05		      lda	#<(pfcolorlabel13-83)
    272  10b2					      endif
    273  10b2		       85 f0		      sta	pfcolortable
    274  10b4				   .L026		; playfield:
    275  10b4
    276  10b4				  -	      ifconst	pfres
    277  10b4				  -	      ldx	#(11>pfres)*(pfres*pfwidth-1)+(11<=pfres)*43
    278  10b4					      else
    279  10b4		       a2 2b		      ldx	#((11*pfwidth-1)*((11*pfwidth-1)<47))+(47*((11*pfwidth-1)>=47))
    280  10b6					      endif
    281  10b6		       4c e5 10 	      jmp	pflabel1
    282  10b9				   PF_data1
    283  10b9		       1f ff		      .byte.b	%00011111, %11111111
    284  10bb					      if	(pfwidth>2)
    285  10bb		       ff 1f		      .byte.b	%11111111, %00011111
    286  10bd					      endif
    287  10bd		       01 ff		      .byte.b	%00000001, %11111111
    288  10bf					      if	(pfwidth>2)
    289  10bf		       ff 01		      .byte.b	%11111111, %00000001
    290  10c1					      endif
    291  10c1		       00 fe		      .byte.b	%00000000, %11111110
    292  10c3					      if	(pfwidth>2)
    293  10c3		       fe 00		      .byte.b	%11111110, %00000000
    294  10c5					      endif
    295  10c5		       00 f8		      .byte.b	%00000000, %11111000
    296  10c7					      if	(pfwidth>2)
    297  10c7		       f8 00		      .byte.b	%11111000, %00000000
    298  10c9					      endif
    299  10c9		       00 e0		      .byte.b	%00000000, %11100000
    300  10cb					      if	(pfwidth>2)
    301  10cb		       e0 00		      .byte.b	%11100000, %00000000
    302  10cd					      endif
    303  10cd		       00 e0		      .byte.b	%00000000, %11100000
    304  10cf					      if	(pfwidth>2)
    305  10cf		       e0 00		      .byte.b	%11100000, %00000000
    306  10d1					      endif
    307  10d1		       00 e0		      .byte.b	%00000000, %11100000
    308  10d3					      if	(pfwidth>2)
    309  10d3		       e0 00		      .byte.b	%11100000, %00000000
    310  10d5					      endif
    311  10d5		       00 f8		      .byte.b	%00000000, %11111000
    312  10d7					      if	(pfwidth>2)
    313  10d7		       f8 00		      .byte.b	%11111000, %00000000
    314  10d9					      endif
    315  10d9		       00 fe		      .byte.b	%00000000, %11111110
    316  10db					      if	(pfwidth>2)
    317  10db		       fe 00		      .byte.b	%11111110, %00000000
    318  10dd					      endif
    319  10dd		       01 ff		      .byte.b	%00000001, %11111111
    320  10df					      if	(pfwidth>2)
    321  10df		       ff 01		      .byte.b	%11111111, %00000001
    322  10e1					      endif
    323  10e1		       1f ff		      .byte.b	%00011111, %11111111
    324  10e3					      if	(pfwidth>2)
    325  10e3		       ff 1f		      .byte.b	%11111111, %00011111
    326  10e5					      endif
    327  10e5				   pflabel1
    328  10e5		       bd b9 10 	      lda	PF_data1,x
    329  10e8		       95 a4		      sta	playfield,x
    330  10ea		       ca		      dex
    331  10eb		       10 f8		      bpl	pflabel1
    332  10ed				   .
    333  10ed							;
    334  10ed
    335  10ed				   .
    336  10ed							;
    337  10ed
    338  10ed				   .L027		; rem This main function is what loops constantly
    339  10ed
    340  10ed				   .main
    341  10ed							; main
    342  10ed
    343  10ed				   .
    344  10ed							;
    345  10ed
    346  10ed				   .L028		; rem This is the animation function
    347  10ed
    348  10ed				   .animate
    349  10ed							; animate
    350  10ed
    351  10ed				   .L029		; rem This frame variable slows down the animation
    352  10ed
    353  10ed				   .L030		; v = v + 1
    354  10ed
    355  10ed		       e6 e9		      INC	v
    356  10ef				   .
    357  10ef							;
    358  10ef
    359  10ef				   .L031		; rem This code animates the sprites
    360  10ef
    361  10ef				   .L032		; if v = 7 && w = 0 then ax
    362  10ef
    363  10ef		       a5 e9		      LDA	v
    364  10f1		       c9 07		      CMP	#7
    365  10f3		       d0 04		      BNE	.skipL032
    366  10f5				   .condpart2
    367  10f5		       a5 ea		      LDA	w
    368  10f7
    369  10f7		       f0 27		      beq	.ax
    370  10f9				  -	      if	( (((((#>*)&$1f)*256)|(#<.ax))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.ax))<=(bankswitch_hotspot+bs_mask)) )
    371  10f9				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    372  10f9					      endif
    373  10f9				   .skipL032
    374  10f9				   .L033		; if v = 7 && w = 1 then bx
    375  10f9
    376  10f9		       a5 e9		      LDA	v
    377  10fb		       c9 07		      CMP	#7
    378  10fd		       d0 06		      BNE	.skipL033
    379  10ff				   .condpart3
    380  10ff		       a5 ea		      LDA	w
    381  1101		       c9 01		      CMP	#1
    382  1103		       f0 32		      beq	.bx
    383  1105				  -	      if	( (((((#>*)&$1f)*256)|(#<.bx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.bx))<=(bankswitch_hotspot+bs_mask)) )
    384  1105				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    385  1105					      endif
    386  1105				   .skipL033
    387  1105				   .L034		; if v = 7 && w = 2 then cx
    388  1105
    389  1105		       a5 e9		      LDA	v
    390  1107		       c9 07		      CMP	#7
    391  1109		       d0 06		      BNE	.skipL034
    392  110b				   .condpart4
    393  110b		       a5 ea		      LDA	w
    394  110d		       c9 02		      CMP	#2
    395  110f		       f0 3d		      beq	.cx
    396  1111				  -	      if	( (((((#>*)&$1f)*256)|(#<.cx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.cx))<=(bankswitch_hotspot+bs_mask)) )
    397  1111				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    398  1111					      endif
    399  1111				   .skipL034
    400  1111				   .L035		; if v = 7 && w = 3 then dx
    401  1111
    402  1111		       a5 e9		      LDA	v
    403  1113		       c9 07		      CMP	#7
    404  1115		       d0 06		      BNE	.skipL035
    405  1117				   .condpart5
    406  1117		       a5 ea		      LDA	w
    407  1119		       c9 03		      CMP	#3
    408  111b		       f0 48		      beq	.dx
    409  111d				  -	      if	( (((((#>*)&$1f)*256)|(#<.dx))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.dx))<=(bankswitch_hotspot+bs_mask)) )
    410  111d				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    411  111d					      endif
    412  111d				   .skipL035
    413  111d				   .
    414  111d							;
    415  111d
    416  111d				   .L036		; goto nextstep
    417  111d
    418  111d		       4c 7c 11 	      jmp	.nextstep
    419  1120
    420  1120				   .
    421  1120							;
    422  1120
    423  1120				   .L037		; rem These four sprites are different stages of the animation
    424  1120
    425  1120				   .ax
    426  1120							; ax
    427  1120
    428  1120				   .L038		; v = 0
    429  1120
    430  1120		       a9 00		      LDA	#0
    431  1122		       85 e9		      STA	v
    432  1124				   .L039		; w = 1
    433  1124
    434  1124		       a9 01		      LDA	#1
    435  1126		       85 ea		      STA	w
    436  1128				   .L040		; player1:
    437  1128
    438  1128		       a2 84		      LDX	#<playerL040_1
    439  112a		       86 8c		      STX	player1pointerlo
    440  112c		       a9 f5		      LDA	#>playerL040_1
    441  112e		       85 8d		      STA	player1pointerhi
    442  1130		       a9 03		      LDA	#3
    443  1132		       85 8f		      STA	player1height
    444  1134				   .L041		; goto nextstep
    445  1134
    446  1134		       4c 7c 11 	      jmp	.nextstep
    447  1137
    448  1137				   .
    449  1137							;
    450  1137
    451  1137				   .bx
    452  1137							; bx
    453  1137
    454  1137				   .L042		; v = 0
    455  1137
    456  1137		       a9 00		      LDA	#0
    457  1139		       85 e9		      STA	v
    458  113b				   .L043		; w = 2
    459  113b
    460  113b		       a9 02		      LDA	#2
    461  113d		       85 ea		      STA	w
    462  113f				   .L044		; player1:
    463  113f
    464  113f		       a2 88		      LDX	#<playerL044_1
    465  1141		       86 8c		      STX	player1pointerlo
    466  1143		       a9 f5		      LDA	#>playerL044_1
    467  1145		       85 8d		      STA	player1pointerhi
    468  1147		       a9 03		      LDA	#3
    469  1149		       85 8f		      STA	player1height
    470  114b				   .L045		; goto nextstep
    471  114b
    472  114b		       4c 7c 11 	      jmp	.nextstep
    473  114e
    474  114e				   .
    475  114e							;
    476  114e
    477  114e				   .cx
    478  114e							; cx
    479  114e
    480  114e				   .L046		; v = 0
    481  114e
    482  114e		       a9 00		      LDA	#0
    483  1150		       85 e9		      STA	v
    484  1152				   .L047		; w = 3
    485  1152
    486  1152		       a9 03		      LDA	#3
    487  1154		       85 ea		      STA	w
    488  1156				   .L048		; player1:
    489  1156
    490  1156		       a2 8c		      LDX	#<playerL048_1
    491  1158		       86 8c		      STX	player1pointerlo
    492  115a		       a9 f5		      LDA	#>playerL048_1
    493  115c		       85 8d		      STA	player1pointerhi
    494  115e		       a9 03		      LDA	#3
    495  1160		       85 8f		      STA	player1height
    496  1162				   .L049		; goto nextstep
    497  1162
    498  1162		       4c 7c 11 	      jmp	.nextstep
    499  1165
    500  1165				   .
    501  1165							;
    502  1165
    503  1165				   .dx
    504  1165							; dx
    505  1165
    506  1165				   .L050		; v = 0
    507  1165
    508  1165		       a9 00		      LDA	#0
    509  1167		       85 e9		      STA	v
    510  1169				   .L051		; w = 0
    511  1169
    512  1169		       a9 00		      LDA	#0
    513  116b		       85 ea		      STA	w
    514  116d				   .L052		; player1:
    515  116d
    516  116d		       a2 90		      LDX	#<playerL052_1
    517  116f		       86 8c		      STX	player1pointerlo
    518  1171		       a9 f5		      LDA	#>playerL052_1
    519  1173		       85 8d		      STA	player1pointerhi
    520  1175		       a9 03		      LDA	#3
    521  1177		       85 8f		      STA	player1height
    522  1179				   .L053		; goto nextstep
    523  1179
    524  1179		       4c 7c 11 	      jmp	.nextstep
    525  117c
    526  117c				   .
    527  117c							;
    528  117c
    529  117c				   .L054		; rem Create acorn sprite
    530  117c
    531  117c				   .nextstep
    532  117c							; nextstep
    533  117c
    534  117c				   .L055		; player0:
    535  117c
    536  117c		       a2 94		      LDX	#<playerL055_0
    537  117e		       86 8a		      STX	player0pointerlo
    538  1180		       a9 f5		      LDA	#>playerL055_0
    539  1182		       85 8b		      STA	player0pointerhi
    540  1184		       a9 0e		      LDA	#14
    541  1186		       85 8e		      STA	player0height
    542  1188				   .
    543  1188							;
    544  1188
    545  1188				   .L056		; rem check to see if a missile has already been fired
    546  1188
    547  1188				   .checkfire
    548  1188							; checkfire
    549  1188
    550  1188				   .L057		; if bally > 240 then goto skip
    551  1188
    552  1188		       a9 f0		      LDA	#240
    553  118a		       c5 89		      CMP	bally
    554  118c		       b0 03		      BCS	.skipL057
    555  118e				   .condpart6
    556  118e		       4c 9b 11 	      jmp	.skip
    557  1191
    558  1191				   .skipL057
    559  1191				   .L058		; bally = bally - 2 : goto draw
    560  1191
    561  1191		       a5 89		      LDA	bally
    562  1193		       38		      SEC
    563  1194		       e9 02		      SBC	#2
    564  1196		       85 89		      STA	bally
    565  1198		       4c ad 11 	      jmp	.draw
    566  119b
    567  119b				   .
    568  119b							;
    569  119b
    570  119b				   .L059		; rem if a missile hasn't been fired, then fire missile
    571  119b
    572  119b				   .skip
    573  119b							; skip
    574  119b
    575  119b				   .L060		; if joy0fire then bally = player0y - 2 : ballx = player0x + 4
    576  119b
    577  119b		       24 0c		      bit	INPT4
    578  119d		       30 0e		      BMI	.skipL060
    579  119f				   .condpart7
    580  119f		       a5 85		      LDA	player0y
    581  11a1		       38		      SEC
    582  11a2		       e9 02		      SBC	#2
    583  11a4		       85 89		      STA	bally
    584  11a6		       a5 80		      lda	player0x
    585  11a8		       18		      CLC
    586  11a9		       69 04		      ADC	#4
    587  11ab		       85 84		      STA	ballx
    588  11ad				   .skipL060
    589  11ad				   .
    590  11ad							;
    591  11ad
    592  11ad				   .L061		; rem Draw output to screen
    593  11ad
    594  11ad				   .draw
    595  11ad							; draw
    596  11ad
    597  11ad				   .L062		; drawscreen
    598  11ad
    599  11ad		       85 ee		      sta	temp7
    600  11af		       a9 11		      lda	#>(ret_point2-1)
    601  11b1		       48		      pha
    602  11b2		       a9 c4		      lda	#<(ret_point2-1)
    603  11b4		       48		      pha
    604  11b5		       a9 f4		      lda	#>(drawscreen-1)
    605  11b7		       48		      pha
    606  11b8		       a9 35		      lda	#<(drawscreen-1)
    607  11ba		       48		      pha
    608  11bb		       a5 ee		      lda	temp7
    609  11bd		       48		      pha
    610  11be		       8a		      txa
    611  11bf		       48		      pha
    612  11c0		       a2 08		      ldx	#8
    613  11c2		       4c eb ff 	      jmp	BS_jsr
    614  11c5				   ret_point2
    615  11c5				   .
    616  11c5							;
    617  11c5
    618  11c5				   .L063		; rem Fix player wraparound bug
    619  11c5
    620  11c5				   .L064		; if player0x < 8 then player0x = 8
    621  11c5
    622  11c5		       a5 80		      LDA	player0x
    623  11c7		       c9 08		      CMP	#8
    624  11c9		       b0 04		      BCS	.skipL064
    625  11cb				   .condpart8
    626  11cb		       a9 08		      LDA	#8
    627  11cd		       85 80		      STA	player0x
    628  11cf				   .skipL064
    629  11cf				   .L065		; if player0x > 150 then player0x = 150
    630  11cf
    631  11cf		       a9 96		      LDA	#150
    632  11d1		       c5 80		      CMP	player0x
    633  11d3		       b0 04		      BCS	.skipL065
    634  11d5				   .condpart9
    635  11d5		       a9 96		      LDA	#150
    636  11d7		       85 80		      STA	player0x
    637  11d9				   .skipL065
    638  11d9				   .L066		; if player0y < 8 then player0y = 8
    639  11d9
    640  11d9		       a5 85		      LDA	player0y
    641  11db		       c9 08		      CMP	#8
    642  11dd		       b0 04		      BCS	.skipL066
    643  11df				   .condpart10
    644  11df		       a9 08		      LDA	#8
    645  11e1		       85 85		      STA	player0y
    646  11e3				   .skipL066
    647  11e3				   .L067		; if player0y > 88 then player0y = 88
    648  11e3
    649  11e3		       a9 58		      LDA	#88
    650  11e5		       c5 85		      CMP	player0y
    651  11e7		       b0 04		      BCS	.skipL067
    652  11e9				   .condpart11
    653  11e9		       a9 58		      LDA	#88
    654  11eb		       85 85		      STA	player0y
    655  11ed				   .skipL067
    656  11ed				   .
    657  11ed							;
    658  11ed
    659  11ed				   .L068		; rem Have player 1 chase player 2
    660  11ed
    661  11ed				   .L069		; if player1y < player0y then player1y = player1y + 1
    662  11ed
    663  11ed		       a5 86		      LDA	player1y
    664  11ef		       c5 85		      CMP	player0y
    665  11f1		       b0 02		      BCS	.skipL069
    666  11f3				   .condpart12
    667  11f3		       e6 86		      INC	player1y
    668  11f5				   .skipL069
    669  11f5				   .L070		; if player1y > player0y then player1y = player1y - 1
    670  11f5
    671  11f5		       a5 85		      LDA	player0y
    672  11f7		       c5 86		      CMP	player1y
    673  11f9		       b0 02		      BCS	.skipL070
    674  11fb				   .condpart13
    675  11fb		       c6 86		      DEC	player1y
    676  11fd				   .skipL070
    677  11fd				   .L071		; if player1x < player0x then player1x = player1x + 1
    678  11fd
    679  11fd		       a5 81		      LDA	player1x
    680  11ff		       c5 80		      CMP	player0x
    681  1201		       b0 02		      BCS	.skipL071
    682  1203				   .condpart14
    683  1203		       e6 81		      INC	player1x
    684  1205				   .skipL071
    685  1205				   .L072		; if player1x > player0x then player1x = player1x - 1
    686  1205
    687  1205		       a5 80		      LDA	player0x
    688  1207		       c5 81		      CMP	player1x
    689  1209		       b0 02		      BCS	.skipL072
    690  120b				   .condpart15
    691  120b		       c6 81		      DEC	player1x
    692  120d				   .skipL072
    693  120d				   .L073		; player1x = player1x : player1y = player1y
    694  120d
    695  120d		       a5 81		      LDA	player1x
    696  120f		       85 81		      STA	player1x
    697  1211		       a5 86		      lda	player1y
    698  1213		       85 86		      STA	player1y
    699  1215				   .
    700  1215							;
    701  1215
    702  1215				   .
    703  1215							;
    704  1215
    705  1215				   .L074		; rem Detect missile collision with squirrel
    706  1215
    707  1215				   .L075		; if collision(ball,player1) then score = score + 1 : player1x = rand / 2 : player1y = 0 : bally = 255 : goto pointsound
    708  1215
    709  1215		       24 03		      bit	CXP1FB
    710  1217		       50 3b		      BVC	.skipL075
    711  1219				   .condpart16
    712  1219		       f8		      SED
    713  121a		       18		      CLC
    714  121b		       a5 95		      LDA	score+2
    715  121d		       69 01		      ADC	#$01
    716  121f		       85 95		      STA	score+2
    717  1221		       a5 94		      LDA	score+1
    718  1223		       69 00		      ADC	#$00
    719  1225		       85 94		      STA	score+1
    720  1227		       a5 93		      LDA	score
    721  1229		       69 00		      ADC	#$00
    722  122b		       85 93		      STA	score
    723  122d		       d8		      CLD
    724  122e		       85 ee		      sta	temp7
    725  1230		       a9 12		      lda	#>(ret_point3-1)
    726  1232		       48		      pha
    727  1233		       a9 45		      lda	#<(ret_point3-1)
    728  1235		       48		      pha
    729  1236		       a9 f4		      lda	#>(randomize-1)
    730  1238		       48		      pha
    731  1239		       a9 29		      lda	#<(randomize-1)
    732  123b		       48		      pha
    733  123c		       a5 ee		      lda	temp7
    734  123e		       48		      pha
    735  123f		       8a		      txa
    736  1240		       48		      pha
    737  1241		       a2 08		      ldx	#8
    738  1243		       4c eb ff 	      jmp	BS_jsr
    739  1246				   ret_point3
    740  1246		       4a		      lsr
    741  1247		       85 81		      STA	player1x
    742  1249		       a9 00		      LDA	#0
    743  124b		       85 86		      STA	player1y
    744  124d		       a9 ff		      LDA	#255
    745  124f		       85 89		      STA	bally
    746  1251		       4c ac 12 	      jmp	.pointsound
    747  1254
    748  1254				   .skipL075
    749  1254				   .L076		; rem Detect squirrel collision with the acorn
    750  1254
    751  1254				   .L077		; if collision(player0,player1) then score = score - 1 : player1x = rand / 2 : player1y = 0 : bally = 255 : a = a - 1 : goto deadsound
    752  1254
    753  1254		       24 07		      bit	CXPPMM
    754  1256		       10 3d		      BPL	.skipL077
    755  1258				   .condpart17
    756  1258		       f8		      SED
    757  1259		       38		      SEC
    758  125a		       a5 95		      LDA	score+2
    759  125c		       e9 01		      SBC	#$01
    760  125e		       85 95		      STA	score+2
    761  1260		       a5 94		      LDA	score+1
    762  1262		       e9 00		      SBC	#$00
    763  1264		       85 94		      STA	score+1
    764  1266		       a5 93		      LDA	score
    765  1268		       e9 00		      SBC	#$00
    766  126a		       85 93		      STA	score
    767  126c		       d8		      CLD
    768  126d		       85 ee		      sta	temp7
    769  126f		       a9 12		      lda	#>(ret_point4-1)
    770  1271		       48		      pha
    771  1272		       a9 84		      lda	#<(ret_point4-1)
    772  1274		       48		      pha
    773  1275		       a9 f4		      lda	#>(randomize-1)
    774  1277		       48		      pha
    775  1278		       a9 29		      lda	#<(randomize-1)
    776  127a		       48		      pha
    777  127b		       a5 ee		      lda	temp7
    778  127d		       48		      pha
    779  127e		       8a		      txa
    780  127f		       48		      pha
    781  1280		       a2 08		      ldx	#8
    782  1282		       4c eb ff 	      jmp	BS_jsr
    783  1285				   ret_point4
    784  1285		       4a		      lsr
    785  1286		       85 81		      STA	player1x
    786  1288		       a9 00		      LDA	#0
    787  128a		       85 86		      STA	player1y
    788  128c		       a9 ff		      LDA	#255
    789  128e		       85 89		      STA	bally
    790  1290		       c6 d4		      DEC	a
    791  1292		       4c e7 12 	      jmp	.deadsound
    792  1295
    793  1295				   .skipL077
    794  1295				   .
    795  1295							;
    796  1295
    797  1295				   .
    798  1295							;
    799  1295
    800  1295				   .L078		; rem joystick movements
    801  1295
    802  1295				   .
    803  1295							;
    804  1295
    805  1295				   .
    806  1295							;
    807  1295
    808  1295				   .L079		; if joy0left then player0x = player0x - 1 : goto skipmove
    809  1295
    810  1295		       2c 80 02 	      bit	SWCHA
    811  1298		       70 05		      BVS	.skipL079
    812  129a				   .condpart18
    813  129a		       c6 80		      DEC	player0x
    814  129c		       4c a9 12 	      jmp	.skipmove
    815  129f
    816  129f				   .skipL079
    817  129f				   .L080		; if joy0right then player0x = player0x + 1 : goto skipmove
    818  129f
    819  129f		       2c 80 02 	      bit	SWCHA
    820  12a2		       30 05		      BMI	.skipL080
    821  12a4				   .condpart19
    822  12a4		       e6 80		      INC	player0x
    823  12a6		       4c a9 12 	      jmp	.skipmove
    824  12a9
    825  12a9				   .skipL080
    826  12a9				   .
    827  12a9							;
    828  12a9
    829  12a9				   .L081		; rem refresh the screen
    830  12a9
    831  12a9				   .skipmove
    832  12a9							; skipmove
    833  12a9
    834  12a9				   .L082		; goto main
    835  12a9
    836  12a9		       4c ed 10 	      jmp	.main
    837  12ac
    838  12ac				   .
    839  12ac							;
    840  12ac
    841  12ac				   .L083		; rem Play point sound
    842  12ac
    843  12ac				   .pointsound
    844  12ac							; pointsound
    845  12ac
    846  12ac				   .L084		; AUDV0 = 5 : AUDC0 = 4 : AUDF0 = 10
    847  12ac
    848  12ac		       a9 05		      LDA	#5
    849  12ae		       85 19		      STA	AUDV0
    850  12b0		       a9 04		      LDA	#4
    851  12b2		       85 15		      STA	AUDC0
    852  12b4		       a9 0a		      LDA	#10
    853  12b6		       85 17		      STA	AUDF0
    854  12b8				   .L085		; p = p + 1
    855  12b8
    856  12b8		       e6 e3		      INC	p
    857  12ba				   .L086		; drawscreen
    858  12ba
    859  12ba		       85 ee		      sta	temp7
    860  12bc		       a9 12		      lda	#>(ret_point5-1)
    861  12be		       48		      pha
    862  12bf		       a9 d1		      lda	#<(ret_point5-1)
    863  12c1		       48		      pha
    864  12c2		       a9 f4		      lda	#>(drawscreen-1)
    865  12c4		       48		      pha
    866  12c5		       a9 35		      lda	#<(drawscreen-1)
    867  12c7		       48		      pha
    868  12c8		       a5 ee		      lda	temp7
    869  12ca		       48		      pha
    870  12cb		       8a		      txa
    871  12cc		       48		      pha
    872  12cd		       a2 08		      ldx	#8
    873  12cf		       4c eb ff 	      jmp	BS_jsr
    874  12d2				   ret_point5
    875  12d2				   .L087		; if p < 2 then pointsound
    876  12d2
    877  12d2		       a5 e3		      LDA	p
    878  12d4		       c9 02		      CMP	#2
    879  12d6		       90 d4		      bcc	.pointsound
    880  12d8				  -	      if	( (((((#>*)&$1f)*256)|(#<.pointsound))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.pointsound))<=(bankswitch_hotspot+bs_mask)) )
    881  12d8				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    882  12d8					      endif
    883  12d8				   .L088		; p = 0
    884  12d8
    885  12d8		       a9 00		      LDA	#0
    886  12da		       85 e3		      STA	p
    887  12dc				   .L089		; AUDV0 = 0 : AUDC0 = 0 : AUDF0 = 0
    888  12dc
    889  12dc		       a9 00		      LDA	#0
    890  12de		       85 19		      STA	AUDV0
    891  12e0		       85 15		      STA	AUDC0
    892  12e2		       85 17		      STA	AUDF0
    893  12e4				   .L090		; goto main
    894  12e4
    895  12e4		       4c ed 10 	      jmp	.main
    896  12e7
    897  12e7				   .
    898  12e7							;
    899  12e7
    900  12e7				   .L091		; rem Play dead sound
    901  12e7
    902  12e7				   .deadsound
    903  12e7							; deadsound
    904  12e7
    905  12e7				   .L092		; AUDV1 = 10
    906  12e7
    907  12e7		       a9 0a		      LDA	#10
    908  12e9		       85 1a		      STA	AUDV1
    909  12eb				   .L093		; AUDC1 = 7
    910  12eb
    911  12eb		       a9 07		      LDA	#7
    912  12ed		       85 16		      STA	AUDC1
    913  12ef				   .L094		; AUDF1 = 12
    914  12ef
    915  12ef		       a9 0c		      LDA	#12
    916  12f1		       85 18		      STA	AUDF1
    917  12f3				   .L095		; p = p + 1
    918  12f3
    919  12f3		       e6 e3		      INC	p
    920  12f5				   .L096		; drawscreen
    921  12f5
    922  12f5		       85 ee		      sta	temp7
    923  12f7		       a9 13		      lda	#>(ret_point6-1)
    924  12f9		       48		      pha
    925  12fa		       a9 0c		      lda	#<(ret_point6-1)
    926  12fc		       48		      pha
    927  12fd		       a9 f4		      lda	#>(drawscreen-1)
    928  12ff		       48		      pha
    929  1300		       a9 35		      lda	#<(drawscreen-1)
    930  1302		       48		      pha
    931  1303		       a5 ee		      lda	temp7
    932  1305		       48		      pha
    933  1306		       8a		      txa
    934  1307		       48		      pha
    935  1308		       a2 08		      ldx	#8
    936  130a		       4c eb ff 	      jmp	BS_jsr
    937  130d				   ret_point6
    938  130d				   .L097		; if p < 10 then deadsound
    939  130d
    940  130d		       a5 e3		      LDA	p
    941  130f		       c9 0a		      CMP	#10
    942  1311		       90 d4		      bcc	.deadsound
    943  1313				  -	      if	( (((((#>*)&$1f)*256)|(#<.deadsound))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.deadsound))<=(bankswitch_hotspot+bs_mask)) )
    944  1313				  -	      echo	"WARNING: branch near the end of bank 1 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
    945  1313					      endif
    946  1313				   .L098		; p = 0
    947  1313
    948  1313		       a9 00		      LDA	#0
    949  1315		       85 e3		      STA	p
    950  1317				   .L099		; AUDV1 = 0 : AUDC1 = 0 : AUDF1 = 0
    951  1317
    952  1317		       a9 00		      LDA	#0
    953  1319		       85 1a		      STA	AUDV1
    954  131b		       85 16		      STA	AUDC1
    955  131d		       85 18		      STA	AUDF1
    956  131f				   .L0100		; if a = 0 then goto opening
    957  131f
    958  131f		       a5 d4		      LDA	a
    959  1321
    960  1321		       d0 03		      BNE	.skipL0100
    961  1323				   .condpart20
    962  1323		       4c 00 10 	      jmp	.opening
    963  1326
    964  1326				   .skipL0100
    965  1326				   .L0101		; goto main
    966  1326
    967  1326		       4c ed 10 	      jmp	.main
    968  1329
    969  1329				   .
    970  1329							;
    971  1329
    972  1329				   .
    973  1329							;
    974  1329
    975  1329				   .
    976  1329							;
    977  1329
    978  1329				   .
    979  1329							;
    980  1329
    981  1329				   .
    982  1329							;
    983  1329
    984  1329				   .
    985  1329							;
    986  1329
    987  1329				   .
    988  1329							;
    989  1329
    990  1329				   .
    991  1329							;
    992  1329
    993  1329				   .
    994  1329							;
    995  1329
    996  1329					      if	ECHO1
   3243 bytes of ROM space left in bank 1
    997  1329					      echo	" ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
    998  1329					      endif
    999  1329		       00 01	   ECHO1      =	1
   1000  1fd4					      ORG	$1FF4-bscode_length
   1001  1fd4					      RORG	$1FF4-bscode_length
   1002  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1003  1fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1004  1fd6				  -	      stx	FASTFETCH
   1005  1fd6					      endif
   1006  1fd6		       9a		      txs
   1007  1fd7				  -	      if	bankswitch == 64
   1008  1fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1009  1fd7					      else
   1010  1fd7		       a9 f2		      lda	#>(start-1)
   1011  1fd9					      endif
   1012  1fd9		       48		      pha
   1013  1fda		       a9 4f		      lda	#<(start-1)
   1014  1fdc		       48		      pha
   1015  1fdd		       48		      pha
   1016  1fde		       8a		      txa
   1017  1fdf		       48		      pha
   1018  1fe0		       ba		      tsx
   1019  1fe1					      if	bankswitch != 64
   1020  1fe1		       b5 04		      lda	4,x	; get high byte of return address
   1021  1fe3		       2a		      rol
   1022  1fe4		       2a		      rol
   1023  1fe5		       2a		      rol
   1024  1fe6		       2a		      rol
   1025  1fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1026  1fe9		       aa		      tax
   1027  1fea		       e8		      inx
   1028  1feb				  -	      else
   1029  1feb				  -	      lda	4,x	; get high byte of return address
   1030  1feb				  -	      tay
   1031  1feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1032  1feb				  -	      sta	4,x
   1033  1feb				  -	      tya
   1034  1feb				  -	      lsr
   1035  1feb				  -	      lsr
   1036  1feb				  -	      lsr
   1037  1feb				  -	      lsr
   1038  1feb				  -	      tax
   1039  1feb				  -	      inx
   1040  1feb					      endif
   1041  1feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1042  1fee		       68		      pla
   1043  1fef		       aa		      tax
   1044  1ff0		       68		      pla
   1045  1ff1		       60		      rts
   1046  1ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1047  1ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1048  1ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1049  1ff2					      endif
   1050  1ffc					      ORG	$1FFC
   1051  1ffc					      RORG	$1FFC
   1052  1ffc		       d4 1f		      .word.w	start_bank1
   1053  1ffe		       d4 1f		      .word.w	start_bank1
   1054  2000					      ORG	$2000
   1055  2000					      RORG	$3000
   1056  2000					      if	ECHO2
   4052 bytes of ROM space left in bank 2
   1057  2000					      echo	" ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   1058  2000					      endif
   1059  2000		       00 01	   ECHO2      =	1
   1060  2fd4					      ORG	$2FF4-bscode_length
   1061  2fd4					      RORG	$3FF4-bscode_length
   1062  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   1063  2fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1064  2fd6				  -	      stx	FASTFETCH
   1065  2fd6					      endif
   1066  2fd6		       9a		      txs
   1067  2fd7				  -	      if	bankswitch == 64
   1068  2fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1069  2fd7					      else
   1070  2fd7		       a9 f2		      lda	#>(start-1)
   1071  2fd9					      endif
   1072  2fd9		       48		      pha
   1073  2fda		       a9 4f		      lda	#<(start-1)
   1074  2fdc		       48		      pha
   1075  2fdd		       48		      pha
   1076  2fde		       8a		      txa
   1077  2fdf		       48		      pha
   1078  2fe0		       ba		      tsx
   1079  2fe1					      if	bankswitch != 64
   1080  2fe1		       b5 04		      lda	4,x	; get high byte of return address
   1081  2fe3		       2a		      rol
   1082  2fe4		       2a		      rol
   1083  2fe5		       2a		      rol
   1084  2fe6		       2a		      rol
   1085  2fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1086  2fe9		       aa		      tax
   1087  2fea		       e8		      inx
   1088  2feb				  -	      else
   1089  2feb				  -	      lda	4,x	; get high byte of return address
   1090  2feb				  -	      tay
   1091  2feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1092  2feb				  -	      sta	4,x
   1093  2feb				  -	      tya
   1094  2feb				  -	      lsr
   1095  2feb				  -	      lsr
   1096  2feb				  -	      lsr
   1097  2feb				  -	      lsr
   1098  2feb				  -	      tax
   1099  2feb				  -	      inx
   1100  2feb					      endif
   1101  2feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1102  2fee		       68		      pla
   1103  2fef		       aa		      tax
   1104  2ff0		       68		      pla
   1105  2ff1		       60		      rts
   1106  2ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1107  2ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1108  2ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1109  2ff2					      endif
   1110  2ffc					      ORG	$2FFC
   1111  2ffc					      RORG	$3FFC
   1112  2ffc		       d4 3f		      .word.w	start_bank2
   1113  2ffe		       d4 3f		      .word.w	start_bank2
   1114  3000					      ORG	$3000
   1115  3000					      RORG	$5000
   1116  3000					      if	ECHO3
   4052 bytes of ROM space left in bank 3
   1117  3000					      echo	" ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   1118  3000					      endif
   1119  3000		       00 01	   ECHO3      =	1
   1120  3fd4					      ORG	$3FF4-bscode_length
   1121  3fd4					      RORG	$5FF4-bscode_length
   1122  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   1123  3fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1124  3fd6				  -	      stx	FASTFETCH
   1125  3fd6					      endif
   1126  3fd6		       9a		      txs
   1127  3fd7				  -	      if	bankswitch == 64
   1128  3fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1129  3fd7					      else
   1130  3fd7		       a9 f2		      lda	#>(start-1)
   1131  3fd9					      endif
   1132  3fd9		       48		      pha
   1133  3fda		       a9 4f		      lda	#<(start-1)
   1134  3fdc		       48		      pha
   1135  3fdd		       48		      pha
   1136  3fde		       8a		      txa
   1137  3fdf		       48		      pha
   1138  3fe0		       ba		      tsx
   1139  3fe1					      if	bankswitch != 64
   1140  3fe1		       b5 04		      lda	4,x	; get high byte of return address
   1141  3fe3		       2a		      rol
   1142  3fe4		       2a		      rol
   1143  3fe5		       2a		      rol
   1144  3fe6		       2a		      rol
   1145  3fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1146  3fe9		       aa		      tax
   1147  3fea		       e8		      inx
   1148  3feb				  -	      else
   1149  3feb				  -	      lda	4,x	; get high byte of return address
   1150  3feb				  -	      tay
   1151  3feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1152  3feb				  -	      sta	4,x
   1153  3feb				  -	      tya
   1154  3feb				  -	      lsr
   1155  3feb				  -	      lsr
   1156  3feb				  -	      lsr
   1157  3feb				  -	      lsr
   1158  3feb				  -	      tax
   1159  3feb				  -	      inx
   1160  3feb					      endif
   1161  3feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1162  3fee		       68		      pla
   1163  3fef		       aa		      tax
   1164  3ff0		       68		      pla
   1165  3ff1		       60		      rts
   1166  3ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1167  3ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1168  3ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1169  3ff2					      endif
   1170  3ffc					      ORG	$3FFC
   1171  3ffc					      RORG	$5FFC
   1172  3ffc		       d4 5f		      .word.w	start_bank3
   1173  3ffe		       d4 5f		      .word.w	start_bank3
   1174  4000					      ORG	$4000
   1175  4000					      RORG	$7000
   1176  4000					      if	ECHO4
   4052 bytes of ROM space left in bank 4
   1177  4000					      echo	" ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   1178  4000					      endif
   1179  4000		       00 01	   ECHO4      =	1
   1180  4fd4					      ORG	$4FF4-bscode_length
   1181  4fd4					      RORG	$7FF4-bscode_length
   1182  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   1183  4fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1184  4fd6				  -	      stx	FASTFETCH
   1185  4fd6					      endif
   1186  4fd6		       9a		      txs
   1187  4fd7				  -	      if	bankswitch == 64
   1188  4fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1189  4fd7					      else
   1190  4fd7		       a9 f2		      lda	#>(start-1)
   1191  4fd9					      endif
   1192  4fd9		       48		      pha
   1193  4fda		       a9 4f		      lda	#<(start-1)
   1194  4fdc		       48		      pha
   1195  4fdd		       48		      pha
   1196  4fde		       8a		      txa
   1197  4fdf		       48		      pha
   1198  4fe0		       ba		      tsx
   1199  4fe1					      if	bankswitch != 64
   1200  4fe1		       b5 04		      lda	4,x	; get high byte of return address
   1201  4fe3		       2a		      rol
   1202  4fe4		       2a		      rol
   1203  4fe5		       2a		      rol
   1204  4fe6		       2a		      rol
   1205  4fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1206  4fe9		       aa		      tax
   1207  4fea		       e8		      inx
   1208  4feb				  -	      else
   1209  4feb				  -	      lda	4,x	; get high byte of return address
   1210  4feb				  -	      tay
   1211  4feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1212  4feb				  -	      sta	4,x
   1213  4feb				  -	      tya
   1214  4feb				  -	      lsr
   1215  4feb				  -	      lsr
   1216  4feb				  -	      lsr
   1217  4feb				  -	      lsr
   1218  4feb				  -	      tax
   1219  4feb				  -	      inx
   1220  4feb					      endif
   1221  4feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1222  4fee		       68		      pla
   1223  4fef		       aa		      tax
   1224  4ff0		       68		      pla
   1225  4ff1		       60		      rts
   1226  4ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1227  4ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1228  4ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1229  4ff2					      endif
   1230  4ffc					      ORG	$4FFC
   1231  4ffc					      RORG	$7FFC
   1232  4ffc		       d4 7f		      .word.w	start_bank4
   1233  4ffe		       d4 7f		      .word.w	start_bank4
   1234  5000					      ORG	$5000
   1235  5000					      RORG	$9000
   1236  5000					      if	ECHO5
   4052 bytes of ROM space left in bank 5
   1237  5000					      echo	" ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   1238  5000					      endif
   1239  5000		       00 01	   ECHO5      =	1
   1240  5fd4					      ORG	$5FF4-bscode_length
   1241  5fd4					      RORG	$9FF4-bscode_length
   1242  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   1243  5fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1244  5fd6				  -	      stx	FASTFETCH
   1245  5fd6					      endif
   1246  5fd6		       9a		      txs
   1247  5fd7				  -	      if	bankswitch == 64
   1248  5fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1249  5fd7					      else
   1250  5fd7		       a9 f2		      lda	#>(start-1)
   1251  5fd9					      endif
   1252  5fd9		       48		      pha
   1253  5fda		       a9 4f		      lda	#<(start-1)
   1254  5fdc		       48		      pha
   1255  5fdd		       48		      pha
   1256  5fde		       8a		      txa
   1257  5fdf		       48		      pha
   1258  5fe0		       ba		      tsx
   1259  5fe1					      if	bankswitch != 64
   1260  5fe1		       b5 04		      lda	4,x	; get high byte of return address
   1261  5fe3		       2a		      rol
   1262  5fe4		       2a		      rol
   1263  5fe5		       2a		      rol
   1264  5fe6		       2a		      rol
   1265  5fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1266  5fe9		       aa		      tax
   1267  5fea		       e8		      inx
   1268  5feb				  -	      else
   1269  5feb				  -	      lda	4,x	; get high byte of return address
   1270  5feb				  -	      tay
   1271  5feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1272  5feb				  -	      sta	4,x
   1273  5feb				  -	      tya
   1274  5feb				  -	      lsr
   1275  5feb				  -	      lsr
   1276  5feb				  -	      lsr
   1277  5feb				  -	      lsr
   1278  5feb				  -	      tax
   1279  5feb				  -	      inx
   1280  5feb					      endif
   1281  5feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1282  5fee		       68		      pla
   1283  5fef		       aa		      tax
   1284  5ff0		       68		      pla
   1285  5ff1		       60		      rts
   1286  5ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1287  5ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1288  5ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1289  5ff2					      endif
   1290  5ffc					      ORG	$5FFC
   1291  5ffc					      RORG	$9FFC
   1292  5ffc		       d4 9f		      .word.w	start_bank5
   1293  5ffe		       d4 9f		      .word.w	start_bank5
   1294  6000					      ORG	$6000
   1295  6000					      RORG	$B000
   1296  6000					      if	ECHO6
   4052 bytes of ROM space left in bank 6
   1297  6000					      echo	" ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   1298  6000					      endif
   1299  6000		       00 01	   ECHO6      =	1
   1300  6fd4					      ORG	$6FF4-bscode_length
   1301  6fd4					      RORG	$BFF4-bscode_length
   1302  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   1303  6fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1304  6fd6				  -	      stx	FASTFETCH
   1305  6fd6					      endif
   1306  6fd6		       9a		      txs
   1307  6fd7				  -	      if	bankswitch == 64
   1308  6fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1309  6fd7					      else
   1310  6fd7		       a9 f2		      lda	#>(start-1)
   1311  6fd9					      endif
   1312  6fd9		       48		      pha
   1313  6fda		       a9 4f		      lda	#<(start-1)
   1314  6fdc		       48		      pha
   1315  6fdd		       48		      pha
   1316  6fde		       8a		      txa
   1317  6fdf		       48		      pha
   1318  6fe0		       ba		      tsx
   1319  6fe1					      if	bankswitch != 64
   1320  6fe1		       b5 04		      lda	4,x	; get high byte of return address
   1321  6fe3		       2a		      rol
   1322  6fe4		       2a		      rol
   1323  6fe5		       2a		      rol
   1324  6fe6		       2a		      rol
   1325  6fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1326  6fe9		       aa		      tax
   1327  6fea		       e8		      inx
   1328  6feb				  -	      else
   1329  6feb				  -	      lda	4,x	; get high byte of return address
   1330  6feb				  -	      tay
   1331  6feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1332  6feb				  -	      sta	4,x
   1333  6feb				  -	      tya
   1334  6feb				  -	      lsr
   1335  6feb				  -	      lsr
   1336  6feb				  -	      lsr
   1337  6feb				  -	      lsr
   1338  6feb				  -	      tax
   1339  6feb				  -	      inx
   1340  6feb					      endif
   1341  6feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1342  6fee		       68		      pla
   1343  6fef		       aa		      tax
   1344  6ff0		       68		      pla
   1345  6ff1		       60		      rts
   1346  6ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1347  6ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1348  6ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1349  6ff2					      endif
   1350  6ffc					      ORG	$6FFC
   1351  6ffc					      RORG	$BFFC
   1352  6ffc		       d4 bf		      .word.w	start_bank6
   1353  6ffe		       d4 bf		      .word.w	start_bank6
   1354  7000					      ORG	$7000
   1355  7000					      RORG	$D000
   1356  7000					      if	ECHO7
   4052 bytes of ROM space left in bank 7
   1357  7000					      echo	" ",[(start_bank7 - *)]d , "bytes of ROM space left in bank 7")
   1358  7000					      endif
   1359  7000		       00 01	   ECHO7      =	1
   1360  7fd4					      ORG	$7FF4-bscode_length
   1361  7fd4					      RORG	$DFF4-bscode_length
   1362  7fd4		       a2 ff	   start_bank7 ldx	#$ff
   1363  7fd6				  -	      ifconst	FASTFETCH	; using DPC+
   1364  7fd6				  -	      stx	FASTFETCH
   1365  7fd6					      endif
   1366  7fd6		       9a		      txs
   1367  7fd7				  -	      if	bankswitch == 64
   1368  7fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1369  7fd7					      else
   1370  7fd7		       a9 f2		      lda	#>(start-1)
   1371  7fd9					      endif
   1372  7fd9		       48		      pha
   1373  7fda		       a9 4f		      lda	#<(start-1)
   1374  7fdc		       48		      pha
   1375  7fdd		       48		      pha
   1376  7fde		       8a		      txa
   1377  7fdf		       48		      pha
   1378  7fe0		       ba		      tsx
   1379  7fe1					      if	bankswitch != 64
   1380  7fe1		       b5 04		      lda	4,x	; get high byte of return address
   1381  7fe3		       2a		      rol
   1382  7fe4		       2a		      rol
   1383  7fe5		       2a		      rol
   1384  7fe6		       2a		      rol
   1385  7fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1386  7fe9		       aa		      tax
   1387  7fea		       e8		      inx
   1388  7feb				  -	      else
   1389  7feb				  -	      lda	4,x	; get high byte of return address
   1390  7feb				  -	      tay
   1391  7feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1392  7feb				  -	      sta	4,x
   1393  7feb				  -	      tya
   1394  7feb				  -	      lsr
   1395  7feb				  -	      lsr
   1396  7feb				  -	      lsr
   1397  7feb				  -	      lsr
   1398  7feb				  -	      tax
   1399  7feb				  -	      inx
   1400  7feb					      endif
   1401  7feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   1402  7fee		       68		      pla
   1403  7fef		       aa		      tax
   1404  7ff0		       68		      pla
   1405  7ff1		       60		      rts
   1406  7ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1407  7ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1408  7ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1409  7ff2					      endif
   1410  7ffc					      ORG	$7FFC
   1411  7ffc					      RORG	$DFFC
   1412  7ffc		       d4 df		      .word.w	start_bank7
   1413  7ffe		       d4 df		      .word.w	start_bank7
   1414  8000					      ORG	$8000
   1415  8000					      RORG	$F000
   1416  8000							; This is a 2-line kernel!
   1417  8000					      ifnconst	vertical_reflect
   1418  8000				   kernel
   1419  8000					      endif
   1420  8000		       85 02		      sta	WSYNC
   1421  8002		       a9 ff		      lda	#255
   1422  8004		       8d 96 02 	      sta	TIM64T
   1423  8007
   1424  8007		       a9 01		      lda	#1
   1425  8009		       85 27		      sta	VDELBL
   1426  800b		       85 25		      sta	VDELP0
   1427  800d		       a6 92		      ldx	ballheight
   1428  800f		       e8		      inx
   1429  8010		       e8		      inx
   1430  8011		       86 9f		      stx	temp4
   1431  8013		       a5 86		      lda	player1y
   1432  8015		       85 9e		      sta	temp3
   1433  8017
   1434  8017				  -	      ifconst	shakescreen
   1435  8017				  -	      jsr	doshakescreen
   1436  8017					      else
   1437  8017		       a6 90		      ldx	missile0height
   1438  8019		       e8		      inx
   1439  801a					      endif
   1440  801a
   1441  801a		       e8		      inx
   1442  801b		       86 f6		      stx	stack1
   1443  801d
   1444  801d		       a5 89		      lda	bally
   1445  801f		       85 f7		      sta	stack2
   1446  8021
   1447  8021		       a5 85		      lda	player0y
   1448  8023		       a2 00		      ldx	#0
   1449  8025		       85 02		      sta	WSYNC
   1450  8027		       86 1b		      stx	GRP0
   1451  8029		       86 1c		      stx	GRP1
   1452  802b		       86 0e		      stx	PF1L
   1453  802d		       86 0f		      stx	PF2
   1454  802f		       86 2c		      stx	CXCLR
   1455  8031				  -	      ifconst	readpaddle
   1456  8031				  -	      stx	paddle
   1457  8031					      else
      0  8031					      sleep	3
      1  8031				   .CYCLES    SET	3
      2  8031
      3  8031				  -	      IF	.CYCLES < 2
      4  8031				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8031				  -	      ERR
      6  8031					      ENDIF
      7  8031
      8  8031					      IF	.CYCLES & 1
      9  8031					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8031		       04 00		      nop	0
     11  8033				  -	      ELSE
     12  8033				  -	      bit	VSYNC
     13  8033					      ENDIF
     14  8033				   .CYCLES    SET	.CYCLES - 3
     15  8033					      ENDIF
     16  8033
     17  8033				  -	      REPEAT	.CYCLES / 2
     18  8033				  -	      nop
     19  8033					      REPEND
   1459  8033					      endif
   1460  8033
   1461  8033		       95 9d		      sta	temp2,x
   1462  8035
   1463  8035							;store these so they can be retrieved later
   1464  8035					      ifnconst	pfres
   1465  8035		       a2 54		      ldx	#128-44+(4-pfwidth)*12
   1466  8037				  -	      else
   1467  8037				  -	      ldx	#132-pfres*pfwidth
   1468  8037					      endif
   1469  8037
   1470  8037		       c6 85		      dec	player0y
   1471  8039
   1472  8039		       a5 91		      lda	missile0y
   1473  803b		       85 a0		      sta	temp5
   1474  803d		       a5 88		      lda	missile1y
   1475  803f		       85 a1		      sta	temp6
   1476  8041
   1477  8041		       a5 ef		      lda	playfieldpos
   1478  8043		       85 9c		      sta	temp1
   1479  8045
   1480  8045				  -	      ifconst	pfrowheight
   1481  8045				  -	      lda	#pfrowheight+2
   1482  8045					      else
   1483  8045					      ifnconst	pfres
   1484  8045		       a9 0a		      lda	#10
   1485  8047				  -	      else
   1486  8047				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1487  8047					      endif
   1488  8047					      endif
   1489  8047		       18		      clc
   1490  8048		       e5 ef		      sbc	playfieldpos
   1491  804a		       85 ef		      sta	playfieldpos
   1492  804c		       4c 74 f0 	      jmp	.startkernel
   1493  804f
   1494  804f				   .skipDrawP0
   1495  804f		       a9 00		      lda	#0
   1496  8051		       a8		      tay
   1497  8052		       4c a2 f0 	      jmp	.continueP0
   1498  8055
   1499  8055				   .skipDrawP1
   1500  8055		       a9 00		      lda	#0
   1501  8057		       a8		      tay
   1502  8058		       4c 7e f0 	      jmp	.continueP1
   1503  805b
   1504  805b				   .kerloop		; enter at cycle 59??
   1505  805b
   1506  805b				   continuekernel
      0  805b					      sleep	2
      1  805b				   .CYCLES    SET	2
      2  805b
      3  805b				  -	      IF	.CYCLES < 2
      4  805b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  805b				  -	      ERR
      6  805b					      ENDIF
      7  805b
      8  805b				  -	      IF	.CYCLES & 1
      9  805b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  805b				  -	      nop	0
     11  805b				  -	      ELSE
     12  805b				  -	      bit	VSYNC
     13  805b				  -	      ENDIF
     14  805b				  -.CYCLES    SET	.CYCLES - 3
     15  805b					      ENDIF
     16  805b
     17  805b					      REPEAT	.CYCLES / 2
     18  805b		       ea		      nop
     19  805c					      REPEND
   1508  805c				   continuekernel2
   1509  805c		       a5 92		      lda	ballheight
   1510  805e
   1511  805e				  -	      ifconst	pfres
   1512  805e				  -	      ldy	playfield+pfres*pfwidth-132,x
   1513  805e				  -	      sty	PF1L	;3
   1514  805e				  -	      ldy	playfield+pfres*pfwidth-131-pfadjust,x
   1515  805e				  -	      sty	PF2L	;3
   1516  805e				  -	      ldy	playfield+pfres*pfwidth-129,x
   1517  805e				  -	      sty	PF1R	; 3 too early?
   1518  805e				  -	      ldy	playfield+pfres*pfwidth-130-pfadjust,x
   1519  805e				  -	      sty	PF2R	;3
   1520  805e					      else
   1521  805e		       b4 50		      ldy	playfield-48+pfwidth*12+44-128,x
   1522  8060		       84 0e		      sty	PF1L	;3
   1523  8062		       b4 51		      ldy	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1524  8064		       84 0f		      sty	PF2L	;3
   1525  8066		       b4 53		      ldy	playfield-48+pfwidth*12+47-128,x	;4
   1526  8068		       84 0e		      sty	PF1R	; 3 too early?
   1527  806a		       b4 52		      ldy	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1528  806c		       84 0f		      sty	PF2R	;3
   1529  806e					      endif
   1530  806e
   1531  806e							; should be playfield+$38 for width=2
   1532  806e
   1533  806e		       c7 89		      dcp	bally
   1534  8070		       2a		      rol
   1535  8071		       2a		      rol
   1536  8072							; rol
   1537  8072							; rol
   1538  8072				   goback
   1539  8072		       85 1f		      sta	ENABL
   1540  8074				   .startkernel
   1541  8074		       a5 8f		      lda	player1height	;3
   1542  8076		       c7 86		      dcp	player1y	;5
   1543  8078		       90 db		      bcc	.skipDrawP1	;2
   1544  807a		       a4 86		      ldy	player1y	;3
   1545  807c		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1546  807e							; so it doesn't cross a page boundary!
   1547  807e
   1548  807e				   .continueP1
   1549  807e		       85 1c		      sta	GRP1	;3
   1550  8080
   1551  8080				  -	      ifnconst	player1colors
   1552  8080				  -	      lda	missile1height	;3
   1553  8080				  -	      dcp	missile1y	;5
   1554  8080				  -	      rol		;2
   1555  8080				  -	      rol		;2
   1556  8080				  -	      sta	ENAM1	;3
   1557  8080					      else
   1558  8080		       b1 87		      lda	(player1color),y
   1559  8082		       85 07		      sta	COLUP1
   1560  8084					      ifnconst	playercolors
      0  8084					      sleep	7
      1  8084				   .CYCLES    SET	7
      2  8084
      3  8084				  -	      IF	.CYCLES < 2
      4  8084				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8084				  -	      ERR
      6  8084					      ENDIF
      7  8084
      8  8084					      IF	.CYCLES & 1
      9  8084					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8084		       04 00		      nop	0
     11  8086				  -	      ELSE
     12  8086				  -	      bit	VSYNC
     13  8086					      ENDIF
     14  8086				   .CYCLES    SET	.CYCLES - 3
     15  8086					      ENDIF
     16  8086
     17  8086					      REPEAT	.CYCLES / 2
     18  8086		       ea		      nop
     17  8086					      REPEND
     18  8087		       ea		      nop
     19  8088					      REPEND
   1562  8088				  -	      else
   1563  8088				  -	      lda.w	player0colorstore
   1564  8088				  -	      sta	COLUP0
   1565  8088					      endif
   1566  8088					      endif
   1567  8088
   1568  8088				  -	      ifconst	pfres
   1569  8088				  -	      lda	playfield+pfres*pfwidth-132,x
   1570  8088				  -	      sta	PF1L	;3
   1571  8088				  -	      lda	playfield+pfres*pfwidth-131-pfadjust,x
   1572  8088				  -	      sta	PF2L	;3
   1573  8088				  -	      lda	playfield+pfres*pfwidth-129,x
   1574  8088				  -	      sta	PF1R	; 3 too early?
   1575  8088				  -	      lda	playfield+pfres*pfwidth-130-pfadjust,x
   1576  8088				  -	      sta	PF2R	;3
   1577  8088					      else
   1578  8088		       b5 50		      lda	playfield-48+pfwidth*12+44-128,x	;4
   1579  808a		       85 0e		      sta	PF1L	;3
   1580  808c		       b5 51		      lda	playfield-48+pfwidth*12+45-128-pfadjust,x	;4
   1581  808e		       85 0f		      sta	PF2L	;3
   1582  8090		       b5 53		      lda	playfield-48+pfwidth*12+47-128,x	;4
   1583  8092		       85 0e		      sta	PF1R	; 3 too early?
   1584  8094		       b5 52		      lda	playfield-48+pfwidth*12+46-128-pfadjust,x	;4
   1585  8096		       85 0f		      sta	PF2R	;3
   1586  8098					      endif
   1587  8098							; sleep 3
   1588  8098
   1589  8098		       a5 8e		      lda	player0height
   1590  809a		       c7 85		      dcp	player0y
   1591  809c		       90 b1		      bcc	.skipDrawP0
   1592  809e		       a4 85		      ldy	player0y
   1593  80a0		       b1 8a		      lda	(player0pointer),y
   1594  80a2				   .continueP0
   1595  80a2		       85 1b		      sta	GRP0
   1596  80a4
   1597  80a4				  -	      ifnconst	no_blank_lines
   1598  80a4				  -	      ifnconst	playercolors
   1599  80a4				  -	      lda	missile0height	;3
   1600  80a4				  -	      dcp	missile0y	;5
   1601  80a4				  -	      sbc	stack1
   1602  80a4				  -	      sta	ENAM0	;3
   1603  80a4				  -	      else
   1604  80a4				  -	      lda	(player0color),y
   1605  80a4				  -	      sta	player0colorstore
   1606  80a4				  -	      sleep	6
   1607  80a4				  -	      endif
   1608  80a4				  -	      dec	temp1
   1609  80a4				  -	      bne	continuekernel
   1610  80a4					      else
   1611  80a4		       c6 9c		      dec	temp1
   1612  80a6		       f0 0c		      beq	altkernel2
   1613  80a8				  -	      ifconst	readpaddle
   1614  80a8				  -	      ldy	currentpaddle
   1615  80a8				  -	      lda	INPT0,y
   1616  80a8				  -	      bpl	noreadpaddle
   1617  80a8				  -	      inc	paddle
   1618  80a8				  -	      jmp	continuekernel2
   1619  80a8				  -noreadpaddle
   1620  80a8				  -	      sleep	2
   1621  80a8				  -	      jmp	continuekernel
   1622  80a8					      else
   1623  80a8					      ifnconst	playercolors
   1624  80a8					      ifconst	PFcolors
   1625  80a8		       8a		      txa
   1626  80a9		       a8		      tay
   1627  80aa		       b1 f0		      lda	(pfcolortable),y
   1628  80ac					      ifnconst	backgroundchange
   1629  80ac		       85 08		      sta	COLUPF
   1630  80ae				  -	      else
   1631  80ae				  -	      sta	COLUBK
   1632  80ae					      endif
   1633  80ae		       4c 5b f0 	      jmp	continuekernel
   1634  80b1				  -	      else
   1635  80b1				  -	      ifconst	kernelmacrodef
   1636  80b1				  -	      kernelmacro
   1637  80b1				  -	      else
   1638  80b1				  -	      sleep	12
   1639  80b1				  -	      endif
   1640  80b1					      endif
   1641  80b1				  -	      else
   1642  80b1				  -	      lda	(player0color),y
   1643  80b1				  -	      sta	player0colorstore
   1644  80b1				  -	      sleep	4
   1645  80b1					      endif
   1646  80b1		       4c 5b f0 	      jmp	continuekernel
   1647  80b4					      endif
   1648  80b4				   altkernel2
   1649  80b4		       8a		      txa
   1650  80b5					      ifnconst	vertical_reflect
   1651  80b5		       cb fc		      sbx	#256-pfwidth
   1652  80b7				  -	      else
   1653  80b7				  -	      sbx	#256-pfwidth/2
   1654  80b7					      endif
   1655  80b7		       30 24		      bmi	lastkernelline
   1656  80b9				  -	      ifconst	pfrowheight
   1657  80b9				  -	      lda	#pfrowheight
   1658  80b9					      else
   1659  80b9					      ifnconst	pfres
   1660  80b9		       a9 08		      lda	#8
   1661  80bb				  -	      else
   1662  80bb				  -	      lda	#(96/pfres)	; try to come close to the real size
   1663  80bb					      endif
   1664  80bb					      endif
   1665  80bb		       85 9c		      sta	temp1
   1666  80bd		       4c 5b f0 	      jmp	continuekernel
   1667  80c0					      endif
   1668  80c0
   1669  80c0				   altkernel
   1670  80c0
   1671  80c0				  -	      ifconst	PFmaskvalue
   1672  80c0				  -	      lda	#PFmaskvalue
   1673  80c0					      else
   1674  80c0		       a9 00		      lda	#0
   1675  80c2					      endif
   1676  80c2		       85 0e		      sta	PF1L
   1677  80c4		       85 0f		      sta	PF2
   1678  80c6
   1679  80c6
   1680  80c6							;sleep 3
   1681  80c6
   1682  80c6							;28 cycles to fix things
   1683  80c6							;minus 11=17
   1684  80c6
   1685  80c6							; lax temp4
   1686  80c6							; clc
   1687  80c6		       8a		      txa
   1688  80c7					      ifnconst	vertical_reflect
   1689  80c7		       cb fc		      sbx	#256-pfwidth
   1690  80c9				  -	      else
   1691  80c9				  -	      sbx	#256-pfwidth/2
   1692  80c9					      endif
   1693  80c9
   1694  80c9		       30 12		      bmi	lastkernelline
   1695  80cb
   1696  80cb				  -	      ifconst	PFcolorandheight
   1697  80cb				  -	      ifconst	pfres
   1698  80cb				  -	      ldy	playfieldcolorandheight-131+pfres*pfwidth,x
   1699  80cb				  -	      else
   1700  80cb				  -	      ldy	playfieldcolorandheight-87,x
   1701  80cb				  -	      endif
   1702  80cb				  -	      ifnconst	backgroundchange
   1703  80cb				  -	      sty	COLUPF
   1704  80cb				  -	      else
   1705  80cb				  -	      sty	COLUBK
   1706  80cb				  -	      endif
   1707  80cb				  -	      ifconst	pfres
   1708  80cb				  -	      lda	playfieldcolorandheight-132+pfres*pfwidth,x
   1709  80cb				  -	      else
   1710  80cb				  -	      lda	playfieldcolorandheight-88,x
   1711  80cb				  -	      endif
   1712  80cb				  -	      sta.w	temp1
   1713  80cb					      endif
   1714  80cb				  -	      ifconst	PFheights
   1715  80cb				  -	      lsr
   1716  80cb				  -	      lsr
   1717  80cb				  -	      tay
   1718  80cb				  -	      lda	(pfheighttable),y
   1719  80cb				  -	      sta.w	temp1
   1720  80cb					      endif
   1721  80cb					      ifconst	PFcolors
   1722  80cb		       a8		      tay
   1723  80cc		       b1 f0		      lda	(pfcolortable),y
   1724  80ce					      ifnconst	backgroundchange
   1725  80ce		       85 08		      sta	COLUPF
   1726  80d0				  -	      else
   1727  80d0				  -	      sta	COLUBK
   1728  80d0					      endif
   1729  80d0				  -	      ifconst	pfrowheight
   1730  80d0				  -	      lda	#pfrowheight
   1731  80d0					      else
   1732  80d0					      ifnconst	pfres
   1733  80d0		       a9 08		      lda	#8
   1734  80d2				  -	      else
   1735  80d2				  -	      lda	#(96/pfres)	; try to come close to the real size
   1736  80d2					      endif
   1737  80d2					      endif
   1738  80d2		       85 9c		      sta	temp1
   1739  80d4					      endif
   1740  80d4					      ifnconst	PFcolorandheight
   1741  80d4				  -	      ifnconst	PFcolors
   1742  80d4				  -	      ifnconst	PFheights
   1743  80d4				  -	      ifnconst	no_blank_lines
   1744  80d4				  -			; read paddle 0
   1745  80d4				  -			; lo-res paddle read
   1746  80d4				  -			; bit INPT0
   1747  80d4				  -			; bmi paddleskipread
   1748  80d4				  -			; inc paddle0
   1749  80d4				  -			;donepaddleskip
   1750  80d4				  -	      sleep	10
   1751  80d4				  -	      ifconst	pfrowheight
   1752  80d4				  -	      lda	#pfrowheight
   1753  80d4				  -	      else
   1754  80d4				  -	      ifnconst	pfres
   1755  80d4				  -	      lda	#8
   1756  80d4				  -	      else
   1757  80d4				  -	      lda	#(96/pfres)	; try to come close to the real size
   1758  80d4				  -	      endif
   1759  80d4				  -	      endif
   1760  80d4				  -	      sta	temp1
   1761  80d4				  -	      endif
   1762  80d4				  -	      endif
   1763  80d4					      endif
   1764  80d4					      endif
   1765  80d4
   1766  80d4
   1767  80d4		       a5 92		      lda	ballheight
   1768  80d6		       c7 89		      dcp	bally
   1769  80d8		       e5 9f		      sbc	temp4
   1770  80da
   1771  80da
   1772  80da		       4c 72 f0 	      jmp	goback
   1773  80dd
   1774  80dd
   1775  80dd				  -	      ifnconst	no_blank_lines
   1776  80dd				  -lastkernelline
   1777  80dd				  -	      ifnconst	PFcolors
   1778  80dd				  -	      sleep	10
   1779  80dd				  -	      else
   1780  80dd				  -	      ldy	#124
   1781  80dd				  -	      lda	(pfcolortable),y
   1782  80dd				  -	      sta	COLUPF
   1783  80dd				  -	      endif
   1784  80dd				  -
   1785  80dd				  -	      ifconst	PFheights
   1786  80dd				  -	      ldx	#1
   1787  80dd				  -			;sleep 4
   1788  80dd				  -	      sleep	3	; REVENG - this was over 1 cycle
   1789  80dd				  -	      else
   1790  80dd				  -	      ldx	playfieldpos
   1791  80dd				  -			;sleep 3
   1792  80dd				  -	      sleep	2	; REVENG - this was over 1 cycle
   1793  80dd				  -	      endif
   1794  80dd				  -
   1795  80dd				  -	      jmp	enterlastkernel
   1796  80dd				  -
   1797  80dd					      else
   1798  80dd				   lastkernelline
   1799  80dd
   1800  80dd				  -	      ifconst	PFheights
   1801  80dd				  -	      ldx	#1
   1802  80dd				  -			;sleep 5
   1803  80dd				  -	      sleep	4	; REVENG - this was over 1 cycle
   1804  80dd					      else
   1805  80dd		       a6 ef		      ldx	playfieldpos
   1806  80df							;sleep 4
      0  80df					      sleep	3	; REVENG - this was over 1 cycle
      1  80df				   .CYCLES    SET	3
      2  80df
      3  80df				  -	      IF	.CYCLES < 2
      4  80df				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  80df				  -	      ERR
      6  80df					      ENDIF
      7  80df
      8  80df					      IF	.CYCLES & 1
      9  80df					      IFNCONST	NO_ILLEGAL_OPCODES
     10  80df		       04 00		      nop	0
     11  80e1				  -	      ELSE
     12  80e1				  -	      bit	VSYNC
     13  80e1					      ENDIF
     14  80e1				   .CYCLES    SET	.CYCLES - 3
     15  80e1					      ENDIF
     16  80e1
     17  80e1				  -	      REPEAT	.CYCLES / 2
     18  80e1				  -	      nop
     19  80e1					      REPEND
   1808  80e1					      endif
   1809  80e1
   1810  80e1		       e0 00		      cpx	#0
   1811  80e3		       d0 22		      bne	.enterfromNBL
   1812  80e5		       4c 68 f1 	      jmp	no_blank_lines_bailout
   1813  80e8					      endif
   1814  80e8
   1815  80e8					      if	((<*)>$d5)
   1816  8100		       00 00 00 00*	      align	256
   1817  8100					      endif
   1818  8100							; this is a kludge to prevent page wrapping - fix!!!
   1819  8100
   1820  8100				   .skipDrawlastP1
   1821  8100		       a9 00		      lda	#0
   1822  8102		       a8		      tay		; REVENG - added so we don't cross a page
   1823  8103		       4c 2d f1 	      jmp	.continuelastP1
   1824  8106
   1825  8106				   .endkerloop		; enter at cycle 59??
   1826  8106
   1827  8106		       ea		      nop
   1828  8107
   1829  8107				   .enterfromNBL
   1830  8107				  -	      ifconst	pfres
   1831  8107				  -	      ldy.w	playfield+pfres*pfwidth-4
   1832  8107				  -	      sty	PF1L	;3
   1833  8107				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1834  8107				  -	      sty	PF2L	;3
   1835  8107				  -	      ldy.w	playfield+pfres*pfwidth-1
   1836  8107				  -	      sty	PF1R	; possibly too early?
   1837  8107				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1838  8107				  -	      sty	PF2R	;3
   1839  8107					      else
   1840  8107		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1841  810a		       84 0e		      sty	PF1L	;3
   1842  810c		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1843  810f		       84 0f		      sty	PF2L	;3
   1844  8111		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1845  8114		       84 0e		      sty	PF1R	; possibly too early?
   1846  8116		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1847  8119		       84 0f		      sty	PF2R	;3
   1848  811b					      endif
   1849  811b
   1850  811b				   enterlastkernel
   1851  811b		       a5 92		      lda	ballheight
   1852  811d
   1853  811d							; tya
   1854  811d		       c7 89		      dcp	bally
   1855  811f							; sleep 4
   1856  811f
   1857  811f							; sbc stack3
   1858  811f		       2a		      rol
   1859  8120		       2a		      rol
   1860  8121		       85 1f		      sta	ENABL
   1861  8123
   1862  8123		       a5 8f		      lda	player1height	;3
   1863  8125		       c7 86		      dcp	player1y	;5
   1864  8127		       90 d7		      bcc	.skipDrawlastP1
   1865  8129		       a4 86		      ldy	player1y	;3
   1866  812b		       b1 8c		      lda	(player1pointer),y	;5; player0pointer must be selected carefully by the compiler
   1867  812d							; so it doesn't cross a page boundary!
   1868  812d
   1869  812d				   .continuelastP1
   1870  812d		       85 1c		      sta	GRP1	;3
   1871  812f
   1872  812f				  -	      ifnconst	player1colors
   1873  812f				  -	      lda	missile1height	;3
   1874  812f				  -	      dcp	missile1y	;5
   1875  812f					      else
   1876  812f		       b1 87		      lda	(player1color),y
   1877  8131		       85 07		      sta	COLUP1
   1878  8133					      endif
   1879  8133
   1880  8133		       ca		      dex
   1881  8134							;dec temp4 ; might try putting this above PF writes
   1882  8134		       f0 34		      beq	endkernel
   1883  8136
   1884  8136
   1885  8136				  -	      ifconst	pfres
   1886  8136				  -	      ldy.w	playfield+pfres*pfwidth-4
   1887  8136				  -	      sty	PF1L	;3
   1888  8136				  -	      ldy.w	playfield+pfres*pfwidth-3-pfadjust
   1889  8136				  -	      sty	PF2L	;3
   1890  8136				  -	      ldy.w	playfield+pfres*pfwidth-1
   1891  8136				  -	      sty	PF1R	; possibly too early?
   1892  8136				  -	      ldy.w	playfield+pfres*pfwidth-2-pfadjust
   1893  8136				  -	      sty	PF2R	;3
   1894  8136					      else
   1895  8136		       ac d0 00 	      ldy.w	playfield-48+pfwidth*12+44
   1896  8139		       84 0e		      sty	PF1L	;3
   1897  813b		       ac d1 00 	      ldy.w	playfield-48+pfwidth*12+45-pfadjust
   1898  813e		       84 0f		      sty	PF2L	;3
   1899  8140		       ac d3 00 	      ldy.w	playfield-48+pfwidth*12+47
   1900  8143		       84 0e		      sty	PF1R	; possibly too early?
   1901  8145		       ac d2 00 	      ldy.w	playfield-48+pfwidth*12+46-pfadjust
   1902  8148		       84 0f		      sty	PF2R	;3
   1903  814a					      endif
   1904  814a
   1905  814a				  -	      ifnconst	player1colors
   1906  814a				  -	      rol		;2
   1907  814a				  -	      rol		;2
   1908  814a				  -	      sta	ENAM1	;3
   1909  814a					      else
   1910  814a					      ifnconst	playercolors
      0  814a					      sleep	7
      1  814a				   .CYCLES    SET	7
      2  814a
      3  814a				  -	      IF	.CYCLES < 2
      4  814a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  814a				  -	      ERR
      6  814a					      ENDIF
      7  814a
      8  814a					      IF	.CYCLES & 1
      9  814a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  814a		       04 00		      nop	0
     11  814c				  -	      ELSE
     12  814c				  -	      bit	VSYNC
     13  814c					      ENDIF
     14  814c				   .CYCLES    SET	.CYCLES - 3
     15  814c					      ENDIF
     16  814c
     17  814c					      REPEAT	.CYCLES / 2
     18  814c		       ea		      nop
     17  814c					      REPEND
     18  814d		       ea		      nop
     19  814e					      REPEND
   1912  814e				  -	      else
   1913  814e				  -	      lda.w	player0colorstore
   1914  814e				  -	      sta	COLUP0
   1915  814e					      endif
   1916  814e					      endif
   1917  814e
   1918  814e		       ad 8e 00 	      lda.w	player0height
   1919  8151		       c7 85		      dcp	player0y
   1920  8153		       90 0d		      bcc	.skipDrawlastP0
   1921  8155		       a4 85		      ldy	player0y
   1922  8157		       b1 8a		      lda	(player0pointer),y
   1923  8159				   .continuelastP0
   1924  8159		       85 1b		      sta	GRP0
   1925  815b
   1926  815b
   1927  815b
   1928  815b				  -	      ifnconst	no_blank_lines
   1929  815b				  -	      lda	missile0height	;3
   1930  815b				  -	      dcp	missile0y	;5
   1931  815b				  -	      sbc	stack1
   1932  815b				  -	      sta	ENAM0	;3
   1933  815b				  -	      jmp	.endkerloop
   1934  815b					      else
   1935  815b				  -	      ifconst	readpaddle
   1936  815b				  -	      ldy	currentpaddle
   1937  815b				  -	      lda	INPT0,y
   1938  815b				  -	      bpl	noreadpaddle2
   1939  815b				  -	      inc	paddle
   1940  815b				  -	      jmp	.endkerloop
   1941  815b				  -noreadpaddle2
   1942  815b				  -	      sleep	4
   1943  815b				  -	      jmp	.endkerloop
   1944  815b					      else		; no_blank_lines and no paddle reading
   1945  815b		       68		      pla
   1946  815c		       48		      pha		; 14 cycles in 4 bytes
   1947  815d		       68		      pla
   1948  815e		       48		      pha
   1949  815f							; sleep 14
   1950  815f		       4c 06 f1 	      jmp	.endkerloop
   1951  8162					      endif
   1952  8162					      endif
   1953  8162
   1954  8162
   1955  8162							; ifconst donepaddleskip
   1956  8162							;paddleskipread
   1957  8162							; this is kind of lame, since it requires 4 cycles from a page boundary crossing
   1958  8162							; plus we get a lo-res paddle read
   1959  8162							; bmi donepaddleskip
   1960  8162							; endif
   1961  8162
   1962  8162				   .skipDrawlastP0
   1963  8162		       a9 00		      lda	#0
   1964  8164		       a8		      tay
   1965  8165		       4c 59 f1 	      jmp	.continuelastP0
   1966  8168
   1967  8168					      ifconst	no_blank_lines
   1968  8168				   no_blank_lines_bailout
   1969  8168		       a2 00		      ldx	#0
   1970  816a					      endif
   1971  816a
   1972  816a				   endkernel
   1973  816a							; 6 digit score routine
   1974  816a		       86 0e		      stx	PF1
   1975  816c		       86 0f		      stx	PF2
   1976  816e		       86 0d		      stx	PF0
   1977  8170		       18		      clc
   1978  8171
   1979  8171				  -	      ifconst	pfrowheight
   1980  8171				  -	      lda	#pfrowheight+2
   1981  8171					      else
   1982  8171					      ifnconst	pfres
   1983  8171		       a9 0a		      lda	#10
   1984  8173				  -	      else
   1985  8173				  -	      lda	#(96/pfres)+2	; try to come close to the real size
   1986  8173					      endif
   1987  8173					      endif
   1988  8173
   1989  8173		       e5 ef		      sbc	playfieldpos
   1990  8175		       85 ef		      sta	playfieldpos
   1991  8177		       8a		      txa
   1992  8178
   1993  8178				  -	      ifconst	shakescreen
   1994  8178				  -	      bit	shakescreen
   1995  8178				  -	      bmi	noshakescreen2
   1996  8178				  -	      ldx	#$3D
   1997  8178				  -noshakescreen2
   1998  8178					      endif
   1999  8178
   2000  8178		       95 02		      sta	WSYNC,x
   2001  817a
   2002  817a							; STA WSYNC ;first one, need one more
   2003  817a		       85 0b		      sta	REFP0
   2004  817c		       85 0c		      sta	REFP1
   2005  817e		       85 1b		      STA	GRP0
   2006  8180		       85 1c		      STA	GRP1
   2007  8182							; STA PF1
   2008  8182							; STA PF2
   2009  8182		       85 2b		      sta	HMCLR
   2010  8184		       85 1d		      sta	ENAM0
   2011  8186		       85 1e		      sta	ENAM1
   2012  8188		       85 1f		      sta	ENABL
   2013  818a
   2014  818a		       a5 9d		      lda	temp2	;restore variables that were obliterated by kernel
   2015  818c		       85 85		      sta	player0y
   2016  818e		       a5 9e		      lda	temp3
   2017  8190		       85 86		      sta	player1y
   2018  8192				  -	      ifnconst	player1colors
   2019  8192				  -	      lda	temp6
   2020  8192				  -	      sta	missile1y
   2021  8192					      endif
   2022  8192					      ifnconst	playercolors
   2023  8192					      ifnconst	readpaddle
   2024  8192		       a5 a0		      lda	temp5
   2025  8194		       85 91		      sta	missile0y
   2026  8196					      endif
   2027  8196					      endif
   2028  8196		       a5 f7		      lda	stack2
   2029  8198		       85 89		      sta	bally
   2030  819a
   2031  819a							; REVENG - strangely, this isn't required any more. might have
   2032  819a							; resulted from the no_blank_lines score bounce fix
   2033  819a							;ifconst no_blank_lines
   2034  819a							;sta WSYNC
   2035  819a							;endif
   2036  819a
   2037  819a		       ad 84 02 	      lda	INTIM
   2038  819d		       18		      clc
   2039  819e				  -	      ifnconst	vblank_time
   2040  819e				  -	      adc	#43+12+87
   2041  819e					      else
   2042  819e		       69 8e		      adc	#vblank_time+12+87
   2043  81a0
   2044  81a0					      endif
   2045  81a0							; sta WSYNC
   2046  81a0		       8d 96 02 	      sta	TIM64T
   2047  81a3
   2048  81a3				  -	      ifconst	minikernel
   2049  81a3				  -	      jsr	minikernel
   2050  81a3					      endif
   2051  81a3
   2052  81a3							; now reassign temp vars for score pointers
   2053  81a3
   2054  81a3							; score pointers contain:
   2055  81a3							; score1-5: lo1,lo2,lo3,lo4,lo5,lo6
   2056  81a3							; swap lo2->temp1
   2057  81a3							; swap lo4->temp3
   2058  81a3							; swap lo6->temp5
   2059  81a3					      ifnconst	noscore
   2060  81a3		       a5 97		      lda	scorepointers+1
   2061  81a5							; ldy temp1
   2062  81a5		       85 9c		      sta	temp1
   2063  81a7							; sty scorepointers+1
   2064  81a7
   2065  81a7		       a5 99		      lda	scorepointers+3
   2066  81a9							; ldy temp3
   2067  81a9		       85 9e		      sta	temp3
   2068  81ab							; sty scorepointers+3
   2069  81ab
   2070  81ab
   2071  81ab		       85 2b		      sta	HMCLR
   2072  81ad		       ba		      tsx
   2073  81ae		       86 f6		      stx	stack1
   2074  81b0		       a2 e0		      ldx	#$E0
   2075  81b2		       86 20		      stx	HMP0
   2076  81b4
   2077  81b4		       a5 a3		      LDA	scorecolor
   2078  81b6		       85 06		      STA	COLUP0
   2079  81b8		       85 07		      STA	COLUP1
   2080  81ba				  -	      ifconst	scorefade
   2081  81ba				  -	      STA	stack2
   2082  81ba					      endif
   2083  81ba				  -	      ifconst	pfscore
   2084  81ba				  -	      lda	pfscorecolor
   2085  81ba				  -	      sta	COLUPF
   2086  81ba					      endif
   2087  81ba		       85 02		      sta	WSYNC
   2088  81bc		       a2 00		      ldx	#0
   2089  81be		       86 1b		      STx	GRP0
   2090  81c0		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   2091  81c2
   2092  81c2		       a5 9b		      lda	scorepointers+5
   2093  81c4							; ldy temp5
   2094  81c4		       95 a0		      sta	temp5,x
   2095  81c6							; sty scorepointers+5
   2096  81c6		       a9 ff		      lda	#>scoretable
   2097  81c8		       85 97		      sta	scorepointers+1
   2098  81ca		       85 99		      sta	scorepointers+3
   2099  81cc		       85 9b		      sta	scorepointers+5
   2100  81ce		       85 9d		      sta	temp2
   2101  81d0		       85 9f		      sta	temp4
   2102  81d2		       85 a1		      sta	temp6
   2103  81d4		       a0 07		      LDY	#7
   2104  81d6		       84 25		      STY	VDELP0
   2105  81d8		       85 10		      STA	RESP0
   2106  81da		       85 11		      STA	RESP1
   2107  81dc
   2108  81dc
   2109  81dc		       a9 03		      LDA	#$03
   2110  81de		       85 04		      STA	NUSIZ0
   2111  81e0		       85 05		      STA	NUSIZ1
   2112  81e2		       85 26		      STA	VDELP1
   2113  81e4		       a9 f0		      LDA	#$F0
   2114  81e6		       85 21		      STA	HMP1
   2115  81e8		       b1 96		      lda	(scorepointers),y
   2116  81ea		       85 1b		      sta	GRP0
   2117  81ec		       85 2a		      STA	HMOVE	; cycle 73 ?
   2118  81ee		       4c 08 f2 	      jmp	beginscore
   2119  81f1
   2120  81f1
   2121  81f1					      if	((<*)>$d4)
   2122  8200		       00 00 00 00*	      align	256	; kludge that potentially wastes space! should be fixed!
   2123  8200					      endif
   2124  8200
   2125  8200				   loop2
   2126  8200		       b1 96		      lda	(scorepointers),y	;+5 68 204
   2127  8202		       85 1b		      sta	GRP0	;+3 71 213 D1 -- -- --
   2128  8204				  -	      ifconst	pfscore
   2129  8204				  -	      lda.w	pfscore1
   2130  8204				  -	      sta	PF1
   2131  8204					      else
   2132  8204				  -	      ifconst	scorefade
   2133  8204				  -	      sleep	2
   2134  8204				  -	      dec	stack2	; decrement the temporary scorecolor
   2135  8204					      else
      0  8204					      sleep	7
      1  8204				   .CYCLES    SET	7
      2  8204
      3  8204				  -	      IF	.CYCLES < 2
      4  8204				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8204				  -	      ERR
      6  8204					      ENDIF
      7  8204
      8  8204					      IF	.CYCLES & 1
      9  8204					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8204		       04 00		      nop	0
     11  8206				  -	      ELSE
     12  8206				  -	      bit	VSYNC
     13  8206					      ENDIF
     14  8206				   .CYCLES    SET	.CYCLES - 3
     15  8206					      ENDIF
     16  8206
     17  8206					      REPEAT	.CYCLES / 2
     18  8206		       ea		      nop
     17  8206					      REPEND
     18  8207		       ea		      nop
     19  8208					      REPEND
   2137  8208					      endif
   2138  8208					      endif
   2139  8208							; cycle 0
   2140  8208				   beginscore
   2141  8208		       b1 9e		      lda	(scorepointers+$8),y	;+5 5 15
   2142  820a		       85 1c		      sta	GRP1	;+3 8 24 D1 D1 D2 --
   2143  820c		       b1 9c		      lda	(scorepointers+$6),y	;+5 13 39
   2144  820e		       85 1b		      sta	GRP0	;+3 16 48 D3 D1 D2 D2
   2145  8210		       b3 98		      lax	(scorepointers+$2),y	;+5 29 87
   2146  8212		       9a		      txs
   2147  8213		       b3 9a		      lax	(scorepointers+$4),y	;+5 36 108
   2148  8215				  -	      ifconst	scorefade
   2149  8215				  -	      lda	stack2
   2150  8215					      else
      0  8215					      sleep	3
      1  8215				   .CYCLES    SET	3
      2  8215
      3  8215				  -	      IF	.CYCLES < 2
      4  8215				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8215				  -	      ERR
      6  8215					      ENDIF
      7  8215
      8  8215					      IF	.CYCLES & 1
      9  8215					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8215		       04 00		      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217					      ENDIF
     14  8217				   .CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217				  -	      REPEAT	.CYCLES / 2
     18  8217				  -	      nop
     19  8217					      REPEND
   2152  8217					      endif
   2153  8217
   2154  8217				  -	      ifconst	pfscore
   2155  8217				  -	      lda	pfscore2
   2156  8217				  -	      sta	PF1
   2157  8217					      else
   2158  8217				  -	      ifconst	scorefade
   2159  8217				  -	      sta	COLUP0
   2160  8217				  -	      sta	COLUP1
   2161  8217					      else
      0  8217					      sleep	6
      1  8217				   .CYCLES    SET	6
      2  8217
      3  8217				  -	      IF	.CYCLES < 2
      4  8217				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8217				  -	      ERR
      6  8217					      ENDIF
      7  8217
      8  8217				  -	      IF	.CYCLES & 1
      9  8217				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  8217				  -	      nop	0
     11  8217				  -	      ELSE
     12  8217				  -	      bit	VSYNC
     13  8217				  -	      ENDIF
     14  8217				  -.CYCLES    SET	.CYCLES - 3
     15  8217					      ENDIF
     16  8217
     17  8217					      REPEAT	.CYCLES / 2
     18  8217		       ea		      nop
     17  8217					      REPEND
     18  8218		       ea		      nop
     17  8218					      REPEND
     18  8219		       ea		      nop
     19  821a					      REPEND
   2163  821a					      endif
   2164  821a					      endif
   2165  821a
   2166  821a		       b1 a0		      lda	(scorepointers+$A),y	;+5 21 63
   2167  821c		       86 1c		      stx	GRP1	;+3 44 132 D3 D3 D4 D2!
   2168  821e		       ba		      tsx
   2169  821f		       86 1b		      stx	GRP0	;+3 47 141 D5 D3! D4 D4
   2170  8221		       85 1c		      sta	GRP1	;+3 50 150 D5 D5 D6 D4!
   2171  8223		       84 1b		      sty	GRP0	;+3 53 159 D4* D5! D6 D6
   2172  8225		       88		      dey
   2173  8226		       10 d8		      bpl	loop2	;+2 60 180
   2174  8228
   2175  8228		       a6 f6		      ldx	stack1
   2176  822a		       9a		      txs
   2177  822b							; lda scorepointers+1
   2178  822b		       a4 9c		      ldy	temp1
   2179  822d							; sta temp1
   2180  822d		       84 97		      sty	scorepointers+1
   2181  822f
   2182  822f		       a9 00		      LDA	#0
   2183  8231		       85 0e		      sta	PF1
   2184  8233		       85 1b		      STA	GRP0
   2185  8235		       85 1c		      STA	GRP1
   2186  8237		       85 25		      STA	VDELP0
   2187  8239		       85 26		      STA	VDELP1	;do we need these
   2188  823b		       85 04		      STA	NUSIZ0
   2189  823d		       85 05		      STA	NUSIZ1
   2190  823f
   2191  823f							; lda scorepointers+3
   2192  823f		       a4 9e		      ldy	temp3
   2193  8241							; sta temp3
   2194  8241		       84 99		      sty	scorepointers+3
   2195  8243
   2196  8243							; lda scorepointers+5
   2197  8243		       a4 a0		      ldy	temp5
   2198  8245							; sta temp5
   2199  8245		       84 9b		      sty	scorepointers+5
   2200  8247					      endif		;noscore
   2201  8247		       a9 c2		      LDA	#%11000010
   2202  8249		       85 02		      sta	WSYNC
   2203  824b		       85 01		      STA	VBLANK
      0  824d					      RETURN
      1  824d				  -	      ifnconst	bankswitch
      2  824d				  -	      rts
      3  824d					      else
      4  824d		       4c dd ff 	      jmp	BS_return
      5  8250					      endif
   2205  8250
   2206  8250				  -	      ifconst	shakescreen
   2207  8250				  -doshakescreen
   2208  8250				  -	      bit	shakescreen
   2209  8250				  -	      bmi	noshakescreen
   2210  8250				  -	      sta	WSYNC
   2211  8250				  -noshakescreen
   2212  8250				  -	      ldx	missile0height
   2213  8250				  -	      inx
   2214  8250				  -	      rts
   2215  8250					      endif
   2216  8250
   2217  8250				   start
   2218  8250		       78		      sei
   2219  8251		       d8		      cld
   2220  8252		       a0 00		      ldy	#0
   2221  8254		       a5 d0		      lda	$D0
   2222  8256		       c9 2c		      cmp	#$2C	;check RAM location #1
   2223  8258		       d0 07		      bne	MachineIs2600
   2224  825a		       a5 d1		      lda	$D1
   2225  825c		       c9 a9		      cmp	#$A9	;check RAM location #2
   2226  825e		       d0 01		      bne	MachineIs2600
   2227  8260		       88		      dey
   2228  8261				   MachineIs2600
   2229  8261		       a2 00		      ldx	#0
   2230  8263		       8a		      txa
   2231  8264				   clearmem
   2232  8264		       e8		      inx
   2233  8265		       9a		      txs
   2234  8266		       48		      pha
   2235  8267		       d0 fb		      bne	clearmem
   2236  8269		       84 9c		      sty	temp1
   2237  826b					      ifnconst	multisprite
   2238  826b				  -	      ifconst	pfrowheight
   2239  826b				  -	      lda	#pfrowheight
   2240  826b					      else
   2241  826b				  -	      ifconst	pfres
   2242  826b				  -	      lda	#(96/pfres)
   2243  826b					      else
   2244  826b		       a9 08		      lda	#8
   2245  826d					      endif
   2246  826d					      endif
   2247  826d		       85 ef		      sta	playfieldpos
   2248  826f					      endif
   2249  826f		       a2 05		      ldx	#5
   2250  8271				   initscore
   2251  8271		       a9 74		      lda	#<scoretable
   2252  8273		       95 96		      sta	scorepointers,x
   2253  8275		       ca		      dex
   2254  8276		       10 f9		      bpl	initscore
   2255  8278		       a9 01		      lda	#1
   2256  827a		       85 0a		      sta	CTRLPF
   2257  827c		       0d 84 02 	      ora	INTIM
   2258  827f		       85 a2		      sta	rand
   2259  8281
   2260  8281				  -	      ifconst	multisprite
   2261  8281				  -	      jsr	multisprite_setup
   2262  8281					      endif
   2263  8281
   2264  8281				  -	      ifnconst	bankswitch
   2265  8281				  -	      jmp	game
   2266  8281					      else
   2267  8281		       a9 0f		      lda	#>(game-1)
   2268  8283		       48		      pha
   2269  8284		       a9 ff		      lda	#<(game-1)
   2270  8286		       48		      pha
   2271  8287		       48		      pha
   2272  8288		       48		      pha
   2273  8289		       a2 01		      ldx	#1
   2274  828b		       4c eb ff 	      jmp	BS_jsr
   2275  828e					      endif
   2276  828e							; playfield drawing routines
   2277  828e							; you get a 32x12 bitmapped display in a single color :)
   2278  828e							; 0-31 and 0-11
   2279  828e
   2280  828e				   pfclear		; clears playfield - or fill with pattern
   2281  828e				  -	      ifconst	pfres
   2282  828e				  -	      ldx	#pfres*pfwidth-1
   2283  828e					      else
   2284  828e		       a2 2f		      ldx	#47-(4-pfwidth)*12	; will this work?
   2285  8290					      endif
   2286  8290				   pfclear_loop
   2287  8290					      ifnconst	superchip
   2288  8290		       95 a4		      sta	playfield,x
   2289  8292				  -	      else
   2290  8292				  -	      sta	playfield-128,x
   2291  8292					      endif
   2292  8292		       ca		      dex
   2293  8293		       10 fb		      bpl	pfclear_loop
      0  8295					      RETURN
      1  8295				  -	      ifnconst	bankswitch
      2  8295				  -	      rts
      3  8295					      else
      4  8295		       4c dd ff 	      jmp	BS_return
      5  8298					      endif
   2295  8298
   2296  8298				   setuppointers
   2297  8298		       86 9d		      stx	temp2	; store on.off.flip value
   2298  829a		       aa		      tax		; put x-value in x
   2299  829b		       4a		      lsr
   2300  829c		       4a		      lsr
   2301  829d		       4a		      lsr		; divide x pos by 8
   2302  829e		       85 9c		      sta	temp1
   2303  82a0		       98		      tya
   2304  82a1		       0a		      asl
   2305  82a2					      if	pfwidth=4
   2306  82a2		       0a		      asl		; multiply y pos by 4
   2307  82a3					      endif		; else multiply by 2
   2308  82a3		       18		      clc
   2309  82a4		       65 9c		      adc	temp1	; add them together to get actual memory location offset
   2310  82a6		       a8		      tay		; put the value in y
   2311  82a7		       a5 9d		      lda	temp2	; restore on.off.flip value
   2312  82a9		       60		      rts
   2313  82aa
   2314  82aa				   pfread
   2315  82aa							;x=xvalue, y=yvalue
   2316  82aa		       20 98 f2 	      jsr	setuppointers
   2317  82ad		       bd 42 f3 	      lda	setbyte,x
   2318  82b0		       39 a4 00 	      and	playfield,y
   2319  82b3		       5d 42 f3 	      eor	setbyte,x
   2320  82b6							; beq readzero
   2321  82b6							; lda #1
   2322  82b6							; readzero
      0  82b6					      RETURN
      1  82b6				  -	      ifnconst	bankswitch
      2  82b6				  -	      rts
      3  82b6					      else
      4  82b6		       4c dd ff 	      jmp	BS_return
      5  82b9					      endif
   2324  82b9
   2325  82b9				   pfpixel
   2326  82b9							;x=xvalue, y=yvalue, a=0,1,2
   2327  82b9		       20 98 f2 	      jsr	setuppointers
   2328  82bc
   2329  82bc					      ifconst	bankswitch
   2330  82bc		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2331  82be		       f0 0f		      beq	pixelon_r	; if "on" go to on
   2332  82c0		       4a		      lsr
   2333  82c1		       b0 18		      bcs	pixeloff_r	; value is 1 if true
   2334  82c3		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2335  82c6		       5d 42 f3 	      eor	setbyte,x
   2336  82c9				  -	      ifconst	superchip
   2337  82c9				  -	      sta	playfield-128,y
   2338  82c9					      else
   2339  82c9		       99 a4 00 	      sta	playfield,y
   2340  82cc					      endif
      0  82cc					      RETURN
      1  82cc				  -	      ifnconst	bankswitch
      2  82cc				  -	      rts
      3  82cc					      else
      4  82cc		       4c dd ff 	      jmp	BS_return
      5  82cf					      endif
   2342  82cf				   pixelon_r
   2343  82cf		       b9 a4 00 	      lda	playfield,y
   2344  82d2		       1d 42 f3 	      ora	setbyte,x
   2345  82d5				  -	      ifconst	superchip
   2346  82d5				  -	      sta	playfield-128,y
   2347  82d5					      else
   2348  82d5		       99 a4 00 	      sta	playfield,y
   2349  82d8					      endif
      0  82d8					      RETURN
      1  82d8				  -	      ifnconst	bankswitch
      2  82d8				  -	      rts
      3  82d8					      else
      4  82d8		       4c dd ff 	      jmp	BS_return
      5  82db					      endif
   2351  82db				   pixeloff_r
   2352  82db		       bd 42 f3 	      lda	setbyte,x
   2353  82de		       49 ff		      eor	#$ff
   2354  82e0		       39 a4 00 	      and	playfield,y
   2355  82e3				  -	      ifconst	superchip
   2356  82e3				  -	      sta	playfield-128,y
   2357  82e3					      else
   2358  82e3		       99 a4 00 	      sta	playfield,y
   2359  82e6					      endif
      0  82e6					      RETURN
      1  82e6				  -	      ifnconst	bankswitch
      2  82e6				  -	      rts
      3  82e6					      else
      4  82e6		       4c dd ff 	      jmp	BS_return
      5  82e9					      endif
   2361  82e9
   2362  82e9				  -	      else
   2363  82e9				  -	      jmp	plotpoint
   2364  82e9					      endif
   2365  82e9
   2366  82e9				   pfhline
   2367  82e9							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2368  82e9		       20 98 f2 	      jsr	setuppointers
   2369  82ec		       4c f6 f2 	      jmp	noinc
   2370  82ef				   keepgoing
   2371  82ef		       e8		      inx
   2372  82f0		       8a		      txa
   2373  82f1		       29 07		      and	#7
   2374  82f3		       d0 01		      bne	noinc
   2375  82f5		       c8		      iny
   2376  82f6				   noinc
   2377  82f6		       20 1b f3 	      jsr	plotpoint
   2378  82f9		       e4 9e		      cpx	temp3
   2379  82fb		       30 f2		      bmi	keepgoing
      0  82fd					      RETURN
      1  82fd				  -	      ifnconst	bankswitch
      2  82fd				  -	      rts
      3  82fd					      else
      4  82fd		       4c dd ff 	      jmp	BS_return
      5  8300					      endif
   2381  8300
   2382  8300				   pfvline
   2383  8300							;x=xvalue, y=yvalue, a=0,1,2, temp3=endx
   2384  8300		       20 98 f2 	      jsr	setuppointers
   2385  8303		       84 9c		      sty	temp1	; store memory location offset
   2386  8305		       e6 9e		      inc	temp3	; increase final x by 1
   2387  8307		       a5 9e		      lda	temp3
   2388  8309		       0a		      asl
   2389  830a					      if	pfwidth=4
   2390  830a		       0a		      asl		; multiply by 4
   2391  830b					      endif		; else multiply by 2
   2392  830b		       85 9e		      sta	temp3	; store it
   2393  830d							; Thanks to Michael Rideout for fixing a bug in this code
   2394  830d							; right now, temp1=y=starting memory location, temp3=final
   2395  830d							; x should equal original x value
   2396  830d				   keepgoingy
   2397  830d		       20 1b f3 	      jsr	plotpoint
   2398  8310		       c8		      iny
   2399  8311		       c8		      iny
   2400  8312					      if	pfwidth=4
   2401  8312		       c8		      iny
   2402  8313		       c8		      iny
   2403  8314					      endif
   2404  8314		       c4 9e		      cpy	temp3
   2405  8316		       30 f5		      bmi	keepgoingy
      0  8318					      RETURN
      1  8318				  -	      ifnconst	bankswitch
      2  8318				  -	      rts
      3  8318					      else
      4  8318		       4c dd ff 	      jmp	BS_return
      5  831b					      endif
   2407  831b
   2408  831b				   plotpoint
   2409  831b		       a5 9d		      lda	temp2	; load on.off.flip value (0,1, or 2)
   2410  831d		       f0 0d		      beq	pixelon	; if "on" go to on
   2411  831f		       4a		      lsr
   2412  8320		       b0 14		      bcs	pixeloff	; value is 1 if true
   2413  8322		       b9 a4 00 	      lda	playfield,y	; if here, it's "flip"
   2414  8325		       5d 42 f3 	      eor	setbyte,x
   2415  8328				  -	      ifconst	superchip
   2416  8328				  -	      sta	playfield-128,y
   2417  8328					      else
   2418  8328		       99 a4 00 	      sta	playfield,y
   2419  832b					      endif
   2420  832b		       60		      rts
   2421  832c				   pixelon
   2422  832c		       b9 a4 00 	      lda	playfield,y
   2423  832f		       1d 42 f3 	      ora	setbyte,x
   2424  8332				  -	      ifconst	superchip
   2425  8332				  -	      sta	playfield-128,y
   2426  8332					      else
   2427  8332		       99 a4 00 	      sta	playfield,y
   2428  8335					      endif
   2429  8335		       60		      rts
   2430  8336				   pixeloff
   2431  8336		       bd 42 f3 	      lda	setbyte,x
   2432  8339		       49 ff		      eor	#$ff
   2433  833b		       39 a4 00 	      and	playfield,y
   2434  833e				  -	      ifconst	superchip
   2435  833e				  -	      sta	playfield-128,y
   2436  833e					      else
   2437  833e		       99 a4 00 	      sta	playfield,y
   2438  8341					      endif
   2439  8341		       60		      rts
   2440  8342
   2441  8342				   setbyte
   2442  8342					      ifnconst	pfcenter
   2443  8342		       80		      .byte.b	$80
   2444  8343		       40		      .byte.b	$40
   2445  8344		       20		      .byte.b	$20
   2446  8345		       10		      .byte.b	$10
   2447  8346		       08		      .byte.b	$08
   2448  8347		       04		      .byte.b	$04
   2449  8348		       02		      .byte.b	$02
   2450  8349		       01		      .byte.b	$01
   2451  834a					      endif
   2452  834a		       01		      .byte.b	$01
   2453  834b		       02		      .byte.b	$02
   2454  834c		       04		      .byte.b	$04
   2455  834d		       08		      .byte.b	$08
   2456  834e		       10		      .byte.b	$10
   2457  834f		       20		      .byte.b	$20
   2458  8350		       40		      .byte.b	$40
   2459  8351		       80		      .byte.b	$80
   2460  8352		       80		      .byte.b	$80
   2461  8353		       40		      .byte.b	$40
   2462  8354		       20		      .byte.b	$20
   2463  8355		       10		      .byte.b	$10
   2464  8356		       08		      .byte.b	$08
   2465  8357		       04		      .byte.b	$04
   2466  8358		       02		      .byte.b	$02
   2467  8359		       01		      .byte.b	$01
   2468  835a		       01		      .byte.b	$01
   2469  835b		       02		      .byte.b	$02
   2470  835c		       04		      .byte.b	$04
   2471  835d		       08		      .byte.b	$08
   2472  835e		       10		      .byte.b	$10
   2473  835f		       20		      .byte.b	$20
   2474  8360		       40		      .byte.b	$40
   2475  8361		       80		      .byte.b	$80
   2476  8362				   pfscroll		;(a=0 left, 1 right, 2 up, 4 down, 6=upup, 12=downdown)
   2477  8362		       d0 15		      bne	notleft
   2478  8364							;left
   2479  8364				  -	      ifconst	pfres
   2480  8364				  -	      ldx	#pfres*4
   2481  8364					      else
   2482  8364		       a2 30		      ldx	#48
   2483  8366					      endif
   2484  8366				   leftloop
   2485  8366		       b5 a3		      lda	playfield-1,x
   2486  8368		       4a		      lsr
   2487  8369
   2488  8369				  -	      ifconst	superchip
   2489  8369				  -	      lda	playfield-2,x
   2490  8369				  -	      rol
   2491  8369				  -	      sta	playfield-130,x
   2492  8369				  -	      lda	playfield-3,x
   2493  8369				  -	      ror
   2494  8369				  -	      sta	playfield-131,x
   2495  8369				  -	      lda	playfield-4,x
   2496  8369				  -	      rol
   2497  8369				  -	      sta	playfield-132,x
   2498  8369				  -	      lda	playfield-1,x
   2499  8369				  -	      ror
   2500  8369				  -	      sta	playfield-129,x
   2501  8369					      else
   2502  8369		       36 a2		      rol	playfield-2,x
   2503  836b		       76 a1		      ror	playfield-3,x
   2504  836d		       36 a0		      rol	playfield-4,x
   2505  836f		       76 a3		      ror	playfield-1,x
   2506  8371					      endif
   2507  8371
   2508  8371		       8a		      txa
   2509  8372		       cb 04		      sbx	#4
   2510  8374		       d0 f0		      bne	leftloop
      0  8376					      RETURN
      1  8376				  -	      ifnconst	bankswitch
      2  8376				  -	      rts
      3  8376					      else
      4  8376		       4c dd ff 	      jmp	BS_return
      5  8379					      endif
   2512  8379
   2513  8379				   notleft
   2514  8379		       4a		      lsr
   2515  837a		       90 15		      bcc	notright
   2516  837c							;right
   2517  837c
   2518  837c				  -	      ifconst	pfres
   2519  837c				  -	      ldx	#pfres*4
   2520  837c					      else
   2521  837c		       a2 30		      ldx	#48
   2522  837e					      endif
   2523  837e				   rightloop
   2524  837e		       b5 a0		      lda	playfield-4,x
   2525  8380		       4a		      lsr
   2526  8381				  -	      ifconst	superchip
   2527  8381				  -	      lda	playfield-3,x
   2528  8381				  -	      rol
   2529  8381				  -	      sta	playfield-131,x
   2530  8381				  -	      lda	playfield-2,x
   2531  8381				  -	      ror
   2532  8381				  -	      sta	playfield-130,x
   2533  8381				  -	      lda	playfield-1,x
   2534  8381				  -	      rol
   2535  8381				  -	      sta	playfield-129,x
   2536  8381				  -	      lda	playfield-4,x
   2537  8381				  -	      ror
   2538  8381				  -	      sta	playfield-132,x
   2539  8381					      else
   2540  8381		       36 a1		      rol	playfield-3,x
   2541  8383		       76 a2		      ror	playfield-2,x
   2542  8385		       36 a3		      rol	playfield-1,x
   2543  8387		       76 a0		      ror	playfield-4,x
   2544  8389					      endif
   2545  8389		       8a		      txa
   2546  838a		       cb 04		      sbx	#4
   2547  838c		       d0 f0		      bne	rightloop
      0  838e					      RETURN
      1  838e				  -	      ifnconst	bankswitch
      2  838e				  -	      rts
      3  838e					      else
      4  838e		       4c dd ff 	      jmp	BS_return
      5  8391					      endif
   2549  8391
   2550  8391				   notright
   2551  8391		       4a		      lsr
   2552  8392		       90 4b		      bcc	notup
   2553  8394							;up
   2554  8394		       4a		      lsr
   2555  8395		       90 02		      bcc	onedecup
   2556  8397		       c6 ef		      dec	playfieldpos
   2557  8399				   onedecup
   2558  8399		       c6 ef		      dec	playfieldpos
   2559  839b		       f0 02		      beq	shiftdown
   2560  839d		       10 3d		      bpl	noshiftdown2
   2561  839f				   shiftdown
   2562  839f				  -	      ifconst	pfrowheight
   2563  839f				  -	      lda	#pfrowheight
   2564  839f					      else
   2565  839f					      ifnconst	pfres
   2566  839f		       a9 08		      lda	#8
   2567  83a1				  -	      else
   2568  83a1				  -	      lda	#(96/pfres)	; try to come close to the real size
   2569  83a1					      endif
   2570  83a1					      endif
   2571  83a1
   2572  83a1		       85 ef		      sta	playfieldpos
   2573  83a3		       a5 a7		      lda	playfield+3
   2574  83a5		       85 9f		      sta	temp4
   2575  83a7		       a5 a6		      lda	playfield+2
   2576  83a9		       85 9e		      sta	temp3
   2577  83ab		       a5 a5		      lda	playfield+1
   2578  83ad		       85 9d		      sta	temp2
   2579  83af		       a5 a4		      lda	playfield
   2580  83b1		       85 9c		      sta	temp1
   2581  83b3		       a2 00		      ldx	#0
   2582  83b5				   up2
   2583  83b5		       b5 a8		      lda	playfield+4,x
   2584  83b7				  -	      ifconst	superchip
   2585  83b7				  -	      sta	playfield-128,x
   2586  83b7				  -	      lda	playfield+5,x
   2587  83b7				  -	      sta	playfield-127,x
   2588  83b7				  -	      lda	playfield+6,x
   2589  83b7				  -	      sta	playfield-126,x
   2590  83b7				  -	      lda	playfield+7,x
   2591  83b7				  -	      sta	playfield-125,x
   2592  83b7					      else
   2593  83b7		       95 a4		      sta	playfield,x
   2594  83b9		       b5 a9		      lda	playfield+5,x
   2595  83bb		       95 a5		      sta	playfield+1,x
   2596  83bd		       b5 aa		      lda	playfield+6,x
   2597  83bf		       95 a6		      sta	playfield+2,x
   2598  83c1		       b5 ab		      lda	playfield+7,x
   2599  83c3		       95 a7		      sta	playfield+3,x
   2600  83c5					      endif
   2601  83c5		       8a		      txa
   2602  83c6		       cb fc		      sbx	#252
   2603  83c8				  -	      ifconst	pfres
   2604  83c8				  -	      cpx	#(pfres-1)*4
   2605  83c8					      else
   2606  83c8		       e0 2c		      cpx	#44
   2607  83ca					      endif
   2608  83ca		       d0 e9		      bne	up2
   2609  83cc
   2610  83cc		       a5 9f		      lda	temp4
   2611  83ce
   2612  83ce				  -	      ifconst	superchip
   2613  83ce				  -	      ifconst	pfres
   2614  83ce				  -	      sta	playfield+pfres*4-129
   2615  83ce				  -	      lda	temp3
   2616  83ce				  -	      sta	playfield+pfres*4-130
   2617  83ce				  -	      lda	temp2
   2618  83ce				  -	      sta	playfield+pfres*4-131
   2619  83ce				  -	      lda	temp1
   2620  83ce				  -	      sta	playfield+pfres*4-132
   2621  83ce				  -	      else
   2622  83ce				  -	      sta	playfield+47-128
   2623  83ce				  -	      lda	temp3
   2624  83ce				  -	      sta	playfield+46-128
   2625  83ce				  -	      lda	temp2
   2626  83ce				  -	      sta	playfield+45-128
   2627  83ce				  -	      lda	temp1
   2628  83ce				  -	      sta	playfield+44-128
   2629  83ce				  -	      endif
   2630  83ce					      else
   2631  83ce				  -	      ifconst	pfres
   2632  83ce				  -	      sta	playfield+pfres*4-1
   2633  83ce				  -	      lda	temp3
   2634  83ce				  -	      sta	playfield+pfres*4-2
   2635  83ce				  -	      lda	temp2
   2636  83ce				  -	      sta	playfield+pfres*4-3
   2637  83ce				  -	      lda	temp1
   2638  83ce				  -	      sta	playfield+pfres*4-4
   2639  83ce					      else
   2640  83ce		       85 d3		      sta	playfield+47
   2641  83d0		       a5 9e		      lda	temp3
   2642  83d2		       85 d2		      sta	playfield+46
   2643  83d4		       a5 9d		      lda	temp2
   2644  83d6		       85 d1		      sta	playfield+45
   2645  83d8		       a5 9c		      lda	temp1
   2646  83da		       85 d0		      sta	playfield+44
   2647  83dc					      endif
   2648  83dc					      endif
   2649  83dc				   noshiftdown2
      0  83dc					      RETURN
      1  83dc				  -	      ifnconst	bankswitch
      2  83dc				  -	      rts
      3  83dc					      else
      4  83dc		       4c dd ff 	      jmp	BS_return
      5  83df					      endif
   2651  83df
   2652  83df
   2653  83df				   notup
   2654  83df							;down
   2655  83df		       4a		      lsr
   2656  83e0		       b0 02		      bcs	oneincup
   2657  83e2		       e6 ef		      inc	playfieldpos
   2658  83e4				   oneincup
   2659  83e4		       e6 ef		      inc	playfieldpos
   2660  83e6		       a5 ef		      lda	playfieldpos
   2661  83e8
   2662  83e8				  -	      ifconst	pfrowheight
   2663  83e8				  -	      cmp	#pfrowheight+1
   2664  83e8					      else
   2665  83e8					      ifnconst	pfres
   2666  83e8		       c9 09		      cmp	#9
   2667  83ea				  -	      else
   2668  83ea				  -	      cmp	#(96/pfres)+1	; try to come close to the real size
   2669  83ea					      endif
   2670  83ea					      endif
   2671  83ea
   2672  83ea		       90 3b		      bcc	noshiftdown
   2673  83ec		       a9 01		      lda	#1
   2674  83ee		       85 ef		      sta	playfieldpos
   2675  83f0
   2676  83f0				  -	      ifconst	pfres
   2677  83f0				  -	      lda	playfield+pfres*4-1
   2678  83f0				  -	      sta	temp4
   2679  83f0				  -	      lda	playfield+pfres*4-2
   2680  83f0				  -	      sta	temp3
   2681  83f0				  -	      lda	playfield+pfres*4-3
   2682  83f0				  -	      sta	temp2
   2683  83f0				  -	      lda	playfield+pfres*4-4
   2684  83f0					      else
   2685  83f0		       a5 d3		      lda	playfield+47
   2686  83f2		       85 9f		      sta	temp4
   2687  83f4		       a5 d2		      lda	playfield+46
   2688  83f6		       85 9e		      sta	temp3
   2689  83f8		       a5 d1		      lda	playfield+45
   2690  83fa		       85 9d		      sta	temp2
   2691  83fc		       a5 d0		      lda	playfield+44
   2692  83fe					      endif
   2693  83fe
   2694  83fe		       85 9c		      sta	temp1
   2695  8400
   2696  8400				  -	      ifconst	pfres
   2697  8400				  -	      ldx	#(pfres-1)*4
   2698  8400					      else
   2699  8400		       a2 2c		      ldx	#44
   2700  8402					      endif
   2701  8402				   down2
   2702  8402		       b5 a3		      lda	playfield-1,x
   2703  8404				  -	      ifconst	superchip
   2704  8404				  -	      sta	playfield-125,x
   2705  8404				  -	      lda	playfield-2,x
   2706  8404				  -	      sta	playfield-126,x
   2707  8404				  -	      lda	playfield-3,x
   2708  8404				  -	      sta	playfield-127,x
   2709  8404				  -	      lda	playfield-4,x
   2710  8404				  -	      sta	playfield-128,x
   2711  8404					      else
   2712  8404		       95 a7		      sta	playfield+3,x
   2713  8406		       b5 a2		      lda	playfield-2,x
   2714  8408		       95 a6		      sta	playfield+2,x
   2715  840a		       b5 a1		      lda	playfield-3,x
   2716  840c		       95 a5		      sta	playfield+1,x
   2717  840e		       b5 a0		      lda	playfield-4,x
   2718  8410		       95 a4		      sta	playfield,x
   2719  8412					      endif
   2720  8412		       8a		      txa
   2721  8413		       cb 04		      sbx	#4
   2722  8415		       d0 eb		      bne	down2
   2723  8417
   2724  8417		       a5 9f		      lda	temp4
   2725  8419				  -	      ifconst	superchip
   2726  8419				  -	      sta	playfield-125
   2727  8419				  -	      lda	temp3
   2728  8419				  -	      sta	playfield-126
   2729  8419				  -	      lda	temp2
   2730  8419				  -	      sta	playfield-127
   2731  8419				  -	      lda	temp1
   2732  8419				  -	      sta	playfield-128
   2733  8419					      else
   2734  8419		       85 a7		      sta	playfield+3
   2735  841b		       a5 9e		      lda	temp3
   2736  841d		       85 a6		      sta	playfield+2
   2737  841f		       a5 9d		      lda	temp2
   2738  8421		       85 a5		      sta	playfield+1
   2739  8423		       a5 9c		      lda	temp1
   2740  8425		       85 a4		      sta	playfield
   2741  8427					      endif
   2742  8427				   noshiftdown
      0  8427					      RETURN
      1  8427				  -	      ifnconst	bankswitch
      2  8427				  -	      rts
      3  8427					      else
      4  8427		       4c dd ff 	      jmp	BS_return
      5  842a					      endif
   2744  842a							;standard routines needed for pretty much all games
   2745  842a							; just the random number generator is left - maybe we should remove this asm file altogether?
   2746  842a							; repositioning code and score pointer setup moved to overscan
   2747  842a							; read switches, joysticks now compiler generated (more efficient)
   2748  842a
   2749  842a				   randomize
   2750  842a		       a5 a2		      lda	rand
   2751  842c		       4a		      lsr
   2752  842d				  -	      ifconst	rand16
   2753  842d				  -	      rol	rand16
   2754  842d					      endif
   2755  842d		       90 02		      bcc	noeor
   2756  842f		       49 b4		      eor	#$B4
   2757  8431				   noeor
   2758  8431		       85 a2		      sta	rand
   2759  8433				  -	      ifconst	rand16
   2760  8433				  -	      eor	rand16
   2761  8433					      endif
      0  8433					      RETURN
      1  8433				  -	      ifnconst	bankswitch
      2  8433				  -	      rts
      3  8433					      else
      4  8433		       4c dd ff 	      jmp	BS_return
      5  8436					      endif
   2763  8436				   drawscreen
   2764  8436				  -	      ifconst	debugscore
   2765  8436				  -	      ldx	#14
   2766  8436				  -	      lda	INTIM	; display # cycles left in the score
   2767  8436				  -
   2768  8436				  -	      ifconst	mincycles
   2769  8436				  -	      lda	mincycles
   2770  8436				  -	      cmp	INTIM
   2771  8436				  -	      lda	mincycles
   2772  8436				  -	      bcc	nochange
   2773  8436				  -	      lda	INTIM
   2774  8436				  -	      sta	mincycles
   2775  8436				  -nochange
   2776  8436				  -	      endif
   2777  8436				  -
   2778  8436				  -			; cmp #$2B
   2779  8436				  -			; bcs no_cycles_left
   2780  8436				  -	      bmi	cycles_left
   2781  8436				  -	      ldx	#64
   2782  8436				  -	      eor	#$ff	;make negative
   2783  8436				  -cycles_left
   2784  8436				  -	      stx	scorecolor
   2785  8436				  -	      and	#$7f	; clear sign bit
   2786  8436				  -	      tax
   2787  8436				  -	      lda	scorebcd,x
   2788  8436				  -	      sta	score+2
   2789  8436				  -	      lda	scorebcd1,x
   2790  8436				  -	      sta	score+1
   2791  8436				  -	      jmp	done_debugscore
   2792  8436				  -scorebcd
   2793  8436				  -	      .byte	$00, $64, $28, $92, $56, $20, $84, $48, $12, $76, $40
   2794  8436				  -	      .byte	$04, $68, $32, $96, $60, $24, $88, $52, $16, $80, $44
   2795  8436				  -	      .byte	$08, $72, $36, $00, $64, $28, $92, $56, $20, $84, $48
   2796  8436				  -	      .byte	$12, $76, $40, $04, $68, $32, $96, $60, $24, $88
   2797  8436				  -scorebcd1
   2798  8436				  -	      .byte	0, 0, 1, 1, 2, 3, 3, 4, 5, 5, 6
   2799  8436				  -	      .byte	7, 7, 8, 8, 9, $10, $10, $11, $12, $12, $13
   2800  8436				  -	      .byte	$14, $14, $15, $16, $16, $17, $17, $18, $19, $19, $20
   2801  8436				  -	      .byte	$21, $21, $22, $23, $23, $24, $24, $25, $26, $26
   2802  8436				  -done_debugscore
   2803  8436					      endif
   2804  8436
   2805  8436				  -	      ifconst	debugcycles
   2806  8436				  -	      lda	INTIM	; if we go over, it mucks up the background color
   2807  8436				  -			; cmp #$2B
   2808  8436				  -			; BCC overscan
   2809  8436				  -	      bmi	overscan
   2810  8436				  -	      sta	COLUBK
   2811  8436				  -	      bcs	doneoverscan
   2812  8436					      endif
   2813  8436
   2814  8436				   overscan
   2815  8436				  -	      ifconst	interlaced
   2816  8436				  -	      PHP
   2817  8436				  -	      PLA
   2818  8436				  -	      EOR	#4	; flip interrupt bit
   2819  8436				  -	      PHA
   2820  8436				  -	      PLP
   2821  8436				  -	      AND	#4	; isolate the interrupt bit
   2822  8436				  -	      TAX		; save it for later
   2823  8436					      endif
   2824  8436
   2825  8436				   overscanloop
   2826  8436		       ad 84 02 	      lda	INTIM	;wait for sync
   2827  8439		       30 fb		      bmi	overscanloop
   2828  843b				   doneoverscan
   2829  843b
   2830  843b							;do VSYNC
   2831  843b
   2832  843b				  -	      ifconst	interlaced
   2833  843b				  -	      CPX	#4
   2834  843b				  -	      BNE	oddframevsync
   2835  843b					      endif
   2836  843b
   2837  843b		       a9 02		      lda	#2
   2838  843d		       85 02		      sta	WSYNC
   2839  843f		       85 00		      sta	VSYNC
   2840  8441		       85 02		      STA	WSYNC
   2841  8443		       85 02		      STA	WSYNC
   2842  8445		       4a		      lsr
   2843  8446		       85 02		      STA	WSYNC
   2844  8448		       85 00		      STA	VSYNC
   2845  844a		       85 01		      sta	VBLANK
   2846  844c				  -	      ifnconst	overscan_time
   2847  844c				  -	      lda	#37+128
   2848  844c					      else
   2849  844c		       a9 a5		      lda	#overscan_time+128
   2850  844e					      endif
   2851  844e		       8d 96 02 	      sta	TIM64T
   2852  8451
   2853  8451				  -	      ifconst	interlaced
   2854  8451				  -	      jmp	postsync
   2855  8451				  -
   2856  8451				  -oddframevsync
   2857  8451				  -	      sta	WSYNC
   2858  8451				  -
   2859  8451				  -	      LDA	($80,X)	; 11 waste
   2860  8451				  -	      LDA	($80,X)	; 11 waste
   2861  8451				  -	      LDA	($80,X)	; 11 waste
   2862  8451				  -
   2863  8451				  -	      lda	#2
   2864  8451				  -	      sta	VSYNC
   2865  8451				  -	      sta	WSYNC
   2866  8451				  -	      sta	WSYNC
   2867  8451				  -	      sta	WSYNC
   2868  8451				  -
   2869  8451				  -	      LDA	($80,X)	; 11 waste
   2870  8451				  -	      LDA	($80,X)	; 11 waste
   2871  8451				  -	      LDA	($80,X)	; 11 waste
   2872  8451				  -
   2873  8451				  -	      lda	#0
   2874  8451				  -	      sta	VSYNC
   2875  8451				  -	      sta	VBLANK
   2876  8451				  -	      ifnconst	overscan_time
   2877  8451				  -	      lda	#37+128
   2878  8451				  -	      else
   2879  8451				  -	      lda	#overscan_time+128
   2880  8451				  -	      endif
   2881  8451				  -	      sta	TIM64T
   2882  8451				  -
   2883  8451				  -postsync
   2884  8451					      endif
   2885  8451
   2886  8451				  -	      ifconst	legacy
   2887  8451				  -	      if	legacy < 100
   2888  8451				  -	      ldx	#4
   2889  8451				  -adjustloop
   2890  8451				  -	      lda	player0x,x
   2891  8451				  -	      sec
   2892  8451				  -	      sbc	#14	;?
   2893  8451				  -	      sta	player0x,x
   2894  8451				  -	      dex
   2895  8451				  -	      bpl	adjustloop
   2896  8451				  -	      endif
   2897  8451					      endif
   2898  8451				  -	      if	((<*)>$e9)&&((<*)<$fa)
   2899  8451				  -	      repeat	($fa-(<*))
   2900  8451				  -	      nop
   2901  8451				  -	      repend
   2902  8451					      endif
   2903  8451		       85 02		      sta	WSYNC
   2904  8453		       a2 04		      ldx	#4
      0  8455					      SLEEP	3
      1  8455				   .CYCLES    SET	3
      2  8455
      3  8455				  -	      IF	.CYCLES < 2
      4  8455				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  8455				  -	      ERR
      6  8455					      ENDIF
      7  8455
      8  8455					      IF	.CYCLES & 1
      9  8455					      IFNCONST	NO_ILLEGAL_OPCODES
     10  8455		       04 00		      nop	0
     11  8457				  -	      ELSE
     12  8457				  -	      bit	VSYNC
     13  8457					      ENDIF
     14  8457				   .CYCLES    SET	.CYCLES - 3
     15  8457					      ENDIF
     16  8457
     17  8457				  -	      REPEAT	.CYCLES / 2
     18  8457				  -	      nop
     19  8457					      REPEND
   2906  8457				   HorPosLoop		; 5
   2907  8457		       b5 80		      lda	player0x,X	;+4 9
   2908  8459		       38		      sec		;+2 11
   2909  845a				   DivideLoop
   2910  845a		       e9 0f		      sbc	#15
   2911  845c		       b0 fc		      bcs	DivideLoop	;+4 15
   2912  845e		       95 9c		      sta	temp1,X	;+4 19
   2913  8460		       95 10		      sta	RESP0,X	;+4 23
   2914  8462		       85 02		      sta	WSYNC
   2915  8464		       ca		      dex
   2916  8465		       10 f0		      bpl	HorPosLoop	;+5 5
   2917  8467							; 4
   2918  8467
   2919  8467		       a2 04		      ldx	#4
   2920  8469		       b4 9c		      ldy	temp1,X
   2921  846b		       b9 c7 f3 	      lda	repostable-256,Y
   2922  846e		       95 20		      sta	HMP0,X	;+14 18
   2923  8470
   2924  8470		       ca		      dex
   2925  8471		       b4 9c		      ldy	temp1,X
   2926  8473		       b9 c7 f3 	      lda	repostable-256,Y
   2927  8476		       95 20		      sta	HMP0,X	;+14 32
   2928  8478
   2929  8478		       ca		      dex
   2930  8479		       b4 9c		      ldy	temp1,X
   2931  847b		       b9 c7 f3 	      lda	repostable-256,Y
   2932  847e		       95 20		      sta	HMP0,X	;+14 46
   2933  8480
   2934  8480		       ca		      dex
   2935  8481		       b4 9c		      ldy	temp1,X
   2936  8483		       b9 c7 f3 	      lda	repostable-256,Y
   2937  8486		       95 20		      sta	HMP0,X	;+14 60
   2938  8488
   2939  8488		       ca		      dex
   2940  8489		       b4 9c		      ldy	temp1,X
   2941  848b		       b9 c7 f3 	      lda	repostable-256,Y
   2942  848e		       95 20		      sta	HMP0,X	;+14 74
   2943  8490
   2944  8490		       85 02		      sta	WSYNC
   2945  8492
   2946  8492		       85 2a		      sta	HMOVE	;+3 3
   2947  8494
   2948  8494
   2949  8494				  -	      ifconst	legacy
   2950  8494				  -	      if	legacy < 100
   2951  8494				  -	      ldx	#4
   2952  8494				  -adjustloop2
   2953  8494				  -	      lda	player0x,x
   2954  8494				  -	      clc
   2955  8494				  -	      adc	#14	;?
   2956  8494				  -	      sta	player0x,x
   2957  8494				  -	      dex
   2958  8494				  -	      bpl	adjustloop2
   2959  8494				  -	      endif
   2960  8494					      endif
   2961  8494
   2962  8494
   2963  8494
   2964  8494
   2965  8494							;set score pointers
   2966  8494		       a7 95		      lax	score+2
   2967  8496		       20 c7 f4 	      jsr	scorepointerset
   2968  8499		       84 9b		      sty	scorepointers+5
   2969  849b		       86 98		      stx	scorepointers+2
   2970  849d		       a7 94		      lax	score+1
   2971  849f		       20 c7 f4 	      jsr	scorepointerset
   2972  84a2		       84 9a		      sty	scorepointers+4
   2973  84a4		       86 97		      stx	scorepointers+1
   2974  84a6		       a7 93		      lax	score
   2975  84a8		       20 c7 f4 	      jsr	scorepointerset
   2976  84ab		       84 99		      sty	scorepointers+3
   2977  84ad		       86 96		      stx	scorepointers
   2978  84af
   2979  84af				   vblk
   2980  84af							; run possible vblank bB code
   2981  84af				  -	      ifconst	vblank_bB_code
   2982  84af				  -	      jsr	vblank_bB_code
   2983  84af					      endif
   2984  84af				   vblk2
   2985  84af		       ad 84 02 	      LDA	INTIM
   2986  84b2		       30 fb		      bmi	vblk2
   2987  84b4		       4c 00 f0 	      jmp	kernel
   2988  84b7
   2989  84b7
   2990  84b7		       80 70 60 50*	      .byte.b	$80,$70,$60,$50,$40,$30,$20,$10,$00
   2991  84c0		       f0 e0 d0 c0*	      .byte.b	$F0,$E0,$D0,$C0,$B0,$A0,$90
   2992  84c7				   repostable
   2993  84c7
   2994  84c7				   scorepointerset
   2995  84c7		       29 0f		      and	#$0F
   2996  84c9		       0a		      asl
   2997  84ca		       0a		      asl
   2998  84cb		       0a		      asl
   2999  84cc		       69 74		      adc	#<scoretable
   3000  84ce		       a8		      tay
   3001  84cf		       8a		      txa
   3002  84d0							; and #$F0
   3003  84d0							; lsr
   3004  84d0		       4b f0		      asr	#$F0
   3005  84d2		       69 74		      adc	#<scoretable
   3006  84d4		       aa		      tax
   3007  84d5		       60		      rts
   3008  84d6							;bB.asm
   3009  84d6							; bB.asm file is split here
   3010  84d6				  -	      ifconst	pfres
   3011  84d6				  -	      if	(<*) > (254-pfres*pfwidth)
   3012  84d6				  -	      align	256
   3013  84d6				  -	      endif
   3014  84d6				  -	      if	(<*) < (136-pfres*pfwidth)
   3015  84d6				  -	      repeat	((136-pfres*pfwidth)-(<*))
   3016  84d6				  -	      .byte	0
   3017  84d6				  -	      repend
   3018  84d6				  -	      endif
   3019  84d6					      else
   3020  84d6					      if	(<*) > 206
   3021  8500		       00 00 00 00*	      align	256
   3022  8500					      endif
   3023  8500					      if	(<*) < 88
   3024  8500					      repeat	(88-(<*))
   3025  8500		       00		      .byte.b	0
   3024  8500					      repend
   3025  8501		       00		      .byte.b	0
   3024  8501					      repend
   3025  8502		       00		      .byte.b	0
   3024  8502					      repend
   3025  8503		       00		      .byte.b	0
   3024  8503					      repend
   3025  8504		       00		      .byte.b	0
   3024  8504					      repend
   3025  8505		       00		      .byte.b	0
   3024  8505					      repend
   3025  8506		       00		      .byte.b	0
   3024  8506					      repend
   3025  8507		       00		      .byte.b	0
   3024  8507					      repend
   3025  8508		       00		      .byte.b	0
   3024  8508					      repend
   3025  8509		       00		      .byte.b	0
   3024  8509					      repend
   3025  850a		       00		      .byte.b	0
   3024  850a					      repend
   3025  850b		       00		      .byte.b	0
   3024  850b					      repend
   3025  850c		       00		      .byte.b	0
   3024  850c					      repend
   3025  850d		       00		      .byte.b	0
   3024  850d					      repend
   3025  850e		       00		      .byte.b	0
   3024  850e					      repend
   3025  850f		       00		      .byte.b	0
   3024  850f					      repend
   3025  8510		       00		      .byte.b	0
   3024  8510					      repend
   3025  8511		       00		      .byte.b	0
   3024  8511					      repend
   3025  8512		       00		      .byte.b	0
   3024  8512					      repend
   3025  8513		       00		      .byte.b	0
   3024  8513					      repend
   3025  8514		       00		      .byte.b	0
   3024  8514					      repend
   3025  8515		       00		      .byte.b	0
   3024  8515					      repend
   3025  8516		       00		      .byte.b	0
   3024  8516					      repend
   3025  8517		       00		      .byte.b	0
   3024  8517					      repend
   3025  8518		       00		      .byte.b	0
   3024  8518					      repend
   3025  8519		       00		      .byte.b	0
   3024  8519					      repend
   3025  851a		       00		      .byte.b	0
   3024  851a					      repend
   3025  851b		       00		      .byte.b	0
   3024  851b					      repend
   3025  851c		       00		      .byte.b	0
   3024  851c					      repend
   3025  851d		       00		      .byte.b	0
   3024  851d					      repend
   3025  851e		       00		      .byte.b	0
   3024  851e					      repend
   3025  851f		       00		      .byte.b	0
   3024  851f					      repend
   3025  8520		       00		      .byte.b	0
   3024  8520					      repend
   3025  8521		       00		      .byte.b	0
   3024  8521					      repend
   3025  8522		       00		      .byte.b	0
   3024  8522					      repend
   3025  8523		       00		      .byte.b	0
   3024  8523					      repend
   3025  8524		       00		      .byte.b	0
   3024  8524					      repend
   3025  8525		       00		      .byte.b	0
   3024  8525					      repend
   3025  8526		       00		      .byte.b	0
   3024  8526					      repend
   3025  8527		       00		      .byte.b	0
   3024  8527					      repend
   3025  8528		       00		      .byte.b	0
   3024  8528					      repend
   3025  8529		       00		      .byte.b	0
   3024  8529					      repend
   3025  852a		       00		      .byte.b	0
   3024  852a					      repend
   3025  852b		       00		      .byte.b	0
   3024  852b					      repend
   3025  852c		       00		      .byte.b	0
   3024  852c					      repend
   3025  852d		       00		      .byte.b	0
   3024  852d					      repend
   3025  852e		       00		      .byte.b	0
   3024  852e					      repend
   3025  852f		       00		      .byte.b	0
   3024  852f					      repend
   3025  8530		       00		      .byte.b	0
   3024  8530					      repend
   3025  8531		       00		      .byte.b	0
   3024  8531					      repend
   3025  8532		       00		      .byte.b	0
   3024  8532					      repend
   3025  8533		       00		      .byte.b	0
   3024  8533					      repend
   3025  8534		       00		      .byte.b	0
   3024  8534					      repend
   3025  8535		       00		      .byte.b	0
   3024  8535					      repend
   3025  8536		       00		      .byte.b	0
   3024  8536					      repend
   3025  8537		       00		      .byte.b	0
   3024  8537					      repend
   3025  8538		       00		      .byte.b	0
   3024  8538					      repend
   3025  8539		       00		      .byte.b	0
   3024  8539					      repend
   3025  853a		       00		      .byte.b	0
   3024  853a					      repend
   3025  853b		       00		      .byte.b	0
   3024  853b					      repend
   3025  853c		       00		      .byte.b	0
   3024  853c					      repend
   3025  853d		       00		      .byte.b	0
   3024  853d					      repend
   3025  853e		       00		      .byte.b	0
   3024  853e					      repend
   3025  853f		       00		      .byte.b	0
   3024  853f					      repend
   3025  8540		       00		      .byte.b	0
   3024  8540					      repend
   3025  8541		       00		      .byte.b	0
   3024  8541					      repend
   3025  8542		       00		      .byte.b	0
   3024  8542					      repend
   3025  8543		       00		      .byte.b	0
   3024  8543					      repend
   3025  8544		       00		      .byte.b	0
   3024  8544					      repend
   3025  8545		       00		      .byte.b	0
   3024  8545					      repend
   3025  8546		       00		      .byte.b	0
   3024  8546					      repend
   3025  8547		       00		      .byte.b	0
   3024  8547					      repend
   3025  8548		       00		      .byte.b	0
   3024  8548					      repend
   3025  8549		       00		      .byte.b	0
   3024  8549					      repend
   3025  854a		       00		      .byte.b	0
   3024  854a					      repend
   3025  854b		       00		      .byte.b	0
   3024  854b					      repend
   3025  854c		       00		      .byte.b	0
   3024  854c					      repend
   3025  854d		       00		      .byte.b	0
   3024  854d					      repend
   3025  854e		       00		      .byte.b	0
   3024  854e					      repend
   3025  854f		       00		      .byte.b	0
   3024  854f					      repend
   3025  8550		       00		      .byte.b	0
   3024  8550					      repend
   3025  8551		       00		      .byte.b	0
   3024  8551					      repend
   3025  8552		       00		      .byte.b	0
   3024  8552					      repend
   3025  8553		       00		      .byte.b	0
   3024  8553					      repend
   3025  8554		       00		      .byte.b	0
   3024  8554					      repend
   3025  8555		       00		      .byte.b	0
   3024  8555					      repend
   3025  8556		       00		      .byte.b	0
   3024  8556					      repend
   3025  8557		       00		      .byte.b	0
   3026  8558					      repend
   3027  8558					      endif
   3028  8558					      endif
   3029  8558				   pfcolorlabel13
   3030  8558		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3031  855c		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3032  8560		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3033  8564		       8a 36 00 00	      .byte.b	$8A, $36,0,0
   3034  8568		       28 82 00 00	      .byte.b	$28, $82,0,0
   3035  856c		       28 82 00 00	      .byte.b	$28, $82,0,0
   3036  8570		       28 82 00 00	      .byte.b	$28, $82,0,0
   3037  8574		       28 38 00 00	      .byte.b	$28, $38,0,0
   3038  8578		       28 38 00 00	      .byte.b	$28, $38,0,0
   3039  857c		       28 38 00 00	      .byte.b	$28, $38,0,0
   3040  8580		       28 38 00 00	      .byte.b	$28, $38,0,0
   3041  8584				  -	      if	(<*) > (<(*+3))
   3042  8584				  -	      repeat	($100-<*)
   3043  8584				  -	      .byte	0
   3044  8584				  -	      repend
   3045  8584					      endif
   3046  8584				   playerL040_1
   3047  8584		       0a		      .byte.b	%00001010
   3048  8585		       0e		      .byte.b	%00001110
   3049  8586		       33		      .byte.b	%00110011
   3050  8587		       74		      .byte.b	%01110100
   3051  8588				  -	      if	(<*) > (<(*+3))
   3052  8588				  -	      repeat	($100-<*)
   3053  8588				  -	      .byte	0
   3054  8588				  -	      repend
   3055  8588					      endif
   3056  8588				   playerL044_1
   3057  8588		       09		      .byte.b	%00001001
   3058  8589		       0e		      .byte.b	%00001110
   3059  858a		       33		      .byte.b	%00110011
   3060  858b		       74		      .byte.b	%01110100
   3061  858c				  -	      if	(<*) > (<(*+3))
   3062  858c				  -	      repeat	($100-<*)
   3063  858c				  -	      .byte	0
   3064  858c				  -	      repend
   3065  858c					      endif
   3066  858c				   playerL048_1
   3067  858c		       11		      .byte.b	%00010001
   3068  858d		       0e		      .byte.b	%00001110
   3069  858e		       33		      .byte.b	%00110011
   3070  858f		       74		      .byte.b	%01110100
   3071  8590				  -	      if	(<*) > (<(*+3))
   3072  8590				  -	      repeat	($100-<*)
   3073  8590				  -	      .byte	0
   3074  8590				  -	      repend
   3075  8590					      endif
   3076  8590				   playerL052_1
   3077  8590		       12		      .byte.b	%00010010
   3078  8591		       0e		      .byte.b	%00001110
   3079  8592		       33		      .byte.b	%00110011
   3080  8593		       74		      .byte.b	%01110100
   3081  8594				  -	      if	(<*) > (<(*+14))
   3082  8594				  -	      repeat	($100-<*)
   3083  8594				  -	      .byte	0
   3084  8594				  -	      repend
   3085  8594					      endif
   3086  8594				   playerL055_0
   3087  8594		       3c		      .byte.b	%00111100
   3088  8595		       3c		      .byte.b	%00111100
   3089  8596		       3c		      .byte.b	%00111100
   3090  8597		       7e		      .byte.b	%01111110
   3091  8598		       3c		      .byte.b	%00111100
   3092  8599		       3c		      .byte.b	%00111100
   3093  859a		       18		      .byte.b	%00011000
   3094  859b		       00		      .byte.b	%00000000
   3095  859c		       00		      .byte.b	%00000000
   3096  859d		       00		      .byte.b	%00000000
   3097  859e		       00		      .byte.b	%00000000
   3098  859f		       00		      .byte.b	%00000000
   3099  85a0		       00		      .byte.b	%00000000
   3100  85a1		       00		      .byte.b	%00000000
   3101  85a2		       00		      .byte.b	%00000000
   3102  85a3					      if	ECHOFIRST
   2513 bytes of ROM space left in bank 8
   3103  85a3					      echo	" ",[(scoretable - *)]d , "bytes of ROM space left in bank 8")
   3104  85a3					      endif
   3105  85a3		       00 01	   ECHOFIRST  =	1
   3106  85a3
   3107  85a3
   3108  85a3							; feel free to modify the score graphics - just keep each digit 8 high
   3109  85a3							; and keep the conditional compilation stuff intact
   3110  85a3				  -	      ifconst	ROM2k
   3111  85a3				  -	      ORG	$F7AC-8
   3112  85a3					      else
   3113  85a3					      ifconst	bankswitch
   3114  85a3				  -	      if	bankswitch == 8
   3115  85a3				  -	      ORG	$2F94-bscode_length
   3116  85a3				  -	      RORG	$FF94-bscode_length
   3117  85a3					      endif
   3118  85a3				  -	      if	bankswitch == 16
   3119  85a3				  -	      ORG	$4F94-bscode_length
   3120  85a3				  -	      RORG	$FF94-bscode_length
   3121  85a3					      endif
   3122  85a3					      if	bankswitch == 32
   3123  8f74					      ORG	$8F94-bscode_length
   3124  8f74					      RORG	$FF94-bscode_length
   3125  8f74					      endif
   3126  8f74				  -	      if	bankswitch == 64
   3127  8f74				  -	      ORG	$10F80-bscode_length
   3128  8f74				  -	      RORG	$1FF80-bscode_length
   3129  8f74					      endif
   3130  8f74				  -	      else
   3131  8f74				  -	      ORG	$FF9C
   3132  8f74					      endif
   3133  8f74					      endif
   3134  8f74
   3135  8f74							; font equates
   3136  8f74		       00 01	   .21stcentury =	1
   3137  8f74		       00 02	   alarmclock =	2
   3138  8f74		       00 03	   handwritten =	3
   3139  8f74		       00 04	   interrupted =	4
   3140  8f74		       00 05	   retroputer =	5
   3141  8f74		       00 06	   whimsey    =	6
   3142  8f74		       00 07	   tiny       =	7
   3143  8f74
   3144  8f74				   scoretable
   3145  8f74
   3146  8f74				  -	      ifconst	font
   3147  8f74				  -	      if	font == .21stcentury
   3148  8f74				  -	      include	"score_graphics.asm.21stcentury"
   3149  8f74				  -	      endif
   3150  8f74				  -	      if	font == alarmclock
   3151  8f74				  -	      include	"score_graphics.asm.alarmclock"
   3152  8f74				  -	      endif
   3153  8f74				  -	      if	font == handwritten
   3154  8f74				  -	      include	"score_graphics.asm.handwritten"
   3155  8f74				  -	      endif
   3156  8f74				  -	      if	font == interrupted
   3157  8f74				  -	      include	"score_graphics.asm.interrupted"
   3158  8f74				  -	      endif
   3159  8f74				  -	      if	font == retroputer
   3160  8f74				  -	      include	"score_graphics.asm.retroputer"
   3161  8f74				  -	      endif
   3162  8f74				  -	      if	font == whimsey
   3163  8f74				  -	      include	"score_graphics.asm.whimsey"
   3164  8f74				  -	      endif
   3165  8f74				  -	      if	font == tiny
   3166  8f74				  -	      include	"score_graphics.asm.tiny"
   3167  8f74				  -	      endif
   3168  8f74					      else		; default font
   3169  8f74
   3170  8f74		       3c		      .byte.b	%00111100
   3171  8f75		       66		      .byte.b	%01100110
   3172  8f76		       66		      .byte.b	%01100110
   3173  8f77		       66		      .byte.b	%01100110
   3174  8f78		       66		      .byte.b	%01100110
   3175  8f79		       66		      .byte.b	%01100110
   3176  8f7a		       66		      .byte.b	%01100110
   3177  8f7b		       3c		      .byte.b	%00111100
   3178  8f7c
   3179  8f7c		       7e		      .byte.b	%01111110
   3180  8f7d		       18		      .byte.b	%00011000
   3181  8f7e		       18		      .byte.b	%00011000
   3182  8f7f		       18		      .byte.b	%00011000
   3183  8f80		       18		      .byte.b	%00011000
   3184  8f81		       38		      .byte.b	%00111000
   3185  8f82		       18		      .byte.b	%00011000
   3186  8f83		       08		      .byte.b	%00001000
   3187  8f84
   3188  8f84		       7e		      .byte.b	%01111110
   3189  8f85		       60		      .byte.b	%01100000
   3190  8f86		       60		      .byte.b	%01100000
   3191  8f87		       3c		      .byte.b	%00111100
   3192  8f88		       06		      .byte.b	%00000110
   3193  8f89		       06		      .byte.b	%00000110
   3194  8f8a		       46		      .byte.b	%01000110
   3195  8f8b		       3c		      .byte.b	%00111100
   3196  8f8c
   3197  8f8c		       3c		      .byte.b	%00111100
   3198  8f8d		       46		      .byte.b	%01000110
   3199  8f8e		       06		      .byte.b	%00000110
   3200  8f8f		       06		      .byte.b	%00000110
   3201  8f90		       1c		      .byte.b	%00011100
   3202  8f91		       06		      .byte.b	%00000110
   3203  8f92		       46		      .byte.b	%01000110
   3204  8f93		       3c		      .byte.b	%00111100
   3205  8f94
   3206  8f94		       0c		      .byte.b	%00001100
   3207  8f95		       0c		      .byte.b	%00001100
   3208  8f96		       7e		      .byte.b	%01111110
   3209  8f97		       4c		      .byte.b	%01001100
   3210  8f98		       4c		      .byte.b	%01001100
   3211  8f99		       2c		      .byte.b	%00101100
   3212  8f9a		       1c		      .byte.b	%00011100
   3213  8f9b		       0c		      .byte.b	%00001100
   3214  8f9c
   3215  8f9c		       3c		      .byte.b	%00111100
   3216  8f9d		       46		      .byte.b	%01000110
   3217  8f9e		       06		      .byte.b	%00000110
   3218  8f9f		       06		      .byte.b	%00000110
   3219  8fa0		       3c		      .byte.b	%00111100
   3220  8fa1		       60		      .byte.b	%01100000
   3221  8fa2		       60		      .byte.b	%01100000
   3222  8fa3		       7e		      .byte.b	%01111110
   3223  8fa4
   3224  8fa4		       3c		      .byte.b	%00111100
   3225  8fa5		       66		      .byte.b	%01100110
   3226  8fa6		       66		      .byte.b	%01100110
   3227  8fa7		       66		      .byte.b	%01100110
   3228  8fa8		       7c		      .byte.b	%01111100
   3229  8fa9		       60		      .byte.b	%01100000
   3230  8faa		       62		      .byte.b	%01100010
   3231  8fab		       3c		      .byte.b	%00111100
   3232  8fac
   3233  8fac		       30		      .byte.b	%00110000
   3234  8fad		       30		      .byte.b	%00110000
   3235  8fae		       30		      .byte.b	%00110000
   3236  8faf		       18		      .byte.b	%00011000
   3237  8fb0		       0c		      .byte.b	%00001100
   3238  8fb1		       06		      .byte.b	%00000110
   3239  8fb2		       42		      .byte.b	%01000010
   3240  8fb3		       3e		      .byte.b	%00111110
   3241  8fb4
   3242  8fb4		       3c		      .byte.b	%00111100
   3243  8fb5		       66		      .byte.b	%01100110
   3244  8fb6		       66		      .byte.b	%01100110
   3245  8fb7		       66		      .byte.b	%01100110
   3246  8fb8		       3c		      .byte.b	%00111100
   3247  8fb9		       66		      .byte.b	%01100110
   3248  8fba		       66		      .byte.b	%01100110
   3249  8fbb		       3c		      .byte.b	%00111100
   3250  8fbc
   3251  8fbc		       3c		      .byte.b	%00111100
   3252  8fbd		       46		      .byte.b	%01000110
   3253  8fbe		       06		      .byte.b	%00000110
   3254  8fbf		       3e		      .byte.b	%00111110
   3255  8fc0		       66		      .byte.b	%01100110
   3256  8fc1		       66		      .byte.b	%01100110
   3257  8fc2		       66		      .byte.b	%01100110
   3258  8fc3		       3c		      .byte.b	%00111100
   3259  8fc4
   3260  8fc4					      ifnconst	DPC_kernel_options
   3261  8fc4
   3262  8fc4		       00		      .byte.b	%00000000
   3263  8fc5		       00		      .byte.b	%00000000
   3264  8fc6		       00		      .byte.b	%00000000
   3265  8fc7		       00		      .byte.b	%00000000
   3266  8fc8		       00		      .byte.b	%00000000
   3267  8fc9		       00		      .byte.b	%00000000
   3268  8fca		       00		      .byte.b	%00000000
   3269  8fcb		       00		      .byte.b	%00000000
   3270  8fcc
   3271  8fcc					      endif
   3272  8fcc
   3273  8fcc					      endif
   3274  8fcc
   3275  8fcc				  -	      ifconst	ROM2k
   3276  8fcc				  -	      ORG	$F7FC
   3277  8fcc					      else
   3278  8fcc					      ifconst	bankswitch
   3279  8fcc				  -	      if	bankswitch == 8
   3280  8fcc				  -	      ORG	$2FF4-bscode_length
   3281  8fcc				  -	      RORG	$FFF4-bscode_length
   3282  8fcc					      endif
   3283  8fcc				  -	      if	bankswitch == 16
   3284  8fcc				  -	      ORG	$4FF4-bscode_length
   3285  8fcc				  -	      RORG	$FFF4-bscode_length
   3286  8fcc					      endif
   3287  8fcc					      if	bankswitch == 32
   3288  8fd4					      ORG	$8FF4-bscode_length
   3289  8fd4					      RORG	$FFF4-bscode_length
   3290  8fd4					      endif
   3291  8fd4				  -	      if	bankswitch == 64
   3292  8fd4				  -	      ORG	$10FE0-bscode_length
   3293  8fd4				  -	      RORG	$1FFE0-bscode_length
   3294  8fd4					      endif
   3295  8fd4				  -	      else
   3296  8fd4				  -	      ORG	$FFFC
   3297  8fd4					      endif
   3298  8fd4					      endif
   3299  8fd4							; every bank has this stuff at the same place
   3300  8fd4							; this code can switch to/from any bank at any entry point
   3301  8fd4							; and can preserve register values
   3302  8fd4							; note: lines not starting with a space are not placed in all banks
   3303  8fd4							;
   3304  8fd4							; line below tells the compiler how long this is - do not remove
   3305  8fd4							;size=32
   3306  8fd4
   3307  8fd4				   begin_bscode
   3308  8fd4		       a2 ff		      ldx	#$ff
   3309  8fd6				  -	      ifconst	FASTFETCH	; using DPC+
   3310  8fd6				  -	      stx	FASTFETCH
   3311  8fd6					      endif
   3312  8fd6		       9a		      txs
   3313  8fd7				  -	      if	bankswitch == 64
   3314  8fd7				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   3315  8fd7					      else
   3316  8fd7		       a9 f2		      lda	#>(start-1)
   3317  8fd9					      endif
   3318  8fd9		       48		      pha
   3319  8fda		       a9 4f		      lda	#<(start-1)
   3320  8fdc		       48		      pha
   3321  8fdd
   3322  8fdd				   BS_return
   3323  8fdd		       48		      pha
   3324  8fde		       8a		      txa
   3325  8fdf		       48		      pha
   3326  8fe0		       ba		      tsx
   3327  8fe1
   3328  8fe1					      if	bankswitch != 64
   3329  8fe1		       b5 04		      lda	4,x	; get high byte of return address
   3330  8fe3
   3331  8fe3		       2a		      rol
   3332  8fe4		       2a		      rol
   3333  8fe5		       2a		      rol
   3334  8fe6		       2a		      rol
   3335  8fe7		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   3336  8fe9		       aa		      tax
   3337  8fea		       e8		      inx
   3338  8feb				  -	      else
   3339  8feb				  -	      lda	4,x	; get high byte of return address
   3340  8feb				  -	      tay
   3341  8feb				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   3342  8feb				  -	      sta	4,x
   3343  8feb				  -	      tya
   3344  8feb				  -	      lsr
   3345  8feb				  -	      lsr
   3346  8feb				  -	      lsr
   3347  8feb				  -	      lsr
   3348  8feb				  -	      tax
   3349  8feb				  -	      inx
   3350  8feb					      endif
   3351  8feb
   3352  8feb				   BS_jsr
   3353  8feb		       bd f3 1f 	      lda	bankswitch_hotspot-1,x
   3354  8fee		       68		      pla
   3355  8fef		       aa		      tax
   3356  8ff0		       68		      pla
   3357  8ff1		       60		      rts
   3358  8ff2				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   3359  8ff2				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   3360  8ff2				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   3361  8ff2					      endif
   3362  8ff2					      ifconst	bankswitch
   3363  8ff2				  -	      if	bankswitch == 8
   3364  8ff2				  -	      ORG	$2FFC
   3365  8ff2				  -	      RORG	$FFFC
   3366  8ff2					      endif
   3367  8ff2				  -	      if	bankswitch == 16
   3368  8ff2				  -	      ORG	$4FFC
   3369  8ff2				  -	      RORG	$FFFC
   3370  8ff2					      endif
   3371  8ff2					      if	bankswitch == 32
   3372  8ffc					      ORG	$8FFC
   3373  8ffc					      RORG	$FFFC
   3374  8ffc					      endif
   3375  8ffc				  -	      if	bankswitch == 64
   3376  8ffc				  -	      ORG	$10FF0
   3377  8ffc				  -	      RORG	$1FFF0
   3378  8ffc				  -	      lda	$ffe0	; we use wasted space to assist stella with EF format auto-detection
   3379  8ffc				  -	      ORG	$10FF8
   3380  8ffc				  -	      RORG	$1FFF8
   3381  8ffc				  -	      ifconst	superchip
   3382  8ffc				  -	      .byte	"E","F","S","C"
   3383  8ffc				  -	      else
   3384  8ffc				  -	      .byte	"E","F","E","F"
   3385  8ffc				  -	      endif
   3386  8ffc				  -	      ORG	$10FFC
   3387  8ffc				  -	      RORG	$1FFFC
   3388  8ffc					      endif
   3389  8ffc				  -	      else
   3390  8ffc				  -	      ifconst	ROM2k
   3391  8ffc				  -	      ORG	$F7FC
   3392  8ffc				  -	      else
   3393  8ffc				  -	      ORG	$FFFC
   3394  8ffc				  -	      endif
   3395  8ffc					      endif
   3396  8ffc		       50 f2		      .word.w	start
   3397  8ffe		       50 f2		      .word.w	start
